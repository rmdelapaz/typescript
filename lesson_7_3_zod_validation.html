<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn Zod schema validation with React Hook Form. Master type-safe form validation, schema definition, and error handling with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 7.3: Form Validation with Zod - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module7">Module 7: Forms and Validation</a></li>
            <li aria-current="page">Lesson 7.3: Form Validation with Zod</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üõ°Ô∏è Lesson 7.3: Form Validation with Zod</h1>
                <p class="lead">In the previous lesson, you learned React Hook Form and saw how it simplifies form handling. But you still wrote validation rules inline with each field‚Äîrequired here, pattern there, custom validators everywhere. What if you could define your entire form's validation schema in one place, get automatic TypeScript types, and write validation that's reusable, composable, and incredibly powerful? That's exactly what Zod gives you. In this lesson, you'll learn how to combine React Hook Form with Zod to create bulletproof, type-safe forms with schema-based validation.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what Zod is and why schema validation is powerful</li>
                        <li>Install and configure Zod with React Hook Form</li>
                        <li>Define validation schemas with Zod</li>
                        <li>Integrate Zod schemas with React Hook Form using resolvers</li>
                        <li>Create reusable validation schemas</li>
                        <li>Use advanced Zod features (transforms, refinements, custom errors)</li>
                        <li>Get automatic TypeScript type inference from schemas</li>
                        <li>Build complex nested schemas for real-world forms</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a complete registration form with Zod validation</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Why Zod?</a></li>
                        <li><a href="#section2" class="toc-link">Installation and Setup</a></li>
                        <li><a href="#section3" class="toc-link">Your First Zod Schema</a></li>
                        <li><a href="#section4" class="toc-link">Integrating with React Hook Form</a></li>
                        <li><a href="#section5" class="toc-link">Basic Zod Types</a></li>
                        <li><a href="#section6" class="toc-link">String Validation</a></li>
                        <li><a href="#section7" class="toc-link">Number and Date Validation</a></li>
                        <li><a href="#section8" class="toc-link">TypeScript Type Inference</a></li>
                        <li><a href="#section9" class="toc-link">Custom Error Messages</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Why Zod? -->
            <section id="section1" aria-labelledby="section1-title">
                <h2 id="section1-title">ü§î Why Zod?</h2>
                <p>In Lesson 7.2, you learned React Hook Form and wrote validation like this:</p>

                <pre><code class="language-typescript">// React Hook Form validation (from Lesson 7.2)
&lt;input
  {...register('email', {
    required: 'Email is required',
    pattern: {
      value: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
      message: 'Invalid email format'
    },
    minLength: {
      value: 5,
      message: 'Email must be at least 5 characters'
    }
  })}
/&gt;

&lt;input
  {...register('password', {
    required: 'Password is required',
    minLength: { value: 8, message: 'At least 8 characters' },
    validate: {
      hasUpper: v => /[A-Z]/.test(v) || 'Need uppercase',
      hasLower: v => /[a-z]/.test(v) || 'Need lowercase',
      hasNumber: v => /\d/.test(v) || 'Need number'
    }
  })}
/&gt;</code></pre>

                <div class="card" style="background: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Problems with Inline Validation</h4>
                    <ul>
                        <li><strong>Repetitive</strong> - Copy-paste validation across forms</li>
                        <li><strong>Hard to maintain</strong> - Update validation in multiple places</li>
                        <li><strong>No reusability</strong> - Can't share validation logic</li>
                        <li><strong>Manual types</strong> - Define TypeScript types separately</li>
                        <li><strong>Scattered logic</strong> - Validation rules mixed with UI code</li>
                        <li><strong>Limited composition</strong> - Hard to combine validations</li>
                        <li><strong>Runtime-only</strong> - No validation at build time</li>
                    </ul>
                </div>

                <h3>Enter Zod: Schema-Based Validation</h3>
                <p>Now see the same form with Zod:</p>

                <pre><code class="language-typescript">// Zod schema - define once, use everywhere
import { z } from 'zod';

const formSchema = z.object({
  email: z.string()
    .min(1, 'Email is required')
    .email('Invalid email format')
    .min(5, 'Email must be at least 5 characters'),
  
  password: z.string()
    .min(1, 'Password is required')
    .min(8, 'At least 8 characters')
    .regex(/[A-Z]/, 'Need uppercase letter')
    .regex(/[a-z]/, 'Need lowercase letter')
    .regex(/\d/, 'Need number')
});

// TypeScript type automatically inferred!
type FormData = z.infer&lt;typeof formSchema&gt;;
// Result: { email: string; password: string }

// Use with React Hook Form (one line!)
const { register, handleSubmit } = useForm&lt;FormData&gt;({
  resolver: zodResolver(formSchema)
});

// Now just register without validation
&lt;input {...register('email')} /&gt;
&lt;input {...register('password')} /&gt;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Zod Benefits</h4>
                    <ul>
                        <li><strong>Single source of truth</strong> - All validation in one schema</li>
                        <li><strong>Reusable</strong> - Share schemas across forms and API validation</li>
                        <li><strong>Composable</strong> - Build complex schemas from simple ones</li>
                        <li><strong>Type inference</strong> - TypeScript types generated automatically</li>
                        <li><strong>Runtime + build time</strong> - Validation at both stages</li>
                        <li><strong>Chainable API</strong> - Beautiful, readable validation chains</li>
                        <li><strong>Rich validation</strong> - 40+ built-in validators</li>
                        <li><strong>Tiny bundle</strong> - Only 8KB minified + gzipped</li>
                    </ul>
                </div>

                <h3>What is Zod?</h3>
                <p>Zod is a <strong>TypeScript-first schema validation library</strong>. Think of it as a way to define the "shape" of your data‚Äîwhat fields exist, what types they are, and what rules they must follow‚Äîall in one place.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Key Concepts</h4>
                    <ul style="color: white;">
                        <li><strong>Schema</strong> - A definition of what valid data looks like</li>
                        <li><strong>Validation</strong> - Checking if data matches the schema</li>
                        <li><strong>Parsing</strong> - Validating and transforming data</li>
                        <li><strong>Type inference</strong> - Automatic TypeScript types from schemas</li>
                        <li><strong>Resolver</strong> - Bridge between Zod and React Hook Form</li>
                    </ul>
                </div>

                <h3>Zod vs Other Validation Libraries</h3>
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>Zod</th>
                                <th>Yup</th>
                                <th>Joi</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>TypeScript</strong></td>
                                <td>Native, first-class</td>
                                <td>Via types package</td>
                                <td>Limited support</td>
                            </tr>
                            <tr>
                                <td><strong>Type inference</strong></td>
                                <td>Automatic ‚úÖ</td>
                                <td>Manual</td>
                                <td>Manual</td>
                            </tr>
                            <tr>
                                <td><strong>Bundle size</strong></td>
                                <td>8KB</td>
                                <td>15KB</td>
                                <td>Not browser-friendly</td>
                            </tr>
                            <tr>
                                <td><strong>API style</strong></td>
                                <td>Chainable, modern</td>
                                <td>Chainable</td>
                                <td>Object-based</td>
                            </tr>
                            <tr>
                                <td><strong>Learning curve</strong></td>
                                <td>Easy</td>
                                <td>Easy</td>
                                <td>Moderate</td>
                            </tr>
                            <tr>
                                <td><strong>Popularity</strong></td>
                                <td>Growing fast üöÄ</td>
                                <td>Established</td>
                                <td>Server-focused</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>How Zod Works with React Hook Form</h3>
                <p>Zod and React Hook Form work together beautifully:</p>

                <div class="mermaid">
                graph LR
                    A[1. Define Zod Schema] --> B[2. Infer TypeScript Type]
                    B --> C[3. Pass to useForm with resolver]
                    C --> D[4. Register inputs]
                    D --> E[5. User submits form]
                    E --> F[6. Zod validates data]
                    F --> G{Valid?}
                    G -->|Yes| H[Call onSubmit with typed data]
                    G -->|No| I[Show Zod error messages]
                    
                    style A fill:#667eea,color:#fff
                    style H fill:#48bb78,color:#fff
                    style I fill:#f56565,color:#fff
                </graph>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Power of Schemas</h4>
                    <p>A schema is like a blueprint. Once you define it:</p>
                    <ul>
                        <li>‚úÖ Use it for form validation</li>
                        <li>‚úÖ Use it for API request validation</li>
                        <li>‚úÖ Use it for API response validation</li>
                        <li>‚úÖ Share it between frontend and backend</li>
                        <li>‚úÖ Generate documentation from it</li>
                        <li>‚úÖ Get TypeScript types automatically</li>
                    </ul>
                </div>

                <h3>When to Use Zod</h3>
                <div class="card">
                    <h4>‚úÖ Perfect For:</h4>
                    <ul>
                        <li>Any form with more than basic validation</li>
                        <li>Forms where you need strong typing</li>
                        <li>Reusable validation across multiple forms</li>
                        <li>API request/response validation</li>
                        <li>Complex nested data structures</li>
                        <li>Projects already using TypeScript</li>
                        <li>When you want a single source of truth</li>
                    </ul>
                    
                    <h4>‚ùå Maybe Overkill For:</h4>
                    <ul>
                        <li>Single-field forms (search boxes)</li>
                        <li>Prototypes where validation rules are still changing</li>
                        <li>Simple forms with only required/minLength validation</li>
                        <li>Projects not using TypeScript</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Installation and Setup -->
            <section id="section2" aria-labelledby="section2-title">
                <h2 id="section2-title">üì¶ Installation and Setup</h2>
                <p>Let's get Zod installed and integrated with React Hook Form.</p>

                <h3>Step 1: Install Zod</h3>
                <p>First, install Zod itself:</p>

                <pre><code class="language-bash"># Using npm
npm install zod

# Using yarn
yarn add zod

# Using pnpm
pnpm add zod</code></pre>

                <h3>Step 2: Install the Resolver</h3>
                <p>To connect Zod with React Hook Form, you need the resolver package:</p>

                <pre><code class="language-bash"># Using npm
npm install @hookform/resolvers

# Using yarn
yarn add @hookform/resolvers

# Using pnpm
pnpm add @hookform/resolvers</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° What is a Resolver?</h4>
                    <p>A <strong>resolver</strong> is a bridge that connects validation libraries (like Zod, Yup, Joi) to React Hook Form. It tells React Hook Form:</p>
                    <ul>
                        <li>How to validate form data using your schema</li>
                        <li>How to format error messages</li>
                        <li>When to trigger validation</li>
                    </ul>
                    <p>The <code>@hookform/resolvers</code> package includes resolvers for all major validation libraries.</p>
                </div>

                <h3>Step 3: Import and Set Up</h3>
                <p>Here's the complete setup in a React component:</p>

                <pre><code class="language-typescript">// 1. Import Zod
import { z } from 'zod';

// 2. Import React Hook Form
import { useForm } from 'react-hook-form';

// 3. Import the Zod resolver
import { zodResolver } from '@hookform/resolvers/zod';

// 4. Define your schema
const schema = z.object({
  email: z.string().email(),
  password: z.string().min(8)
});

// 5. Infer the TypeScript type
type FormData = z.infer&lt;typeof schema&gt;;

// 6. Use in your component
function MyForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;FormData&gt;({
    resolver: zodResolver(schema) // Connect Zod to React Hook Form!
  });

  const onSubmit = (data: FormData) => {
    console.log(data); // Fully validated and typed!
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;input {...register('email')} /&gt;
      {errors.email && &lt;span&gt;{errors.email.message}&lt;/span&gt;}
      
      &lt;input type="password" {...register('password')} /&gt;
      {errors.password && &lt;span&gt;{errors.password.message}&lt;/span&gt;}
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What Just Happened?</h4>
                    <ol>
                        <li>Defined a Zod schema describing valid form data</li>
                        <li>Inferred TypeScript type from the schema (no manual typing!)</li>
                        <li>Connected schema to React Hook Form via <code>zodResolver</code></li>
                        <li>Registered inputs without inline validation rules</li>
                        <li>Zod automatically validates and provides error messages</li>
                    </ol>
                </div>

                <h3>Minimal Working Example</h3>
                <p>Here's the absolute minimum to get started:</p>

                <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Schema
const schema = z.object({
  name: z.string().min(1, 'Name is required')
});

// Type
type FormData = z.infer&lt;typeof schema&gt;;

function SimpleForm() {
  const { register, handleSubmit } = useForm&lt;FormData&gt;({
    resolver: zodResolver(schema)
  });

  return (
    &lt;form onSubmit={handleSubmit(data => console.log(data))}&gt;
      &lt;input {...register('name')} /&gt;
      &lt;button&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Setup Mistakes</h4>
                    <ul>
                        <li>‚ùå Forgetting to install <code>@hookform/resolvers</code></li>
                        <li>‚ùå Using <code>zod</code> resolver instead of <code>zodResolver</code></li>
                        <li>‚ùå Not passing the resolver to <code>useForm</code></li>
                        <li>‚ùå Defining the schema inside the component (will recreate on every render)</li>
                    </ul>
                    <p><strong>Always define schemas outside your component!</strong></p>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 1: Setup and First Form</strong></summary>
                    <p><strong>Task:</strong> Set up Zod with React Hook Form and create a simple login form.</p>
                    
                    <ol>
                        <li>Install zod and @hookform/resolvers</li>
                        <li>Create a LoginForm component</li>
                        <li>Define a schema with email and password fields</li>
                        <li>Email must be a valid email</li>
                        <li>Password must be at least 6 characters</li>
                        <li>Show error messages below each field</li>
                        <li>Log the data on successful submit</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Import z from 'zod', use z.object() for the schema, z.string() for fields, and chain .email() and .min(). Use zodResolver when calling useForm.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Define schema outside component
const loginSchema = z.object({
  email: z.string()
    .min(1, 'Email is required')
    .email('Invalid email address'),
  password: z.string()
    .min(1, 'Password is required')
    .min(6, 'Password must be at least 6 characters')
});

// Infer TypeScript type
type LoginFormData = z.infer&lt;typeof loginSchema&gt;;

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;LoginFormData&gt;({
    resolver: zodResolver(loginSchema)
  });

  const onSubmit = (data: LoginFormData) => {
    console.log('Login data:', data);
    alert(`Logging in with email: ${data.email}`);
  };

  return (
    &lt;form
      onSubmit={handleSubmit(onSubmit)}
      style={{ maxWidth: '400px', margin: '2rem auto' }}
    &gt;
      &lt;h2&gt;Login&lt;/h2&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="email" style={{ display: 'block', marginBottom: '0.5rem' }}&gt;
          Email
        &lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          {...register('email')}
          style={{
            width: '100%',
            padding: '0.5rem',
            border: `1px solid ${errors.email ? '#f56565' : '#ddd'}`,
            borderRadius: '4px'
          }}
        /&gt;
        {errors.email && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.email.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="password" style={{ display: 'block', marginBottom: '0.5rem' }}&gt;
          Password
        &lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          {...register('password')}
          style={{
            width: '100%',
            padding: '0.5rem',
            border: `1px solid ${errors.password ? '#f56565' : '#ddd'}`,
            borderRadius: '4px'
          }}
        /&gt;
        {errors.password && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.password.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button
        type="submit"
        style={{
          width: '100%',
          padding: '0.75rem',
          background: '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
          fontSize: '1rem'
        }}
      &gt;
        Login
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

export default LoginForm;</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 3: Your First Zod Schema -->
            <section id="section3" aria-labelledby="section3-title">
                <h2 id="section3-title">üìù Your First Zod Schema</h2>
                <p>Let's build schemas step-by-step to understand how Zod works.</p>

                <h3>Basic Object Schema</h3>
                <p>The most common schema is an object with fields:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Define a schema
const userSchema = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string()
});

// The schema is now a validator!
// It can parse and validate data:

// ‚úÖ Valid data
const validUser = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com'
};

const result = userSchema.parse(validUser);
console.log(result); // { name: 'Alice', age: 30, email: 'alice@example.com' }

// ‚ùå Invalid data
const invalidUser = {
  name: 'Bob',
  age: 'thirty', // Wrong type!
  email: 'bob@example.com'
};

try {
  userSchema.parse(invalidUser);
} catch (error) {
  console.error('Validation failed:', error);
  // ZodError with detailed error information
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Zod Methods</h4>
                    <ul>
                        <li><code>.parse(data)</code> - Validate and return data (throws error if invalid)</li>
                        <li><code>.safeParse(data)</code> - Validate and return {success, data} or {success, error}</li>
                        <li><code>.parseAsync(data)</code> - Async version of parse</li>
                        <li><code>.partial()</code> - Make all fields optional</li>
                        <li><code>.required()</code> - Make all fields required</li>
                        <li><code>.extend()</code> - Add more fields to schema</li>
                    </ul>
                </div>

                <h3>Building a Schema Step by Step</h3>
                <p>Let's build a registration form schema progressively:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Start simple
const step1 = z.object({
  username: z.string(),
  email: z.string()
});

// Add validation rules
const step2 = z.object({
  username: z.string().min(3).max(20),
  email: z.string().email()
});

// Add custom error messages
const step3 = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters'),
  email: z.string()
    .email('Invalid email address')
});

// Add more fields
const step4 = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters'),
  email: z.string()
    .email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters'),
  confirmPassword: z.string()
});

// Add field relationships (password confirmation)
const registrationSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username must be at most 20 characters'),
  email: z.string()
    .email('Invalid email address'),
  password: z.string()
    .min(8, 'Password must be at least 8 characters'),
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'] // Error will show on confirmPassword field
});

// Infer the TypeScript type
type RegistrationData = z.infer&lt;typeof registrationSchema&gt;;
// Result: {
//   username: string;
//   email: string;
//   password: string;
//   confirmPassword: string;
// }</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Schema Building Strategy</h4>
                    <ol>
                        <li>Start with basic structure (field names and types)</li>
                        <li>Add simple validation (min, max, email, etc.)</li>
                        <li>Add custom error messages</li>
                        <li>Add more fields as needed</li>
                        <li>Add cross-field validation with <code>refine()</code></li>
                        <li>Test with sample data</li>
                    </ol>
                </div>

                <h3>Schema Composition</h3>
                <p>Build complex schemas by composing smaller ones:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Define reusable schemas
const addressSchema = z.object({
  street: z.string().min(1, 'Street is required'),
  city: z.string().min(1, 'City is required'),
  zipCode: z.string().regex(/^\d{5}$/, 'Zip code must be 5 digits'),
  country: z.string().min(1, 'Country is required')
});

const contactSchema = z.object({
  phone: z.string().regex(/^\d{10}$/, 'Phone must be 10 digits'),
  email: z.string().email('Invalid email')
});

// Compose them into a larger schema
const userProfileSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  age: z.number().min(18, 'Must be 18 or older'),
  address: addressSchema,     // Nested schema!
  contact: contactSchema,      // Another nested schema!
  bio: z.string().optional()   // Optional field
});

// Type inference works with nested schemas!
type UserProfile = z.infer&lt;typeof userProfileSchema&gt;;
// Result: {
//   name: string;
//   age: number;
//   address: {
//     street: string;
//     city: string;
//     zipCode: string;
//     country: string;
//   };
//   contact: {
//     phone: string;
//     email: string;
//   };
//   bio?: string | undefined;
// }</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Benefits of Schema Composition</h4>
                    <ul>
                        <li><strong>Reusability</strong> - Use addressSchema across multiple forms</li>
                        <li><strong>Maintainability</strong> - Update address validation in one place</li>
                        <li><strong>Clarity</strong> - Each schema has a single responsibility</li>
                        <li><strong>Testing</strong> - Test schemas independently</li>
                        <li><strong>Sharing</strong> - Share schemas between frontend and backend</li>
                    </ul>
                </div>


                <h3>Testing Schemas</h3>
                <p>Before using a schema in a form, test it with sample data:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

const userSchema = z.object({
  email: z.string().email(),
  age: z.number().min(18)
});

// Test valid data
const validData = { email: 'test@example.com', age: 25 };
const result1 = userSchema.safeParse(validData);
console.log(result1);
// { success: true, data: { email: 'test@example.com', age: 25 } }

// Test invalid data
const invalidData = { email: 'not-an-email', age: 15 };
const result2 = userSchema.safeParse(invalidData);
console.log(result2);
// { success: false, error: ZodError { issues: [...] } }

if (!result2.success) {
  console.log('Validation errors:');
  result2.error.issues.forEach(issue => {
    console.log(`${issue.path.join('.')}: ${issue.message}`);
  });
}
// Output:
// email: Invalid email
// age: Number must be greater than or equal to 18</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practice: Test Your Schemas</h4>
                    <p>Always test schemas with both valid and invalid data before using them in production:</p>
                    <ul>
                        <li>Create a test file for your schemas</li>
                        <li>Test edge cases (empty strings, negative numbers, etc.)</li>
                        <li>Verify error messages are clear and helpful</li>
                        <li>Test nested schemas thoroughly</li>
                        <li>Use <code>safeParse</code> for testing (doesn't throw errors)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Integrating with React Hook Form -->
            <section id="section4" aria-labelledby="section4-title">
                <h2 id="section4-title">üîó Integrating with React Hook Form</h2>
                <p>Now that you understand Zod schemas, let's see how to use them with React Hook Form in practice.</p>

                <h3>Complete Integration Example</h3>
                <p>Here's a full working example with all the pieces together:</p>

                <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// 1. Define the schema
const registrationSchema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username cannot exceed 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
  
  email: z.string()
    .min(1, 'Email is required')
    .email('Invalid email address'),
  
  age: z.number({
    required_error: 'Age is required',
    invalid_type_error: 'Age must be a number'
  })
    .min(18, 'You must be at least 18 years old')
    .max(120, 'Please enter a valid age'),
  
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number'),
  
  confirmPassword: z.string(),
  
  terms: z.boolean()
    .refine(val => val === true, {
      message: 'You must accept the terms and conditions'
    })
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword']
});

// 2. Infer TypeScript type
type RegistrationFormData = z.infer<typeof registrationSchema>;

// 3. Create the form component
function RegistrationForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<RegistrationFormData>({
    resolver: zodResolver(registrationSchema)
  });

  const onSubmit = async (data: RegistrationFormData) => {
    console.log('Form data:', data);
    // Data is already validated by Zod!
    await new Promise(resolve => setTimeout(resolve, 1000));
    alert('Registration successful!');
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)} style={{ maxWidth: '500px', margin: '2rem auto' }}&gt;
      &lt;h2&gt;Create Account&lt;/h2&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="username"&gt;Username *&lt;/label&gt;
        &lt;input
          id="username"
          {...register('username')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.username ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.username && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.username.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="email"&gt;Email *&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          {...register('email')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.email ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.email && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.email.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="age"&gt;Age *&lt;/label&gt;
        &lt;input
          id="age"
          type="number"
          {...register('age', { valueAsNumber: true })}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.age ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.age && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.age.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="password"&gt;Password *&lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          {...register('password')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.password ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.password && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.password.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password *&lt;/label&gt;
        &lt;input
          id="confirmPassword"
          type="password"
          {...register('confirmPassword')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.confirmPassword ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.confirmPassword && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.confirmPassword.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}&gt;
          &lt;input type="checkbox" {...register('terms')} /&gt;
          I accept the terms and conditions *
        &lt;/label&gt;
        {errors.terms && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.terms.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button
        type="submit"
        disabled={isSubmitting}
        style={{
          width: '100%',
          padding: '0.75rem',
          background: isSubmitting ? '#ddd' : '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: isSubmitting ? 'not-allowed' : 'pointer'
        }}
      &gt;
        {isSubmitting ? 'Creating Account...' : 'Create Account'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

export default RegistrationForm;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Integration Points</h4>
                    <ul>
                        <li><code>zodResolver(schema)</code> - Connects Zod to React Hook Form</li>
                        <li><code>z.infer&lt;typeof schema&gt;</code> - Automatic TypeScript types</li>
                        <li><code>{...register('fieldName')}</code> - No inline validation needed!</li>
                        <li><code>valueAsNumber: true</code> - Convert number inputs to numbers</li>
                        <li><code>errors.fieldName.message</code> - Zod's custom error messages</li>
                        <li>Cross-field validation with <code>refine()</code> works automatically</li>
                    </ul>
                </div>

                <h3>Validation Modes with Zod</h3>
                <p>Control when Zod validates your form:</p>

                <pre><code class="language-typescript">// Validate on submit only (default)
const { register } = useForm<FormData>({
  resolver: zodResolver(schema),
  mode: 'onSubmit'
});

// Validate on blur (good UX)
const { register } = useForm<FormData>({
  resolver: zodResolver(schema),
  mode: 'onBlur'
});

// Validate on change (real-time feedback)
const { register } = useForm<FormData>({
  resolver: zodResolver(schema),
  mode: 'onChange'
});

// Validate on blur, then on change (best UX)
const { register } = useForm<FormData>({
  resolver: zodResolver(schema),
  mode: 'onTouched'
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Recommended Mode for Zod</h4>
                    <p>Use <code>mode: 'onTouched'</code> for the best user experience with Zod:</p>
                    <ul>
                        <li>User isn't bothered while typing</li>
                        <li>Validation happens after they leave a field</li>
                        <li>Subsequent changes show real-time feedback</li>
                        <li>Balances helpfulness with intrusiveness</li>
                    </ul>
                </div>

                <h3>Handling Number and Date Inputs</h3>
                <p>Special handling for non-string inputs:</p>

                <pre><code class="language-typescript">const schema = z.object({
  age: z.number(),
  birthDate: z.date(),
  quantity: z.number().int().positive()
});

type FormData = z.infer<typeof schema>;

function NumberDateForm() {
  const { register, handleSubmit } = useForm<FormData>({
    resolver: zodResolver(schema)
  });

  return (
    &lt;form onSubmit={handleSubmit(data =&gt; console.log(data))}&gt;
      {/* For number inputs, use valueAsNumber */}
      &lt;input
        type="number"
        {...register('age', { valueAsNumber: true })}
      /&gt;
      
      {/* For date inputs, use valueAsDate */}
      &lt;input
        type="date"
        {...register('birthDate', { valueAsDate: true })}
      /&gt;
      
      {/* Integer input */}
      &lt;input
        type="number"
        {...register('quantity', { valueAsNumber: true })}
      /&gt;
      
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important: Type Coercion</h4>
                    <p>HTML inputs always return strings by default. You must tell React Hook Form to convert them:</p>
                    <ul>
                        <li><code>valueAsNumber: true</code> - For number inputs</li>
                        <li><code>valueAsDate: true</code> - For date inputs</li>
                    </ul>
                    <p>Without these, Zod will receive strings and validation will fail!</p>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 2: Complete Form Integration</strong></summary>
                    <p><strong>Task:</strong> Build a profile form with Zod validation.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Fields: firstName, lastName, email, age, bio</li>
                        <li>firstName and lastName: required, 2-50 characters</li>
                        <li>Email: required, valid email format</li>
                        <li>Age: required, number between 18-120</li>
                        <li>Bio: optional, max 200 characters</li>
                        <li>Use mode: 'onTouched' for validation</li>
                        <li>Show all error messages</li>
                        <li>Infer TypeScript types from schema</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use z.object() with z.string() and z.number(). Chain .min() and .max() for validation. Use .optional() for bio. Don't forget valueAsNumber for age!</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// Define schema
const profileSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .min(2, 'First name must be at least 2 characters')
    .max(50, 'First name cannot exceed 50 characters'),
  
  lastName: z.string()
    .min(1, 'Last name is required')
    .min(2, 'Last name must be at least 2 characters')
    .max(50, 'Last name cannot exceed 50 characters'),
  
  email: z.string()
    .min(1, 'Email is required')
    .email('Invalid email address'),
  
  age: z.number({
    required_error: 'Age is required',
    invalid_type_error: 'Age must be a number'
  })
    .min(18, 'You must be at least 18 years old')
    .max(120, 'Please enter a valid age'),
  
  bio: z.string()
    .max(200, 'Bio cannot exceed 200 characters')
    .optional()
});

// Infer TypeScript type
type ProfileFormData = z.infer<typeof profileSchema>;

function ProfileForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm<ProfileFormData>({
    resolver: zodResolver(profileSchema),
    mode: 'onTouched'
  });

  const onSubmit = (data: ProfileFormData) => {
    console.log('Profile data:', data);
    alert('Profile updated successfully!');
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)} style={{ maxWidth: '500px', margin: '2rem auto' }}&gt;
      &lt;h2&gt;Update Profile&lt;/h2&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="firstName"&gt;First Name *&lt;/label&gt;
        &lt;input
          id="firstName"
          {...register('firstName')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.firstName ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.firstName && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.firstName.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="lastName"&gt;Last Name *&lt;/label&gt;
        &lt;input
          id="lastName"
          {...register('lastName')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.lastName ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.lastName && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.lastName.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="email"&gt;Email *&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          {...register('email')}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.email ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.email && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.email.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="age"&gt;Age *&lt;/label&gt;
        &lt;input
          id="age"
          type="number"
          {...register('age', { valueAsNumber: true })}
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.age ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.age && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.age.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="bio"&gt;Bio (Optional)&lt;/label&gt;
        &lt;textarea
          id="bio"
          {...register('bio')}
          rows={4}
          placeholder="Tell us about yourself..."
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            fontFamily: 'inherit',
            border: `1px solid ${errors.bio ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.bio && (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.bio.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button
        type="submit"
        style={{
          width: '100%',
          padding: '0.75rem',
          background: '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      &gt;
        Update Profile
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

export default ProfileForm;</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 5: Basic Zod Types -->
            <section id="section5" aria-labelledby="section5-title">
                <h2 id="section5-title">üî§ Basic Zod Types</h2>
                <p>Zod provides types for all JavaScript primitives and more. Let's explore the fundamental building blocks.</p>

                <h3>Primitive Types</h3>
                <pre><code class="language-typescript">import { z } from 'zod';

// String
const stringSchema = z.string();
stringSchema.parse('hello'); // ‚úÖ 'hello'
stringSchema.parse(123);     // ‚ùå Error

// Number
const numberSchema = z.number();
numberSchema.parse(42);      // ‚úÖ 42
numberSchema.parse('42');    // ‚ùå Error

// Boolean
const booleanSchema = z.boolean();
booleanSchema.parse(true);   // ‚úÖ true
booleanSchema.parse('true'); // ‚ùå Error

// BigInt
const bigintSchema = z.bigint();
bigintSchema.parse(9007199254740991n); // ‚úÖ

// Date
const dateSchema = z.date();
dateSchema.parse(new Date()); // ‚úÖ
dateSchema.parse('2024-01-01'); // ‚ùå Error

// Undefined
const undefinedSchema = z.undefined();
undefinedSchema.parse(undefined); // ‚úÖ

// Null
const nullSchema = z.null();
nullSchema.parse(null); // ‚úÖ

// Void (accepts undefined)
const voidSchema = z.void();
voidSchema.parse(undefined); // ‚úÖ</code></pre>

                <h3>String Schema</h3>
                <p>The string type is one of the most commonly used:</p>

                <pre><code class="language-typescript">const schema = z.object({
  // Basic string
  name: z.string(),
  
  // Required string (not empty)
  username: z.string().min(1, 'Username is required'),
  
  // String with length constraints
  password: z.string()
    .min(8, 'At least 8 characters')
    .max(100, 'Maximum 100 characters'),
  
  // Email validation
  email: z.string().email('Invalid email'),
  
  // URL validation
  website: z.string().url('Invalid URL'),
  
  // UUID validation
  id: z.string().uuid('Invalid UUID'),
  
  // Custom regex
  phone: z.string().regex(/^\d{10}$/, 'Phone must be 10 digits'),
  
  // Specific format
  zipCode: z.string().regex(/^\d{5}(-\d{4})?$/, 'Invalid zip code'),
  
  // Optional string
  bio: z.string().optional(),
  
  // String with default value
  role: z.string().default('user'),
  
  // Nullable string
  middleName: z.string().nullable()
});</code></pre>

                <h3>Number Schema</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Basic number
  age: z.number(),
  
  // Positive number
  price: z.number().positive('Price must be positive'),
  
  // Non-negative (0 or greater)
  quantity: z.number().nonnegative('Cannot be negative'),
  
  // Negative number
  temperature: z.number().negative(),
  
  // Number with min/max
  rating: z.number()
    .min(1, 'Minimum rating is 1')
    .max(5, 'Maximum rating is 5'),
  
  // Integer only
  count: z.number().int('Must be an integer'),
  
  // Multiple of (divisible by)
  discount: z.number().multipleOf(5, 'Must be multiple of 5'),
  
  // Safe integer (JavaScript safe range)
  bigNumber: z.number().safe(),
  
  // Finite number (not Infinity or NaN)
  score: z.number().finite(),
  
  // Optional number
  optionalAge: z.number().optional(),
  
  // Number with default
  priority: z.number().default(0)
});</code></pre>

                <h3>Boolean Schema</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Basic boolean
  isActive: z.boolean(),
  
  // Boolean that must be true (for terms acceptance)
  terms: z.boolean()
    .refine(val => val === true, {
      message: 'You must accept the terms'
    }),
  
  // Optional boolean
  newsletter: z.boolean().optional(),
  
  // Boolean with default
  emailNotifications: z.boolean().default(true)
});</code></pre>

                <h3>Array Schema</h3>
                <pre><code class="language-typescript">// Array of strings
const tagsSchema = z.array(z.string());
tagsSchema.parse(['tag1', 'tag2']); // ‚úÖ

// Array with constraints
const schema = z.object({
  // Array with min/max length
  tags: z.array(z.string())
    .min(1, 'At least one tag required')
    .max(5, 'Maximum 5 tags allowed'),
  
  // Array of numbers
  scores: z.array(z.number()),
  
  // Array of objects
  friends: z.array(z.object({
    name: z.string(),
    age: z.number()
  })),
  
  // Non-empty array
  categories: z.array(z.string()).nonempty('Select at least one category'),
  
  // Optional array
  hobbies: z.array(z.string()).optional(),
  
  // Array with default
  permissions: z.array(z.string()).default(['read'])
});</code></pre>

                <h3>Object Schema</h3>
                <pre><code class="language-typescript">// Nested objects
const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  state: z.string(),
  zipCode: z.string()
});

const userSchema = z.object({
  name: z.string(),
  email: z.string().email(),
  address: addressSchema, // Nested object
  
  // Object with dynamic keys
  metadata: z.record(z.string(), z.any()),
  
  // Optional object
  preferences: z.object({
    theme: z.string(),
    language: z.string()
  }).optional()
});</code></pre>

                <h3>Enum Schema</h3>
                <pre><code class="language-typescript">// String enum
const roleSchema = z.enum(['admin', 'user', 'guest']);
roleSchema.parse('admin'); // ‚úÖ
roleSchema.parse('superuser'); // ‚ùå Error

// In a form
const schema = z.object({
  role: z.enum(['admin', 'user', 'guest']),
  
  // With custom error
  status: z.enum(['active', 'inactive', 'pending'], {
    errorMap: () => ({ message: 'Invalid status' })
  }),
  
  // From TypeScript enum
  priority: z.nativeEnum(Priority) // where Priority is a TS enum
});

// TypeScript enum example
enum Priority {
  Low = 'low',
  Medium = 'medium',
  High = 'high'
}

const taskSchema = z.object({
  title: z.string(),
  priority: z.nativeEnum(Priority)
});</code></pre>

                <h3>Union Types</h3>
                <pre><code class="language-typescript">// Union of primitives
const idSchema = z.union([z.string(), z.number()]);
idSchema.parse('123'); // ‚úÖ
idSchema.parse(456);   // ‚úÖ
idSchema.parse(true);  // ‚ùå

// In a form
const schema = z.object({
  // Field can be string or number
  identifier: z.union([z.string(), z.number()]),
  
  // Contact preference
  contact: z.union([
    z.object({ type: z.literal('email'), email: z.string().email() }),
    z.object({ type: z.literal('phone'), phone: z.string() })
  ])
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Type Reference Quick Guide</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Zod Code</th>
                                <th>TypeScript Type</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>String</td>
                                <td><code>z.string()</code></td>
                                <td><code>string</code></td>
                            </tr>
                            <tr>
                                <td>Number</td>
                                <td><code>z.number()</code></td>
                                <td><code>number</code></td>
                            </tr>
                            <tr>
                                <td>Boolean</td>
                                <td><code>z.boolean()</code></td>
                                <td><code>boolean</code></td>
                            </tr>
                            <tr>
                                <td>Array</td>
                                <td><code>z.array(z.string())</code></td>
                                <td><code>string[]</code></td>
                            </tr>
                            <tr>
                                <td>Object</td>
                                <td><code>z.object({...})</code></td>
                                <td><code>{ ... }</code></td>
                            </tr>
                            <tr>
                                <td>Optional</td>
                                <td><code>z.string().optional()</code></td>
                                <td><code>string | undefined</code></td>
                            </tr>
                            <tr>
                                <td>Nullable</td>
                                <td><code>z.string().nullable()</code></td>
                                <td><code>string | null</code></td>
                            </tr>
                            <tr>
                                <td>Enum</td>
                                <td><code>z.enum(['a', 'b'])</code></td>
                                <td><code>'a' | 'b'</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Optional vs Nullable vs Default</h3>
                <p>Understanding the difference is crucial:</p>

                <pre><code class="language-typescript">const schema = z.object({
  // Optional - field can be omitted or undefined
  bio: z.string().optional(),
  // Type: string | undefined
  // Valid: { bio: 'text' }, { bio: undefined }, {}
  
  // Nullable - field must exist but can be null
  middleName: z.string().nullable(),
  // Type: string | null
  // Valid: { middleName: 'Jane' }, { middleName: null }
  // Invalid: {} (field required)
  
  // Default - field uses default if omitted
  role: z.string().default('user'),
  // Type: string
  // Valid: { role: 'admin' }, {}
  // Result: { role: 'admin' }, { role: 'user' }
  
  // Optional + Nullable
  nickname: z.string().optional().nullable(),
  // Type: string | null | undefined
  // Valid: { nickname: 'Bob' }, { nickname: null }, { nickname: undefined }, {}
  
  // Nullable + Default
  theme: z.string().nullable().default('dark'),
  // Type: string | null
  // Valid: { theme: 'light' }, { theme: null }, {}
  // Result: { theme: 'light' }, { theme: null }, { theme: 'dark' }
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Each</h4>
                    <ul>
                        <li><strong>optional()</strong> - Field may or may not be in the data (form fields that can be empty)</li>
                        <li><strong>nullable()</strong> - Field exists but value might be null (API fields that explicitly use null)</li>
                        <li><strong>default()</strong> - Provide fallback value when field is missing (configuration options)</li>
                    </ul>
                </div>

            </section>

            <!-- Section 6: String Validation -->
            <section id="section6" aria-labelledby="section6-title">
                <h2 id="section6-title">üìù String Validation</h2>
                <p>Zod provides extensive string validation capabilities. Let's explore them in detail.</p>

                <h3>Length Validation</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Minimum length
  username: z.string().min(3, 'Username must be at least 3 characters'),
  
  // Maximum length
  bio: z.string().max(200, 'Bio cannot exceed 200 characters'),
  
  // Exact length
  zipCode: z.string().length(5, 'Zip code must be exactly 5 digits'),
  
  // Combined min and max
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .max(100, 'Password cannot exceed 100 characters'),
  
  // Non-empty (at least 1 character)
  name: z.string().min(1, 'Name is required')
});</code></pre>

                <h3>Format Validation</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Email validation
  email: z.string().email('Invalid email address'),
  
  // URL validation
  website: z.string().url('Invalid URL'),
  
  // UUID validation
  id: z.string().uuid('Invalid UUID'),
  
  // CUID validation
  userId: z.string().cuid('Invalid CUID'),
  
  // CUID2 validation
  sessionId: z.string().cuid2('Invalid CUID2'),
  
  // ULID validation
  transactionId: z.string().ulid('Invalid ULID'),
  
  // ISO datetime validation
  createdAt: z.string().datetime('Invalid datetime'),
  
  // IP address validation
  ipAddress: z.string().ip('Invalid IP address'),
  
  // IPv4 specific
  ipv4: z.string().ip({ version: 'v4', message: 'Invalid IPv4' }),
  
  // IPv6 specific
  ipv6: z.string().ip({ version: 'v6', message: 'Invalid IPv6' })
});</code></pre>

                <h3>Pattern Matching (Regex)</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Phone number (US format)
  phone: z.string().regex(
    /^\d{3}-\d{3}-\d{4}$/,
    'Phone must be in format: 123-456-7890'
  ),
  
  // Alphanumeric only
  username: z.string().regex(
    /^[a-zA-Z0-9]+$/,
    'Username can only contain letters and numbers'
  ),
  
  // Starts with capital letter
  name: z.string().regex(
    /^[A-Z]/,
    'Name must start with a capital letter'
  ),
  
  // Hex color code
  color: z.string().regex(
    /^#[0-9A-Fa-f]{6}$/,
    'Invalid hex color code'
  ),
  
  // Credit card number (simple check)
  creditCard: z.string().regex(
    /^\d{4}-\d{4}-\d{4}-\d{4}$/,
    'Credit card must be in format: 1234-5678-9012-3456'
  ),
  
  // Social Security Number
  ssn: z.string().regex(
    /^\d{3}-\d{2}-\d{4}$/,
    'SSN must be in format: 123-45-6789'
  )
});</code></pre>

                <h3>String Transformations</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Trim whitespace
  name: z.string().trim(),
  
  // Convert to lowercase
  email: z.string().toLowerCase().email(),
  
  // Convert to uppercase
  code: z.string().toUpperCase(),
  
  // Chain transformations
  username: z.string()
    .trim()
    .toLowerCase()
    .min(3, 'At least 3 characters'),
  
  // Custom transformation
  slug: z.string().transform(val => 
    val.toLowerCase().replace(/\s+/g, '-')
  )
});

// Example usage
const result = schema.parse({
  name: '  John Doe  ',
  email: 'JOHN@EXAMPLE.COM',
  code: 'abc123',
  username: '  JohnDoe  ',
  slug: 'My Blog Post'
});

console.log(result);
// {
//   name: 'John Doe',
//   email: 'john@example.com',
//   code: 'ABC123',
//   username: 'johndoe',
//   slug: 'my-blog-post'
// }</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ String Validation Best Practices</h4>
                    <ul>
                        <li>Always trim strings to remove accidental whitespace</li>
                        <li>Use built-in validators (email, url) instead of custom regex when possible</li>
                        <li>Provide clear, specific error messages</li>
                        <li>Consider case sensitivity (toLowerCase for emails)</li>
                        <li>Validate format AND length (e.g., email + min length)</li>
                        <li>Use transformations to normalize data</li>
                    </ul>
                </div>


                <h3>Common String Validation Patterns</h3>
                <p>Here are ready-to-use validation patterns for common scenarios:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Common patterns
const commonPatterns = {
  // Username (alphanumeric + underscore, 3-20 chars)
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username cannot exceed 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
  
  // Password (strong - 8+ chars, uppercase, lowercase, number, special)
  strongPassword: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain at least one uppercase letter')
    .regex(/[a-z]/, 'Password must contain at least one lowercase letter')
    .regex(/[0-9]/, 'Password must contain at least one number')
    .regex(/[^A-Za-z0-9]/, 'Password must contain at least one special character'),
  
  // US Phone number
  usPhone: z.string()
    .regex(/^\d{3}-\d{3}-\d{4}$/, 'Phone must be in format: 123-456-7890'),
  
  // US Zip code (5 or 9 digits)
  usZip: z.string()
    .regex(/^\d{5}(-\d{4})?$/, 'Invalid zip code'),
  
  // Credit card number (simple format check)
  creditCard: z.string()
    .regex(/^\d{4}-\d{4}-\d{4}-\d{4}$/, 'Invalid credit card format'),
  
  // URL slug (lowercase, hyphens, numbers)
  slug: z.string()
    .regex(/^[a-z0-9-]+$/, 'Slug can only contain lowercase letters, numbers, and hyphens'),
  
  // Hex color code
  hexColor: z.string()
    .regex(/^#[0-9A-Fa-f]{6}$/, 'Invalid hex color (e.g., #FF5733)'),
  
  // ISO Date string
  isoDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format')
};

// Example usage in a form
const formSchema = z.object({
  username: commonPatterns.username,
  password: commonPatterns.strongPassword,
  phone: commonPatterns.usPhone,
  zipCode: commonPatterns.usZip
});</code></pre>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 3: String Validation Practice</strong></summary>
                    <p><strong>Task:</strong> Create a contact form with advanced string validation.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Name: required, trimmed, 2-50 characters, starts with capital letter</li>
                        <li>Email: required, valid email format, lowercase</li>
                        <li>Phone: required, US format (123-456-7890)</li>
                        <li>Website: optional, valid URL</li>
                        <li>Message: required, 10-500 characters, trimmed</li>
                        <li>Use proper error messages for each validation</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Chain validations: .trim().min().max().regex(). Use .toLowerCase() for email. Use .url() for website. Make website optional with .optional().</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const contactSchema = z.object({
  name: z.string()
    .trim()
    .min(1, 'Name is required')
    .min(2, 'Name must be at least 2 characters')
    .max(50, 'Name cannot exceed 50 characters')
    .regex(/^[A-Z]/, 'Name must start with a capital letter'),
  
  email: z.string()
    .trim()
    .min(1, 'Email is required')
    .email('Invalid email address')
    .toLowerCase(),
  
  phone: z.string()
    .regex(/^\d{3}-\d{3}-\d{4}$/, 'Phone must be in format: 123-456-7890'),
  
  website: z.string()
    .url('Invalid URL')
    .optional()
    .or(z.literal('')), // Allow empty string
  
  message: z.string()
    .trim()
    .min(10, 'Message must be at least 10 characters')
    .max(500, 'Message cannot exceed 500 characters')
});

type ContactFormData = z.infer&lt;typeof contactSchema&gt;;

function ContactForm() {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;ContactFormData&gt;({
    resolver: zodResolver(contactSchema)
  });

  const onSubmit = (data: ContactFormData) =&gt; {
    console.log('Contact form data:', data);
    alert('Message sent successfully!');
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)} style={{ maxWidth: '500px', margin: '2rem auto' }}&gt;
      &lt;h2&gt;Contact Us&lt;/h2&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="name"&gt;Name *&lt;/label&gt;
        &lt;input
          id="name"
          {...register('name')}
          placeholder="John Doe"
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.name ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.name &amp;&amp; (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.name.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="email"&gt;Email *&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          {...register('email')}
          placeholder="john@example.com"
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.email ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.email &amp;&amp; (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.email.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="phone"&gt;Phone *&lt;/label&gt;
        &lt;input
          id="phone"
          type="tel"
          {...register('phone')}
          placeholder="123-456-7890"
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.phone ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.phone &amp;&amp; (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.phone.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="website"&gt;Website (Optional)&lt;/label&gt;
        &lt;input
          id="website"
          type="url"
          {...register('website')}
          placeholder="https://example.com"
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            border: `1px solid ${errors.website ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.website &amp;&amp; (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.website.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label htmlFor="message"&gt;Message *&lt;/label&gt;
        &lt;textarea
          id="message"
          {...register('message')}
          rows={5}
          placeholder="Tell us what you need..."
          style={{
            width: '100%',
            padding: '0.5rem',
            marginTop: '0.5rem',
            fontFamily: 'inherit',
            border: `1px solid ${errors.message ? '#f56565' : '#ddd'}`
          }}
        /&gt;
        {errors.message &amp;&amp; (
          &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
            {errors.message.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button
        type="submit"
        style={{
          width: '100%',
          padding: '0.75rem',
          background: '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      &gt;
        Send Message
      &lt;/button&gt;
    &lt;/form&gt;
  );
}

export default ContactForm;</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 7: Number and Date Validation -->
            <section id="section7" aria-labelledby="section7-title">
                <h2 id="section7-title">üî¢ Number and Date Validation</h2>
                <p>Zod provides powerful validation for numbers and dates. Let's explore the options.</p>

                <h3>Number Validation Methods</h3>
                <pre><code class="language-typescript">import { z } from 'zod';

const schema = z.object({
  // Greater than (exclusive)
  age: z.number().gt(0, 'Age must be greater than 0'),
  
  // Greater than or equal (inclusive)
  rating: z.number().gte(1, 'Rating must be at least 1'),
  
  // Less than (exclusive)
  discount: z.number().lt(100, 'Discount must be less than 100'),
  
  // Less than or equal (inclusive)
  percentage: z.number().lte(100, 'Percentage cannot exceed 100'),
  
  // Positive (> 0)
  price: z.number().positive('Price must be positive'),
  
  // Non-negative (>= 0)
  quantity: z.number().nonnegative('Quantity cannot be negative'),
  
  // Negative (< 0)
  temperature: z.number().negative('Temperature must be negative'),
  
  // Non-positive (<= 0)
  debt: z.number().nonpositive('Debt cannot be positive'),
  
  // Multiple of (divisible by)
  stepValue: z.number().multipleOf(5, 'Must be a multiple of 5'),
  
  // Integer only
  count: z.number().int('Must be a whole number'),
  
  // Finite (not Infinity or NaN)
  score: z.number().finite('Must be a finite number'),
  
  // Safe integer (within JavaScript safe range)
  id: z.number().safe('Number too large')
});</code></pre>

                <h3>Number Range Validation</h3>
                <pre><code class="language-typescript">const schema = z.object({
  // Between two values (inclusive)
  age: z.number()
    .min(18, 'Must be at least 18')
    .max(120, 'Must be at most 120'),
  
  // Rating system (1-5)
  rating: z.number()
    .int('Rating must be a whole number')
    .min(1, 'Minimum rating is 1')
    .max(5, 'Maximum rating is 5'),
  
  // Percentage (0-100)
  progress: z.number()
    .min(0, 'Cannot be negative')
    .max(100, 'Cannot exceed 100'),
  
  // Price (positive, max 2 decimals)
  price: z.number()
    .positive('Price must be positive')
    .multipleOf(0.01, 'Price can have at most 2 decimal places')
    .max(999999.99, 'Price is too high'),
  
  // Quantity (positive integer)
  quantity: z.number()
    .int('Quantity must be a whole number')
    .positive('Quantity must be positive')
    .max(9999, 'Quantity cannot exceed 9999')
});</code></pre>

                <h3>Number with React Hook Form</h3>
                <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const productSchema = z.object({
  name: z.string().min(1, 'Product name is required'),
  
  price: z.number({
    required_error: 'Price is required',
    invalid_type_error: 'Price must be a number'
  })
    .positive('Price must be positive')
    .multipleOf(0.01, 'Price can have at most 2 decimal places'),
  
  quantity: z.number({
    required_error: 'Quantity is required',
    invalid_type_error: 'Quantity must be a number'
  })
    .int('Quantity must be a whole number')
    .positive('Quantity must be positive'),
  
  discount: z.number()
    .min(0, 'Discount cannot be negative')
    .max(100, 'Discount cannot exceed 100%')
    .optional()
    .default(0)
});

type ProductFormData = z.infer&lt;typeof productSchema&gt;;

function ProductForm() {
  const { register, handleSubmit, formState: { errors } } = useForm&lt;ProductFormData&gt;({
    resolver: zodResolver(productSchema)
  });

  const onSubmit = (data: ProductFormData) =&gt; {
    console.log('Product data:', data);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;label&gt;Product Name&lt;/label&gt;
        &lt;input {...register('name')} /&gt;
        {errors.name &amp;&amp; &lt;span&gt;{errors.name.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Price ($)&lt;/label&gt;
        &lt;input
          type="number"
          step="0.01"
          {...register('price', { valueAsNumber: true })}
        /&gt;
        {errors.price &amp;&amp; &lt;span&gt;{errors.price.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Quantity&lt;/label&gt;
        &lt;input
          type="number"
          {...register('quantity', { valueAsNumber: true })}
        /&gt;
        {errors.quantity &amp;&amp; &lt;span&gt;{errors.quantity.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Discount (%)&lt;/label&gt;
        &lt;input
          type="number"
          step="1"
          {...register('discount', { valueAsNumber: true })}
        /&gt;
        {errors.discount &amp;&amp; &lt;span&gt;{errors.discount.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Add Product&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Critical: valueAsNumber</h4>
                    <p>Always use <code>valueAsNumber: true</code> with number inputs:</p>
                    <pre><code class="language-typescript">// ‚ùå Wrong - Zod receives string "42"
&lt;input type="number" {...register('age')} /&gt;

// ‚úÖ Correct - Zod receives number 42
&lt;input type="number" {...register('age', { valueAsNumber: true })} /&gt;</code></pre>
                    <p>Without <code>valueAsNumber</code>, HTML inputs return strings and Zod validation will fail!</p>
                </div>

                <h3>Date Validation</h3>
                <pre><code class="language-typescript">import { z } from 'zod';

const schema = z.object({
  // Basic date
  birthDate: z.date(),
  
  // Date with min (must be after)
  startDate: z.date()
    .min(new Date('2024-01-01'), 'Start date must be after Jan 1, 2024'),
  
  // Date with max (must be before)
  endDate: z.date()
    .max(new Date('2025-12-31'), 'End date must be before Dec 31, 2025'),
  
  // Date range
  eventDate: z.date()
    .min(new Date(), 'Event date must be in the future')
    .max(new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), 'Event date must be within 1 year'),
  
  // Age validation (must be 18+ years old)
  dateOfBirth: z.date()
    .refine(date => {
      const age = Math.floor((Date.now() - date.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
      return age >= 18;
    }, {
      message: 'You must be at least 18 years old'
    })
});</code></pre>

                <h3>Date with React Hook Form</h3>
                <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

const today = new Date();
today.setHours(0, 0, 0, 0);

const eventSchema = z.object({
  eventName: z.string().min(1, 'Event name is required'),
  
  startDate: z.date({
    required_error: 'Start date is required',
    invalid_type_error: 'Invalid date'
  })
    .min(today, 'Start date must be today or later'),
  
  endDate: z.date({
    required_error: 'End date is required',
    invalid_type_error: 'Invalid date'
  })
}).refine(data => data.endDate >= data.startDate, {
  message: 'End date must be after or equal to start date',
  path: ['endDate']
});

type EventFormData = z.infer&lt;typeof eventSchema&gt;;

function EventForm() {
  const { register, handleSubmit, formState: { errors } } = useForm&lt;EventFormData&gt;({
    resolver: zodResolver(eventSchema)
  });

  const onSubmit = (data: EventFormData) =&gt; {
    console.log('Event data:', data);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;label&gt;Event Name&lt;/label&gt;
        &lt;input {...register('eventName')} /&gt;
        {errors.eventName &amp;&amp; &lt;span&gt;{errors.eventName.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Start Date&lt;/label&gt;
        &lt;input
          type="date"
          {...register('startDate', { valueAsDate: true })}
        /&gt;
        {errors.startDate &amp;&amp; &lt;span&gt;{errors.startDate.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;End Date&lt;/label&gt;
        &lt;input
          type="date"
          {...register('endDate', { valueAsDate: true })}
        /&gt;
        {errors.endDate &amp;&amp; &lt;span&gt;{errors.endDate.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Create Event&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Critical: valueAsDate</h4>
                    <p>Always use <code>valueAsDate: true</code> with date inputs:</p>
                    <pre><code class="language-typescript">// ‚ùå Wrong - Zod receives string "2024-01-01"
&lt;input type="date" {...register('birthDate')} /&gt;

// ‚úÖ Correct - Zod receives Date object
&lt;input type="date" {...register('birthDate', { valueAsDate: true })} /&gt;</code></pre>
                </div>

                <h3>Working with Date Strings</h3>
                <p>Sometimes you need to work with date strings instead of Date objects:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Validate ISO date string
const schema = z.object({
  // ISO 8601 datetime string
  createdAt: z.string().datetime(),
  
  // Custom date string format
  birthDate: z.string()
    .regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format')
    .refine(dateStr => {
      const date = new Date(dateStr);
      return !isNaN(date.getTime());
    }, {
      message: 'Invalid date'
    }),
  
  // Transform date string to Date object
  eventDate: z.string()
    .transform(str => new Date(str))
    .pipe(z.date().min(new Date(), 'Date must be in the future'))
});</code></pre>

                <h3>Coercion for Flexibility</h3>
                <p>Use Zod's coerce feature to automatically convert types:</p>

                <pre><code class="language-typescript">const schema = z.object({
  // Coerce string to number
  age: z.coerce.number()
    .int()
    .min(18, 'Must be at least 18'),
  
  // Coerce string to date
  birthDate: z.coerce.date()
    .max(new Date(), 'Birth date cannot be in the future'),
  
  // Coerce to boolean
  acceptTerms: z.coerce.boolean()
});

// Now you don't need valueAsNumber or valueAsDate!
function FlexibleForm() {
  const { register } = useForm({
    resolver: zodResolver(schema)
  });

  return (
    &lt;form&gt;
      {/* These work without valueAsNumber/valueAsDate */}
      &lt;input type="number" {...register('age')} /&gt;
      &lt;input type="date" {...register('birthDate')} /&gt;
      &lt;input type="checkbox" {...register('acceptTerms')} /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Coercion</h4>
                    <ul>
                        <li><strong>Use coerce</strong> - For API data or when types might vary</li>
                        <li><strong>Use explicit types</strong> - For strict validation and type safety</li>
                        <li><strong>Recommendation</strong> - Use explicit types with valueAsNumber/valueAsDate for forms (clearer intent)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: TypeScript Type Inference -->
            <section id="section8" aria-labelledby="section8-title">
                <h2 id="section8-title">üî∑ TypeScript Type Inference</h2>
                <p>One of Zod's superpowers is automatic TypeScript type inference. Let's explore how it works.</p>

                <h3>Basic Type Inference</h3>
                <pre><code class="language-typescript">import { z } from 'zod';

// Define a schema
const userSchema = z.object({
  name: z.string(),
  age: z.number(),
  email: z.string().email()
});

// Infer the TypeScript type
type User = z.infer<typeof userSchema>;

// Result is equivalent to:
// type User = {
//   name: string;
//   age: number;
//   email: string;
// }

// Use the inferred type
const user: User = {
  name: 'Alice',
  age: 30,
  email: 'alice@example.com'
};</code></pre>

                <h3>Inference with Optional and Nullable</h3>
                <pre><code class="language-typescript">const schema = z.object({
  required: z.string(),
  optional: z.string().optional(),
  nullable: z.string().nullable(),
  withDefault: z.string().default('default'),
  optionalNullable: z.string().optional().nullable()
});

type InferredType = z.infer<typeof schema>;

// Result:
// type InferredType = {
//   required: string;
//   optional?: string | undefined;
//   nullable: string | null;
//   withDefault: string;
//   optionalNullable?: string | null | undefined;
// }</code></pre>

                <h3>Inference with Arrays and Objects</h3>
                <pre><code class="language-typescript">const schema = z.object({
  tags: z.array(z.string()),
  scores: z.array(z.number()),
  
  address: z.object({
    street: z.string(),
    city: z.string(),
    zipCode: z.string()
  }),
  
  contacts: z.array(z.object({
    name: z.string(),
    email: z.string().email()
  }))
});

type InferredType = z.infer<typeof schema>;

// Result:
// type InferredType = {
//   tags: string[];
//   scores: number[];
//   address: {
//     street: string;
//     city: string;
//     zipCode: string;
//   };
//   contacts: Array<{
//     name: string;
//     email: string;
//   }>;
// }</code></pre>

                <h3>Inference with Enums and Unions</h3>
                <pre><code class="language-typescript">const schema = z.object({
  role: z.enum(['admin', 'user', 'guest']),
  
  status: z.union([
    z.literal('active'),
    z.literal('inactive'),
    z.literal('pending')
  ]),
  
  identifier: z.union([z.string(), z.number()])
});

type InferredType = z.infer<typeof schema>;

// Result:
// type InferredType = {
//   role: 'admin' | 'user' | 'guest';
//   status: 'active' | 'inactive' | 'pending';
//   identifier: string | number;
// }</code></pre>

                <h3>Input vs Output Types</h3>
                <p>Zod schemas can have different input and output types (e.g., with transforms):</p>

                <pre><code class="language-typescript">const schema = z.object({
  name: z.string().trim(), // Transform: trims whitespace
  email: z.string().toLowerCase(), // Transform: converts to lowercase
  age: z.string().transform(val => parseInt(val)) // Transform: string to number
});

// Input type (what goes in)
type Input = z.input<typeof schema>;
// Result: { name: string; email: string; age: string; }

// Output type (what comes out after validation)
type Output = z.output<typeof schema>;
// Result: { name: string; email: string; age: number; }

// z.infer is an alias for z.output
type InferredOutput = z.infer<typeof schema>;
// Same as Output</code></pre>

                <h3>Extracting Nested Types</h3>
                <pre><code class="language-typescript">const addressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipCode: z.string()
});

const userSchema = z.object({
  name: z.string(),
  address: addressSchema
});

// Extract the entire user type
type User = z.infer<typeof userSchema>;

// Extract just the address type
type Address = z.infer<typeof addressSchema>;

// Or extract from nested schema
type AddressFromUser = User['address'];</code></pre>

                <h3>Reusing Schema Pieces</h3>
                <pre><code class="language-typescript">// Define reusable schemas
const emailSchema = z.string().email();
const passwordSchema = z.string().min(8);
const phoneSchema = z.string().regex(/^\d{3}-\d{3}-\d{4}$/);

// Combine into different forms
const loginSchema = z.object({
  email: emailSchema,
  password: passwordSchema
});

const registrationSchema = z.object({
  email: emailSchema,
  password: passwordSchema,
  phone: phoneSchema,
  name: z.string()
});

// Both share the same email and password validation!
type LoginData = z.infer<typeof loginSchema>;
type RegistrationData = z.infer<typeof registrationSchema>;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Type Inference Benefits</h4>
                    <ul>
                        <li><strong>No duplicate definitions</strong> - Schema defines both validation and types</li>
                        <li><strong>Always in sync</strong> - Change schema, types update automatically</li>
                        <li><strong>Reduce errors</strong> - Impossible for types and validation to diverge</li>
                        <li><strong>Better refactoring</strong> - TypeScript catches all affected code</li>
                        <li><strong>Self-documenting</strong> - Schema shows exactly what's valid</li>
                        <li><strong>Shared schemas</strong> - Use same schema for frontend and backend</li>
                    </ul>
                </div>

                <h3>Advanced Pattern: Extending Schemas</h3>
                <pre><code class="language-typescript">// Base schema
const baseUserSchema = z.object({
  name: z.string(),
  email: z.string().email()
});

// Extend with more fields
const adminSchema = baseUserSchema.extend({
  role: z.literal('admin'),
  permissions: z.array(z.string())
});

// Merge schemas
const userWithAddressSchema = baseUserSchema.merge(
  z.object({
    address: z.object({
      street: z.string(),
      city: z.string()
    })
  })
);

// Pick specific fields
const emailOnlySchema = baseUserSchema.pick({ email: true });

// Omit specific fields
const nameOnlySchema = baseUserSchema.omit({ email: true });

// Make all fields optional
const partialUserSchema = baseUserSchema.partial();

// Make all fields required
const requiredUserSchema = partialUserSchema.required();

// Infer types from all variants
type Admin = z.infer<typeof adminSchema>;
type UserWithAddress = z.infer<typeof userWithAddressSchema>;
type EmailOnly = z.infer<typeof emailOnlySchema>;
type PartialUser = z.infer<typeof partialUserSchema>;</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Schema Manipulation Methods</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Purpose</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>.extend()</code></td>
                                <td>Add new fields</td>
                                <td>Add role to user</td>
                            </tr>
                            <tr>
                                <td><code>.merge()</code></td>
                                <td>Combine schemas</td>
                                <td>Merge user + address</td>
                            </tr>
                            <tr>
                                <td><code>.pick()</code></td>
                                <td>Select specific fields</td>
                                <td>Email-only form</td>
                            </tr>
                            <tr>
                                <td><code>.omit()</code></td>
                                <td>Exclude fields</td>
                                <td>Remove password field</td>
                            </tr>
                            <tr>
                                <td><code>.partial()</code></td>
                                <td>Make all optional</td>
                                <td>Update forms</td>
                            </tr>
                            <tr>
                                <td><code>.required()</code></td>
                                <td>Make all required</td>
                                <td>Strict validation</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Section 9: Custom Error Messages -->
            <section id="section9" aria-labelledby="section9-title">
                <h2 id="section9-title">üí¨ Custom Error Messages</h2>
                <p>Zod makes it easy to customize error messages for better user experience.</p>

                <h3>Per-Validation Messages</h3>
                <pre><code class="language-typescript">const schema = z.object({
  username: z.string()
    .min(3, 'Username must be at least 3 characters')
    .max(20, 'Username cannot exceed 20 characters')
    .regex(/^[a-zA-Z0-9_]+$/, 'Only letters, numbers, and underscores allowed'),
  
  email: z.string()
    .min(1, 'Email is required')
    .email('Please enter a valid email address'),
  
  age: z.number({
    required_error: 'Age is required',
    invalid_type_error: 'Age must be a number'
  })
    .min(18, 'You must be at least 18 years old')
    .max(120, 'Please enter a valid age')
});</code></pre>

                <h3>Custom Error Maps</h3>
                <p>Override default error messages globally:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

const customErrorMap: z.ZodErrorMap = (issue, ctx) => {
  if (issue.code === z.ZodIssueCode.invalid_type) {
    if (issue.expected === 'string') {
      return { message: 'This field must be text' };
    }
    if (issue.expected === 'number') {
      return { message: 'This field must be a number' };
    }
  }
  
  if (issue.code === z.ZodIssueCode.too_small) {
    if (issue.type === 'string') {
      return { message: `Minimum ${issue.minimum} characters required` };
    }
  }
  
  if (issue.code === z.ZodIssueCode.too_big) {
    if (issue.type === 'string') {
      return { message: `Maximum ${issue.maximum} characters allowed` };
    }
  }
  
  // Fallback to default message
  return { message: ctx.defaultError };
};

// Use custom error map
z.setErrorMap(customErrorMap);

// Or use per-schema
const schema = z.object({
  name: z.string().min(3)
}, { errorMap: customErrorMap });</code></pre>

                <h3>Error Messages with Field Names</h3>
                <pre><code class="language-typescript">const createSchema = (fieldName: string) => {
  return z.string()
    .min(1, `${fieldName} is required`)
    .min(3, `${fieldName} must be at least 3 characters`);
};

const schema = z.object({
  firstName: createSchema('First name'),
  lastName: createSchema('Last name'),
  city: createSchema('City')
});

// Errors will be:
// "First name is required"
// "Last name must be at least 3 characters"
// "City is required"</code></pre>

                <h3>Internationalization (i18n)</h3>
                <pre><code class="language-typescript">// Error messages in different languages
const errorMessages = {
  en: {
    required: 'This field is required',
    email: 'Invalid email address',
    minLength: (min: number) => `Minimum ${min} characters required`
  },
  es: {
    required: 'Este campo es obligatorio',
    email: 'Direcci√≥n de correo electr√≥nico no v√°lida',
    minLength: (min: number) => `M√≠nimo ${min} caracteres requeridos`
  }
};

const createLocalizedSchema = (lang: 'en' | 'es') => {
  const msg = errorMessages[lang];
  
  return z.object({
    email: z.string()
      .min(1, msg.required)
      .email(msg.email),
    
    password: z.string()
      .min(1, msg.required)
      .min(8, msg.minLength(8))
  });
};

// Use with current language
const schema = createLocalizedSchema('en'); // or 'es'</code></pre>

                <h3>Contextual Error Messages</h3>
                <pre><code class="language-typescript">const schema = z.object({
  password: z.string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain an uppercase letter')
    .regex(/[a-z]/, 'Password must contain a lowercase letter')
    .regex(/[0-9]/, 'Password must contain a number')
    .regex(/[^A-Za-z0-9]/, 'Password must contain a special character'),
  
  confirmPassword: z.string()
}).refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword'] // Show error on confirmPassword field
}).refine(data => data.password !== 'password123', {
  message: 'This password is too common. Please choose a different one.',
  path: ['password']
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Error Message Best Practices</h4>
                    <ul>
                        <li><strong>Be specific</strong> - "Email is required" not "Required"</li>
                        <li><strong>Be helpful</strong> - Tell users how to fix the error</li>
                        <li><strong>Be concise</strong> - Keep messages short and clear</li>
                        <li><strong>Be polite</strong> - Use friendly, non-accusatory language</li>
                        <li><strong>Show examples</strong> - "Format: 123-456-7890" for phone numbers</li>
                        <li><strong>Use plain language</strong> - Avoid technical jargon</li>
                        <li><strong>Be consistent</strong> - Use similar wording across forms</li>
                    </ul>
                </div>

                <h3>Error Message Examples</h3>
                <div class="card">
                    <h4>‚ùå Poor Error Messages</h4>
                    <ul>
                        <li>"Invalid" - What's invalid?</li>
                        <li>"Error in field" - Which field? What error?</li>
                        <li>"Must match pattern /^[A-Z]/" - Too technical</li>
                        <li>"Required" - Which field is required?</li>
                    </ul>
                    
                    <h4>‚úÖ Good Error Messages</h4>
                    <ul>
                        <li>"Email address is required"</li>
                        <li>"Password must be at least 8 characters"</li>
                        <li>"Name must start with a capital letter"</li>
                        <li>"Phone number format: 123-456-7890"</li>
                    </ul>
                </div>


            </section>

            <!-- Section 10: Summary -->
            <section id="section10" aria-labelledby="section10-title">
                <h2 id="section10-title">üìö Summary</h2>
                <p>Congratulations! You've mastered Zod and learned how to create powerful, type-safe forms. Let's recap what you've learned:</p>

                <div class="card">
                    <h3>Key Takeaways</h3>
                    <ul>
                        <li>‚úÖ <strong>Schema-based validation</strong> - Define validation once, use everywhere</li>
                        <li>‚úÖ <strong>Type inference</strong> - Automatic TypeScript types from schemas</li>
                        <li>‚úÖ <strong>React Hook Form integration</strong> - Seamless with zodResolver</li>
                        <li>‚úÖ <strong>Rich validation</strong> - 40+ built-in validators for all types</li>
                        <li>‚úÖ <strong>Composable schemas</strong> - Build complex schemas from simple ones</li>
                        <li>‚úÖ <strong>Custom error messages</strong> - User-friendly, localized errors</li>
                        <li>‚úÖ <strong>Transformations</strong> - Clean and normalize data automatically</li>
                        <li>‚úÖ <strong>Cross-field validation</strong> - Validate fields against each other</li>
                    </ul>
                </div>

                <h3>Zod vs React Hook Form Inline Validation</h3>
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>Inline Validation</th>
                                <th>Zod + React Hook Form</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Code location</strong></td>
                                <td>Mixed with UI</td>
                                <td>Separate schema</td>
                            </tr>
                            <tr>
                                <td><strong>Reusability</strong></td>
                                <td>Copy-paste</td>
                                <td>Import and use</td>
                            </tr>
                            <tr>
                                <td><strong>TypeScript types</strong></td>
                                <td>Manual definition</td>
                                <td>Auto-inferred</td>
                            </tr>
                            <tr>
                                <td><strong>Validation logic</strong></td>
                                <td>Per field, scattered</td>
                                <td>Centralized schema</td>
                            </tr>
                            <tr>
                                <td><strong>Cross-field validation</strong></td>
                                <td>Complex with watch()</td>
                                <td>Simple with refine()</td>
                            </tr>
                            <tr>
                                <td><strong>API validation</strong></td>
                                <td>Separate logic</td>
                                <td>Same schema</td>
                            </tr>
                            <tr>
                                <td><strong>Transformations</strong></td>
                                <td>Manual in submit</td>
                                <td>Built into schema</td>
                            </tr>
                            <tr>
                                <td><strong>Best for</strong></td>
                                <td>Simple forms</td>
                                <td>Complex forms</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Complete Example: Everything Together</h3>
                <p>Here's a comprehensive example showing all the concepts you've learned:</p>

                <pre><code class="language-typescript">import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

// 1. Reusable schema pieces
const emailSchema = z.string()
  .min(1, 'Email is required')
  .email('Invalid email address')
  .toLowerCase();

const passwordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Must contain uppercase letter')
  .regex(/[a-z]/, 'Must contain lowercase letter')
  .regex(/[0-9]/, 'Must contain number')
  .regex(/[^A-Za-z0-9]/, 'Must contain special character');

// 2. Nested schemas
const addressSchema = z.object({
  street: z.string().min(1, 'Street is required'),
  city: z.string().min(1, 'City is required'),
  zipCode: z.string().regex(/^\d{5}$/, 'Invalid zip code'),
  country: z.enum(['US', 'CA', 'UK', 'AU'])
});

// 3. Main form schema with all features
const userRegistrationSchema = z.object({
  // Basic string validation
  firstName: z.string()
    .trim()
    .min(1, 'First name is required')
    .min(2, 'At least 2 characters')
    .max(50, 'Maximum 50 characters'),
  
  lastName: z.string()
    .trim()
    .min(1, 'Last name is required')
    .min(2, 'At least 2 characters')
    .max(50, 'Maximum 50 characters'),
  
  // Reusable schema
  email: emailSchema,
  password: passwordSchema,
  confirmPassword: z.string(),
  
  // Number validation
  age: z.number({
    required_error: 'Age is required',
    invalid_type_error: 'Age must be a number'
  })
    .int('Age must be a whole number')
    .min(18, 'Must be at least 18 years old')
    .max(120, 'Please enter a valid age'),
  
  // Date validation
  birthDate: z.date()
    .max(new Date(), 'Birth date cannot be in the future')
    .refine(date => {
      const age = Math.floor((Date.now() - date.getTime()) / (365.25 * 24 * 60 * 60 * 1000));
      return age >= 18;
    }, 'Must be at least 18 years old'),
  
  // Nested schema
  address: addressSchema,
  
  // Array validation
  interests: z.array(z.string())
    .min(1, 'Select at least one interest')
    .max(5, 'Maximum 5 interests'),
  
  // Enum validation
  role: z.enum(['user', 'admin', 'moderator']),
  
  // Boolean validation
  terms: z.boolean()
    .refine(val => val === true, 'You must accept the terms'),
  
  // Optional fields
  bio: z.string()
    .max(500, 'Bio cannot exceed 500 characters')
    .optional(),
  
  // Field with default
  notifications: z.boolean().default(true)
})
// 4. Cross-field validation
.refine(data => data.password === data.confirmPassword, {
  message: 'Passwords do not match',
  path: ['confirmPassword']
});

// 5. Infer TypeScript type
type UserRegistrationData = z.infer<typeof userRegistrationSchema>;

// 6. Create form component
function UserRegistrationForm() {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting }
  } = useForm<UserRegistrationData>({
    resolver: zodResolver(userRegistrationSchema),
    mode: 'onTouched'
  });

  const onSubmit = async (data: UserRegistrationData) => {
    console.log('Validated data:', data);
    // Data is fully validated and typed!
    await new Promise(resolve => setTimeout(resolve, 1000));
    alert('Registration successful!');
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* All fields would go here */}
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Registering...' : 'Register'}
      </button>
    </form>
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>‚úÖ Best Practices Checklist</h3>
                    <ul>
                        <li>‚úÖ Define schemas outside components (avoid recreation on render)</li>
                        <li>‚úÖ Use z.infer for automatic TypeScript types</li>
                        <li>‚úÖ Create reusable schema pieces for common patterns</li>
                        <li>‚úÖ Use meaningful, user-friendly error messages</li>
                        <li>‚úÖ Use transformations (trim, toLowerCase) to normalize data</li>
                        <li>‚úÖ Use mode: 'onTouched' for best UX</li>
                        <li>‚úÖ Use valueAsNumber for number inputs</li>
                        <li>‚úÖ Use valueAsDate for date inputs</li>
                        <li>‚úÖ Test schemas with sample data before using in production</li>
                        <li>‚úÖ Use refine() for cross-field validation</li>
                        <li>‚úÖ Compose complex schemas from simpler ones</li>
                        <li>‚úÖ Share schemas between frontend and backend</li>
                    </ul>
                </div>

                <h3>Common Patterns Quick Reference</h3>
                <div class="card">
                    <pre><code class="language-typescript">// Required string
z.string().min(1, 'Required')

// Email
z.string().email('Invalid email')

// Password (strong)
z.string()
  .min(8)
  .regex(/[A-Z]/)
  .regex(/[a-z]/)
  .regex(/[0-9]/)

// Number range
z.number().min(1).max(100)

// Positive integer
z.number().int().positive()

// Date in future
z.date().min(new Date())

// Optional field
z.string().optional()

// Field with default
z.string().default('default')

// Enum
z.enum(['option1', 'option2'])

// Array with limits
z.array(z.string()).min(1).max(5)

// Nested object
z.object({
  nested: z.object({
    field: z.string()
  })
})

// Cross-field validation
schema.refine(data => data.password === data.confirm, {
  message: 'Must match',
  path: ['confirm']
})

// Transform
z.string().trim().toLowerCase()

// Coerce types
z.coerce.number()
z.coerce.date()

// Union
z.union([z.string(), z.number()])

// Regex validation
z.string().regex(/pattern/, 'Message')</code></pre>
                </div>

                <h3>When to Use Zod</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Perfect For:</h4>
                    <ul>
                        <li>Forms with 5+ fields</li>
                        <li>Complex validation rules</li>
                        <li>Cross-field dependencies</li>
                        <li>TypeScript projects (type inference is amazing!)</li>
                        <li>Reusable validation across multiple forms</li>
                        <li>API request/response validation</li>
                        <li>Full-stack apps (share schemas between FE and BE)</li>
                        <li>When validation logic needs to be centralized</li>
                        <li>Production applications requiring maintainability</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Consider Simpler Solutions When:</h4>
                    <ul>
                        <li>Form has 1-3 fields with basic validation</li>
                        <li>Validation rules are extremely simple (just "required")</li>
                        <li>One-off form that won't be reused</li>
                        <li>Prototype where requirements are changing rapidly</li>
                        <li>Team unfamiliar with schema validation</li>
                        <li>Project not using TypeScript (lose main benefit)</li>
                    </ul>
                </div>

                <h3>Troubleshooting Common Issues</h3>
                <div class="card">
                    <h4>Problem: "Expected number, received string"</h4>
                    <p><strong>Solution:</strong> Use <code>valueAsNumber: true</code> on number inputs</p>
                    <pre><code>&lt;input type="number" {...register('age', { valueAsNumber: true })} /&gt;</code></pre>

                    <h4>Problem: "Expected date, received string"</h4>
                    <p><strong>Solution:</strong> Use <code>valueAsDate: true</code> on date inputs</p>
                    <pre><code>&lt;input type="date" {...register('date', { valueAsDate: true })} /&gt;</code></pre>

                    <h4>Problem: Schema recreated on every render</h4>
                    <p><strong>Solution:</strong> Define schema outside component</p>
                    <pre><code>// ‚ùå Wrong - inside component
function MyForm() {
  const schema = z.object({ ... });
}

// ‚úÖ Correct - outside component
const schema = z.object({ ... });
function MyForm() { ... }</code></pre>

                    <h4>Problem: Optional field shows "Required" error</h4>
                    <p><strong>Solution:</strong> Use <code>.optional()</code> or accept empty string</p>
                    <pre><code>// For truly optional
bio: z.string().optional()

// For optional but allow empty string
website: z.string().url().optional().or(z.literal(''))</code></pre>

                    <h4>Problem: Cross-field validation error on wrong field</h4>
                    <p><strong>Solution:</strong> Specify <code>path</code> in refine</p>
                    <pre><code>.refine(data => data.password === data.confirm, {
  message: 'Passwords must match',
  path: ['confirm'] // Show error on confirm field
})</code></pre>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ What's Next?</h3>
                    <p style="color: white;">In the upcoming lessons, you'll learn:</p>
                    <ul style="color: white;">
                        <li><strong>Lesson 7.4: File Uploads</strong> - Handle file inputs, image previews, and validation</li>
                        <li><strong>Lesson 7.5: Advanced Form Patterns</strong> - Dynamic field arrays, multi-step wizards, conditional fields</li>
                        <li><strong>Module Project</strong> - Build a complete user registration system with everything you've learned</li>
                    </ul>
                    <p style="color: white;">You now have professional-grade form validation skills!</p>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üí™ You've Mastered</h3>
                    <ul>
                        <li>Schema-based validation with Zod</li>
                        <li>Seamless integration with React Hook Form</li>
                        <li>TypeScript type inference from schemas</li>
                        <li>All Zod primitive types (string, number, date, etc.)</li>
                        <li>Advanced string validation (email, URL, regex patterns)</li>
                        <li>Number and date validation with ranges</li>
                        <li>Optional, nullable, and default values</li>
                        <li>Cross-field validation with refine()</li>
                        <li>Schema composition and reusability</li>
                        <li>Custom error messages and localization</li>
                        <li>Data transformations and normalization</li>
                        <li>Schema manipulation (extend, merge, pick, omit)</li>
                    </ul>
                    <p><strong>You're now ready to build production-quality forms with confidence!</strong></p>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üìñ Additional Resources</h3>
                    <ul>
                        <li><a href="https://zod.dev/" target="_blank">Official Zod Documentation</a></li>
                        <li><a href="https://github.com/colinhacks/zod" target="_blank">Zod GitHub Repository</a></li>
                        <li><a href="https://zod.dev/?id=basic-usage" target="_blank">Zod Basic Usage Guide</a></li>
                        <li><a href="https://react-hook-form.com/get-started#SchemaValidation" target="_blank">React Hook Form with Zod</a></li>
                        <li><a href="https://github.com/react-hook-form/resolvers" target="_blank">@hookform/resolvers Documentation</a></li>
                        <li><a href="https://zod.dev/?id=primitives" target="_blank">Zod Primitives Reference</a></li>
                        <li><a href="https://zod.dev/?id=strings" target="_blank">Zod String Validation</a></li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3e0; border-left: 4px solid #ff9800;">
                    <h3>üî• Pro Tips</h3>
                    <ul>
                        <li><strong>Share schemas</strong> - Use the same Zod schemas on frontend and backend</li>
                        <li><strong>Test schemas</strong> - Write unit tests for complex validation logic</li>
                        <li><strong>Document schemas</strong> - Schemas are self-documenting but add comments for complex rules</li>
                        <li><strong>Version schemas</strong> - When APIs evolve, version your schemas</li>
                        <li><strong>Error messages matter</strong> - Invest time in clear, helpful error messages</li>
                        <li><strong>Colocate schemas</strong> - Keep schemas near the forms that use them</li>
                        <li><strong>Use TypeScript strict mode</strong> - Catch more errors at compile time</li>
                        <li><strong>Leverage transformations</strong> - Clean data automatically (trim, lowercase)</li>
                        <li><strong>Build a schema library</strong> - Create reusable schemas for your app</li>
                        <li><strong>Monitor bundle size</strong> - Zod is small but tree-shake unused validators</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h2 style="color: white; margin-top: 0;">üéâ Congratulations!</h2>
                    <p style="color: white; font-size: 1.2rem;">You've completed Lesson 7.3: Form Validation with Zod</p>
                    <p style="color: white;">You now have the skills to build professional, type-safe forms that are maintainable, reusable, and user-friendly. Combined with React Hook Form, you have one of the most powerful form solutions available in the React ecosystem!</p>
                </div>
            </section>
        </div>
    </main>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_7_2_react_hook_form.html" class="nav-button prev-lesson">
            <span class="nav-label">‚Üê Previous Lesson</span>
            <span class="nav-title">Lesson 7.2: React Hook Form</span>
        </a>
        <a href="index.html" class="nav-button home">
            <span class="nav-label">üìö</span>
            <span class="nav-title">All Lessons</span>
        </a>
        <a href="lesson_7_4_file_uploads.html" class="nav-button next-lesson">
            <span class="nav-label">Next Lesson ‚Üí</span>
            <span class="nav-title">Lesson 7.4: File Uploads</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org/docs/" target="_blank">TypeScript Docs</a> |
                <a href="https://zod.dev/" target="_blank">Zod Docs</a> |
                <a href="https://react-hook-form.com/" target="_blank">React Hook Form Docs</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
