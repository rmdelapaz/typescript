<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React's useContext Hook - Learn how to solve prop drilling, share state across components, create and consume context, and properly type context with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>useContext Hook - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.2: useContext Hook</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üåê useContext Hook</h1>
                <p class="lead">Welcome to one of React's most powerful features for sharing data! Have you ever found yourself passing props down through multiple layers of components, just to get data to a deeply nested child? That's called "prop drilling," and it's a pain. The useContext Hook solves this problem elegantly by creating a "wormhole" for your data - allowing any component to access shared values without passing props through every level. Think of it like a radio broadcast: instead of passing a message person-to-person through a chain, you broadcast it, and anyone tuned in can receive it. Let's learn how to use this superpower wisely! üì°</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the prop drilling problem and why it matters</li>
                        <li>Create a Context with proper TypeScript typing</li>
                        <li>Provide context values to component trees</li>
                        <li>Consume context using the useContext Hook</li>
                        <li>Implement common context patterns (theme, authentication, etc.)</li>
                        <li>Combine useContext with useReducer for state management</li>
                        <li>Understand when to use context vs props</li>
                        <li>Avoid common context pitfalls and performance issues</li>
                        <li>Structure context for scalable applications</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a theme switcher and authentication context</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">The Prop Drilling Problem</a></li>
                        <li><a href="#section2" class="toc-link">Introduction to Context</a></li>
                        <li><a href="#section3" class="toc-link">Creating Context</a></li>
                        <li><a href="#section4" class="toc-link">Providing Context Values</a></li>
                        <li><a href="#section5" class="toc-link">Consuming Context</a></li>
                        <li><a href="#section6" class="toc-link">Typing Context with TypeScript</a></li>
                        <li><a href="#section7" class="toc-link">Theme Context Example</a></li>
                        <li><a href="#section8" class="toc-link">Context with useReducer</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Performance Considerations</a></li>
                        <li><a href="#section11" class="toc-link">Best Practices</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: The Prop Drilling Problem -->
            <section id="section1" class="lesson-section">
                <h2>‚õèÔ∏è The Prop Drilling Problem</h2>
                <p>Before we dive into Context, let's understand the problem it solves. Prop drilling occurs when you need to pass data through many layers of components to reach a deeply nested child.</p>

                <h3>A Real-World Scenario</h3>
                <p>Imagine you're building an app with user information that needs to be accessed by components at different levels:</p>

                <div class="mermaid">
                graph TD
                    A[App - has user data] --> B[Dashboard]
                    B --> C[Sidebar]
                    C --> D[UserMenu]
                    D --> E[UserProfile - needs user data!]
                    
                    B --> F[MainContent]
                    F --> G[Header - needs user data!]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <h3>The Prop Drilling Approach</h3>
                <p>Without Context, you'd have to pass the user data through every component in the chain:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Prop drilling - passing through components that don't need the data

interface User {
    id: number;
    name: string;
    email: string;
}

// App component - has the user data
function App() {
    const [user, setUser] = useState&lt;User&gt;({
        id: 1,
        name: 'John Doe',
        email: 'john@example.com'
    });

    return &lt;Dashboard user={user} /&gt;;
}

// Dashboard - doesn't use user, just passes it along
function Dashboard({ user }: { user: User }) {
    return (
        &lt;div&gt;
            &lt;Sidebar user={user} /&gt;
            &lt;MainContent user={user} /&gt;
        &lt;/div&gt;
    );
}

// Sidebar - doesn't use user, just passes it along
function Sidebar({ user }: { user: User }) {
    return (
        &lt;div&gt;
            &lt;UserMenu user={user} /&gt;
        &lt;/div&gt;
    );
}

// UserMenu - doesn't use user, just passes it along
function UserMenu({ user }: { user: User }) {
    return &lt;UserProfile user={user} /&gt;;
}

// UserProfile - FINALLY uses the user data!
function UserProfile({ user }: { user: User }) {
    return &lt;div&gt;{user.name}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with Prop Drilling</h4>
                    <ul>
                        <li><strong>Verbose</strong> - Lots of repetitive prop declarations</li>
                        <li><strong>Fragile</strong> - Adding props requires updating every component in the chain</li>
                        <li><strong>Confusing</strong> - Components receive props they don't use</li>
                        <li><strong>Hard to Refactor</strong> - Moving components means updating all props</li>
                        <li><strong>Tight Coupling</strong> - Intermediate components depend on data they don't need</li>
                    </ul>
                </div>

                <h3>The Visual Problem</h3>
                <p>Here's what prop drilling looks like visually:</p>

                <div class="mermaid">
                sequenceDiagram
                    participant App
                    participant Dashboard
                    participant Sidebar
                    participant UserMenu
                    participant UserProfile
                    
                    App->>Dashboard: user prop
                    Dashboard->>Sidebar: user prop (not used)
                    Sidebar->>UserMenu: user prop (not used)
                    UserMenu->>UserProfile: user prop
                    UserProfile->>UserProfile: Finally! Use user data
                    
                    Note over Dashboard,UserMenu: These components don't<br/>need user, but must<br/>pass it through
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When Does Prop Drilling Become a Problem?</h4>
                    <ul>
                        <li>Data needs to pass through 3+ component levels</li>
                        <li>Many components need the same data</li>
                        <li>Intermediate components don't use the data</li>
                        <li>The data changes frequently</li>
                        <li>You find yourself adding props to components just to pass them down</li>
                    </ul>
                </div>

                <h3>Real-World Examples</h3>
                <p>Common scenarios where prop drilling becomes painful:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>What Needs Sharing</th>
                            <th>Who Needs It</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Theme</strong></td>
                            <td>Dark/light mode preference</td>
                            <td>Every styled component</td>
                        </tr>
                        <tr>
                            <td><strong>Authentication</strong></td>
                            <td>Current user, login status</td>
                            <td>Protected routes, user menus, etc.</td>
                        </tr>
                        <tr>
                            <td><strong>Language</strong></td>
                            <td>Current locale (en, es, fr)</td>
                            <td>All text-displaying components</td>
                        </tr>
                        <tr>
                            <td><strong>Shopping Cart</strong></td>
                            <td>Cart items, total, quantity</td>
                            <td>Product pages, cart icon, checkout</td>
                        </tr>
                        <tr>
                            <td><strong>Settings</strong></td>
                            <td>User preferences</td>
                            <td>Various UI components</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 2: Introduction to Context -->
            <section id="section2" class="lesson-section">
                <h2>üåê Introduction to Context</h2>
                <p>React Context is the solution to prop drilling. It provides a way to share values between components without explicitly passing props through every level of the tree.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Context:</strong> A feature in React that provides a way to pass data through the component tree without having to pass props down manually at every level. It creates a "global" scope for a specific part of your component tree.</p>
                </div>

                <h3>The Context Solution</h3>
                <p>With Context, components can "broadcast" data, and any component in the tree can "tune in" to receive it:</p>

                <div class="mermaid">
                graph TD
                    A[App with Context Provider] -.broadcasts user.-> B[Dashboard]
                    B --> C[Sidebar]
                    C --> D[UserMenu]
                    D --> E[UserProfile - reads from context!]
                    
                    B --> F[MainContent]
                    F --> G[Header - reads from context!]
                    
                    A -.-> E
                    A -.-> G
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <p>Notice how Dashboard, Sidebar, and UserMenu don't need to pass the user prop anymore! The components that need the data can directly access it from context.</p>

                <h3>How Context Works</h3>
                <p>Context has three main parts:</p>

                <div class="card">
                    <h4>The Three Pieces of Context</h4>
                    <ol>
                        <li>
                            <strong>Create Context</strong> - Define what data will be shared
                            <pre><code>const UserContext = createContext(defaultValue);</code></pre>
                        </li>
                        <li>
                            <strong>Provide Context</strong> - Wrap components that need access
                            <pre><code>&lt;UserContext.Provider value={user}&gt;
    {children}
&lt;/UserContext.Provider&gt;</code></pre>
                        </li>
                        <li>
                            <strong>Consume Context</strong> - Read the value in components
                            <pre><code>const user = useContext(UserContext);</code></pre>
                        </li>
                    </ol>
                </div>

                <h3>Context Flow Visualization</h3>
                <div class="mermaid">
                sequenceDiagram
                    participant Create as 1. Create Context
                    participant Provider as 2. Provider
                    participant Tree as Component Tree
                    participant Consumer as 3. Consumer (useContext)
                    
                    Create->>Provider: Define context
                    Provider->>Tree: Wrap components
                    Tree->>Consumer: Component needs data
                    Consumer->>Provider: Read value
                    Provider->>Consumer: Return current value
                </div>

                <h3>Real-World Analogy</h3>
                <p>Think of Context like a radio broadcast system:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Radio Broadcast</th>
                            <th>React Context</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Radio Station</td>
                            <td>Context Provider</td>
                        </tr>
                        <tr>
                            <td>Broadcast Signal</td>
                            <td>Context Value</td>
                        </tr>
                        <tr>
                            <td>Radio Receiver</td>
                            <td>useContext Hook</td>
                        </tr>
                        <tr>
                            <td>Tune to Frequency</td>
                            <td>Import and use context</td>
                        </tr>
                        <tr>
                            <td>Broadcast Range</td>
                            <td>Provider's component tree</td>
                        </tr>
                    </tbody>
                </table>

                <p>Just like how any radio in range can tune into a station without being physically connected, any component within a Provider can access the context value without receiving props!</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Context</h4>
                    <ul>
                        <li><strong>No Prop Drilling</strong> - Skip intermediate components</li>
                        <li><strong>Cleaner Code</strong> - Less boilerplate, more focused components</li>
                        <li><strong>Easier Refactoring</strong> - Move components without updating props</li>
                        <li><strong>Shared State</strong> - Multiple components access same data</li>
                        <li><strong>Loose Coupling</strong> - Components only depend on data they use</li>
                        <li><strong>Better Organization</strong> - Group related data together</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use Context</h4>
                    <p>Context isn't always the answer. Don't use it when:</p>
                    <ul>
                        <li>Data only needs to go 1-2 levels down (use props)</li>
                        <li>You're just trying to avoid typing props (that's what props are for!)</li>
                        <li>The data changes very frequently and affects many components (may cause performance issues)</li>
                        <li>The data is only used by a single component</li>
                        <li>You need to optimize re-renders carefully (Context re-renders all consumers)</li>
                    </ul>
                </div>

                <h3>Context vs Props vs State Management</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>Use When</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Props</strong></td>
                            <td>Parent-child communication, 1-2 levels</td>
                            <td>Passing onClick to a button</td>
                        </tr>
                        <tr>
                            <td><strong>Context</strong></td>
                            <td>Data needed by many components, deep nesting</td>
                            <td>Theme, auth, language</td>
                        </tr>
                        <tr>
                            <td><strong>State Management</strong><br/>(Redux, Zustand)</td>
                            <td>Complex global state, time travel, middleware</td>
                            <td>Large e-commerce app state</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 3: Creating Context -->
            <section id="section3" class="lesson-section">
                <h2>üî® Creating Context</h2>
                <p>Let's learn how to create Context step by step. We'll use TypeScript to ensure type safety throughout.</p>

                <h3>Basic Context Creation</h3>
                <p>The first step is to create a context using <code>createContext</code>:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Simple value context
const ThemeContext = createContext('light');

// Object context
const UserContext = createContext({
    name: 'Guest',
    isLoggedIn: false
});</code></pre>
                </div>

                <p><code>createContext</code> takes a default value that's used when a component tries to access context without a Provider. This default is mostly useful for testing.</p>

                <h3>Context with TypeScript</h3>
                <p>For TypeScript, we need to properly type our context:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Define the shape of your context value
interface User {
    id: number;
    name: string;
    email: string;
}

// Create context with type and default value
const UserContext = createContext&lt;User&gt;({
    id: 0,
    name: 'Guest',
    email: ''
});</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Tip</h4>
                    <p>The generic <code>&lt;User&gt;</code> tells TypeScript what type of value the context holds. This gives you autocomplete and type checking when using the context!</p>
                </div>

                <h3>Context with Functions</h3>
                <p>Context can hold more than just data - it can include functions too:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

interface ThemeContextType {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType&gt;({
    theme: 'light',
    toggleTheme: () => {
        console.warn('toggleTheme called outside of Provider');
    }
});</code></pre>
                </div>

                <h3>Context with Undefined Default</h3>
                <p>Sometimes you don't want a meaningful default value. Use <code>undefined</code> and force components to check:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

interface User {
    id: number;
    name: string;
}

// Allow undefined - requires Provider
const UserContext = createContext&lt;User | undefined&gt;(undefined);

// Later, when consuming:
const user = useContext(UserContext);
if (!user) {
    throw new Error('useUser must be used within UserProvider');
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Undefined Default</h4>
                    <p>Use <code>undefined</code> as default when:</p>
                    <ul>
                        <li>Context must always be used within a Provider</li>
                        <li>You want to catch mistakes early (forgetting Provider)</li>
                        <li>A fake default value doesn't make sense</li>
                        <li>You want to enforce proper setup</li>
                    </ul>
                </div>

                <h3>File Organization</h3>
                <p>Best practice is to create contexts in separate files:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/UserContext.tsx
import { createContext } from 'react';

export interface User {
    id: number;
    name: string;
    email: string;
}

export interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

export const UserContext = createContext&lt;UserContextType | undefined&gt;(
    undefined
);</code></pre>
                </div>

                <p>This keeps your contexts organized and makes them easy to import:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// In any component
import { UserContext } from '@/contexts/UserContext';
import { useContext } from 'react';

function MyComponent() {
    const userContext = useContext(UserContext);
    // ...
}</code></pre>
                </div>

            <!-- Section 4: Providing Context Values -->
            <section id="section4" class="lesson-section">
                <h2>üì§ Providing Context Values</h2>
                <p>Creating a context is just the first step. To make the context value available to components, you need to wrap them in a Provider. Think of the Provider as the broadcasting station that transmits the signal.</p>

                <h3>Basic Provider Usage</h3>
                <p>Every context comes with a Provider component that accepts a value prop:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

const ThemeContext = createContext('light');

function App() {
    return (
        &lt;ThemeContext.Provider value="dark"&gt;
            &lt;Header /&gt;
            &lt;MainContent /&gt;
            &lt;Footer /&gt;
        &lt;/ThemeContext.Provider&gt;
    );
}

// Now Header, MainContent, Footer (and all their children)
// can access the theme value "dark"</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Provider Scope</h4>
                    <p>The Provider's scope is its entire component tree. Any component inside the Provider (at any nesting level) can access the context value. Components outside the Provider cannot.</p>
                </div>

                <h3>Provider with State</h3>
                <p>Usually, you'll want the context value to be dynamic, not static. Use state in the Provider:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState } from 'react';

interface User {
    id: number;
    name: string;
}

const UserContext = createContext&lt;User | null&gt;(null);

function App() {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    return (
        &lt;UserContext.Provider value={user}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}

// Now the user state is accessible throughout the Dashboard tree</code></pre>
                </div>

                <h3>Provider with Multiple Values</h3>
                <p>You can provide multiple related values by wrapping them in an object:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

function App() {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => {
        setUser(newUser);
    };

    const logout = () => {
        setUser(null);
    };

    const contextValue = {
        user,
        login,
        logout
    };

    return (
        &lt;UserContext.Provider value={contextValue}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Provider Value Warning</h4>
                    <p>Be careful with the value prop! If you pass an object literal or create a new object on every render, you'll cause unnecessary re-renders:</p>
                    <pre><code>// ‚ùå Bad - creates new object every render
&lt;UserContext.Provider value={{ user, login, logout }}&gt;

// ‚úÖ Good - stable reference
const contextValue = { user, login, logout };
&lt;UserContext.Provider value={contextValue}&gt;</code></pre>
                    <p>We'll cover this more in the performance section!</p>
                </div>

                <h3>Custom Provider Component Pattern</h3>
                <p>A common pattern is to create a custom Provider component that encapsulates the logic:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState, ReactNode } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

export const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom Provider component
export function UserProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => {
        setUser(newUser);
        localStorage.setItem('user', JSON.stringify(newUser));
    };

    const logout = () => {
        setUser(null);
        localStorage.removeItem('user');
    };

    const value = { user, login, logout };

    return (
        &lt;UserContext.Provider value={value}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// Now use the custom Provider
function App() {
    return (
        &lt;UserProvider&gt;
            &lt;Dashboard /&gt;
        &lt;/UserProvider&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Provider Benefits</h4>
                    <ul>
                        <li><strong>Encapsulation</strong> - Logic lives with the context</li>
                        <li><strong>Reusability</strong> - Easy to use across apps</li>
                        <li><strong>Cleaner App Component</strong> - Less clutter in main component</li>
                        <li><strong>Single Responsibility</strong> - Provider handles one concern</li>
                        <li><strong>Easier Testing</strong> - Test provider independently</li>
                    </ul>
                </div>

                <h3>Multiple Providers</h3>
                <p>You can nest multiple Providers for different contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;UserProvider&gt;
                &lt;LanguageProvider&gt;
                    &lt;Dashboard /&gt;
                &lt;/LanguageProvider&gt;
            &lt;/UserProvider&gt;
        &lt;/ThemeProvider&gt;
    );
}

// Dashboard and all children can access theme, user, and language contexts</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Provider Order</h4>
                    <p>The order of Providers usually doesn't matter, unless one Provider depends on another's context. Put independent Providers in any order, but if ThemeProvider needs user data, put UserProvider outside.</p>
                </div>

                <h3>Scoped Providers</h3>
                <p>You can have multiple Providers of the same context in different parts of your tree:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function App() {
    return (
        &lt;div&gt;
            {/* Light theme section */}
            &lt;ThemeContext.Provider value="light"&gt;
                &lt;Header /&gt;
            &lt;/ThemeContext.Provider&gt;

            {/* Dark theme section */}
            &lt;ThemeContext.Provider value="dark"&gt;
                &lt;MainContent /&gt;
            &lt;/ThemeContext.Provider&gt;

            {/* Uses default or nearest Provider */}
            &lt;Footer /&gt;
        &lt;/div&gt;
    );
}

// Header uses light theme, MainContent uses dark theme</code></pre>
                </div>

                <p>Components use the value from the nearest Provider above them in the tree.</p>

                <h3>Provider Placement Strategy</h3>
                <div class="mermaid">
                graph TD
                    A[Where to Place Provider?] --> B{Who needs the data?}
                    B -->|Entire app| C[Wrap App root]
                    B -->|Specific section| D[Wrap that section]
                    B -->|Multiple sections| E[Consider multiple Providers]
                    
                    C --> F[Performance impact: High]
                    D --> G[Performance impact: Low]
                    E --> H[Performance impact: Medium]
                    
                    style C fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#f093fb,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>
            </section>

            <!-- Section 5: Consuming Context -->
            <section id="section5" class="lesson-section">
                <h2>üì• Consuming Context</h2>
                <p>Now that we know how to provide context, let's learn how to consume it using the useContext Hook. This is where the magic happens!</p>

                <h3>Basic useContext Usage</h3>
                <p>The useContext Hook reads the value from the nearest Provider above it:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function Header() {
    const theme = useContext(ThemeContext);
    
    return (
        &lt;header className={theme === 'dark' ? 'dark' : 'light'}&gt;
            &lt;h1&gt;My App&lt;/h1&gt;
        &lt;/header&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° How useContext Works</h4>
                    <ol>
                        <li>Import the context you want to use</li>
                        <li>Call useContext with that context</li>
                        <li>Get back the current value from the Provider</li>
                        <li>Use the value in your component</li>
                    </ol>
                </div>

                <h3>Consuming Object Context</h3>
                <p>When your context provides an object with multiple values:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { UserContext } from './UserContext';

function UserProfile() {
    const userContext = useContext(UserContext);
    
    // Destructure for cleaner code
    const { user, login, logout } = userContext;
    
    if (!user) {
        return (
            &lt;button onClick={() =&gt; login({ id: 1, name: 'John' })}&gt;
                Login
            &lt;/button&gt;
        );
    }
    
    return (
        &lt;div&gt;
            &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;
            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Multiple Context Consumption</h3>
                <p>A component can consume multiple contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';
import { UserContext } from './UserContext';
import { LanguageContext } from './LanguageContext';

function Dashboard() {
    const theme = useContext(ThemeContext);
    const { user } = useContext(UserContext);
    const { language } = useContext(LanguageContext);
    
    return (
        &lt;div className={`dashboard ${theme}`}&gt;
            &lt;h1&gt;{language === 'en' ? 'Dashboard' : 'Tablero'}&lt;/h1&gt;
            &lt;p&gt;User: {user?.name}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Custom Hook Pattern</h3>
                <p>A best practice is to create a custom hook for each context:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// UserContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom Provider
export function UserProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => setUser(newUser);
    const logout = () => setUser(null);

    return (
        &lt;UserContext.Provider value={{ user, login, logout }}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// Custom Hook - this is the magic!
export function useUser() {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    return context;
}

// Now in components:
function MyComponent() {
    const { user, login, logout } = useUser(); // Clean and type-safe!
    // ...
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Hook Benefits</h4>
                    <ul>
                        <li><strong>Error Checking</strong> - Catches missing Provider at runtime</li>
                        <li><strong>Type Safety</strong> - No undefined checks needed</li>
                        <li><strong>Cleaner Imports</strong> - Import one hook instead of context + useContext</li>
                        <li><strong>Consistent API</strong> - Every context has the same usage pattern</li>
                        <li><strong>Better DX</strong> - Autocomplete works perfectly</li>
                    </ul>
                </div>

                <h3>Context with Computed Values</h3>
                <p>You can derive values based on context in the consuming component:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function TodoStats() {
    const { todos } = useTodos();
    
    // Derive values from context
    const totalTodos = todos.length;
    const completedTodos = todos.filter(t => t.completed).length;
    const activeTodos = totalTodos - completedTodos;
    const completionRate = totalTodos > 0 
        ? Math.round((completedTodos / totalTodos) * 100) 
        : 0;
    
    return (
        &lt;div&gt;
            &lt;p&gt;Total: {totalTodos}&lt;/p&gt;
            &lt;p&gt;Completed: {completedTodos}&lt;/p&gt;
            &lt;p&gt;Active: {activeTodos}&lt;/p&gt;
            &lt;p&gt;Completion: {completionRate}%&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Conditional Context Usage</h3>
                <p>Sometimes you want to use context only if it's available:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Optional context hook
export function useOptionalUser() {
    return useContext(UserContext);
}

function UserGreeting() {
    const userContext = useOptionalUser();
    
    // Handle both cases: inside and outside Provider
    if (!userContext || !userContext.user) {
        return &lt;p&gt;Welcome, Guest!&lt;/p&gt;;
    }
    
    return &lt;p&gt;Welcome, {userContext.user.name}!&lt;/p&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't call useContext conditionally or in loops:</p>
                    <pre><code>// ‚ùå Wrong - breaks Rules of Hooks
if (someCondition) {
    const theme = useContext(ThemeContext);
}

// ‚úÖ Correct - call at top level, use conditionally
const theme = useContext(ThemeContext);
if (someCondition) {
    // use theme
}</code></pre>
                </div>

                <h3>Context Consumer Flow</h3>
                <div class="mermaid">
                sequenceDiagram
                    participant Component
                    participant useContext
                    participant Provider
                    
                    Component->>useContext: Call useContext(MyContext)
                    useContext->>Provider: Find nearest Provider
                    Provider->>useContext: Return current value
                    useContext->>Component: Return value
                    Component->>Component: Use value in render
                    
                    Note over Provider: If Provider value changes
                    Provider->>Component: Trigger re-render
                    Component->>useContext: Get updated value
                </div>
            </section>

            <!-- Section 6: Typing Context with TypeScript -->
            <section id="section6" class="lesson-section">
                <h2>üî∑ Typing Context with TypeScript</h2>
                <p>TypeScript makes Context even more powerful by ensuring type safety. Let's explore the best patterns for typing contexts.</p>

                <h3>Basic Context Typing</h3>
                <p>The simplest approach - define an interface and use it:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Define the shape of your context
interface ThemeContextType {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

// Create context with type
const ThemeContext = createContext&lt;ThemeContextType&gt;({
    theme: 'light',
    toggleTheme: () => {}
});</code></pre>
                </div>

                <h3>Context with Undefined (Recommended)</h3>
                <p>The safest pattern - force Provider usage with undefined default:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
}

interface UserContextType {
    user: User | null;
    setUser: (user: User | null) => void;
}

// Create context that allows undefined
const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom hook with type guard
export function useUser(): UserContextType {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    // Now TypeScript knows context is UserContextType, not undefined!
    return context;
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why This Pattern is Best</h4>
                    <ul>
                        <li><strong>Runtime Safety</strong> - Catches missing Provider immediately</li>
                        <li><strong>No Fake Defaults</strong> - Don't need meaningless default values</li>
                        <li><strong>Type Safety</strong> - Custom hook returns non-undefined type</li>
                        <li><strong>Clear Errors</strong> - Helpful error message for developers</li>
                    </ul>
                </div>

                <h3>Complete Typed Context Example</h3>
                <p>Here's a full example with all TypeScript best practices:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// UserContext.tsx
import { 
    createContext, 
    useContext, 
    useState, 
    ReactNode,
    useCallback 
} from 'react';

// 1. Define data types
export interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

// 2. Define context type
interface UserContextType {
    user: User | null;
    isLoggedIn: boolean;
    login: (user: User) => void;
    logout: () => void;
    updateUser: (updates: Partial&lt;User&gt;) => void;
}

// 3. Create context with undefined default
const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// 4. Provider props type
interface UserProviderProps {
    children: ReactNode;
}

// 5. Custom Provider component
export function UserProvider({ children }: UserProviderProps) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = useCallback((newUser: User) => {
        setUser(newUser);
        localStorage.setItem('user', JSON.stringify(newUser));
    }, []);

    const logout = useCallback(() => {
        setUser(null);
        localStorage.removeItem('user');
    }, []);

    const updateUser = useCallback((updates: Partial&lt;User&gt;) => {
        setUser(current => {
            if (!current) return null;
            return { ...current, ...updates };
        });
    }, []);

    const value: UserContextType = {
        user,
        isLoggedIn: user !== null,
        login,
        logout,
        updateUser
    };

    return (
        &lt;UserContext.Provider value={value}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// 6. Custom hook with type guard
export function useUser(): UserContextType {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    return context;
}

// 7. Optional: Additional utility hooks
export function useIsAdmin(): boolean {
    const { user } = useUser();
    return user?.role === 'admin';
}

export function useCurrentUserId(): number | null {
    const { user } = useUser();
    return user?.id ?? null;
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Features Used</h4>
                    <ul>
                        <li><strong>Interface</strong> - Define shape of User and context</li>
                        <li><strong>Union Types</strong> - <code>User | null</code> for optional user</li>
                        <li><strong>Literal Types</strong> - <code>'admin' | 'user'</code> for role</li>
                        <li><strong>Partial Type</strong> - <code>Partial&lt;User&gt;</code> for updates</li>
                        <li><strong>ReactNode</strong> - Type for children prop</li>
                        <li><strong>Type Guard</strong> - Error throwing removes undefined</li>
                    </ul>
                </div>

                <h3>Generic Context Pattern</h3>
                <p>For reusable contexts, use generics:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, useState, ReactNode } from 'react';

// Generic state context creator
function createStateContext&lt;T&gt;(defaultValue: T) {
    const Context = createContext&lt;{
        value: T;
        setValue: (value: T) => void;
    } | undefined&gt;(undefined);

    function Provider({ children }: { children: ReactNode }) {
        const [value, setValue] = useState&lt;T&gt;(defaultValue);

        return (
            &lt;Context.Provider value={{ value, setValue }}&gt;
                {children}
            &lt;/Context.Provider&gt;
        );
    }

    function useValue() {
        const context = useContext(Context);
        if (!context) {
            throw new Error('useValue must be used within Provider');
        }
        return context;
    }

    return [Provider, useValue] as const;
}

// Usage - create typed contexts easily!
const [CountProvider, useCount] = createStateContext(0);
const [NameProvider, useName] = createStateContext('');
const [UserProvider, useUser] = createStateContext&lt;User | null&gt;(null);</code></pre>
                </div>

                <h3>Typing Context Actions</h3>
                <p>When combining with useReducer, type your actions carefully:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, useReducer, ReactNode } from 'react';

// State type
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

interface TodoState {
    todos: Todo[];
}

// Action types
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } };

// Context type
interface TodoContextType {
    state: TodoState;
    dispatch: React.Dispatch&lt;TodoAction&gt;;
}

const TodoContext = createContext&lt;TodoContextType | undefined&gt;(undefined);

// Reducer
function todoReducer(state: TodoState, action: TodoAction): TodoState {
    // Reducer implementation
    return state;
}

// Provider
export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, { todos: [] });

    return (
        &lt;TodoContext.Provider value={{ state, dispatch }}&gt;
            {children}
        &lt;/TodoContext.Provider&gt;
    );
}

// Custom hook
export function useTodos(): TodoContextType {
    const context = useContext(TodoContext);
    if (!context) {
        throw new Error('useTodos must be used within TodoProvider');
    }
    return context;
}</code></pre>
                </div>

            <!-- Section 7: Theme Context Example -->
            <section id="section7" class="lesson-section">
                <h2>üé® Theme Context Example</h2>
                <p>Let's build a complete, real-world example: a theme switcher that allows users to toggle between light and dark modes. This will demonstrate all the concepts we've learned so far.</p>

                <h3>Project Structure</h3>
                <p>We'll create a theme context with the following features:</p>

                <div class="card">
                    <h4>Features We'll Build</h4>
                    <ul>
                        <li>üåì Light and dark theme modes</li>
                        <li>üîÑ Toggle between themes</li>
                        <li>üíæ Persist preference to localStorage</li>
                        <li>üé® Apply theme styles to entire app</li>
                        <li>üî∑ Full TypeScript typing</li>
                    </ul>
                </div>

                <h3>Step 1: Define Types and Create Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/ThemeContext.tsx
import { createContext, useContext } from 'react';

// Define theme type
export type Theme = 'light' | 'dark';

// Define context type
interface ThemeContextType {
    theme: Theme;
    toggleTheme: () => void;
    setTheme: (theme: Theme) => void;
}

// Create context
const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);</code></pre>
                </div>

                <h3>Step 2: Create the Provider</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in ThemeContext.tsx
import { useState, useEffect, ReactNode } from 'react';

interface ThemeProviderProps {
    children: ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
    // Initialize theme from localStorage or default to 'light'
    const [theme, setTheme] = useState&lt;Theme&gt;(() => {
        const savedTheme = localStorage.getItem('theme');
        return (savedTheme as Theme) || 'light';
    });

    // Save theme to localStorage when it changes
    useEffect(() => {
        localStorage.setItem('theme', theme);
        // Apply theme to document for CSS
        document.documentElement.setAttribute('data-theme', theme);
    }, [theme]);

    // Toggle between light and dark
    const toggleTheme = () => {
        setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
    };

    const value: ThemeContextType = {
        theme,
        toggleTheme,
        setTheme
    };

    return (
        &lt;ThemeContext.Provider value={value}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Step 3: Create Custom Hook</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in ThemeContext.tsx

// Custom hook with error checking
export function useTheme(): ThemeContextType {
    const context = useContext(ThemeContext);
    
    if (context === undefined) {
        throw new Error('useTheme must be used within ThemeProvider');
    }
    
    return context;
}

// Complete ThemeContext.tsx file is now ready!</code></pre>
                </div>

                <h3>Step 4: Add CSS Styles</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-css">/* src/styles/theme.css */

/* Light theme (default) */
:root,
[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f5f5f5;
    --text-primary: #333333;
    --text-secondary: #666666;
    --border-color: #dddddd;
    --accent-color: #667eea;
    --card-bg: #ffffff;
    --shadow: rgba(0, 0, 0, 0.1);
}

/* Dark theme */
[data-theme="dark"] {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --text-primary: #e0e0e0;
    --text-secondary: #a0a0a0;
    --border-color: #404040;
    --accent-color: #8b9bff;
    --card-bg: #252525;
    --shadow: rgba(0, 0, 0, 0.5);
}

/* Apply theme variables */
body {
    background-color: var(--bg-primary);
    color: var(--text-primary);
    transition: background-color 0.3s ease, color 0.3s ease;
}

.card {
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 8px var(--shadow);
}

.button {
    background-color: var(--accent-color);
    color: white;
}</code></pre>
                </div>

                <h3>Step 5: Wrap App with Provider</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/main.tsx or App.tsx
import { ThemeProvider } from './contexts/ThemeContext';
import './styles/theme.css';

function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;Header /&gt;
            &lt;MainContent /&gt;
            &lt;Footer /&gt;
        &lt;/ThemeProvider&gt;
    );
}

export default App;</code></pre>
                </div>

                <h3>Step 6: Use Theme in Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/Header.tsx
import { useTheme } from '../contexts/ThemeContext';

function Header() {
    const { theme, toggleTheme } = useTheme();

    return (
        &lt;header&gt;
            &lt;h1&gt;My App&lt;/h1&gt;
            &lt;button onClick={toggleTheme}&gt;
                {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                {theme === 'light' ? ' Dark Mode' : ' Light Mode'}
            &lt;/button&gt;
        &lt;/header&gt;
    );
}

export default Header;</code></pre>
                </div>

                <h3>Step 7: Create Theme Toggle Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/ThemeToggle.tsx
import { useTheme } from '../contexts/ThemeContext';
import './ThemeToggle.css';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        &lt;button 
            className="theme-toggle"
            onClick={toggleTheme}
            aria-label="Toggle theme"
        &gt;
            &lt;span className="theme-toggle-icon"&gt;
                {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
            &lt;/span&gt;
            &lt;span className="theme-toggle-text"&gt;
                {theme === 'light' ? 'Dark' : 'Light'}
            &lt;/span&gt;
        &lt;/button&gt;
    );
}

export default ThemeToggle;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-css">/* ThemeToggle.css */
.theme-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.theme-toggle:hover {
    background-color: var(--accent-color);
    color: white;
    transform: translateY(-2px);
}

.theme-toggle-icon {
    font-size: 1.2rem;
}

.theme-toggle-text {
    font-weight: 500;
}</code></pre>
                </div>

                <h3>Complete Example with Multiple Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/Dashboard.tsx
import { useTheme } from '../contexts/ThemeContext';

function Dashboard() {
    const { theme } = useTheme();

    return (
        &lt;div className="dashboard"&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            &lt;p&gt;Current theme: {theme}&lt;/p&gt;
            
            &lt;div className="card"&gt;
                &lt;h2&gt;Stats&lt;/h2&gt;
                &lt;p&gt;This card uses theme variables for styling!&lt;/p&gt;
            &lt;/div&gt;

            &lt;div className="card"&gt;
                &lt;h2&gt;Activity&lt;/h2&gt;
                &lt;p&gt;The theme changes apply to all components automatically.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// src/components/Settings.tsx
function Settings() {
    const { theme, setTheme } = useTheme();

    return (
        &lt;div className="settings"&gt;
            &lt;h2&gt;Settings&lt;/h2&gt;
            
            &lt;div className="setting-group"&gt;
                &lt;label&gt;Theme Preference:&lt;/label&gt;
                &lt;select 
                    value={theme} 
                    onChange={(e) =&gt; setTheme(e.target.value as 'light' | 'dark')}
                &gt;
                    &lt;option value="light"&gt;Light&lt;/option&gt;
                    &lt;option value="dark"&gt;Dark&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Accomplished</h4>
                    <ul>
                        <li><strong>Context Creation</strong> - Defined theme context with TypeScript</li>
                        <li><strong>Provider Setup</strong> - Created provider with localStorage persistence</li>
                        <li><strong>Custom Hook</strong> - Made useTheme hook with error checking</li>
                        <li><strong>CSS Variables</strong> - Used data attributes for theme styling</li>
                        <li><strong>Multiple Components</strong> - Any component can access theme</li>
                        <li><strong>Persistence</strong> - Theme survives page refresh</li>
                        <li><strong>Smooth Transitions</strong> - CSS transitions for theme changes</li>
                    </ul>
                </div>

                <h3>Enhanced Theme with System Preference</h3>
                <p>Let's add detection of the user's system theme preference:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Enhanced ThemeProvider
export function ThemeProvider({ children }: ThemeProviderProps) {
    // Get system preference
    const getSystemTheme = (): Theme => {
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        return 'light';
    };

    // Initialize with saved theme, or system preference, or default
    const [theme, setTheme] = useState&lt;Theme&gt;(() => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            return savedTheme as Theme;
        }
        return getSystemTheme();
    });

    // Listen for system theme changes
    useEffect(() => {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        
        const handleChange = (e: MediaQueryListEvent) => {
            if (!localStorage.getItem('theme')) {
                // Only update if user hasn't set a preference
                setTheme(e.matches ? 'dark' : 'light');
            }
        };

        mediaQuery.addEventListener('change', handleChange);
        return () => mediaQuery.removeEventListener('change', handleChange);
    }, []);

    // Rest of the provider code...
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Advanced Features Added</h4>
                    <ul>
                        <li><strong>System Preference Detection</strong> - Uses prefers-color-scheme</li>
                        <li><strong>Automatic Updates</strong> - Responds to system theme changes</li>
                        <li><strong>User Preference Priority</strong> - Manual choice overrides system</li>
                        <li><strong>Smart Defaults</strong> - Falls back gracefully</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Context with useReducer -->
            <section id="section8" class="lesson-section">
                <h2>‚öôÔ∏è Context with useReducer</h2>
                <p>Combining Context with useReducer creates a powerful state management solution. This pattern is perfect for complex state that needs to be accessed by many components. Let's build a todo application to see this in action!</p>

                <h3>Why Combine Context + useReducer?</h3>
                <div class="card">
                    <h4>The Power Combination</h4>
                    <ul>
                        <li><strong>useReducer</strong> - Manages complex state logic in one place</li>
                        <li><strong>Context</strong> - Makes state and dispatch available everywhere</li>
                        <li><strong>Together</strong> - Global state management without Redux!</li>
                    </ul>
                </div>

                <div class="mermaid">
                graph TD
                    A[Context + useReducer] --> B[Complex State Logic]
                    A --> C[Global Accessibility]
                    B --> D[Predictable Updates]
                    C --> D
                    D --> E[Scalable State Management]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>Complete Todo Context Example</h3>

                <h4>Step 1: Define Types</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/TodoContext.tsx
import { createContext, useContext, useReducer, ReactNode } from 'react';

// Todo type
export interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

// State type
interface TodoState {
    todos: Todo[];
    filter: 'all' | 'active' | 'completed';
}

// Action types
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } }
    | { type: 'EDIT_TODO'; payload: { id: number; text: string } }
    | { type: 'SET_FILTER'; payload: { filter: 'all' | 'active' | 'completed' } }
    | { type: 'CLEAR_COMPLETED' };</code></pre>
                </div>

                <h4>Step 2: Create Reducer</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

function todoReducer(state: TodoState, action: TodoAction): TodoState {
    switch (action.type) {
        case 'ADD_TODO':
            return {
                ...state,
                todos: [
                    ...state.todos,
                    {
                        id: Date.now(),
                        text: action.payload.text,
                        completed: false
                    }
                ]
            };

        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };

        case 'DELETE_TODO':
            return {
                ...state,
                todos: state.todos.filter(todo => todo.id !== action.payload.id)
            };

        case 'EDIT_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, text: action.payload.text }
                        : todo
                )
            };

        case 'SET_FILTER':
            return {
                ...state,
                filter: action.payload.filter
            };

        case 'CLEAR_COMPLETED':
            return {
                ...state,
                todos: state.todos.filter(todo => !todo.completed)
            };

        default:
            return state;
    }
}</code></pre>
                </div>

                <h4>Step 3: Create Context and Provider</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

// Context type
interface TodoContextType {
    state: TodoState;
    dispatch: React.Dispatch&lt;TodoAction&gt;;
}

// Create context
const TodoContext = createContext&lt;TodoContextType | undefined&gt;(undefined);

// Provider component
export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, {
        todos: [],
        filter: 'all'
    });

    return (
        &lt;TodoContext.Provider value={{ state, dispatch }}&gt;
            {children}
        &lt;/TodoContext.Provider&gt;
    );
}

// Custom hook
export function useTodos() {
    const context = useContext(TodoContext);
    
    if (context === undefined) {
        throw new Error('useTodos must be used within TodoProvider');
    }
    
    return context;
}</code></pre>
                </div>

                <h4>Step 4: Create Action Creators</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

// Action creators for cleaner usage
export const todoActions = {
    addTodo: (text: string): TodoAction => ({
        type: 'ADD_TODO',
        payload: { text }
    }),

    toggleTodo: (id: number): TodoAction => ({
        type: 'TOGGLE_TODO',
        payload: { id }
    }),

    deleteTodo: (id: number): TodoAction => ({
        type: 'DELETE_TODO',
        payload: { id }
    }),

    editTodo: (id: number, text: string): TodoAction => ({
        type: 'EDIT_TODO',
        payload: { id, text }
    }),

    setFilter: (filter: 'all' | 'active' | 'completed'): TodoAction => ({
        type: 'SET_FILTER',
        payload: { filter }
    }),

    clearCompleted: (): TodoAction => ({
        type: 'CLEAR_COMPLETED'
    })
};</code></pre>
                </div>

                <h4>Step 5: Use in Components</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/AddTodo.tsx
import { useState } from 'react';
import { useTodos, todoActions } from '../contexts/TodoContext';

function AddTodo() {
    const { dispatch } = useTodos();
    const [text, setText] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (text.trim()) {
            dispatch(todoActions.addTodo(text));
            setText('');
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input
                type="text"
                value={text}
                onChange={(e) =&gt; setText(e.target.value)}
                placeholder="What needs to be done?"
            /&gt;
            &lt;button type="submit"&gt;Add&lt;/button&gt;
        &lt;/form&gt;
    );
}

export default AddTodo;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoList.tsx
import { useTodos, todoActions } from '../contexts/TodoContext';
import TodoItem from './TodoItem';

function TodoList() {
    const { state, dispatch } = useTodos();

    // Filter todos based on current filter
    const filteredTodos = state.todos.filter(todo => {
        if (state.filter === 'active') return !todo.completed;
        if (state.filter === 'completed') return todo.completed;
        return true; // 'all'
    });

    return (
        &lt;div&gt;
            &lt;ul className="todo-list"&gt;
                {filteredTodos.map(todo =&gt; (
                    &lt;TodoItem key={todo.id} todo={todo} /&gt;
                ))}
            &lt;/ul&gt;

            {filteredTodos.length === 0 && (
                &lt;p className="empty-state"&gt;No todos to show&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

export default TodoList;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoItem.tsx
import { useTodos, todoActions, Todo } from '../contexts/TodoContext';

interface TodoItemProps {
    todo: Todo;
}

function TodoItem({ todo }: TodoItemProps) {
    const { dispatch } = useTodos();

    return (
        &lt;li className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() =&gt; dispatch(todoActions.toggleTodo(todo.id))}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() =&gt; dispatch(todoActions.deleteTodo(todo.id))}&gt;
                Delete
            &lt;/button&gt;
        &lt;/li&gt;
    );
}

export default TodoItem;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoFilters.tsx
import { useTodos, todoActions } from '../contexts/TodoContext';

function TodoFilters() {
    const { state, dispatch } = useTodos();

    const filters: Array&lt;'all' | 'active' | 'completed'&gt; = [
        'all',
        'active', 
        'completed'
    ];

    return (
        &lt;div className="filters"&gt;
            {filters.map(filter =&gt; (
                &lt;button
                    key={filter}
                    className={state.filter === filter ? 'active' : ''}
                    onClick={() =&gt; dispatch(todoActions.setFilter(filter))}
                &gt;
                    {filter.charAt(0).toUpperCase() + filter.slice(1)}
                &lt;/button&gt;
            ))}
        &lt;/div&gt;
    );
}

export default TodoFilters;</code></pre>
                </div>

                <h4>Step 6: Put It All Together</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/App.tsx
import { TodoProvider } from './contexts/TodoContext';
import AddTodo from './components/AddTodo';
import TodoList from './components/TodoList';
import TodoFilters from './components/TodoFilters';

function App() {
    return (
        &lt;TodoProvider&gt;
            &lt;div className="app"&gt;
                &lt;h1&gt;üìù Todo App&lt;/h1&gt;
                &lt;AddTodo /&gt;
                &lt;TodoFilters /&gt;
                &lt;TodoList /&gt;
            &lt;/div&gt;
        &lt;/TodoProvider&gt;
    );
}

export default App;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Achieved</h4>
                    <ul>
                        <li><strong>Global State</strong> - All components access the same todo state</li>
                        <li><strong>Predictable Updates</strong> - Reducer ensures consistent state changes</li>
                        <li><strong>Type Safety</strong> - TypeScript prevents action type errors</li>
                        <li><strong>Clean Components</strong> - Components focus on UI, not logic</li>
                        <li><strong>No Prop Drilling</strong> - Deep components access state directly</li>
                        <li><strong>Testability</strong> - Reducer can be tested independently</li>
                        <li><strong>Scalability</strong> - Easy to add new actions and features</li>
                    </ul>
                </div>

                <h3>Optimized Context Pattern</h3>
                <p>For better performance, split state and dispatch into separate contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Advanced pattern - separate contexts for state and dispatch
const TodoStateContext = createContext&lt;TodoState | undefined&gt;(undefined);
const TodoDispatchContext = createContext&lt;React.Dispatch&lt;TodoAction&gt; | undefined&gt;(undefined);

export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, initialState);

    return (
        &lt;TodoStateContext.Provider value={state}&gt;
            &lt;TodoDispatchContext.Provider value={dispatch}&gt;
                {children}
            &lt;/TodoDispatchContext.Provider&gt;
        &lt;/TodoStateContext.Provider&gt;
    );
}

// Separate hooks
export function useTodoState() {
    const context = useContext(TodoStateContext);
    if (!context) throw new Error('useTodoState must be used within TodoProvider');
    return context;
}

export function useTodoDispatch() {
    const context = useContext(TodoDispatchContext);
    if (!context) throw new Error('useTodoDispatch must be used within TodoProvider');
    return context;
}

// Now components only re-render when the value they use changes!
// Component that only dispatches doesn't re-render when state changes
function AddTodo() {
    const dispatch = useTodoDispatch(); // Won't re-render on state change
    // ...
}

// Component that only reads state doesn't need dispatch
function TodoStats() {
    const state = useTodoState(); // Clean and efficient
    // ...
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Performance Benefit</h4>
                    <p>Splitting contexts means components only re-render when the specific value they use changes. A component that only dispatches actions won't re-render when state changes, and vice versa. This is especially important for large applications!</p>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Now it's your turn! These exercises will help you master Context and useContext. Start with the easier ones and work your way up.</p>

                <h3>Exercise 1: Language Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Create a language/internationalization (i18n) context that allows users to switch between languages.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Support at least 2 languages (e.g., English and Spanish)</li>
                        <li>Provide a way to switch languages</li>
                        <li>Store translations in objects</li>
                        <li>Create a custom hook to access translations</li>
                        <li>Persist language preference to localStorage</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Your context might look like:</p>
                        <pre><code>interface LanguageContextType {
    language: 'en' | 'es';
    setLanguage: (lang: 'en' | 'es') => void;
    t: (key: string) => string; // translation function
}</code></pre>
                        <p>Translation object example:</p>
                        <pre><code>const translations = {
    en: {
        welcome: 'Welcome',
        greeting: 'Hello, {name}!'
    },
    es: {
        welcome: 'Bienvenido',
        greeting: '¬°Hola, {name}!'
    }
};</code></pre>
                    </div>
                </details>

                <details>
                    <summary><strong>‚úÖ Solution</strong></summary>
                    <div style="margin-top: 1rem;">
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">// LanguageContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

type Language = 'en' | 'es';

const translations = {
    en: {
        welcome: 'Welcome',
        login: 'Login',
        logout: 'Logout',
        settings: 'Settings'
    },
    es: {
        welcome: 'Bienvenido',
        login: 'Iniciar sesi√≥n',
        logout: 'Cerrar sesi√≥n',
        settings: 'Configuraci√≥n'
    }
};

interface LanguageContextType {
    language: Language;
    setLanguage: (lang: Language) => void;
    t: (key: string) => string;
}

const LanguageContext = createContext&lt;LanguageContextType | undefined&gt;(undefined);

export function LanguageProvider({ children }: { children: ReactNode }) {
    const [language, setLanguage] = useState&lt;Language&gt;(() => {
        const saved = localStorage.getItem('language');
        return (saved as Language) || 'en';
    });

    const handleSetLanguage = (lang: Language) => {
        setLanguage(lang);
        localStorage.setItem('language', lang);
    };

    const t = (key: string): string => {
        return translations[language][key as keyof typeof translations.en] || key;
    };

    return (
        &lt;LanguageContext.Provider value={{ language, setLanguage: handleSetLanguage, t }}&gt;
            {children}
        &lt;/LanguageContext.Provider&gt;
    );
}

export function useLanguage() {
    const context = useContext(LanguageContext);
    if (!context) throw new Error('useLanguage must be used within LanguageProvider');
    return context;
}</code></pre>
                        </div>
                    </div>
                </details>

                <h3>Exercise 2: Shopping Cart Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Build a shopping cart context using Context + useReducer.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Add items to cart (with quantity)</li>
                        <li>Remove items from cart</li>
                        <li>Update item quantities</li>
                        <li>Calculate total price</li>
                        <li>Clear entire cart</li>
                        <li>Use TypeScript for type safety</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Types you'll need:</p>
                        <pre><code>interface CartItem {
    id: string;
    name: string;
    price: number;
    quantity: number;
}

type CartAction =
    | { type: 'ADD_ITEM'; payload: CartItem }
    | { type: 'REMOVE_ITEM'; payload: { id: string } }
    | { type: 'UPDATE_QUANTITY'; payload: { id: string; quantity: number } }
    | { type: 'CLEAR_CART' };</code></pre>
                    </div>
                </details>

                <h3>Exercise 3: Authentication Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Create an authentication context with login, logout, and protected route logic.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Login/logout functionality</li>
                        <li>Store user information</li>
                        <li>Check authentication status</li>
                        <li>Persist auth state (localStorage or sessionStorage)</li>
                        <li>Provide loading state during authentication</li>
                        <li>Include user roles/permissions</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Context structure:</p>
                        <pre><code>interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (email: string, password: string) => Promise&lt;void&gt;;
    logout: () => void;
    checkAuth: () => Promise&lt;void&gt;;
}</code></pre>
                    </div>
                </details>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Practice Tips</h4>
                    <ul>
                        <li>Start with type definitions first</li>
                        <li>Build the context and provider before the hook</li>
                        <li>Test with console.log before building UI</li>
                        <li>Add one feature at a time</li>
                        <li>Use TypeScript errors as guides</li>
                        <li>Don't forget error boundaries!</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Performance Considerations -->
            <section id="section10" class="lesson-section">
                <h2>‚ö° Performance Considerations</h2>
                <p>Context is powerful, but it can cause performance issues if not used carefully. Let's learn how to optimize Context usage.</p>

                <h3>The Re-render Problem</h3>
                <p>When Context value changes, ALL components that consume it will re-render:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Problem: Creates new object every render
function App() {
    const [user, setUser] = useState(null);
    
    return (
        &lt;UserContext.Provider value={{ user, setUser }}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}

// Every render of App creates a new object
// Even if user hasn't changed, ALL consumers re-render!</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Why This Happens</h4>
                    <p>JavaScript creates a new object on each render:</p>
                    <pre><code>{ user, setUser } !== { user, setUser } // Always true!
// React sees a different object, assumes value changed</code></pre>
                </div>

                <h3>Solution 1: Memoize the Value</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useMemo } from 'react';

function App() {
    const [user, setUser] = useState(null);
    
    // ‚úÖ Value only changes when user changes
    const value = useMemo(
        () => ({ user, setUser }),
        [user] // Only recreate if user changes
    );
    
    return (
        &lt;UserContext.Provider value={value}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Solution 2: Split Contexts</h3>
                <p>Separate state and dispatch to minimize re-renders:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Two separate contexts
const UserStateContext = createContext(null);
const UserDispatchContext = createContext(null);

function UserProvider({ children }) {
    const [user, setUser] = useState(null);
    
    // dispatch is stable, never changes
    return (
        &lt;UserStateContext.Provider value={user}&gt;
            &lt;UserDispatchContext.Provider value={setUser}&gt;
                {children}
            &lt;/UserDispatchContext.Provider&gt;
        &lt;/UserStateContext.Provider&gt;
    );
}

// Components that only dispatch don't re-render on state changes!
function UpdateButton() {
    const setUser = useContext(UserDispatchContext);
    // Won't re-render when user state changes
    return &lt;button onClick={() => setUser(...)}&gt;Update&lt;/button&gt;;
}</code></pre>
                </div>

                <h3>Solution 3: Optimize with React.memo</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { memo } from 'react';

// Expensive component that uses context
const ExpensiveComponent = memo(function ExpensiveComponent() {
    const { someValue } = useMyContext();
    
    // Complex rendering logic
    return &lt;div&gt;{someValue}&lt;/div&gt;;
});

// Now it only re-renders when props or context actually change</code></pre>
                </div>

                <h3>Solution 4: Limit Provider Scope</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Too broad - entire app re-renders
function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;Dashboard /&gt;
            &lt;Settings /&gt;
            &lt;Profile /&gt;
        &lt;/ThemeProvider&gt;
    );
}

// ‚úÖ Scoped - only affected components
function App() {
    return (
        &lt;div&gt;
            &lt;Dashboard /&gt; {/* Doesn't use theme */}
            &lt;ThemeProvider&gt;
                &lt;Settings /&gt; {/* Uses theme */}
                &lt;Profile /&gt; {/* Uses theme */}
            &lt;/ThemeProvider&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Performance Best Practices</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do's</h4>
                    <ul>
                        <li>Use useMemo to stabilize context values</li>
                        <li>Split contexts when state and actions are independent</li>
                        <li>Wrap expensive components in React.memo</li>
                        <li>Keep Provider scope as narrow as possible</li>
                        <li>Use multiple small contexts instead of one large one</li>
                        <li>Derive computed values in components, not context</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Don'ts</h4>
                    <ul>
                        <li>Don't create new objects/arrays in Provider value</li>
                        <li>Don't put everything in one giant context</li>
                        <li>Don't wrap entire app if only few components need it</li>
                        <li>Don't use Context for frequently changing values</li>
                        <li>Don't optimize prematurely - measure first!</li>
                    </ul>
                </div>

                <h3>When to Optimize</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Small app (&lt;50 components)</td>
                            <td>Don't worry about it</td>
                        </tr>
                        <tr>
                            <td>Context changes rarely</td>
                            <td>No optimization needed</td>
                        </tr>
                        <tr>
                            <td>Few consumers</td>
                            <td>Basic setup is fine</td>
                        </tr>
                        <tr>
                            <td>Large app (100+ components)</td>
                            <td>Consider splitting contexts</td>
                        </tr>
                        <tr>
                            <td>Frequent context updates</td>
                            <td>Use useMemo, split contexts</td>
                        </tr>
                        <tr>
                            <td>Performance issues detected</td>
                            <td>Profile and optimize</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 11: Best Practices -->
            <section id="section11" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                <p>Follow these best practices to write maintainable, scalable Context code.</p>

                <h3>‚úÖ Do: Create Custom Hooks</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Always provide a custom hook
export function useUser() {
    const context = useContext(UserContext);
    if (!context) {
        throw new Error('useUser must be used within UserProvider');
    }
    return context;
}

// Usage is clean and safe
function MyComponent() {
    const { user } = useUser(); // Clean!
}</code></pre>
                </div>

                <h3>‚úÖ Do: Organize Context Files</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/UserContext.tsx
// Everything in one file:
// - Types
// - Context creation
// - Provider component
// - Custom hook
// - Export only what's needed

export { UserProvider, useUser };
// Don't export the context itself</code></pre>
                </div>

                <h3>‚úÖ Do: Use TypeScript</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Fully typed context
interface UserContextType {
    user: User | null;
    login: (credentials: LoginCredentials) => Promise&lt;void&gt;;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);</code></pre>
                </div>

                <h3>‚úÖ Do: Split Large Contexts</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå One massive context
interface AppContextType {
    user: User;
    theme: Theme;
    language: Language;
    cart: Cart;
    notifications: Notification[];
    // ... too much!
}

// ‚úÖ Multiple focused contexts
// UserContext, ThemeContext, LanguageContext, CartContext, etc.
// Each handles one concern</code></pre>
                </div>

                <h3>‚úÖ Do: Provide Meaningful Errors</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">export function useUser() {
    const context = useContext(UserContext);
    if (!context) {
        throw new Error(
            'useUser must be used within UserProvider. ' +
            'Make sure your component is wrapped with &lt;UserProvider&gt;.'
        );
    }
    return context;
}</code></pre>
                </div>

                <h3>‚ùå Don't: Use Context for Everything</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Overkill for parent-child communication
function Parent() {
    return (
        &lt;ValueContext.Provider value="hello"&gt;
            &lt;Child /&gt;
        &lt;/ValueContext.Provider&gt;
    );
}

// ‚úÖ Just use props!
function Parent() {
    return &lt;Child value="hello" /&gt;;
}</code></pre>
                </div>

                <h3>‚ùå Don't: Mutate Context Values</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Never mutate context values
const { user } = useUser();
user.name = 'New Name'; // NO!

// ‚úÖ Use provided functions
const { user, updateUser } = useUser();
updateUser({ name: 'New Name' }); // YES!</code></pre>
                </div>

                <h3>Context Naming Conventions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Convention</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Context</td>
                            <td>PascalCase + Context</td>
                            <td><code>UserContext</code></td>
                        </tr>
                        <tr>
                            <td>Provider</td>
                            <td>PascalCase + Provider</td>
                            <td><code>UserProvider</code></td>
                        </tr>
                        <tr>
                            <td>Custom Hook</td>
                            <td>use + PascalCase</td>
                            <td><code>useUser</code></td>
                        </tr>
                        <tr>
                            <td>Type Interface</td>
                            <td>PascalCase + ContextType</td>
                            <td><code>UserContextType</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Testing Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Testing components that use context
import { render, screen } from '@testing-library/react';
import { UserProvider } from './UserContext';
import MyComponent from './MyComponent';

test('renders with user context', () => {
    render(
        &lt;UserProvider&gt;
            &lt;MyComponent /&gt;
        &lt;/UserProvider&gt;
    );
    
    expect(screen.getByText(/welcome/i)).toBeInTheDocument();
});

// Test with custom context value
test('renders with specific user', () => {
    const mockUser = { id: 1, name: 'Test User' };
    
    render(
        &lt;UserContext.Provider value={{ user: mockUser, login: jest.fn(), logout: jest.fn() }}&gt;
            &lt;MyComponent /&gt;
        &lt;/UserContext.Provider&gt;
    );
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
});</code></pre>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                <p>Congratulations! You've mastered the useContext Hook and the Context API. Let's recap what you've learned.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Context solves prop drilling</strong> - Share data without passing props through every level</li>
                        <li><strong>Three-part system</strong> - Create Context, Provide values, Consume with useContext</li>
                        <li><strong>Custom hooks are essential</strong> - Always create custom hooks for type safety and error checking</li>
                        <li><strong>TypeScript makes it better</strong> - Type safety prevents bugs and improves DX</li>
                        <li><strong>Context + useReducer</strong> - Powerful pattern for complex global state</li>
                        <li><strong>Performance matters</strong> - Use useMemo, split contexts, optimize strategically</li>
                        <li><strong>Don't overuse</strong> - Props are fine for parent-child communication</li>
                    </ul>
                </div>

                <h3>What You Learned</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>What You Can Do</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Context Creation</strong></td>
                            <td>Create typed contexts with TypeScript</td>
                        </tr>
                        <tr>
                            <td><strong>Providers</strong></td>
                            <td>Build custom Provider components with state</td>
                        </tr>
                        <tr>
                            <td><strong>useContext</strong></td>
                            <td>Consume context values with the hook</td>
                        </tr>
                        <tr>
                            <td><strong>Custom Hooks</strong></td>
                            <td>Create safe, reusable context hooks</td>
                        </tr>
                        <tr>
                            <td><strong>Real-World Patterns</strong></td>
                            <td>Build theme switchers, auth, todos</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Optimize context for large applications</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Use Cases for Context</h3>
                <div class="card">
                    <ul>
                        <li>üé® <strong>Theme</strong> - Dark/light mode, color schemes</li>
                        <li>üîê <strong>Authentication</strong> - Current user, login status</li>
                        <li>üåê <strong>Language</strong> - Internationalization (i18n)</li>
                        <li>üõí <strong>Shopping Cart</strong> - Cart items, totals</li>
                        <li>‚öôÔ∏è <strong>Settings</strong> - User preferences</li>
                        <li>üîî <strong>Notifications</strong> - Toast messages, alerts</li>
                        <li>üì± <strong>Responsive</strong> - Screen size, device type</li>
                        <li>üéØ <strong>Feature Flags</strong> - Enable/disable features</li>
                    </ul>
                </div>

                <h3>Context vs Other Solutions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>When to Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Props</strong></td>
                            <td>Parent ‚Üí immediate child communication</td>
                        </tr>
                        <tr>
                            <td><strong>Context</strong></td>
                            <td>Share data across many components at different nesting levels</td>
                        </tr>
                        <tr>
                            <td><strong>Redux/Zustand</strong></td>
                            <td>Very large apps, time-travel debugging, complex middleware needs</td>
                        </tr>
                        <tr>
                            <td><strong>React Query</strong></td>
                            <td>Server state management, caching, synchronization</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Next Steps</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üöÄ Continue Learning</h4>
                    <p>Now that you know useContext, you're ready for:</p>
                    <ul>
                        <li><strong>Lesson 5.3: useRef</strong> - Access DOM elements and store mutable values</li>
                        <li><strong>Lesson 5.4: useMemo & useCallback</strong> - Performance optimization</li>
                        <li><strong>Lesson 5.5: Compound Components</strong> - Advanced patterns</li>
                        <li><strong>Module Project</strong> - Build a complete app with Context</li>
                    </ul>
                </div>

                <h3>Practice Projects</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Build These to Master Context</h4>
                    <ol>
                        <li><strong>Multi-theme App</strong> - 3+ themes with custom colors</li>
                        <li><strong>E-commerce with Cart</strong> - Products, cart, checkout</li>
                        <li><strong>Dashboard with Auth</strong> - Login, protected routes, user management</li>
                        <li><strong>Kanban Board</strong> - Drag and drop with global state</li>
                        <li><strong>Multi-language Blog</strong> - i18n with language switching</li>
                    </ol>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h2 style="color: white; margin-bottom: 1rem;">üéâ Congratulations! üéâ</h2>
                    <p style="color: white; font-size: 1.2rem;">
                        You've completed the useContext lesson and gained a powerful tool for managing shared state. You can now build scalable React applications with clean, maintainable code!
                    </p>
                    <p style="color: white; margin-top: 1.5rem;">
                        <strong>Keep practicing, keep building, and keep learning!</strong> üöÄ
                    </p>
                </div>
            </section>

        </main>
    </div>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson Navigation">
        <a href="lesson_5_1_usereducer_hook.html" class="nav-button prev-lesson">
            <span class="nav-arrow">‚Üê</span>
            <span class="nav-label">
                <small>Previous</small>
                <strong>useReducer Hook</strong>
            </span>
        </a>
        <a href="index.html" class="nav-button home-lesson">
            <span class="nav-icon">üè†</span>
            <span class="nav-label">
                <small>Back to</small>
                <strong>Home</strong>
            </span>
        </a>
        <a href="lesson_5_3_useref_hook.html" class="nav-button next-lesson">
            <span class="nav-label">
                <small>Next Lesson</small>
                <strong>useRef Hook</strong>
            </span>
            <span class="nav-arrow">‚Üí</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org" target="_blank">TypeScript Docs</a> |
                <a href="https://react.dev/reference/react/useContext" target="_blank">useContext Reference</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
