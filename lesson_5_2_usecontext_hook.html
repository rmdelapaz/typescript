<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React's useContext Hook - Learn how to solve prop drilling, share state across components, create and consume context, and properly type context with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>useContext Hook - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.2: useContext Hook</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üåê useContext Hook</h1>
                <p class="lead">Welcome to one of React's most powerful features for sharing data! Have you ever found yourself passing props down through multiple layers of components, just to get data to a deeply nested child? That's called "prop drilling," and it's a pain. The useContext Hook solves this problem elegantly by creating a "wormhole" for your data - allowing any component to access shared values without passing props through every level. Think of it like a radio broadcast: instead of passing a message person-to-person through a chain, you broadcast it, and anyone tuned in can receive it. Let's learn how to use this superpower wisely! üì°</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the prop drilling problem and why it matters</li>
                        <li>Create a Context with proper TypeScript typing</li>
                        <li>Provide context values to component trees</li>
                        <li>Consume context using the useContext Hook</li>
                        <li>Implement common context patterns (theme, authentication, etc.)</li>
                        <li>Combine useContext with useReducer for state management</li>
                        <li>Understand when to use context vs props</li>
                        <li>Avoid common context pitfalls and performance issues</li>
                        <li>Structure context for scalable applications</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a theme switcher and authentication context</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">The Prop Drilling Problem</a></li>
                        <li><a href="#section2" class="toc-link">Introduction to Context</a></li>
                        <li><a href="#section3" class="toc-link">Creating Context</a></li>
                        <li><a href="#section4" class="toc-link">Providing Context Values</a></li>
                        <li><a href="#section5" class="toc-link">Consuming Context</a></li>
                        <li><a href="#section6" class="toc-link">Typing Context with TypeScript</a></li>
                        <li><a href="#section7" class="toc-link">Theme Context Example</a></li>
                        <li><a href="#section8" class="toc-link">Context with useReducer</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Performance Considerations</a></li>
                        <li><a href="#section11" class="toc-link">Best Practices</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: The Prop Drilling Problem -->
            <section id="section1" class="lesson-section">
                <h2>‚õèÔ∏è The Prop Drilling Problem</h2>
                <p>Before we dive into Context, let's understand the problem it solves. Prop drilling occurs when you need to pass data through many layers of components to reach a deeply nested child.</p>

                <h3>A Real-World Scenario</h3>
                <p>Imagine you're building an app with user information that needs to be accessed by components at different levels:</p>

                <div class="mermaid">
                graph TD
                    A[App - has user data] --> B[Dashboard]
                    B --> C[Sidebar]
                    C --> D[UserMenu]
                    D --> E[UserProfile - needs user data!]
                    
                    B --> F[MainContent]
                    F --> G[Header - needs user data!]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <h3>The Prop Drilling Approach</h3>
                <p>Without Context, you'd have to pass the user data through every component in the chain:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Prop drilling - passing through components that don't need the data

interface User {
    id: number;
    name: string;
    email: string;
}

// App component - has the user data
function App() {
    const [user, setUser] = useState&lt;User&gt;({
        id: 1,
        name: 'John Doe',
        email: 'john@example.com'
    });

    return &lt;Dashboard user={user} /&gt;;
}

// Dashboard - doesn't use user, just passes it along
function Dashboard({ user }: { user: User }) {
    return (
        &lt;div&gt;
            &lt;Sidebar user={user} /&gt;
            &lt;MainContent user={user} /&gt;
        &lt;/div&gt;
    );
}

// Sidebar - doesn't use user, just passes it along
function Sidebar({ user }: { user: User }) {
    return (
        &lt;div&gt;
            &lt;UserMenu user={user} /&gt;
        &lt;/div&gt;
    );
}

// UserMenu - doesn't use user, just passes it along
function UserMenu({ user }: { user: User }) {
    return &lt;UserProfile user={user} /&gt;;
}

// UserProfile - FINALLY uses the user data!
function UserProfile({ user }: { user: User }) {
    return &lt;div&gt;{user.name}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with Prop Drilling</h4>
                    <ul>
                        <li><strong>Verbose</strong> - Lots of repetitive prop declarations</li>
                        <li><strong>Fragile</strong> - Adding props requires updating every component in the chain</li>
                        <li><strong>Confusing</strong> - Components receive props they don't use</li>
                        <li><strong>Hard to Refactor</strong> - Moving components means updating all props</li>
                        <li><strong>Tight Coupling</strong> - Intermediate components depend on data they don't need</li>
                    </ul>
                </div>

                <h3>The Visual Problem</h3>
                <p>Here's what prop drilling looks like visually:</p>

                <!-- Interactive Prop Drilling vs Context Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">‚ö° Interactive: Prop Drilling vs Context</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Click the buttons to see data flow through props versus context</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="propDrillingViz" viewBox="0 0 800 420" style="width: 100%; max-width: 800px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <!-- Background -->
                            <defs>
                                <linearGradient id="propGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea"/>
                                    <stop offset="100%" style="stop-color:#764ba2"/>
                                </linearGradient>
                                <linearGradient id="contextGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#48bb78"/>
                                    <stop offset="100%" style="stop-color:#38a169"/>
                                </linearGradient>
                                <filter id="glow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="400" y="25" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">Data Flow Comparison</text>
                            
                            <!-- Left Side: Prop Drilling -->
                            <text x="200" y="55" text-anchor="middle" font-size="14" font-weight="600" fill="#667eea">‚ùå Prop Drilling</text>
                            
                            <!-- App Component -->
                            <rect id="pd-app" x="120" y="70" width="160" height="40" rx="8" fill="url(#propGradient)" opacity="0.9"/>
                            <text x="200" y="95" text-anchor="middle" font-size="12" fill="white" font-weight="500">App (has user data)</text>
                            
                            <!-- Connection lines for prop drilling -->
                            <line id="pd-line1" x1="200" y1="110" x2="200" y2="140" stroke="#667eea" stroke-width="2" stroke-dasharray="5,3" opacity="0.3"/>
                            
                            <!-- Dashboard -->
                            <rect id="pd-dashboard" x="120" y="140" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="200" y="162" text-anchor="middle" font-size="11" fill="#666">Dashboard (passes through)</text>
                            
                            <line id="pd-line2" x1="200" y1="175" x2="200" y2="200" stroke="#667eea" stroke-width="2" stroke-dasharray="5,3" opacity="0.3"/>
                            
                            <!-- Sidebar -->
                            <rect id="pd-sidebar" x="120" y="200" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="200" y="222" text-anchor="middle" font-size="11" fill="#666">Sidebar (passes through)</text>
                            
                            <line id="pd-line3" x1="200" y1="235" x2="200" y2="260" stroke="#667eea" stroke-width="2" stroke-dasharray="5,3" opacity="0.3"/>
                            
                            <!-- UserMenu -->
                            <rect id="pd-usermenu" x="120" y="260" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="200" y="282" text-anchor="middle" font-size="11" fill="#666">UserMenu (passes through)</text>
                            
                            <line id="pd-line4" x1="200" y1="295" x2="200" y2="320" stroke="#667eea" stroke-width="2" stroke-dasharray="5,3" opacity="0.3"/>
                            
                            <!-- UserProfile -->
                            <rect id="pd-profile" x="120" y="320" width="160" height="40" rx="8" fill="#48bb78" opacity="0.9"/>
                            <text x="200" y="345" text-anchor="middle" font-size="12" fill="white" font-weight="500">UserProfile (uses data!)</text>
                            
                            <!-- Data packet for prop drilling animation -->
                            <g id="pd-data-packet" opacity="0">
                                <circle r="10" fill="#f093fb" filter="url(#glow)"/>
                                <text y="4" text-anchor="middle" font-size="10" fill="white" font-weight="bold">üì¶</text>
                            </g>
                            
                            <!-- Divider -->
                            <line x1="400" y1="50" x2="400" y2="380" stroke="#ddd" stroke-width="2" stroke-dasharray="8,4"/>
                            
                            <!-- Right Side: Context -->
                            <text x="600" y="55" text-anchor="middle" font-size="14" font-weight="600" fill="#48bb78">‚úÖ Context (Wormhole!)</text>
                            
                            <!-- Provider wrapper -->
                            <rect x="480" y="65" width="240" height="305" rx="12" fill="none" stroke="#48bb78" stroke-width="2" stroke-dasharray="8,4" opacity="0.5"/>
                            <text x="600" y="82" text-anchor="middle" font-size="10" fill="#48bb78" font-weight="500">UserContext.Provider</text>
                            
                            <!-- App Component -->
                            <rect id="ctx-app" x="520" y="90" width="160" height="40" rx="8" fill="url(#contextGradient)" opacity="0.9"/>
                            <text x="600" y="115" text-anchor="middle" font-size="12" fill="white" font-weight="500">App (broadcasts user)</text>
                            
                            <!-- Connection lines for context (regular hierarchy) -->
                            <line x1="600" y1="130" x2="600" y2="155" stroke="#ccc" stroke-width="1"/>
                            
                            <!-- Dashboard -->
                            <rect x="520" y="155" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="600" y="177" text-anchor="middle" font-size="11" fill="#999">Dashboard (no props!)</text>
                            
                            <line x1="600" y1="190" x2="600" y2="210" stroke="#ccc" stroke-width="1"/>
                            
                            <!-- Sidebar -->
                            <rect x="520" y="210" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="600" y="232" text-anchor="middle" font-size="11" fill="#999">Sidebar (no props!)</text>
                            
                            <line x1="600" y1="245" x2="600" y2="265" stroke="#ccc" stroke-width="1"/>
                            
                            <!-- UserMenu -->
                            <rect x="520" y="265" width="160" height="35" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="600" y="287" text-anchor="middle" font-size="11" fill="#999">UserMenu (no props!)</text>
                            
                            <line x1="600" y1="300" x2="600" y2="320" stroke="#ccc" stroke-width="1"/>
                            
                            <!-- UserProfile -->
                            <rect id="ctx-profile" x="520" y="320" width="160" height="40" rx="8" fill="#48bb78" opacity="0.9"/>
                            <text x="600" y="345" text-anchor="middle" font-size="12" fill="white" font-weight="500">UserProfile (reads context)</text>
                            
                            <!-- Wormhole connection (curved line from App directly to Profile) -->
                            <path id="ctx-wormhole" d="M 520 110 Q 460 220 520 340" fill="none" stroke="#48bb78" stroke-width="3" opacity="0" stroke-linecap="round"/>
                            
                            <!-- Data packet for context animation -->
                            <g id="ctx-data-packet" opacity="0">
                                <circle r="12" fill="#48bb78" filter="url(#glow)"/>
                                <text y="4" text-anchor="middle" font-size="12" fill="white" font-weight="bold">üì°</text>
                            </g>
                            
                            <!-- Status text -->
                            <text id="viz-status" x="400" y="405" text-anchor="middle" font-size="12" fill="#666">Click a button to visualize data flow</text>
                        </svg>
                        
                        <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="animatePropDrilling()" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Show Prop Drilling</button>
                            <button onclick="animateContext()" style="padding: 0.75rem 1.5rem; background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Show Context (Wormhole)</button>
                            <button onclick="resetViz()" style="padding: 0.75rem 1.5rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">Reset</button>
                        </div>
                    </div>
                </div>
                
                <script>
                let pdAnimating = false;
                let ctxAnimating = false;
                
                function animatePropDrilling() {
                    if (pdAnimating) return;
                    pdAnimating = true;
                    resetViz();
                    
                    const packet = document.getElementById('pd-data-packet');
                    const status = document.getElementById('viz-status');
                    const lines = ['pd-line1', 'pd-line2', 'pd-line3', 'pd-line4'];
                    const components = ['pd-dashboard', 'pd-sidebar', 'pd-usermenu', 'pd-profile'];
                    const yPositions = [125, 187, 247, 307, 340];
                    
                    status.textContent = '‚è≥ Passing user prop through each component...';
                    packet.setAttribute('opacity', '1');
                    packet.setAttribute('transform', 'translate(200, 90)');
                    
                    let step = 0;
                    const interval = setInterval(() => {
                        if (step < lines.length) {
                            // Highlight current line
                            document.getElementById(lines[step]).setAttribute('opacity', '1');
                            document.getElementById(lines[step]).setAttribute('stroke-width', '3');
                            
                            // Animate packet
                            packet.setAttribute('transform', `translate(200, ${yPositions[step + 1]})`);
                            
                            // Highlight component
                            if (step < components.length - 1) {
                                document.getElementById(components[step]).style.stroke = '#667eea';
                                document.getElementById(components[step]).style.strokeWidth = '2';
                            }
                            
                            step++;
                        } else {
                            clearInterval(interval);
                            status.textContent = 'üò´ Data had to pass through 4 components! That\'s prop drilling.';
                            document.getElementById('pd-profile').style.filter = 'url(#glow)';
                            pdAnimating = false;
                        }
                    }, 600);
                }
                
                function animateContext() {
                    if (ctxAnimating) return;
                    ctxAnimating = true;
                    resetViz();
                    
                    const packet = document.getElementById('ctx-data-packet');
                    const wormhole = document.getElementById('ctx-wormhole');
                    const status = document.getElementById('viz-status');
                    
                    status.textContent = 'üì° Broadcasting via Context...';
                    
                    // Show wormhole path
                    wormhole.setAttribute('opacity', '0.6');
                    
                    // Animate along the wormhole path
                    packet.setAttribute('opacity', '1');
                    
                    const path = wormhole;
                    const pathLength = path.getTotalLength();
                    let progress = 0;
                    
                    const animate = () => {
                        if (progress <= 1) {
                            const point = path.getPointAtLength(progress * pathLength);
                            packet.setAttribute('transform', `translate(${point.x}, ${point.y})`);
                            progress += 0.03;
                            requestAnimationFrame(animate);
                        } else {
                            status.textContent = 'üéâ Direct access! Components in between don\'t need to know about the data.';
                            document.getElementById('ctx-profile').style.filter = 'url(#glow)';
                            wormhole.setAttribute('stroke-width', '4');
                            ctxAnimating = false;
                        }
                    };
                    
                    requestAnimationFrame(animate);
                }
                
                function resetViz() {
                    // Reset prop drilling
                    ['pd-line1', 'pd-line2', 'pd-line3', 'pd-line4'].forEach(id => {
                        const el = document.getElementById(id);
                        el.setAttribute('opacity', '0.3');
                        el.setAttribute('stroke-width', '2');
                    });
                    ['pd-dashboard', 'pd-sidebar', 'pd-usermenu'].forEach(id => {
                        const el = document.getElementById(id);
                        el.style.stroke = '#ddd';
                        el.style.strokeWidth = '1';
                    });
                    document.getElementById('pd-data-packet').setAttribute('opacity', '0');
                    document.getElementById('pd-profile').style.filter = 'none';
                    
                    // Reset context
                    document.getElementById('ctx-wormhole').setAttribute('opacity', '0');
                    document.getElementById('ctx-wormhole').setAttribute('stroke-width', '3');
                    document.getElementById('ctx-data-packet').setAttribute('opacity', '0');
                    document.getElementById('ctx-profile').style.filter = 'none';
                    
                    document.getElementById('viz-status').textContent = 'Click a button to visualize data flow';
                }
                </script>

                <div class="mermaid">
                sequenceDiagram
                    participant App
                    participant Dashboard
                    participant Sidebar
                    participant UserMenu
                    participant UserProfile
                    
                    App->>Dashboard: user prop
                    Dashboard->>Sidebar: user prop (not used)
                    Sidebar->>UserMenu: user prop (not used)
                    UserMenu->>UserProfile: user prop
                    UserProfile->>UserProfile: Finally! Use user data
                    
                    Note over Dashboard,UserMenu: These components don't<br/>need user, but must<br/>pass it through
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When Does Prop Drilling Become a Problem?</h4>
                    <ul>
                        <li>Data needs to pass through 3+ component levels</li>
                        <li>Many components need the same data</li>
                        <li>Intermediate components don't use the data</li>
                        <li>The data changes frequently</li>
                        <li>You find yourself adding props to components just to pass them down</li>
                    </ul>
                </div>

                <h3>Real-World Examples</h3>
                <p>Common scenarios where prop drilling becomes painful:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>What Needs Sharing</th>
                            <th>Who Needs It</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Theme</strong></td>
                            <td>Dark/light mode preference</td>
                            <td>Every styled component</td>
                        </tr>
                        <tr>
                            <td><strong>Authentication</strong></td>
                            <td>Current user, login status</td>
                            <td>Protected routes, user menus, etc.</td>
                        </tr>
                        <tr>
                            <td><strong>Language</strong></td>
                            <td>Current locale (en, es, fr)</td>
                            <td>All text-displaying components</td>
                        </tr>
                        <tr>
                            <td><strong>Shopping Cart</strong></td>
                            <td>Cart items, total, quantity</td>
                            <td>Product pages, cart icon, checkout</td>
                        </tr>
                        <tr>
                            <td><strong>Settings</strong></td>
                            <td>User preferences</td>
                            <td>Various UI components</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 2: Introduction to Context -->
            <section id="section2" class="lesson-section">
                <h2>üåê Introduction to Context</h2>
                <p>React Context is the solution to prop drilling. It provides a way to share values between components without explicitly passing props through every level of the tree.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Context:</strong> A feature in React that provides a way to pass data through the component tree without having to pass props down manually at every level. It creates a "global" scope for a specific part of your component tree.</p>
                </div>

                <h3>The Context Solution</h3>
                <p>With Context, components can "broadcast" data, and any component in the tree can "tune in" to receive it:</p>

                <div class="mermaid">
                graph TD
                    A[App with Context Provider] -.broadcasts user.-> B[Dashboard]
                    B --> C[Sidebar]
                    C --> D[UserMenu]
                    D --> E[UserProfile - reads from context!]
                    
                    B --> F[MainContent]
                    F --> G[Header - reads from context!]
                    
                    A -.-> E
                    A -.-> G
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <p>Notice how Dashboard, Sidebar, and UserMenu don't need to pass the user prop anymore! The components that need the data can directly access it from context.</p>

                <h3>How Context Works</h3>
                <p>Context has three main parts:</p>

                <div class="card">
                    <h4>The Three Pieces of Context</h4>
                    <ol>
                        <li>
                            <strong>Create Context</strong> - Define what data will be shared
                            <pre><code>const UserContext = createContext(defaultValue);</code></pre>
                        </li>
                        <li>
                            <strong>Provide Context</strong> - Wrap components that need access
                            <pre><code>&lt;UserContext.Provider value={user}&gt;
    {children}
&lt;/UserContext.Provider&gt;</code></pre>
                        </li>
                        <li>
                            <strong>Consume Context</strong> - Read the value in components
                            <pre><code>const user = useContext(UserContext);</code></pre>
                        </li>
                    </ol>
                </div>

                <h3>Context Flow Visualization</h3>
                <div class="mermaid">
                sequenceDiagram
                    participant Create as 1. Create Context
                    participant Provider as 2. Provider
                    participant Tree as Component Tree
                    participant Consumer as 3. Consumer (useContext)
                    
                    Create->>Provider: Define context
                    Provider->>Tree: Wrap components
                    Tree->>Consumer: Component needs data
                    Consumer->>Provider: Read value
                    Provider->>Consumer: Return current value
                </div>

                <h3>Real-World Analogy</h3>
                <p>Think of Context like a radio broadcast system:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Radio Broadcast</th>
                            <th>React Context</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Radio Station</td>
                            <td>Context Provider</td>
                        </tr>
                        <tr>
                            <td>Broadcast Signal</td>
                            <td>Context Value</td>
                        </tr>
                        <tr>
                            <td>Radio Receiver</td>
                            <td>useContext Hook</td>
                        </tr>
                        <tr>
                            <td>Tune to Frequency</td>
                            <td>Import and use context</td>
                        </tr>
                        <tr>
                            <td>Broadcast Range</td>
                            <td>Provider's component tree</td>
                        </tr>
                    </tbody>
                </table>

                <p>Just like how any radio in range can tune into a station without being physically connected, any component within a Provider can access the context value without receiving props!</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Context</h4>
                    <ul>
                        <li><strong>No Prop Drilling</strong> - Skip intermediate components</li>
                        <li><strong>Cleaner Code</strong> - Less boilerplate, more focused components</li>
                        <li><strong>Easier Refactoring</strong> - Move components without updating props</li>
                        <li><strong>Shared State</strong> - Multiple components access same data</li>
                        <li><strong>Loose Coupling</strong> - Components only depend on data they use</li>
                        <li><strong>Better Organization</strong> - Group related data together</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use Context</h4>
                    <p>Context isn't always the answer. Don't use it when:</p>
                    <ul>
                        <li>Data only needs to go 1-2 levels down (use props)</li>
                        <li>You're just trying to avoid typing props (that's what props are for!)</li>
                        <li>The data changes very frequently and affects many components (may cause performance issues)</li>
                        <li>The data is only used by a single component</li>
                        <li>You need to optimize re-renders carefully (Context re-renders all consumers)</li>
                    </ul>
                </div>

                <h3>Context vs Props vs State Management</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>Use When</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Props</strong></td>
                            <td>Parent-child communication, 1-2 levels</td>
                            <td>Passing onClick to a button</td>
                        </tr>
                        <tr>
                            <td><strong>Context</strong></td>
                            <td>Data needed by many components, deep nesting</td>
                            <td>Theme, auth, language</td>
                        </tr>
                        <tr>
                            <td><strong>State Management</strong><br/>(Redux, Zustand)</td>
                            <td>Complex global state, time travel, middleware</td>
                            <td>Large e-commerce app state</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 3: Creating Context -->
            <section id="section3" class="lesson-section">
                <h2>üî® Creating Context</h2>
                <p>Let's learn how to create Context step by step. We'll use TypeScript to ensure type safety throughout.</p>

                <h3>Basic Context Creation</h3>
                <p>The first step is to create a context using <code>createContext</code>:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Simple value context
const ThemeContext = createContext('light');

// Object context
const UserContext = createContext({
    name: 'Guest',
    isLoggedIn: false
});</code></pre>
                </div>

                <p><code>createContext</code> takes a default value that's used when a component tries to access context without a Provider. This default is mostly useful for testing.</p>

                <h3>Context with TypeScript</h3>
                <p>For TypeScript, we need to properly type our context:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Define the shape of your context value
interface User {
    id: number;
    name: string;
    email: string;
}

// Create context with type and default value
const UserContext = createContext&lt;User&gt;({
    id: 0,
    name: 'Guest',
    email: ''
});</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Tip</h4>
                    <p>The generic <code>&lt;User&gt;</code> tells TypeScript what type of value the context holds. This gives you autocomplete and type checking when using the context!</p>
                </div>

                <h3>Context with Functions</h3>
                <p>Context can hold more than just data - it can include functions too:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

interface ThemeContextType {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType&gt;({
    theme: 'light',
    toggleTheme: () => {
        console.warn('toggleTheme called outside of Provider');
    }
});</code></pre>
                </div>

                <h3>Context with Undefined Default</h3>
                <p>Sometimes you don't want a meaningful default value. Use <code>undefined</code> and force components to check:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

interface User {
    id: number;
    name: string;
}

// Allow undefined - requires Provider
const UserContext = createContext&lt;User | undefined&gt;(undefined);

// Later, when consuming:
const user = useContext(UserContext);
if (!user) {
    throw new Error('useUser must be used within UserProvider');
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Undefined Default</h4>
                    <p>Use <code>undefined</code> as default when:</p>
                    <ul>
                        <li>Context must always be used within a Provider</li>
                        <li>You want to catch mistakes early (forgetting Provider)</li>
                        <li>A fake default value doesn't make sense</li>
                        <li>You want to enforce proper setup</li>
                    </ul>
                </div>

                <h3>File Organization</h3>
                <p>Best practice is to create contexts in separate files:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/UserContext.tsx
import { createContext } from 'react';

export interface User {
    id: number;
    name: string;
    email: string;
}

export interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

export const UserContext = createContext&lt;UserContextType | undefined&gt;(
    undefined
);</code></pre>
                </div>

                <p>This keeps your contexts organized and makes them easy to import:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// In any component
import { UserContext } from '@/contexts/UserContext';
import { useContext } from 'react';

function MyComponent() {
    const userContext = useContext(UserContext);
    // ...
}</code></pre>
                </div>

            <!-- Section 4: Providing Context Values -->
            <section id="section4" class="lesson-section">
                <h2>üì§ Providing Context Values</h2>
                <p>Creating a context is just the first step. To make the context value available to components, you need to wrap them in a Provider. Think of the Provider as the broadcasting station that transmits the signal.</p>

                <h3>Basic Provider Usage</h3>
                <p>Every context comes with a Provider component that accepts a value prop:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

const ThemeContext = createContext('light');

function App() {
    return (
        &lt;ThemeContext.Provider value="dark"&gt;
            &lt;Header /&gt;
            &lt;MainContent /&gt;
            &lt;Footer /&gt;
        &lt;/ThemeContext.Provider&gt;
    );
}

// Now Header, MainContent, Footer (and all their children)
// can access the theme value "dark"</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Provider Scope</h4>
                    <p>The Provider's scope is its entire component tree. Any component inside the Provider (at any nesting level) can access the context value. Components outside the Provider cannot.</p>
                </div>

                <h3>Provider with State</h3>
                <p>Usually, you'll want the context value to be dynamic, not static. Use state in the Provider:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState } from 'react';

interface User {
    id: number;
    name: string;
}

const UserContext = createContext&lt;User | null&gt;(null);

function App() {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    return (
        &lt;UserContext.Provider value={user}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}

// Now the user state is accessible throughout the Dashboard tree</code></pre>
                </div>

                <h3>Provider with Multiple Values</h3>
                <p>You can provide multiple related values by wrapping them in an object:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

function App() {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => {
        setUser(newUser);
    };

    const logout = () => {
        setUser(null);
    };

    const contextValue = {
        user,
        login,
        logout
    };

    return (
        &lt;UserContext.Provider value={contextValue}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Provider Value Warning</h4>
                    <p>Be careful with the value prop! If you pass an object literal or create a new object on every render, you'll cause unnecessary re-renders:</p>
                    <pre><code>// ‚ùå Bad - creates new object every render
&lt;UserContext.Provider value={{ user, login, logout }}&gt;

// ‚úÖ Good - stable reference
const contextValue = { user, login, logout };
&lt;UserContext.Provider value={contextValue}&gt;</code></pre>
                    <p>We'll cover this more in the performance section!</p>
                </div>

                <h3>Custom Provider Component Pattern</h3>
                <p>A common pattern is to create a custom Provider component that encapsulates the logic:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useState, ReactNode } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

export const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom Provider component
export function UserProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => {
        setUser(newUser);
        localStorage.setItem('user', JSON.stringify(newUser));
    };

    const logout = () => {
        setUser(null);
        localStorage.removeItem('user');
    };

    const value = { user, login, logout };

    return (
        &lt;UserContext.Provider value={value}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// Now use the custom Provider
function App() {
    return (
        &lt;UserProvider&gt;
            &lt;Dashboard /&gt;
        &lt;/UserProvider&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Provider Benefits</h4>
                    <ul>
                        <li><strong>Encapsulation</strong> - Logic lives with the context</li>
                        <li><strong>Reusability</strong> - Easy to use across apps</li>
                        <li><strong>Cleaner App Component</strong> - Less clutter in main component</li>
                        <li><strong>Single Responsibility</strong> - Provider handles one concern</li>
                        <li><strong>Easier Testing</strong> - Test provider independently</li>
                    </ul>
                </div>

                <h3>Multiple Providers</h3>
                <p>You can nest multiple Providers for different contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;UserProvider&gt;
                &lt;LanguageProvider&gt;
                    &lt;Dashboard /&gt;
                &lt;/LanguageProvider&gt;
            &lt;/UserProvider&gt;
        &lt;/ThemeProvider&gt;
    );
}

// Dashboard and all children can access theme, user, and language contexts</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Provider Order</h4>
                    <p>The order of Providers usually doesn't matter, unless one Provider depends on another's context. Put independent Providers in any order, but if ThemeProvider needs user data, put UserProvider outside.</p>
                </div>

                <h3>Scoped Providers</h3>
                <p>You can have multiple Providers of the same context in different parts of your tree:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function App() {
    return (
        &lt;div&gt;
            {/* Light theme section */}
            &lt;ThemeContext.Provider value="light"&gt;
                &lt;Header /&gt;
            &lt;/ThemeContext.Provider&gt;

            {/* Dark theme section */}
            &lt;ThemeContext.Provider value="dark"&gt;
                &lt;MainContent /&gt;
            &lt;/ThemeContext.Provider&gt;

            {/* Uses default or nearest Provider */}
            &lt;Footer /&gt;
        &lt;/div&gt;
    );
}

// Header uses light theme, MainContent uses dark theme</code></pre>
                </div>

                <p>Components use the value from the nearest Provider above them in the tree.</p>

                <h3>Provider Placement Strategy</h3>
                <div class="mermaid">
                graph TD
                    A[Where to Place Provider?] --> B{Who needs the data?}
                    B -->|Entire app| C[Wrap App root]
                    B -->|Specific section| D[Wrap that section]
                    B -->|Multiple sections| E[Consider multiple Providers]
                    
                    C --> F[Performance impact: High]
                    D --> G[Performance impact: Low]
                    E --> H[Performance impact: Medium]
                    
                    style C fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#f093fb,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>
                
                <!-- Interactive Provider Scope Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üéØ Interactive: Provider Scope Explorer</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Click on different Provider scopes to see which components can access the context</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="providerScopeViz" viewBox="0 0 700 400" style="width: 100%; max-width: 700px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="providerGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#48bb78"/>
                                    <stop offset="100%" style="stop-color:#38a169"/>
                                </linearGradient>
                                <filter id="glowScope">
                                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                                <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="8" height="8">
                                    <path d="M-2,2 l4,-4 M0,8 l8,-8 M6,10 l4,-4" style="stroke:#48bb78; stroke-width:1; opacity:0.3;"/>
                                </pattern>
                            </defs>
                            
                            <!-- Title -->
                            <text x="350" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">Provider Scope Determines Context Access</text>
                            
                            <!-- App root -->
                            <rect id="scope-app" x="20" y="45" width="660" height="340" rx="12" fill="#fafafa" stroke="#ddd" stroke-width="2"/>
                            <text x="40" y="70" font-size="13" font-weight="600" fill="#333">App (Root)</text>
                            
                            <!-- Provider boundary indicator (will be animated) -->
                            <rect id="provider-boundary" x="0" y="0" width="0" height="0" rx="10" fill="none" stroke="#48bb78" stroke-width="3" stroke-dasharray="8,4" opacity="0"/>
                            <text id="provider-label" x="0" y="0" font-size="11" fill="#48bb78" font-weight="600" opacity="0">ThemeProvider</text>
                            
                            <!-- Header section -->
                            <g id="comp-header">
                                <rect x="40" y="85" width="200" height="50" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1"/>
                                <text x="140" y="115" text-anchor="middle" font-size="12" fill="#666">Header</text>
                                <circle id="access-header" cx="220" cy="95" r="8" fill="#ccc" opacity="0"/>
                            </g>
                            
                            <!-- Nav section -->
                            <g id="comp-nav">
                                <rect x="40" y="145" width="200" height="50" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1"/>
                                <text x="140" y="175" text-anchor="middle" font-size="12" fill="#666">Navigation</text>
                                <circle id="access-nav" cx="220" cy="155" r="8" fill="#ccc" opacity="0"/>
                            </g>
                            
                            <!-- Main Content area -->
                            <g id="comp-main">
                                <rect x="260" y="85" width="400" height="230" rx="8" fill="#f5f5f5" stroke="#ccc" stroke-width="1"/>
                                <text x="280" y="108" font-size="12" font-weight="500" fill="#555">MainContent</text>
                                <circle id="access-main" cx="640" cy="95" r="8" fill="#ccc" opacity="0"/>
                                
                                <!-- Sidebar inside main -->
                                <g id="comp-sidebar">
                                    <rect x="280" y="120" width="150" height="180" rx="6" fill="#fff" stroke="#ddd" stroke-width="1"/>
                                    <text x="355" y="145" text-anchor="middle" font-size="11" fill="#777">Sidebar</text>
                                    <circle id="access-sidebar" cx="410" cy="130" r="7" fill="#ccc" opacity="0"/>
                                    
                                    <!-- Menu inside sidebar -->
                                    <g id="comp-menu">
                                        <rect x="295" y="160" width="120" height="40" rx="4" fill="#f8f8f8" stroke="#e0e0e0" stroke-width="1"/>
                                        <text x="355" y="185" text-anchor="middle" font-size="10" fill="#888">Menu</text>
                                        <circle id="access-menu" cx="400" cy="168" r="6" fill="#ccc" opacity="0"/>
                                    </g>
                                    
                                    <!-- UserWidget inside sidebar -->
                                    <g id="comp-userwidget">
                                        <rect x="295" y="210" width="120" height="40" rx="4" fill="#f8f8f8" stroke="#e0e0e0" stroke-width="1"/>
                                        <text x="355" y="235" text-anchor="middle" font-size="10" fill="#888">UserWidget</text>
                                        <circle id="access-userwidget" cx="400" cy="218" r="6" fill="#ccc" opacity="0"/>
                                    </g>
                                    
                                    <!-- ThemeToggle inside sidebar -->
                                    <g id="comp-themetoggle">
                                        <rect x="295" y="258" width="120" height="35" rx="4" fill="#f8f8f8" stroke="#e0e0e0" stroke-width="1"/>
                                        <text x="355" y="280" text-anchor="middle" font-size="10" fill="#888">ThemeToggle</text>
                                        <circle id="access-themetoggle" cx="400" cy="266" r="6" fill="#ccc" opacity="0"/>
                                    </g>
                                </g>
                                
                                <!-- Article inside main -->
                                <g id="comp-article">
                                    <rect x="450" y="120" width="190" height="180" rx="6" fill="#fff" stroke="#ddd" stroke-width="1"/>
                                    <text x="545" y="145" text-anchor="middle" font-size="11" fill="#777">Article</text>
                                    <circle id="access-article" cx="620" cy="130" r="7" fill="#ccc" opacity="0"/>
                                    
                                    <!-- Content inside article -->
                                    <g id="comp-content">
                                        <rect x="465" y="160" width="160" height="60" rx="4" fill="#f8f8f8" stroke="#e0e0e0" stroke-width="1"/>
                                        <text x="545" y="195" text-anchor="middle" font-size="10" fill="#888">Content</text>
                                        <circle id="access-content" cx="610" cy="168" r="6" fill="#ccc" opacity="0"/>
                                    </g>
                                    
                                    <!-- Comments inside article -->
                                    <g id="comp-comments">
                                        <rect x="465" y="230" width="160" height="60" rx="4" fill="#f8f8f8" stroke="#e0e0e0" stroke-width="1"/>
                                        <text x="545" y="265" text-anchor="middle" font-size="10" fill="#888">Comments</text>
                                        <circle id="access-comments" cx="610" cy="238" r="6" fill="#ccc" opacity="0"/>
                                    </g>
                                </g>
                            </g>
                            
                            <!-- Footer -->
                            <g id="comp-footer">
                                <rect x="40" y="325" width="620" height="50" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1"/>
                                <text x="350" y="355" text-anchor="middle" font-size="12" fill="#666">Footer</text>
                                <circle id="access-footer" cx="640" cy="335" r="8" fill="#ccc" opacity="0"/>
                            </g>
                            
                            <!-- Legend -->
                            <g transform="translate(20, 395)">
                                <circle cx="10" cy="0" r="6" fill="#48bb78"/>
                                <text x="22" y="4" font-size="10" fill="#666">Has Context Access</text>
                                <circle cx="140" cy="0" r="6" fill="#ef4444"/>
                                <text x="152" y="4" font-size="10" fill="#666">No Access</text>
                            </g>
                            
                            <!-- Status -->
                            <text id="scope-status" x="350" y="395" text-anchor="middle" font-size="11" fill="#666">Select a Provider scope below</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="setProviderScope('app')" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Wrap Entire App</button>
                            <button onclick="setProviderScope('main')" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Wrap MainContent Only</button>
                            <button onclick="setProviderScope('sidebar')" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Wrap Sidebar Only</button>
                            <button onclick="setProviderScope('none')" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset</button>
                        </div>
                    </div>
                </div>
                
                <script>
                const scopeConfigs = {
                    app: {
                        boundary: { x: 25, y: 50, width: 650, height: 330 },
                        access: ['header', 'nav', 'main', 'sidebar', 'menu', 'userwidget', 'themetoggle', 'article', 'content', 'comments', 'footer'],
                        message: 'üåç App-level Provider: ALL components can access the context!'
                    },
                    main: {
                        boundary: { x: 255, y: 80, width: 410, height: 240 },
                        access: ['main', 'sidebar', 'menu', 'userwidget', 'themetoggle', 'article', 'content', 'comments'],
                        message: 'üì¶ MainContent Provider: Only MainContent and its children have access'
                    },
                    sidebar: {
                        boundary: { x: 275, y: 115, width: 160, height: 190 },
                        access: ['sidebar', 'menu', 'userwidget', 'themetoggle'],
                        message: 'üìã Sidebar Provider: Only Sidebar and its children (Menu, UserWidget, ThemeToggle) have access'
                    },
                    none: {
                        boundary: { x: 0, y: 0, width: 0, height: 0 },
                        access: [],
                        message: 'Select a Provider scope to see which components get context access'
                    }
                };
                
                const allComponents = ['header', 'nav', 'main', 'sidebar', 'menu', 'userwidget', 'themetoggle', 'article', 'content', 'comments', 'footer'];
                
                function setProviderScope(scope) {
                    const config = scopeConfigs[scope];
                    const boundary = document.getElementById('provider-boundary');
                    const label = document.getElementById('provider-label');
                    const status = document.getElementById('scope-status');
                    
                    // Update boundary
                    if (scope === 'none') {
                        boundary.setAttribute('opacity', '0');
                        label.setAttribute('opacity', '0');
                    } else {
                        boundary.setAttribute('x', config.boundary.x);
                        boundary.setAttribute('y', config.boundary.y);
                        boundary.setAttribute('width', config.boundary.width);
                        boundary.setAttribute('height', config.boundary.height);
                        boundary.setAttribute('opacity', '1');
                        
                        label.setAttribute('x', config.boundary.x + 5);
                        label.setAttribute('y', config.boundary.y + 12);
                        label.setAttribute('opacity', '1');
                    }
                    
                    // Update access indicators
                    allComponents.forEach(comp => {
                        const indicator = document.getElementById(`access-${comp}`);
                        if (indicator) {
                            if (scope === 'none') {
                                indicator.setAttribute('opacity', '0');
                            } else if (config.access.includes(comp)) {
                                indicator.setAttribute('fill', '#48bb78');
                                indicator.setAttribute('opacity', '1');
                            } else {
                                indicator.setAttribute('fill', '#ef4444');
                                indicator.setAttribute('opacity', '1');
                            }
                        }
                    });
                    
                    // Update status message
                    status.textContent = config.message;
                }
                </script>
            </section>

            <!-- Section 5: Consuming Context -->
            <section id="section5" class="lesson-section">
                <h2>üì• Consuming Context</h2>
                <p>Now that we know how to provide context, let's learn how to consume it using the useContext Hook. This is where the magic happens!</p>

                <h3>Basic useContext Usage</h3>
                <p>The useContext Hook reads the value from the nearest Provider above it:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';

function Header() {
    const theme = useContext(ThemeContext);
    
    return (
        &lt;header className={theme === 'dark' ? 'dark' : 'light'}&gt;
            &lt;h1&gt;My App&lt;/h1&gt;
        &lt;/header&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° How useContext Works</h4>
                    <ol>
                        <li>Import the context you want to use</li>
                        <li>Call useContext with that context</li>
                        <li>Get back the current value from the Provider</li>
                        <li>Use the value in your component</li>
                    </ol>
                </div>

                <h3>Consuming Object Context</h3>
                <p>When your context provides an object with multiple values:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { UserContext } from './UserContext';

function UserProfile() {
    const userContext = useContext(UserContext);
    
    // Destructure for cleaner code
    const { user, login, logout } = userContext;
    
    if (!user) {
        return (
            &lt;button onClick={() =&gt; login({ id: 1, name: 'John' })}&gt;
                Login
            &lt;/button&gt;
        );
    }
    
    return (
        &lt;div&gt;
            &lt;p&gt;Welcome, {user.name}!&lt;/p&gt;
            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Multiple Context Consumption</h3>
                <p>A component can consume multiple contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useContext } from 'react';
import { ThemeContext } from './ThemeContext';
import { UserContext } from './UserContext';
import { LanguageContext } from './LanguageContext';

function Dashboard() {
    const theme = useContext(ThemeContext);
    const { user } = useContext(UserContext);
    const { language } = useContext(LanguageContext);
    
    return (
        &lt;div className={`dashboard ${theme}`}&gt;
            &lt;h1&gt;{language === 'en' ? 'Dashboard' : 'Tablero'}&lt;/h1&gt;
            &lt;p&gt;User: {user?.name}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Custom Hook Pattern</h3>
                <p>A best practice is to create a custom hook for each context:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// UserContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

interface User {
    id: number;
    name: string;
}

interface UserContextType {
    user: User | null;
    login: (user: User) => void;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom Provider
export function UserProvider({ children }: { children: ReactNode }) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = (newUser: User) => setUser(newUser);
    const logout = () => setUser(null);

    return (
        &lt;UserContext.Provider value={{ user, login, logout }}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// Custom Hook - this is the magic!
export function useUser() {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    return context;
}

// Now in components:
function MyComponent() {
    const { user, login, logout } = useUser(); // Clean and type-safe!
    // ...
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Hook Benefits</h4>
                    <ul>
                        <li><strong>Error Checking</strong> - Catches missing Provider at runtime</li>
                        <li><strong>Type Safety</strong> - No undefined checks needed</li>
                        <li><strong>Cleaner Imports</strong> - Import one hook instead of context + useContext</li>
                        <li><strong>Consistent API</strong> - Every context has the same usage pattern</li>
                        <li><strong>Better DX</strong> - Autocomplete works perfectly</li>
                    </ul>
                </div>

                <h3>Context with Computed Values</h3>
                <p>You can derive values based on context in the consuming component:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function TodoStats() {
    const { todos } = useTodos();
    
    // Derive values from context
    const totalTodos = todos.length;
    const completedTodos = todos.filter(t => t.completed).length;
    const activeTodos = totalTodos - completedTodos;
    const completionRate = totalTodos > 0 
        ? Math.round((completedTodos / totalTodos) * 100) 
        : 0;
    
    return (
        &lt;div&gt;
            &lt;p&gt;Total: {totalTodos}&lt;/p&gt;
            &lt;p&gt;Completed: {completedTodos}&lt;/p&gt;
            &lt;p&gt;Active: {activeTodos}&lt;/p&gt;
            &lt;p&gt;Completion: {completionRate}%&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Conditional Context Usage</h3>
                <p>Sometimes you want to use context only if it's available:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Optional context hook
export function useOptionalUser() {
    return useContext(UserContext);
}

function UserGreeting() {
    const userContext = useOptionalUser();
    
    // Handle both cases: inside and outside Provider
    if (!userContext || !userContext.user) {
        return &lt;p&gt;Welcome, Guest!&lt;/p&gt;;
    }
    
    return &lt;p&gt;Welcome, {userContext.user.name}!&lt;/p&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't call useContext conditionally or in loops:</p>
                    <pre><code>// ‚ùå Wrong - breaks Rules of Hooks
if (someCondition) {
    const theme = useContext(ThemeContext);
}

// ‚úÖ Correct - call at top level, use conditionally
const theme = useContext(ThemeContext);
if (someCondition) {
    // use theme
}</code></pre>
                </div>

                <h3>Context Consumer Flow</h3>
                <div class="mermaid">
                sequenceDiagram
                    participant Component
                    participant useContext
                    participant Provider
                    
                    Component->>useContext: Call useContext(MyContext)
                    useContext->>Provider: Find nearest Provider
                    Provider->>useContext: Return current value
                    useContext->>Component: Return value
                    Component->>Component: Use value in render
                    
                    Note over Provider: If Provider value changes
                    Provider->>Component: Trigger re-render
                    Component->>useContext: Get updated value
                </div>
                
                <!-- Interactive useContext Flow Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üîç Interactive: How useContext Finds Its Value</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Watch how useContext traverses up the component tree to find the nearest Provider</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="useContextFlowViz" viewBox="0 0 700 450" style="width: 100%; max-width: 700px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="flowGrad1" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#4facfe"/>
                                    <stop offset="100%" style="stop-color:#00f2fe"/>
                                </linearGradient>
                                <linearGradient id="flowGrad2" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#48bb78"/>
                                    <stop offset="100%" style="stop-color:#38a169"/>
                                </linearGradient>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#4facfe"/>
                                </marker>
                                <filter id="searchGlow">
                                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="350" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">useContext Provider Lookup</text>
                            
                            <!-- Component tree -->
                            <!-- Level 0: App with Provider -->
                            <g id="flow-app">
                                <rect x="250" y="50" width="200" height="55" rx="10" fill="url(#flowGrad2)"/>
                                <text x="350" y="72" text-anchor="middle" font-size="12" fill="white" font-weight="600">App</text>
                                <text x="350" y="90" text-anchor="middle" font-size="10" fill="rgba(255,255,255,0.9)">&lt;ThemeContext.Provider&gt;</text>
                                <circle id="found-indicator" cx="435" cy="77" r="10" fill="#ffd700" opacity="0"/>
                                <text id="found-text" x="435" y="81" text-anchor="middle" font-size="10" fill="#333" font-weight="bold" opacity="0">‚úî</text>
                            </g>
                            
                            <!-- Connection lines -->
                            <line x1="300" y1="105" x2="200" y2="140" stroke="#ccc" stroke-width="2"/>
                            <line x1="400" y1="105" x2="500" y2="140" stroke="#ccc" stroke-width="2"/>
                            
                            <!-- Level 1: Dashboard and Sidebar -->
                            <g id="flow-dashboard">
                                <rect x="100" y="140" width="180" height="45" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1"/>
                                <text x="190" y="167" text-anchor="middle" font-size="11" fill="#666">Dashboard</text>
                            </g>
                            
                            <g id="flow-sidebar">
                                <rect x="420" y="140" width="180" height="45" rx="8" fill="#f0f0f0" stroke="#ccc" stroke-width="1"/>
                                <text x="510" y="167" text-anchor="middle" font-size="11" fill="#666">Sidebar</text>
                            </g>
                            
                            <!-- Connection lines level 1 to 2 -->
                            <line x1="150" y1="185" x2="120" y2="220" stroke="#ccc" stroke-width="2"/>
                            <line x1="230" y1="185" x2="260" y2="220" stroke="#ccc" stroke-width="2"/>
                            <line x1="470" y1="185" x2="440" y2="220" stroke="#ccc" stroke-width="2"/>
                            <line x1="550" y1="185" x2="580" y2="220" stroke="#ccc" stroke-width="2"/>
                            
                            <!-- Level 2: Nested components -->
                            <g id="flow-header">
                                <rect x="40" y="220" width="140" height="40" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                                <text x="110" y="245" text-anchor="middle" font-size="10" fill="#888">Header</text>
                            </g>
                            
                            <g id="flow-content">
                                <rect x="200" y="220" width="140" height="40" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                                <text x="270" y="245" text-anchor="middle" font-size="10" fill="#888">Content</text>
                            </g>
                            
                            <g id="flow-menu">
                                <rect x="360" y="220" width="140" height="40" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                                <text x="430" y="245" text-anchor="middle" font-size="10" fill="#888">Menu</text>
                            </g>
                            
                            <g id="flow-profile">
                                <rect x="520" y="220" width="140" height="40" rx="6" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                                <text x="590" y="245" text-anchor="middle" font-size="10" fill="#888">UserProfile</text>
                            </g>
                            
                            <!-- Connection to ThemeToggle -->
                            <line x1="430" y1="260" x2="430" y2="290" stroke="#ccc" stroke-width="2"/>
                            
                            <!-- Level 3: ThemeToggle (where useContext is called) -->
                            <g id="flow-toggle">
                                <rect id="toggle-box" x="330" y="290" width="200" height="60" rx="8" fill="#e3f2fd" stroke="#2196f3" stroke-width="2"/>
                                <text x="430" y="315" text-anchor="middle" font-size="11" fill="#1976d2" font-weight="600">ThemeToggle</text>
                                <text x="430" y="335" text-anchor="middle" font-size="10" fill="#1976d2">useContext(ThemeContext)</text>
                            </g>
                            
                            <!-- Search path visualization -->
                            <path id="search-path" d="M 430 290 L 430 260 L 430 220 L 430 185 L 510 185 L 510 140 L 500 105 L 400 105 L 350 77" fill="none" stroke="#4facfe" stroke-width="3" stroke-dasharray="8,4" opacity="0"/>
                            
                            <!-- Animated search dot -->
                            <circle id="search-dot" r="8" fill="#4facfe" filter="url(#searchGlow)" opacity="0"/>
                            
                            <!-- Explanation panel -->
                            <rect x="50" y="365" width="600" height="70" rx="10" fill="#f8f9fa" stroke="#e0e0e0" stroke-width="1"/>
                            <text id="flow-step-title" x="350" y="390" text-anchor="middle" font-size="12" font-weight="600" fill="#333">How useContext Works</text>
                            <text id="flow-step-desc" x="350" y="415" text-anchor="middle" font-size="11" fill="#666">Click "Trace Lookup" to see how React finds the Provider</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="traceContextLookup()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Trace Lookup</button>
                            <button onclick="resetContextFlow()" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset</button>
                        </div>
                    </div>
                </div>
                
                <script>
                let flowAnimating = false;
                
                function traceContextLookup() {
                    if (flowAnimating) return;
                    flowAnimating = true;
                    resetContextFlow();
                    
                    const dot = document.getElementById('search-dot');
                    const path = document.getElementById('search-path');
                    const title = document.getElementById('flow-step-title');
                    const desc = document.getElementById('flow-step-desc');
                    const toggleBox = document.getElementById('toggle-box');
                    const foundIndicator = document.getElementById('found-indicator');
                    const foundText = document.getElementById('found-text');
                    
                    const steps = [
                        { x: 430, y: 320, title: 'Step 1: Call useContext', desc: 'ThemeToggle calls useContext(ThemeContext)', highlight: 'flow-toggle' },
                        { x: 430, y: 245, title: 'Step 2: Look at Parent', desc: 'React checks Menu component - no Provider here', highlight: 'flow-menu' },
                        { x: 510, y: 162, title: 'Step 3: Keep Looking Up', desc: 'React checks Sidebar component - no Provider here', highlight: 'flow-sidebar' },
                        { x: 350, y: 77, title: 'Step 4: Found Provider! üéâ', desc: 'App has ThemeContext.Provider - returns the value!', highlight: 'flow-app', found: true }
                    ];
                    
                    dot.setAttribute('opacity', '1');
                    path.setAttribute('opacity', '0.5');
                    
                    let stepIndex = 0;
                    
                    function nextStep() {
                        if (stepIndex < steps.length) {
                            const step = steps[stepIndex];
                            
                            // Move dot
                            dot.setAttribute('cx', step.x);
                            dot.setAttribute('cy', step.y);
                            
                            // Update explanation
                            title.textContent = step.title;
                            desc.textContent = step.desc;
                            
                            // Highlight current component
                            document.querySelectorAll('[id^="flow-"]').forEach(el => {
                                if (el.tagName === 'g') {
                                    const rect = el.querySelector('rect');
                                    if (rect && !rect.id) {
                                        rect.style.stroke = el.id === step.highlight ? '#4facfe' : '';
                                        rect.style.strokeWidth = el.id === step.highlight ? '3' : '';
                                    }
                                }
                            });
                            
                            if (step.found) {
                                foundIndicator.setAttribute('opacity', '1');
                                foundText.setAttribute('opacity', '1');
                                toggleBox.style.fill = '#e8f5e9';
                                toggleBox.style.stroke = '#4caf50';
                            }
                            
                            stepIndex++;
                            setTimeout(nextStep, 1200);
                        } else {
                            flowAnimating = false;
                        }
                    }
                    
                    nextStep();
                }
                
                function resetContextFlow() {
                    document.getElementById('search-dot').setAttribute('opacity', '0');
                    document.getElementById('search-path').setAttribute('opacity', '0');
                    document.getElementById('found-indicator').setAttribute('opacity', '0');
                    document.getElementById('found-text').setAttribute('opacity', '0');
                    document.getElementById('flow-step-title').textContent = 'How useContext Works';
                    document.getElementById('flow-step-desc').textContent = 'Click "Trace Lookup" to see how React finds the Provider';
                    
                    const toggleBox = document.getElementById('toggle-box');
                    toggleBox.style.fill = '#e3f2fd';
                    toggleBox.style.stroke = '#2196f3';
                    
                    document.querySelectorAll('[id^="flow-"]').forEach(el => {
                        if (el.tagName === 'g') {
                            const rect = el.querySelector('rect');
                            if (rect && !rect.id) {
                                rect.style.stroke = '';
                                rect.style.strokeWidth = '';
                            }
                        }
                    });
                }
                </script>
            </section>

            <!-- Section 6: Typing Context with TypeScript -->
            <section id="section6" class="lesson-section">
                <h2>üî∑ Typing Context with TypeScript</h2>
                <p>TypeScript makes Context even more powerful by ensuring type safety. Let's explore the best patterns for typing contexts.</p>

                <h3>Basic Context Typing</h3>
                <p>The simplest approach - define an interface and use it:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext } from 'react';

// Define the shape of your context
interface ThemeContextType {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

// Create context with type
const ThemeContext = createContext&lt;ThemeContextType&gt;({
    theme: 'light',
    toggleTheme: () => {}
});</code></pre>
                </div>

                <h3>Context with Undefined (Recommended)</h3>
                <p>The safest pattern - force Provider usage with undefined default:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
}

interface UserContextType {
    user: User | null;
    setUser: (user: User | null) => void;
}

// Create context that allows undefined
const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// Custom hook with type guard
export function useUser(): UserContextType {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    // Now TypeScript knows context is UserContextType, not undefined!
    return context;
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why This Pattern is Best</h4>
                    <ul>
                        <li><strong>Runtime Safety</strong> - Catches missing Provider immediately</li>
                        <li><strong>No Fake Defaults</strong> - Don't need meaningless default values</li>
                        <li><strong>Type Safety</strong> - Custom hook returns non-undefined type</li>
                        <li><strong>Clear Errors</strong> - Helpful error message for developers</li>
                    </ul>
                </div>

                <h3>Complete Typed Context Example</h3>
                <p>Here's a full example with all TypeScript best practices:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// UserContext.tsx
import { 
    createContext, 
    useContext, 
    useState, 
    ReactNode,
    useCallback 
} from 'react';

// 1. Define data types
export interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

// 2. Define context type
interface UserContextType {
    user: User | null;
    isLoggedIn: boolean;
    login: (user: User) => void;
    logout: () => void;
    updateUser: (updates: Partial&lt;User&gt;) => void;
}

// 3. Create context with undefined default
const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);

// 4. Provider props type
interface UserProviderProps {
    children: ReactNode;
}

// 5. Custom Provider component
export function UserProvider({ children }: UserProviderProps) {
    const [user, setUser] = useState&lt;User | null&gt;(null);

    const login = useCallback((newUser: User) => {
        setUser(newUser);
        localStorage.setItem('user', JSON.stringify(newUser));
    }, []);

    const logout = useCallback(() => {
        setUser(null);
        localStorage.removeItem('user');
    }, []);

    const updateUser = useCallback((updates: Partial&lt;User&gt;) => {
        setUser(current => {
            if (!current) return null;
            return { ...current, ...updates };
        });
    }, []);

    const value: UserContextType = {
        user,
        isLoggedIn: user !== null,
        login,
        logout,
        updateUser
    };

    return (
        &lt;UserContext.Provider value={value}&gt;
            {children}
        &lt;/UserContext.Provider&gt;
    );
}

// 6. Custom hook with type guard
export function useUser(): UserContextType {
    const context = useContext(UserContext);
    
    if (context === undefined) {
        throw new Error('useUser must be used within UserProvider');
    }
    
    return context;
}

// 7. Optional: Additional utility hooks
export function useIsAdmin(): boolean {
    const { user } = useUser();
    return user?.role === 'admin';
}

export function useCurrentUserId(): number | null {
    const { user } = useUser();
    return user?.id ?? null;
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Features Used</h4>
                    <ul>
                        <li><strong>Interface</strong> - Define shape of User and context</li>
                        <li><strong>Union Types</strong> - <code>User | null</code> for optional user</li>
                        <li><strong>Literal Types</strong> - <code>'admin' | 'user'</code> for role</li>
                        <li><strong>Partial Type</strong> - <code>Partial&lt;User&gt;</code> for updates</li>
                        <li><strong>ReactNode</strong> - Type for children prop</li>
                        <li><strong>Type Guard</strong> - Error throwing removes undefined</li>
                    </ul>
                </div>

                <h3>Generic Context Pattern</h3>
                <p>For reusable contexts, use generics:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, useState, ReactNode } from 'react';

// Generic state context creator
function createStateContext&lt;T&gt;(defaultValue: T) {
    const Context = createContext&lt;{
        value: T;
        setValue: (value: T) => void;
    } | undefined&gt;(undefined);

    function Provider({ children }: { children: ReactNode }) {
        const [value, setValue] = useState&lt;T&gt;(defaultValue);

        return (
            &lt;Context.Provider value={{ value, setValue }}&gt;
                {children}
            &lt;/Context.Provider&gt;
        );
    }

    function useValue() {
        const context = useContext(Context);
        if (!context) {
            throw new Error('useValue must be used within Provider');
        }
        return context;
    }

    return [Provider, useValue] as const;
}

// Usage - create typed contexts easily!
const [CountProvider, useCount] = createStateContext(0);
const [NameProvider, useName] = createStateContext('');
const [UserProvider, useUser] = createStateContext&lt;User | null&gt;(null);</code></pre>
                </div>

                <h3>Typing Context Actions</h3>
                <p>When combining with useReducer, type your actions carefully:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, useReducer, ReactNode } from 'react';

// State type
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

interface TodoState {
    todos: Todo[];
}

// Action types
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } };

// Context type
interface TodoContextType {
    state: TodoState;
    dispatch: React.Dispatch&lt;TodoAction&gt;;
}

const TodoContext = createContext&lt;TodoContextType | undefined&gt;(undefined);

// Reducer
function todoReducer(state: TodoState, action: TodoAction): TodoState {
    // Reducer implementation
    return state;
}

// Provider
export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, { todos: [] });

    return (
        &lt;TodoContext.Provider value={{ state, dispatch }}&gt;
            {children}
        &lt;/TodoContext.Provider&gt;
    );
}

// Custom hook
export function useTodos(): TodoContextType {
    const context = useContext(TodoContext);
    if (!context) {
        throw new Error('useTodos must be used within TodoProvider');
    }
    return context;
}</code></pre>
                </div>

            <!-- Section 7: Theme Context Example -->
            <section id="section7" class="lesson-section">
                <h2>üé® Theme Context Example</h2>
                <p>Let's build a complete, real-world example: a theme switcher that allows users to toggle between light and dark modes. This will demonstrate all the concepts we've learned so far.</p>

                <h3>Project Structure</h3>
                <p>We'll create a theme context with the following features:</p>

                <div class="card">
                    <h4>Features We'll Build</h4>
                    <ul>
                        <li>üåì Light and dark theme modes</li>
                        <li>üîÑ Toggle between themes</li>
                        <li>üíæ Persist preference to localStorage</li>
                        <li>üé® Apply theme styles to entire app</li>
                        <li>üî∑ Full TypeScript typing</li>
                    </ul>
                </div>

                <h3>Step 1: Define Types and Create Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/ThemeContext.tsx
import { createContext, useContext } from 'react';

// Define theme type
export type Theme = 'light' | 'dark';

// Define context type
interface ThemeContextType {
    theme: Theme;
    toggleTheme: () => void;
    setTheme: (theme: Theme) => void;
}

// Create context
const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);</code></pre>
                </div>

                <h3>Step 2: Create the Provider</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in ThemeContext.tsx
import { useState, useEffect, ReactNode } from 'react';

interface ThemeProviderProps {
    children: ReactNode;
}

export function ThemeProvider({ children }: ThemeProviderProps) {
    // Initialize theme from localStorage or default to 'light'
    const [theme, setTheme] = useState&lt;Theme&gt;(() => {
        const savedTheme = localStorage.getItem('theme');
        return (savedTheme as Theme) || 'light';
    });

    // Save theme to localStorage when it changes
    useEffect(() => {
        localStorage.setItem('theme', theme);
        // Apply theme to document for CSS
        document.documentElement.setAttribute('data-theme', theme);
    }, [theme]);

    // Toggle between light and dark
    const toggleTheme = () => {
        setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
    };

    const value: ThemeContextType = {
        theme,
        toggleTheme,
        setTheme
    };

    return (
        &lt;ThemeContext.Provider value={value}&gt;
            {children}
        &lt;/ThemeContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Step 3: Create Custom Hook</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in ThemeContext.tsx

// Custom hook with error checking
export function useTheme(): ThemeContextType {
    const context = useContext(ThemeContext);
    
    if (context === undefined) {
        throw new Error('useTheme must be used within ThemeProvider');
    }
    
    return context;
}

// Complete ThemeContext.tsx file is now ready!</code></pre>
                </div>

                <h3>Step 4: Add CSS Styles</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-css">/* src/styles/theme.css */

/* Light theme (default) */
:root,
[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f5f5f5;
    --text-primary: #333333;
    --text-secondary: #666666;
    --border-color: #dddddd;
    --accent-color: #667eea;
    --card-bg: #ffffff;
    --shadow: rgba(0, 0, 0, 0.1);
}

/* Dark theme */
[data-theme="dark"] {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --text-primary: #e0e0e0;
    --text-secondary: #a0a0a0;
    --border-color: #404040;
    --accent-color: #8b9bff;
    --card-bg: #252525;
    --shadow: rgba(0, 0, 0, 0.5);
}

/* Apply theme variables */
body {
    background-color: var(--bg-primary);
    color: var(--text-primary);
    transition: background-color 0.3s ease, color 0.3s ease;
}

.card {
    background-color: var(--card-bg);
    border: 1px solid var(--border-color);
    box-shadow: 0 2px 8px var(--shadow);
}

.button {
    background-color: var(--accent-color);
    color: white;
}</code></pre>
                </div>

                <h3>Step 5: Wrap App with Provider</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/main.tsx or App.tsx
import { ThemeProvider } from './contexts/ThemeContext';
import './styles/theme.css';

function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;Header /&gt;
            &lt;MainContent /&gt;
            &lt;Footer /&gt;
        &lt;/ThemeProvider&gt;
    );
}

export default App;</code></pre>
                </div>

                <h3>Step 6: Use Theme in Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/Header.tsx
import { useTheme } from '../contexts/ThemeContext';

function Header() {
    const { theme, toggleTheme } = useTheme();

    return (
        &lt;header&gt;
            &lt;h1&gt;My App&lt;/h1&gt;
            &lt;button onClick={toggleTheme}&gt;
                {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
                {theme === 'light' ? ' Dark Mode' : ' Light Mode'}
            &lt;/button&gt;
        &lt;/header&gt;
    );
}

export default Header;</code></pre>
                </div>

                <h3>Step 7: Create Theme Toggle Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/ThemeToggle.tsx
import { useTheme } from '../contexts/ThemeContext';
import './ThemeToggle.css';

function ThemeToggle() {
    const { theme, toggleTheme } = useTheme();

    return (
        &lt;button 
            className="theme-toggle"
            onClick={toggleTheme}
            aria-label="Toggle theme"
        &gt;
            &lt;span className="theme-toggle-icon"&gt;
                {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
            &lt;/span&gt;
            &lt;span className="theme-toggle-text"&gt;
                {theme === 'light' ? 'Dark' : 'Light'}
            &lt;/span&gt;
        &lt;/button&gt;
    );
}

export default ThemeToggle;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-css">/* ThemeToggle.css */
.theme-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background-color: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.theme-toggle:hover {
    background-color: var(--accent-color);
    color: white;
    transform: translateY(-2px);
}

.theme-toggle-icon {
    font-size: 1.2rem;
}

.theme-toggle-text {
    font-weight: 500;
}</code></pre>
                </div>

                <h3>Complete Example with Multiple Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/Dashboard.tsx
import { useTheme } from '../contexts/ThemeContext';

function Dashboard() {
    const { theme } = useTheme();

    return (
        &lt;div className="dashboard"&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            &lt;p&gt;Current theme: {theme}&lt;/p&gt;
            
            &lt;div className="card"&gt;
                &lt;h2&gt;Stats&lt;/h2&gt;
                &lt;p&gt;This card uses theme variables for styling!&lt;/p&gt;
            &lt;/div&gt;

            &lt;div className="card"&gt;
                &lt;h2&gt;Activity&lt;/h2&gt;
                &lt;p&gt;The theme changes apply to all components automatically.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// src/components/Settings.tsx
function Settings() {
    const { theme, setTheme } = useTheme();

    return (
        &lt;div className="settings"&gt;
            &lt;h2&gt;Settings&lt;/h2&gt;
            
            &lt;div className="setting-group"&gt;
                &lt;label&gt;Theme Preference:&lt;/label&gt;
                &lt;select 
                    value={theme} 
                    onChange={(e) =&gt; setTheme(e.target.value as 'light' | 'dark')}
                &gt;
                    &lt;option value="light"&gt;Light&lt;/option&gt;
                    &lt;option value="dark"&gt;Dark&lt;/option&gt;
                &lt;/select&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Accomplished</h4>
                    <ul>
                        <li><strong>Context Creation</strong> - Defined theme context with TypeScript</li>
                        <li><strong>Provider Setup</strong> - Created provider with localStorage persistence</li>
                        <li><strong>Custom Hook</strong> - Made useTheme hook with error checking</li>
                        <li><strong>CSS Variables</strong> - Used data attributes for theme styling</li>
                        <li><strong>Multiple Components</strong> - Any component can access theme</li>
                        <li><strong>Persistence</strong> - Theme survives page refresh</li>
                        <li><strong>Smooth Transitions</strong> - CSS transitions for theme changes</li>
                    </ul>
                </div>

                <h3>Enhanced Theme with System Preference</h3>
                <p>Let's add detection of the user's system theme preference:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Enhanced ThemeProvider
export function ThemeProvider({ children }: ThemeProviderProps) {
    // Get system preference
    const getSystemTheme = (): Theme => {
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            return 'dark';
        }
        return 'light';
    };

    // Initialize with saved theme, or system preference, or default
    const [theme, setTheme] = useState&lt;Theme&gt;(() => {
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme) {
            return savedTheme as Theme;
        }
        return getSystemTheme();
    });

    // Listen for system theme changes
    useEffect(() => {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        
        const handleChange = (e: MediaQueryListEvent) => {
            if (!localStorage.getItem('theme')) {
                // Only update if user hasn't set a preference
                setTheme(e.matches ? 'dark' : 'light');
            }
        };

        mediaQuery.addEventListener('change', handleChange);
        return () => mediaQuery.removeEventListener('change', handleChange);
    }, []);

    // Rest of the provider code...
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Advanced Features Added</h4>
                    <ul>
                        <li><strong>System Preference Detection</strong> - Uses prefers-color-scheme</li>
                        <li><strong>Automatic Updates</strong> - Responds to system theme changes</li>
                        <li><strong>User Preference Priority</strong> - Manual choice overrides system</li>
                        <li><strong>Smart Defaults</strong> - Falls back gracefully</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Context with useReducer -->
            <section id="section8" class="lesson-section">
                <h2>‚öôÔ∏è Context with useReducer</h2>
                <p>Combining Context with useReducer creates a powerful state management solution. This pattern is perfect for complex state that needs to be accessed by many components. Let's build a todo application to see this in action!</p>

                <h3>Why Combine Context + useReducer?</h3>
                <div class="card">
                    <h4>The Power Combination</h4>
                    <ul>
                        <li><strong>useReducer</strong> - Manages complex state logic in one place</li>
                        <li><strong>Context</strong> - Makes state and dispatch available everywhere</li>
                        <li><strong>Together</strong> - Global state management without Redux!</li>
                    </ul>
                </div>

                <div class="mermaid">
                graph TD
                    A[Context + useReducer] --> B[Complex State Logic]
                    A --> C[Global Accessibility]
                    B --> D[Predictable Updates]
                    C --> D
                    D --> E[Scalable State Management]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>Complete Todo Context Example</h3>

                <h4>Step 1: Define Types</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/TodoContext.tsx
import { createContext, useContext, useReducer, ReactNode } from 'react';

// Todo type
export interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

// State type
interface TodoState {
    todos: Todo[];
    filter: 'all' | 'active' | 'completed';
}

// Action types
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } }
    | { type: 'EDIT_TODO'; payload: { id: number; text: string } }
    | { type: 'SET_FILTER'; payload: { filter: 'all' | 'active' | 'completed' } }
    | { type: 'CLEAR_COMPLETED' };</code></pre>
                </div>

                <h4>Step 2: Create Reducer</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

function todoReducer(state: TodoState, action: TodoAction): TodoState {
    switch (action.type) {
        case 'ADD_TODO':
            return {
                ...state,
                todos: [
                    ...state.todos,
                    {
                        id: Date.now(),
                        text: action.payload.text,
                        completed: false
                    }
                ]
            };

        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };

        case 'DELETE_TODO':
            return {
                ...state,
                todos: state.todos.filter(todo => todo.id !== action.payload.id)
            };

        case 'EDIT_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, text: action.payload.text }
                        : todo
                )
            };

        case 'SET_FILTER':
            return {
                ...state,
                filter: action.payload.filter
            };

        case 'CLEAR_COMPLETED':
            return {
                ...state,
                todos: state.todos.filter(todo => !todo.completed)
            };

        default:
            return state;
    }
}</code></pre>
                </div>

                <h4>Step 3: Create Context and Provider</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

// Context type
interface TodoContextType {
    state: TodoState;
    dispatch: React.Dispatch&lt;TodoAction&gt;;
}

// Create context
const TodoContext = createContext&lt;TodoContextType | undefined&gt;(undefined);

// Provider component
export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, {
        todos: [],
        filter: 'all'
    });

    return (
        &lt;TodoContext.Provider value={{ state, dispatch }}&gt;
            {children}
        &lt;/TodoContext.Provider&gt;
    );
}

// Custom hook
export function useTodos() {
    const context = useContext(TodoContext);
    
    if (context === undefined) {
        throw new Error('useTodos must be used within TodoProvider');
    }
    
    return context;
}</code></pre>
                </div>

                <h4>Step 4: Create Action Creators</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Continue in TodoContext.tsx

// Action creators for cleaner usage
export const todoActions = {
    addTodo: (text: string): TodoAction => ({
        type: 'ADD_TODO',
        payload: { text }
    }),

    toggleTodo: (id: number): TodoAction => ({
        type: 'TOGGLE_TODO',
        payload: { id }
    }),

    deleteTodo: (id: number): TodoAction => ({
        type: 'DELETE_TODO',
        payload: { id }
    }),

    editTodo: (id: number, text: string): TodoAction => ({
        type: 'EDIT_TODO',
        payload: { id, text }
    }),

    setFilter: (filter: 'all' | 'active' | 'completed'): TodoAction => ({
        type: 'SET_FILTER',
        payload: { filter }
    }),

    clearCompleted: (): TodoAction => ({
        type: 'CLEAR_COMPLETED'
    })
};</code></pre>
                </div>

                <h4>Step 5: Use in Components</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/AddTodo.tsx
import { useState } from 'react';
import { useTodos, todoActions } from '../contexts/TodoContext';

function AddTodo() {
    const { dispatch } = useTodos();
    const [text, setText] = useState('');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (text.trim()) {
            dispatch(todoActions.addTodo(text));
            setText('');
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input
                type="text"
                value={text}
                onChange={(e) =&gt; setText(e.target.value)}
                placeholder="What needs to be done?"
            /&gt;
            &lt;button type="submit"&gt;Add&lt;/button&gt;
        &lt;/form&gt;
    );
}

export default AddTodo;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoList.tsx
import { useTodos, todoActions } from '../contexts/TodoContext';
import TodoItem from './TodoItem';

function TodoList() {
    const { state, dispatch } = useTodos();

    // Filter todos based on current filter
    const filteredTodos = state.todos.filter(todo => {
        if (state.filter === 'active') return !todo.completed;
        if (state.filter === 'completed') return todo.completed;
        return true; // 'all'
    });

    return (
        &lt;div&gt;
            &lt;ul className="todo-list"&gt;
                {filteredTodos.map(todo =&gt; (
                    &lt;TodoItem key={todo.id} todo={todo} /&gt;
                ))}
            &lt;/ul&gt;

            {filteredTodos.length === 0 && (
                &lt;p className="empty-state"&gt;No todos to show&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

export default TodoList;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoItem.tsx
import { useTodos, todoActions, Todo } from '../contexts/TodoContext';

interface TodoItemProps {
    todo: Todo;
}

function TodoItem({ todo }: TodoItemProps) {
    const { dispatch } = useTodos();

    return (
        &lt;li className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() =&gt; dispatch(todoActions.toggleTodo(todo.id))}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() =&gt; dispatch(todoActions.deleteTodo(todo.id))}&gt;
                Delete
            &lt;/button&gt;
        &lt;/li&gt;
    );
}

export default TodoItem;</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/components/TodoFilters.tsx
import { useTodos, todoActions } from '../contexts/TodoContext';

function TodoFilters() {
    const { state, dispatch } = useTodos();

    const filters: Array&lt;'all' | 'active' | 'completed'&gt; = [
        'all',
        'active', 
        'completed'
    ];

    return (
        &lt;div className="filters"&gt;
            {filters.map(filter =&gt; (
                &lt;button
                    key={filter}
                    className={state.filter === filter ? 'active' : ''}
                    onClick={() =&gt; dispatch(todoActions.setFilter(filter))}
                &gt;
                    {filter.charAt(0).toUpperCase() + filter.slice(1)}
                &lt;/button&gt;
            ))}
        &lt;/div&gt;
    );
}

export default TodoFilters;</code></pre>
                </div>

                <h4>Step 6: Put It All Together</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/App.tsx
import { TodoProvider } from './contexts/TodoContext';
import AddTodo from './components/AddTodo';
import TodoList from './components/TodoList';
import TodoFilters from './components/TodoFilters';

function App() {
    return (
        &lt;TodoProvider&gt;
            &lt;div className="app"&gt;
                &lt;h1&gt;üìù Todo App&lt;/h1&gt;
                &lt;AddTodo /&gt;
                &lt;TodoFilters /&gt;
                &lt;TodoList /&gt;
            &lt;/div&gt;
        &lt;/TodoProvider&gt;
    );
}

export default App;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Achieved</h4>
                    <ul>
                        <li><strong>Global State</strong> - All components access the same todo state</li>
                        <li><strong>Predictable Updates</strong> - Reducer ensures consistent state changes</li>
                        <li><strong>Type Safety</strong> - TypeScript prevents action type errors</li>
                        <li><strong>Clean Components</strong> - Components focus on UI, not logic</li>
                        <li><strong>No Prop Drilling</strong> - Deep components access state directly</li>
                        <li><strong>Testability</strong> - Reducer can be tested independently</li>
                        <li><strong>Scalability</strong> - Easy to add new actions and features</li>
                    </ul>
                </div>

                <h3>Optimized Context Pattern</h3>
                <p>For better performance, split state and dispatch into separate contexts:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Advanced pattern - separate contexts for state and dispatch
const TodoStateContext = createContext&lt;TodoState | undefined&gt;(undefined);
const TodoDispatchContext = createContext&lt;React.Dispatch&lt;TodoAction&gt; | undefined&gt;(undefined);

export function TodoProvider({ children }: { children: ReactNode }) {
    const [state, dispatch] = useReducer(todoReducer, initialState);

    return (
        &lt;TodoStateContext.Provider value={state}&gt;
            &lt;TodoDispatchContext.Provider value={dispatch}&gt;
                {children}
            &lt;/TodoDispatchContext.Provider&gt;
        &lt;/TodoStateContext.Provider&gt;
    );
}

// Separate hooks
export function useTodoState() {
    const context = useContext(TodoStateContext);
    if (!context) throw new Error('useTodoState must be used within TodoProvider');
    return context;
}

export function useTodoDispatch() {
    const context = useContext(TodoDispatchContext);
    if (!context) throw new Error('useTodoDispatch must be used within TodoProvider');
    return context;
}

// Now components only re-render when the value they use changes!
// Component that only dispatches doesn't re-render when state changes
function AddTodo() {
    const dispatch = useTodoDispatch(); // Won't re-render on state change
    // ...
}

// Component that only reads state doesn't need dispatch
function TodoStats() {
    const state = useTodoState(); // Clean and efficient
    // ...
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Performance Benefit</h4>
                    <p>Splitting contexts means components only re-render when the specific value they use changes. A component that only dispatches actions won't re-render when state changes, and vice versa. This is especially important for large applications!</p>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Now it's your turn! These exercises will help you master Context and useContext. Start with the easier ones and work your way up.</p>

                <h3>Exercise 1: Language Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Create a language/internationalization (i18n) context that allows users to switch between languages.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Support at least 2 languages (e.g., English and Spanish)</li>
                        <li>Provide a way to switch languages</li>
                        <li>Store translations in objects</li>
                        <li>Create a custom hook to access translations</li>
                        <li>Persist language preference to localStorage</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Your context might look like:</p>
                        <pre><code>interface LanguageContextType {
    language: 'en' | 'es';
    setLanguage: (lang: 'en' | 'es') => void;
    t: (key: string) => string; // translation function
}</code></pre>
                        <p>Translation object example:</p>
                        <pre><code>const translations = {
    en: {
        welcome: 'Welcome',
        greeting: 'Hello, {name}!'
    },
    es: {
        welcome: 'Bienvenido',
        greeting: '¬°Hola, {name}!'
    }
};</code></pre>
                    </div>
                </details>

                <details>
                    <summary><strong>‚úÖ Solution</strong></summary>
                    <div style="margin-top: 1rem;">
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">// LanguageContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';

type Language = 'en' | 'es';

const translations = {
    en: {
        welcome: 'Welcome',
        login: 'Login',
        logout: 'Logout',
        settings: 'Settings'
    },
    es: {
        welcome: 'Bienvenido',
        login: 'Iniciar sesi√≥n',
        logout: 'Cerrar sesi√≥n',
        settings: 'Configuraci√≥n'
    }
};

interface LanguageContextType {
    language: Language;
    setLanguage: (lang: Language) => void;
    t: (key: string) => string;
}

const LanguageContext = createContext&lt;LanguageContextType | undefined&gt;(undefined);

export function LanguageProvider({ children }: { children: ReactNode }) {
    const [language, setLanguage] = useState&lt;Language&gt;(() => {
        const saved = localStorage.getItem('language');
        return (saved as Language) || 'en';
    });

    const handleSetLanguage = (lang: Language) => {
        setLanguage(lang);
        localStorage.setItem('language', lang);
    };

    const t = (key: string): string => {
        return translations[language][key as keyof typeof translations.en] || key;
    };

    return (
        &lt;LanguageContext.Provider value={{ language, setLanguage: handleSetLanguage, t }}&gt;
            {children}
        &lt;/LanguageContext.Provider&gt;
    );
}

export function useLanguage() {
    const context = useContext(LanguageContext);
    if (!context) throw new Error('useLanguage must be used within LanguageProvider');
    return context;
}</code></pre>
                        </div>
                    </div>
                </details>

                <h3>Exercise 2: Shopping Cart Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Build a shopping cart context using Context + useReducer.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Add items to cart (with quantity)</li>
                        <li>Remove items from cart</li>
                        <li>Update item quantities</li>
                        <li>Calculate total price</li>
                        <li>Clear entire cart</li>
                        <li>Use TypeScript for type safety</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Types you'll need:</p>
                        <pre><code>interface CartItem {
    id: string;
    name: string;
    price: number;
    quantity: number;
}

type CartAction =
    | { type: 'ADD_ITEM'; payload: CartItem }
    | { type: 'REMOVE_ITEM'; payload: { id: string } }
    | { type: 'UPDATE_QUANTITY'; payload: { id: string; quantity: number } }
    | { type: 'CLEAR_CART' };</code></pre>
                    </div>
                </details>

                <h3>Exercise 3: Authentication Context</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Create an authentication context with login, logout, and protected route logic.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Login/logout functionality</li>
                        <li>Store user information</li>
                        <li>Check authentication status</li>
                        <li>Persist auth state (localStorage or sessionStorage)</li>
                        <li>Provide loading state during authentication</li>
                        <li>Include user roles/permissions</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Context structure:</p>
                        <pre><code>interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (email: string, password: string) => Promise&lt;void&gt;;
    logout: () => void;
    checkAuth: () => Promise&lt;void&gt;;
}</code></pre>
                    </div>
                </details>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Practice Tips</h4>
                    <ul>
                        <li>Start with type definitions first</li>
                        <li>Build the context and provider before the hook</li>
                        <li>Test with console.log before building UI</li>
                        <li>Add one feature at a time</li>
                        <li>Use TypeScript errors as guides</li>
                        <li>Don't forget error boundaries!</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Performance Considerations -->
            <section id="section10" class="lesson-section">
                <h2>‚ö° Performance Considerations</h2>
                <p>Context is powerful, but it can cause performance issues if not used carefully. Let's learn how to optimize Context usage.</p>

                <h3>The Re-render Problem</h3>
                <p>When Context value changes, ALL components that consume it will re-render:</p>
                
                <!-- Interactive Context Re-render Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üîÑ Interactive: Context Re-render Visualizer</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">See which components re-render when context values change</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="rerenderViz" viewBox="0 0 750 380" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="rerenderGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#f093fb"/>
                                    <stop offset="100%" style="stop-color:#f5576c"/>
                                </linearGradient>
                                <filter id="rerenderGlow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="375" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">Context Change ‚Üí Consumer Re-renders</text>
                            
                            <!-- Provider Box -->
                            <rect x="30" y="45" width="690" height="300" rx="12" fill="none" stroke="#f093fb" stroke-width="2" stroke-dasharray="8,4"/>
                            <text x="50" y="68" font-size="12" fill="#f093fb" font-weight="600">UserContext.Provider</text>
                            
                            <!-- Context State Display -->
                            <rect id="ctx-state-box" x="50" y="80" width="200" height="70" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="150" y="100" text-anchor="middle" font-size="11" font-weight="600" fill="#555">Context State:</text>
                            <text id="ctx-user-display" x="150" y="120" text-anchor="middle" font-size="10" fill="#666">user: { name: "Alice" }</text>
                            <text id="ctx-theme-display" x="150" y="138" text-anchor="middle" font-size="10" fill="#666">theme: "light"</text>
                            
                            <!-- Components that consume context -->
                            <g id="rerender-header">
                                <rect x="300" y="80" width="180" height="50" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="390" y="100" text-anchor="middle" font-size="11" font-weight="500" fill="#333">Header</text>
                                <text x="390" y="118" text-anchor="middle" font-size="9" fill="#4caf50">useContext(User) ‚úî</text>
                                <rect id="flash-header" x="300" y="80" width="180" height="50" rx="8" fill="#f093fb" opacity="0"/>
                            </g>
                            
                            <g id="rerender-sidebar">
                                <rect x="520" y="80" width="180" height="50" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="610" y="100" text-anchor="middle" font-size="11" font-weight="500" fill="#333">Sidebar</text>
                                <text x="610" y="118" text-anchor="middle" font-size="9" fill="#4caf50">useContext(User) ‚úî</text>
                                <rect id="flash-sidebar" x="520" y="80" width="180" height="50" rx="8" fill="#f093fb" opacity="0"/>
                            </g>
                            
                            <!-- Components that DON'T consume context -->
                            <g id="rerender-content">
                                <rect x="300" y="150" width="180" height="50" rx="8" fill="#f5f5f5" stroke="#ccc" stroke-width="1"/>
                                <text x="390" y="170" text-anchor="middle" font-size="11" font-weight="500" fill="#666">ArticleContent</text>
                                <text x="390" y="188" text-anchor="middle" font-size="9" fill="#999">No context used</text>
                            </g>
                            
                            <g id="rerender-footer">
                                <rect x="520" y="150" width="180" height="50" rx="8" fill="#f5f5f5" stroke="#ccc" stroke-width="1"/>
                                <text x="610" y="170" text-anchor="middle" font-size="11" font-weight="500" fill="#666">Footer</text>
                                <text x="610" y="188" text-anchor="middle" font-size="9" fill="#999">No context used</text>
                            </g>
                            
                            <!-- More consuming components -->
                            <g id="rerender-profile">
                                <rect x="300" y="220" width="180" height="50" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="390" y="240" text-anchor="middle" font-size="11" font-weight="500" fill="#333">UserProfile</text>
                                <text x="390" y="258" text-anchor="middle" font-size="9" fill="#4caf50">useContext(User) ‚úî</text>
                                <rect id="flash-profile" x="300" y="220" width="180" height="50" rx="8" fill="#f093fb" opacity="0"/>
                            </g>
                            
                            <g id="rerender-settings">
                                <rect x="520" y="220" width="180" height="50" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="610" y="240" text-anchor="middle" font-size="11" font-weight="500" fill="#333">Settings</text>
                                <text x="610" y="258" text-anchor="middle" font-size="9" fill="#4caf50">useContext(User) ‚úî</text>
                                <rect id="flash-settings" x="520" y="220" width="180" height="50" rx="8" fill="#f093fb" opacity="0"/>
                            </g>
                            
                            <g id="rerender-nav">
                                <rect x="50" y="170" width="200" height="50" rx="8" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="150" y="190" text-anchor="middle" font-size="11" font-weight="500" fill="#333">Navigation</text>
                                <text x="150" y="208" text-anchor="middle" font-size="9" fill="#4caf50">useContext(User) ‚úî</text>
                                <rect id="flash-nav" x="50" y="170" width="200" height="50" rx="8" fill="#f093fb" opacity="0"/>
                            </g>
                            
                            <!-- Re-render counter -->
                            <rect x="50" y="240" width="200" height="90" rx="8" fill="#fff3e0" stroke="#ff9800" stroke-width="2"/>
                            <text x="150" y="265" text-anchor="middle" font-size="12" font-weight="600" fill="#e65100">Re-render Count</text>
                            <text id="rerender-count" x="150" y="295" text-anchor="middle" font-size="28" font-weight="bold" fill="#f57c00">0</text>
                            <text x="150" y="320" text-anchor="middle" font-size="9" fill="#ff9800">components re-rendered</text>
                            
                            <!-- Legend -->
                            <g transform="translate(300, 290)">
                                <rect x="0" y="0" width="14" height="14" rx="3" fill="#e8f5e9" stroke="#4caf50" stroke-width="2"/>
                                <text x="20" y="11" font-size="10" fill="#666">Context Consumer</text>
                                <rect x="150" y="0" width="14" height="14" rx="3" fill="#f5f5f5" stroke="#ccc" stroke-width="1"/>
                                <text x="170" y="11" font-size="10" fill="#666">Non-Consumer</text>
                                <rect x="300" y="0" width="14" height="14" rx="3" fill="#f093fb"/>
                                <text x="320" y="11" font-size="10" fill="#666">Re-rendering!</text>
                            </g>
                            
                            <!-- Status -->
                            <text id="rerender-status" x="375" y="365" text-anchor="middle" font-size="11" fill="#666">Click a button to change context and watch re-renders</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="changeUserName()" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Change User Name</button>
                            <button onclick="changeTheme()" style="padding: 0.6rem 1rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Toggle Theme</button>
                            <button onclick="resetRerenders()" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset Counter</button>
                        </div>
                        
                        <div class="card" style="background: #fff3e0; border-left: 4px solid #ff9800; margin-top: 1rem; padding: 1rem;">
                            <p style="margin: 0; font-size: 0.9rem;"><strong>‚ö†Ô∏è Notice:</strong> ALL 5 consumers re-render when context changes, even if they only use part of the data! This is why splitting contexts or using selectors can improve performance.</p>
                        </div>
                    </div>
                </div>
                
                <script>
                let rerenderTotal = 0;
                let currentUser = 'Alice';
                let currentTheme = 'light';
                const users = ['Alice', 'Bob', 'Carol', 'Dave'];
                
                function flashComponents() {
                    const consumers = ['flash-header', 'flash-sidebar', 'flash-profile', 'flash-settings', 'flash-nav'];
                    consumers.forEach((id, index) => {
                        setTimeout(() => {
                            const el = document.getElementById(id);
                            el.setAttribute('opacity', '0.8');
                            setTimeout(() => {
                                el.setAttribute('opacity', '0');
                            }, 300);
                        }, index * 80);
                    });
                    
                    rerenderTotal += 5;
                    document.getElementById('rerender-count').textContent = rerenderTotal;
                }
                
                function changeUserName() {
                    const currentIndex = users.indexOf(currentUser);
                    currentUser = users[(currentIndex + 1) % users.length];
                    document.getElementById('ctx-user-display').textContent = `user: { name: "${currentUser}" }`;
                    document.getElementById('rerender-status').textContent = `üë§ User changed to "${currentUser}" - 5 components re-rendered!`;
                    flashComponents();
                }
                
                function changeTheme() {
                    currentTheme = currentTheme === 'light' ? 'dark' : 'light';
                    document.getElementById('ctx-theme-display').textContent = `theme: "${currentTheme}"`;
                    document.getElementById('rerender-status').textContent = `üé® Theme changed to "${currentTheme}" - 5 components re-rendered!`;
                    flashComponents();
                }
                
                function resetRerenders() {
                    rerenderTotal = 0;
                    document.getElementById('rerender-count').textContent = '0';
                    document.getElementById('rerender-status').textContent = 'Counter reset. Click a button to change context and watch re-renders';
                }
                </script>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Problem: Creates new object every render
function App() {
    const [user, setUser] = useState(null);
    
    return (
        &lt;UserContext.Provider value={{ user, setUser }}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}

// Every render of App creates a new object
// Even if user hasn't changed, ALL consumers re-render!</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Why This Happens</h4>
                    <p>JavaScript creates a new object on each render:</p>
                    <pre><code>{ user, setUser } !== { user, setUser } // Always true!
// React sees a different object, assumes value changed</code></pre>
                </div>

                <h3>Solution 1: Memoize the Value</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useMemo } from 'react';

function App() {
    const [user, setUser] = useState(null);
    
    // ‚úÖ Value only changes when user changes
    const value = useMemo(
        () => ({ user, setUser }),
        [user] // Only recreate if user changes
    );
    
    return (
        &lt;UserContext.Provider value={value}&gt;
            &lt;Dashboard /&gt;
        &lt;/UserContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Solution 2: Split Contexts</h3>
                <p>Separate state and dispatch to minimize re-renders:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Two separate contexts
const UserStateContext = createContext(null);
const UserDispatchContext = createContext(null);

function UserProvider({ children }) {
    const [user, setUser] = useState(null);
    
    // dispatch is stable, never changes
    return (
        &lt;UserStateContext.Provider value={user}&gt;
            &lt;UserDispatchContext.Provider value={setUser}&gt;
                {children}
            &lt;/UserDispatchContext.Provider&gt;
        &lt;/UserStateContext.Provider&gt;
    );
}

// Components that only dispatch don't re-render on state changes!
function UpdateButton() {
    const setUser = useContext(UserDispatchContext);
    // Won't re-render when user state changes
    return &lt;button onClick={() => setUser(...)}&gt;Update&lt;/button&gt;;
}</code></pre>
                </div>

                <h3>Solution 3: Optimize with React.memo</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { memo } from 'react';

// Expensive component that uses context
const ExpensiveComponent = memo(function ExpensiveComponent() {
    const { someValue } = useMyContext();
    
    // Complex rendering logic
    return &lt;div&gt;{someValue}&lt;/div&gt;;
});

// Now it only re-renders when props or context actually change</code></pre>
                </div>

                <h3>Solution 4: Limit Provider Scope</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Too broad - entire app re-renders
function App() {
    return (
        &lt;ThemeProvider&gt;
            &lt;Dashboard /&gt;
            &lt;Settings /&gt;
            &lt;Profile /&gt;
        &lt;/ThemeProvider&gt;
    );
}

// ‚úÖ Scoped - only affected components
function App() {
    return (
        &lt;div&gt;
            &lt;Dashboard /&gt; {/* Doesn't use theme */}
            &lt;ThemeProvider&gt;
                &lt;Settings /&gt; {/* Uses theme */}
                &lt;Profile /&gt; {/* Uses theme */}
            &lt;/ThemeProvider&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Performance Best Practices</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do's</h4>
                    <ul>
                        <li>Use useMemo to stabilize context values</li>
                        <li>Split contexts when state and actions are independent</li>
                        <li>Wrap expensive components in React.memo</li>
                        <li>Keep Provider scope as narrow as possible</li>
                        <li>Use multiple small contexts instead of one large one</li>
                        <li>Derive computed values in components, not context</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Don'ts</h4>
                    <ul>
                        <li>Don't create new objects/arrays in Provider value</li>
                        <li>Don't put everything in one giant context</li>
                        <li>Don't wrap entire app if only few components need it</li>
                        <li>Don't use Context for frequently changing values</li>
                        <li>Don't optimize prematurely - measure first!</li>
                    </ul>
                </div>

                <h3>When to Optimize</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Small app (&lt;50 components)</td>
                            <td>Don't worry about it</td>
                        </tr>
                        <tr>
                            <td>Context changes rarely</td>
                            <td>No optimization needed</td>
                        </tr>
                        <tr>
                            <td>Few consumers</td>
                            <td>Basic setup is fine</td>
                        </tr>
                        <tr>
                            <td>Large app (100+ components)</td>
                            <td>Consider splitting contexts</td>
                        </tr>
                        <tr>
                            <td>Frequent context updates</td>
                            <td>Use useMemo, split contexts</td>
                        </tr>
                        <tr>
                            <td>Performance issues detected</td>
                            <td>Profile and optimize</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 11: Best Practices -->
            <section id="section11" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                <p>Follow these best practices to write maintainable, scalable Context code.</p>

                <h3>‚úÖ Do: Create Custom Hooks</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Always provide a custom hook
export function useUser() {
    const context = useContext(UserContext);
    if (!context) {
        throw new Error('useUser must be used within UserProvider');
    }
    return context;
}

// Usage is clean and safe
function MyComponent() {
    const { user } = useUser(); // Clean!
}</code></pre>
                </div>

                <h3>‚úÖ Do: Organize Context Files</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// src/contexts/UserContext.tsx
// Everything in one file:
// - Types
// - Context creation
// - Provider component
// - Custom hook
// - Export only what's needed

export { UserProvider, useUser };
// Don't export the context itself</code></pre>
                </div>

                <h3>‚úÖ Do: Use TypeScript</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Fully typed context
interface UserContextType {
    user: User | null;
    login: (credentials: LoginCredentials) => Promise&lt;void&gt;;
    logout: () => void;
}

const UserContext = createContext&lt;UserContextType | undefined&gt;(undefined);</code></pre>
                </div>

                <h3>‚úÖ Do: Split Large Contexts</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå One massive context
interface AppContextType {
    user: User;
    theme: Theme;
    language: Language;
    cart: Cart;
    notifications: Notification[];
    // ... too much!
}

// ‚úÖ Multiple focused contexts
// UserContext, ThemeContext, LanguageContext, CartContext, etc.
// Each handles one concern</code></pre>
                </div>

                <h3>‚úÖ Do: Provide Meaningful Errors</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">export function useUser() {
    const context = useContext(UserContext);
    if (!context) {
        throw new Error(
            'useUser must be used within UserProvider. ' +
            'Make sure your component is wrapped with &lt;UserProvider&gt;.'
        );
    }
    return context;
}</code></pre>
                </div>

                <h3>‚ùå Don't: Use Context for Everything</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Overkill for parent-child communication
function Parent() {
    return (
        &lt;ValueContext.Provider value="hello"&gt;
            &lt;Child /&gt;
        &lt;/ValueContext.Provider&gt;
    );
}

// ‚úÖ Just use props!
function Parent() {
    return &lt;Child value="hello" /&gt;;
}</code></pre>
                </div>

                <h3>‚ùå Don't: Mutate Context Values</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Never mutate context values
const { user } = useUser();
user.name = 'New Name'; // NO!

// ‚úÖ Use provided functions
const { user, updateUser } = useUser();
updateUser({ name: 'New Name' }); // YES!</code></pre>
                </div>

                <h3>Context Naming Conventions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Item</th>
                            <th>Convention</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Context</td>
                            <td>PascalCase + Context</td>
                            <td><code>UserContext</code></td>
                        </tr>
                        <tr>
                            <td>Provider</td>
                            <td>PascalCase + Provider</td>
                            <td><code>UserProvider</code></td>
                        </tr>
                        <tr>
                            <td>Custom Hook</td>
                            <td>use + PascalCase</td>
                            <td><code>useUser</code></td>
                        </tr>
                        <tr>
                            <td>Type Interface</td>
                            <td>PascalCase + ContextType</td>
                            <td><code>UserContextType</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Testing Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Testing components that use context
import { render, screen } from '@testing-library/react';
import { UserProvider } from './UserContext';
import MyComponent from './MyComponent';

test('renders with user context', () => {
    render(
        &lt;UserProvider&gt;
            &lt;MyComponent /&gt;
        &lt;/UserProvider&gt;
    );
    
    expect(screen.getByText(/welcome/i)).toBeInTheDocument();
});

// Test with custom context value
test('renders with specific user', () => {
    const mockUser = { id: 1, name: 'Test User' };
    
    render(
        &lt;UserContext.Provider value={{ user: mockUser, login: jest.fn(), logout: jest.fn() }}&gt;
            &lt;MyComponent /&gt;
        &lt;/UserContext.Provider&gt;
    );
    
    expect(screen.getByText('Test User')).toBeInTheDocument();
});</code></pre>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                <p>Congratulations! You've mastered the useContext Hook and the Context API. Let's recap what you've learned.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Context solves prop drilling</strong> - Share data without passing props through every level</li>
                        <li><strong>Three-part system</strong> - Create Context, Provide values, Consume with useContext</li>
                        <li><strong>Custom hooks are essential</strong> - Always create custom hooks for type safety and error checking</li>
                        <li><strong>TypeScript makes it better</strong> - Type safety prevents bugs and improves DX</li>
                        <li><strong>Context + useReducer</strong> - Powerful pattern for complex global state</li>
                        <li><strong>Performance matters</strong> - Use useMemo, split contexts, optimize strategically</li>
                        <li><strong>Don't overuse</strong> - Props are fine for parent-child communication</li>
                    </ul>
                </div>

                <h3>What You Learned</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>What You Can Do</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Context Creation</strong></td>
                            <td>Create typed contexts with TypeScript</td>
                        </tr>
                        <tr>
                            <td><strong>Providers</strong></td>
                            <td>Build custom Provider components with state</td>
                        </tr>
                        <tr>
                            <td><strong>useContext</strong></td>
                            <td>Consume context values with the hook</td>
                        </tr>
                        <tr>
                            <td><strong>Custom Hooks</strong></td>
                            <td>Create safe, reusable context hooks</td>
                        </tr>
                        <tr>
                            <td><strong>Real-World Patterns</strong></td>
                            <td>Build theme switchers, auth, todos</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Optimize context for large applications</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Use Cases for Context</h3>
                <div class="card">
                    <ul>
                        <li>üé® <strong>Theme</strong> - Dark/light mode, color schemes</li>
                        <li>üîê <strong>Authentication</strong> - Current user, login status</li>
                        <li>üåê <strong>Language</strong> - Internationalization (i18n)</li>
                        <li>üõí <strong>Shopping Cart</strong> - Cart items, totals</li>
                        <li>‚öôÔ∏è <strong>Settings</strong> - User preferences</li>
                        <li>üîî <strong>Notifications</strong> - Toast messages, alerts</li>
                        <li>üì± <strong>Responsive</strong> - Screen size, device type</li>
                        <li>üéØ <strong>Feature Flags</strong> - Enable/disable features</li>
                    </ul>
                </div>

                <h3>Context vs Other Solutions</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>When to Use</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Props</strong></td>
                            <td>Parent ‚Üí immediate child communication</td>
                        </tr>
                        <tr>
                            <td><strong>Context</strong></td>
                            <td>Share data across many components at different nesting levels</td>
                        </tr>
                        <tr>
                            <td><strong>Redux/Zustand</strong></td>
                            <td>Very large apps, time-travel debugging, complex middleware needs</td>
                        </tr>
                        <tr>
                            <td><strong>React Query</strong></td>
                            <td>Server state management, caching, synchronization</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Next Steps</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üöÄ Continue Learning</h4>
                    <p>Now that you know useContext, you're ready for:</p>
                    <ul>
                        <li><strong>Lesson 5.3: useRef</strong> - Access DOM elements and store mutable values</li>
                        <li><strong>Lesson 5.4: useMemo & useCallback</strong> - Performance optimization</li>
                        <li><strong>Lesson 5.5: Compound Components</strong> - Advanced patterns</li>
                        <li><strong>Module Project</strong> - Build a complete app with Context</li>
                    </ul>
                </div>

                <h3>Practice Projects</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Build These to Master Context</h4>
                    <ol>
                        <li><strong>Multi-theme App</strong> - 3+ themes with custom colors</li>
                        <li><strong>E-commerce with Cart</strong> - Products, cart, checkout</li>
                        <li><strong>Dashboard with Auth</strong> - Login, protected routes, user management</li>
                        <li><strong>Kanban Board</strong> - Drag and drop with global state</li>
                        <li><strong>Multi-language Blog</strong> - i18n with language switching</li>
                    </ol>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h2 style="color: white; margin-bottom: 1rem;">üéâ Congratulations! üéâ</h2>
                    <p style="color: white; font-size: 1.2rem;">
                        You've completed the useContext lesson and gained a powerful tool for managing shared state. You can now build scalable React applications with clean, maintainable code!
                    </p>
                    <p style="color: white; margin-top: 1.5rem;">
                        <strong>Keep practicing, keep building, and keep learning!</strong> üöÄ
                    </p>
                </div>
            </section>

        </main>
    </div>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson Navigation">
        <a href="lesson_5_1_usereducer_hook.html" class="nav-button prev-lesson">
            <span class="nav-arrow">‚Üê</span>
            <span class="nav-label">
                <small>Previous</small>
                <strong>useReducer Hook</strong>
            </span>
        </a>
        <a href="index.html" class="nav-button home-lesson">
            <span class="nav-icon">üè†</span>
            <span class="nav-label">
                <small>Back to</small>
                <strong>Home</strong>
            </span>
        </a>
        <a href="lesson_5_3_useref_hook.html" class="nav-button next-lesson">
            <span class="nav-label">
                <small>Next Lesson</small>
                <strong>useRef Hook</strong>
            </span>
            <span class="nav-arrow">‚Üí</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org" target="_blank">TypeScript Docs</a> |
                <a href="https://react.dev/reference/react/useContext" target="_blank">useContext Reference</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
