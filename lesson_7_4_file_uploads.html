<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master file uploads in React with TypeScript. Learn file input handling, image previews, drag-and-drop, multiple file uploads, and validation.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 7.4: File Uploads - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module7">Module 7: Forms and Validation</a></li>
            <li aria-current="page">Lesson 7.4: File Uploads</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üì§ Lesson 7.4: File Uploads in React</h1>
                <p class="lead">You've mastered text inputs, dropdowns, checkboxes, and even complex validation with Zod. But there's one crucial type of user input we haven't covered yet: files. Whether it's a profile picture, a resume, product images, or documents, modern web applications frequently need users to upload files. In this lesson, you'll learn everything about handling file uploads in React with TypeScript‚Äîfrom basic file inputs to drag-and-drop interfaces, image previews, progress tracking, and robust validation. By the end, you'll be able to build professional file upload experiences that rival the best applications on the web.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand how file inputs work in HTML and React</li>
                        <li>Handle file selection events with proper TypeScript types</li>
                        <li>Preview images before upload using FileReader and Object URLs</li>
                        <li>Validate file types, sizes, and dimensions</li>
                        <li>Build drag-and-drop file upload interfaces</li>
                        <li>Handle multiple file uploads</li>
                        <li>Display upload progress with proper UI feedback</li>
                        <li>Integrate file uploads with React Hook Form</li>
                        <li>Implement file upload best practices for security and UX</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a complete image upload component with preview and validation</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Introduction to File Uploads</a></li>
                        <li><a href="#section2" class="toc-link">The HTML File Input</a></li>
                        <li><a href="#section3" class="toc-link">Basic File Upload Component</a></li>
                        <li><a href="#section4" class="toc-link">Understanding File Objects</a></li>
                        <li><a href="#section5" class="toc-link">Image Previews with FileReader</a></li>
                        <li><a href="#section6" class="toc-link">Image Previews with Object URLs</a></li>
                        <li><a href="#section7" class="toc-link">File Validation</a></li>
                        <li><a href="#section8" class="toc-link">Multiple File Uploads</a></li>
                        <li><a href="#section9" class="toc-link">Drag and Drop Basics</a></li>
                        <li><a href="#section10" class="toc-link">Complete Drag and Drop Component</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="section1" class="lesson-section">
                <h2>üìã Introduction to File Uploads</h2>
                
                <p>File uploads are everywhere in modern web applications. Think about all the times you've uploaded files online:</p>

                <ul>
                    <li><strong>Social Media:</strong> Posting photos to Instagram, Facebook, or Twitter</li>
                    <li><strong>Professional Profiles:</strong> Adding your profile picture to LinkedIn, uploading your resume to job applications</li>
                    <li><strong>E-commerce:</strong> Sellers uploading product images to marketplaces like Etsy or eBay</li>
                    <li><strong>Cloud Storage:</strong> Uploading documents to Google Drive, Dropbox, or OneDrive</li>
                    <li><strong>Communication:</strong> Attaching files to emails or sharing images in messaging apps</li>
                    <li><strong>Content Creation:</strong> Uploading videos to YouTube, podcast episodes to Spotify</li>
                </ul>

                <p>Behind each of these experiences is sophisticated file handling code that makes uploading feel seamless and intuitive. In this lesson, you'll learn to build these experiences yourself.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What is a File Upload?</h4>
                    <p style="color: white;"><strong>File Upload:</strong> The process of selecting one or more files from a user's device and sending them to a server or processing them in the browser. In React, this involves handling file input events, reading file data, validating files, and often displaying previews before the actual upload occurs.</p>
                </div>

                <h3>üéØ What You'll Build</h3>
                
                <p>Throughout this lesson, you'll progressively build a comprehensive file upload system:</p>

                <ol>
                    <li><strong>Basic File Input:</strong> Start with a simple file picker that handles selection</li>
                    <li><strong>Image Preview:</strong> Display selected images before upload</li>
                    <li><strong>File Validation:</strong> Check file types, sizes, and dimensions</li>
                    <li><strong>Multiple Uploads:</strong> Handle multiple files at once with individual previews</li>
                    <li><strong>Drag and Drop:</strong> Create an intuitive drag-and-drop interface</li>
                    <li><strong>Upload Progress:</strong> Show progress bars during upload</li>
                    <li><strong>Integration:</strong> Connect everything with React Hook Form</li>
                </ol>

                <div class="mermaid">
                    graph LR
                    A[User Selects File] --> B{File Valid?}
                    B -->|Yes| C[Show Preview]
                    B -->|No| D[Show Error]
                    C --> E[User Confirms]
                    E --> F[Upload to Server]
                    F --> G[Show Progress]
                    G --> H[Complete!]
                    D --> A
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style H fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#f44336,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why This Matters</h4>
                    <p>File uploads are a critical feature in most real-world applications. Understanding how to handle them properly‚Äîwith validation, previews, and good UX‚Äîwill make you a more capable React developer. Plus, the patterns you learn here (like drag-and-drop events and FileReader API) apply to many other browser APIs you'll use throughout your career.</p>
                </div>
            </section>

            <!-- Section 2: The HTML File Input -->
            <section id="section2" class="lesson-section">
                <h2>üî§ The HTML File Input</h2>
                
                <p>Before we dive into React, let's understand the foundation: the HTML <code>&lt;input type="file"&gt;</code> element. This special input type creates a button that opens your operating system's file picker dialog.</p>

                <h3>Basic HTML File Input</h3>

                <pre><code class="language-html">&lt;!-- Most basic file input --&gt;
&lt;input type="file" /&gt;

&lt;!-- Accept only images --&gt;
&lt;input type="file" accept="image/*" /&gt;

&lt;!-- Accept specific image types --&gt;
&lt;input type="file" accept="image/png, image/jpeg, image/gif" /&gt;

&lt;!-- Allow multiple files --&gt;
&lt;input type="file" multiple /&gt;

&lt;!-- Capture from camera on mobile --&gt;
&lt;input type="file" accept="image/*" capture="user" /&gt;</code></pre>

                <h3>Key Attributes</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Attribute</th>
                            <th>Purpose</th>
                            <th>Example Value</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>accept</code></td>
                            <td>Limits file types in picker dialog</td>
                            <td><code>"image/*"</code>, <code>".pdf"</code>, <code>"video/*"</code></td>
                        </tr>
                        <tr>
                            <td><code>multiple</code></td>
                            <td>Allows selecting multiple files</td>
                            <td>Boolean attribute (present or not)</td>
                        </tr>
                        <tr>
                            <td><code>capture</code></td>
                            <td>Specifies capture source on mobile</td>
                            <td><code>"user"</code> (front camera), <code>"environment"</code> (back camera)</td>
                        </tr>
                        <tr>
                            <td><code>disabled</code></td>
                            <td>Disables the input</td>
                            <td>Boolean attribute</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important: Accept is Not Validation</h4>
                    <p>The <code>accept</code> attribute is just a hint to the file picker‚Äîit filters what files are shown in the dialog. However, users can still work around it (by selecting "All Files" in the picker, for example). <strong>Always validate file types on both the client and server side!</strong> Never trust the file extension or MIME type alone.</p>
                </div>

                <h3>Common MIME Types and Extensions</h3>

                <table>
                    <thead>
                        <tr>
                            <th>File Category</th>
                            <th>Accept Value</th>
                            <th>What It Allows</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>All Images</td>
                            <td><code>image/*</code></td>
                            <td>JPG, PNG, GIF, WebP, SVG, etc.</td>
                        </tr>
                        <tr>
                            <td>Specific Images</td>
                            <td><code>image/png, image/jpeg</code></td>
                            <td>Only PNG and JPEG</td>
                        </tr>
                        <tr>
                            <td>All Videos</td>
                            <td><code>video/*</code></td>
                            <td>MP4, WebM, MOV, etc.</td>
                        </tr>
                        <tr>
                            <td>All Audio</td>
                            <td><code>audio/*</code></td>
                            <td>MP3, WAV, OGG, etc.</td>
                        </tr>
                        <tr>
                            <td>PDFs</td>
                            <td><code>application/pdf</code> or <code>.pdf</code></td>
                            <td>PDF documents only</td>
                        </tr>
                        <tr>
                            <td>Word Docs</td>
                            <td><code>.doc, .docx</code></td>
                            <td>Microsoft Word files</td>
                        </tr>
                        <tr>
                            <td>Excel</td>
                            <td><code>.xls, .xlsx</code></td>
                            <td>Microsoft Excel files</td>
                        </tr>
                        <tr>
                            <td>Text Files</td>
                            <td><code>text/plain</code> or <code>.txt</code></td>
                            <td>Plain text files</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip: Combining Accept Values</h4>
                    <p>You can combine multiple accept values with commas:</p>
                    <pre><code class="language-html">&lt;input 
  type="file" 
  accept="image/png, image/jpeg, image/gif, image/webp"
/&gt;</code></pre>
                    <p>Or use wildcards for broader categories:</p>
                    <pre><code class="language-html">&lt;input 
  type="file" 
  accept="image/*, .pdf"
/&gt;</code></pre>
                </div>

                <h3>The File Selection Event</h3>

                <p>When a user selects files, the input fires a <code>change</code> event. The selected files are available in the <code>event.target.files</code> property, which is a <code>FileList</code> object‚Äîsimilar to an array but not quite.</p>

                <pre><code class="language-javascript">// Plain JavaScript example
const input = document.querySelector('input[type="file"]');

input.addEventListener('change', (event) => {
  const files = event.target.files;
  console.log('Number of files:', files.length);
  
  // FileList is array-like but not an array
  // You can access by index
  if (files.length > 0) {
    const firstFile = files[0];
    console.log('File name:', firstFile.name);
    console.log('File size:', firstFile.size, 'bytes');
    console.log('File type:', firstFile.type);
  }
});</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ FileList Object</h4>
                    <p style="color: white;"><strong>FileList:</strong> An array-like object (not a true array) that contains <code>File</code> objects. It has a <code>length</code> property and can be accessed by index (like <code>files[0]</code>), but it doesn't have array methods like <code>map</code> or <code>filter</code>. You'll often convert it to a real array using <code>Array.from(files)</code> or the spread operator <code>[...files]</code>.</p>
                </div>
            </section>

            <!-- Section 3: Basic File Upload Component -->
            <section id="section3" class="lesson-section">
                <h2>‚öõÔ∏è Basic File Upload Component</h2>
                
                <p>Let's create our first React file upload component with proper TypeScript types. We'll start simple and build up from here.</p>

                <h3>Simple File Input Component</h3>

                <pre><code class="language-typescript">import React, { useState } from 'react';

interface FileUploadProps {
  onFileSelect?: (file: File | null) => void;
}

const FileUpload: React.FC&lt;FileUploadProps&gt; = ({ onFileSelect }) => {
  const [selectedFile, setSelectedFile] = useState&lt;File | null&gt;(null);

  // Handle file selection
  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const files = event.target.files;
    
    // Check if files exist and grab the first one
    if (files && files.length > 0) {
      const file = files[0];
      setSelectedFile(file);
      
      // Call callback if provided
      if (onFileSelect) {
        onFileSelect(file);
      }
    } else {
      // User cancelled the file picker
      setSelectedFile(null);
      if (onFileSelect) {
        onFileSelect(null);
      }
    }
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Upload a File&lt;/h3&gt;
      
      &lt;input
        type="file"
        onChange={handleFileChange}
        accept="image/*"
      /&gt;
      
      {selectedFile && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;h4&gt;Selected File:&lt;/h4&gt;
          &lt;ul&gt;
            &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt; {selectedFile.name}&lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;Size:&lt;/strong&gt; {(selectedFile.size / 1024).toFixed(2)} KB&lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;Type:&lt;/strong&gt; {selectedFile.type}&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default FileUpload;</code></pre>

                <h3>Breaking Down the TypeScript Types</h3>

                <pre><code class="language-typescript">// The change event for file inputs
React.ChangeEvent&lt;HTMLInputElement&gt;

// This event object has a target property
event.target // HTMLInputElement

// The files property is a FileList or null
event.target.files // FileList | null

// Individual files are File objects
files[0] // File</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Type Safety Benefits</h4>
                    <p>By properly typing our event handler as <code>React.ChangeEvent&lt;HTMLInputElement&gt;</code>, TypeScript knows exactly what properties are available on <code>event.target</code>. If you try to access <code>event.target.value</code> (which doesn't contain file data), TypeScript guides you to use <code>event.target.files</code> instead!</p>
                </div>

                <h3>Using the Component</h3>

                <pre><code class="language-typescript">import FileUpload from './FileUpload';

function App() {
  const handleFileSelect = (file: File | null) => {
    if (file) {
      console.log('User selected:', file.name);
      // Here you might send the file to a server
    } else {
      console.log('User cancelled selection');
    }
  };

  return (
    &lt;div&gt;
      &lt;h1&gt;File Upload Demo&lt;/h1&gt;
      &lt;FileUpload onFileSelect={handleFileSelect} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake: Accessing value Instead of files</h4>
                    <p>Unlike text inputs where you access <code>event.target.value</code>, file inputs use <code>event.target.files</code>. The <code>value</code> property on file inputs contains a fake path (for security reasons) and isn't useful. Always use the <code>files</code> property!</p>
                    <pre><code class="language-typescript">// ‚ùå WRONG
const fileName = event.target.value; // Returns "C:\fakepath\image.jpg"

// ‚úÖ CORRECT
const file = event.target.files[0];
const fileName = file.name; // Returns "image.jpg"</code></pre>
                </div>
            </section>

            <!-- Section 4: Understanding File Objects -->
            <section id="section4" class="lesson-section">
                <h2>üìÑ Understanding File Objects</h2>
                
                <p>The <code>File</code> object represents a single file selected by the user. It's part of the web platform's File API and contains useful properties and methods. Let's explore what information is available and how to use it.</p>

                <h3>File Object Properties</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>name</code></td>
                            <td><code>string</code></td>
                            <td>The file name with extension (e.g., "photo.jpg")</td>
                        </tr>
                        <tr>
                            <td><code>size</code></td>
                            <td><code>number</code></td>
                            <td>File size in bytes</td>
                        </tr>
                        <tr>
                            <td><code>type</code></td>
                            <td><code>string</code></td>
                            <td>MIME type (e.g., "image/jpeg", "application/pdf")</td>
                        </tr>
                        <tr>
                            <td><code>lastModified</code></td>
                            <td><code>number</code></td>
                            <td>Unix timestamp of last modification</td>
                        </tr>
                        <tr>
                            <td><code>lastModifiedDate</code></td>
                            <td><code>Date</code></td>
                            <td>Date object of last modification (deprecated but still works)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Practical Example: File Information Display</h3>

                <pre><code class="language-typescript">interface FileInfoProps {
  file: File;
}

const FileInfo: React.FC&lt;FileInfoProps&gt; = ({ file }) => {
  // Helper function to format file size
  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
  };

  // Helper function to format date
  const formatDate = (timestamp: number): string => {
    return new Date(timestamp).toLocaleString();
  };

  return (
    &lt;div className="file-info"&gt;
      &lt;h4&gt;üìÑ File Information&lt;/h4&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Name:&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;{file.name}&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Size:&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;{formatFileSize(file.size)}&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Type:&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;{file.type || 'Unknown'}&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
            &lt;td&gt;&lt;strong&gt;Last Modified:&lt;/strong&gt;&lt;/td&gt;
            &lt;td&gt;{formatDate(file.lastModified)}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/div&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Helpful Utility Functions</h4>
                    <p>You'll often want to format file sizes and extract file extensions. Here are some utility functions you can reuse:</p>
                    <pre><code class="language-typescript">// Format bytes to human-readable string
export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
};

// Get file extension
export const getFileExtension = (filename: string): string => {
  return filename.slice((filename.lastIndexOf('.') - 1 >>> 0) + 2);
};

// Get file name without extension
export const getFileNameWithoutExtension = (filename: string): string => {
  return filename.substring(0, filename.lastIndexOf('.')) || filename;
};</code></pre>
                </div>

                <h3>File Extends Blob</h3>

                <p>The <code>File</code> object extends the <code>Blob</code> (Binary Large Object) interface, which means files have additional methods for reading their content:</p>

                <pre><code class="language-typescript">// File extends Blob, so you can use Blob methods

// Create a slice of the file (useful for chunked uploads)
const firstKB = file.slice(0, 1024); // First 1KB

// Read as text (we'll cover FileReader in detail soon)
const text = await file.text();

// Read as ArrayBuffer
const buffer = await file.arrayBuffer();

// Get a readable stream
const stream = file.stream();</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Blob vs File</h4>
                    <p style="color: white;"><strong>Blob:</strong> Represents raw binary data. It's the base interface for File.</p>
                    <p style="color: white;"><strong>File:</strong> A specific type of Blob that includes additional metadata like filename, size, type, and last modified date. When a user selects a file, you get a File object. When you create binary data programmatically, you often work with Blobs.</p>
                </div>
            </section>

            <!-- Section 5: Image Previews with FileReader -->
            <section id="section5" class="lesson-section">
                <h2>üñºÔ∏è Image Previews with FileReader</h2>
                
                <p>One of the most common requirements when handling file uploads is showing a preview‚Äîespecially for images. Users want to see what they've selected before uploading. There are two main approaches to creating previews: using the <code>FileReader</code> API or creating <code>Object URLs</code>. Let's start with FileReader.</p>

                <h3>What is FileReader?</h3>

                <p>The <code>FileReader</code> API allows you to asynchronously read the contents of files stored on the user's computer. It can read files in several formats:</p>

                <ul>
                    <li><strong>readAsDataURL:</strong> Reads the file as a base64-encoded data URL (perfect for image previews)</li>
                    <li><strong>readAsText:</strong> Reads the file as text (useful for .txt, .json, .csv files)</li>
                    <li><strong>readAsArrayBuffer:</strong> Reads the file as a raw binary buffer</li>
                    <li><strong>readAsBinaryString:</strong> Reads the file as a binary string (deprecated, use ArrayBuffer instead)</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Data URL</h4>
                    <p style="color: white;"><strong>Data URL:</strong> A way to embed file content directly in a URL string using base64 encoding. It looks like: <code style="color: #ffe;">data:image/png;base64,iVBORw0KGgo...</code>. You can use data URLs directly in <code>&lt;img&gt;</code> src attributes to display images without uploading them to a server first.</p>
                </div>

                <h3>Basic FileReader Example</h3>

                <pre><code class="language-typescript">// Plain JavaScript FileReader example
const file = event.target.files[0];

if (file && file.type.startsWith('image/')) {
  const reader = new FileReader();
  
  // Set up what happens when reading completes
  reader.onload = (e) => {
    const dataUrl = e.target?.result as string;
    console.log('Data URL:', dataUrl);
    // Now you can use this dataUrl in an img src
  };
  
  // Set up error handling
  reader.onerror = (e) => {
    console.error('Error reading file:', e);
  };
  
  // Start reading the file
  reader.readAsDataURL(file);
}</code></pre>

                <h3>FileReader with React</h3>

                <p>Now let's integrate FileReader into a React component that displays an image preview:</p>

                <pre><code class="language-typescript">import React, { useState } from 'react';

const ImagePreview: React.FC = () => {
  const [selectedFile, setSelectedFile] = useState&lt;File | null&gt;(null);
  const [preview, setPreview] = useState&lt;string&gt;('');
  const [loading, setLoading] = useState(false);

  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const files = event.target.files;
    
    if (!files || files.length === 0) {
      setSelectedFile(null);
      setPreview('');
      return;
    }

    const file = files[0];
    
    // Validate it's an image
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    setSelectedFile(file);
    setLoading(true);

    // Create FileReader instance
    const reader = new FileReader();

    // Handle successful read
    reader.onload = (e) => {
      const result = e.target?.result;
      if (typeof result === 'string') {
        setPreview(result);
      }
      setLoading(false);
    };

    // Handle error
    reader.onerror = () => {
      alert('Error reading file');
      setLoading(false);
    };

    // Start reading as data URL
    reader.readAsDataURL(file);
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Image Upload with Preview&lt;/h3&gt;
      
      &lt;input
        type="file"
        accept="image/*"
        onChange={handleFileChange}
      /&gt;

      {loading && &lt;p&gt;Loading preview...&lt;/p&gt;}

      {preview && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;h4&gt;Preview:&lt;/h4&gt;
          &lt;img 
            src={preview} 
            alt="Preview" 
            style={{ 
              maxWidth: '400px', 
              maxHeight: '400px',
              border: '2px solid #ddd',
              borderRadius: '8px'
            }} 
          /&gt;
          {selectedFile && (
            &lt;p&gt;
              {selectedFile.name} - {(selectedFile.size / 1024).toFixed(2)} KB
            &lt;/p&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default ImagePreview;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ FileReader Benefits</h4>
                    <ul>
                        <li><strong>Works Everywhere:</strong> Excellent browser support, works in all modern browsers</li>
                        <li><strong>Complete Control:</strong> Access to the actual file content as a data URL or text</li>
                        <li><strong>No Cleanup:</strong> Data URLs don't need to be revoked (unlike Object URLs)</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è FileReader Drawbacks</h4>
                    <ul>
                        <li><strong>Memory Intensive:</strong> Base64 encoding increases file size by ~33%, which uses more memory</li>
                        <li><strong>Slower for Large Files:</strong> Reading and encoding large files can take time</li>
                        <li><strong>Event-based API:</strong> Requires callbacks, though you can wrap it in a Promise</li>
                    </ul>
                </div>

                <h3>Promise-based FileReader Wrapper</h3>

                <p>To make FileReader easier to work with, you can wrap it in a Promise. This is especially useful with async/await:</p>

                <pre><code class="language-typescript">// Utility function: Read file as data URL
const readFileAsDataURL = (file: File): Promise&lt;string&gt; => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      const result = e.target?.result;
      if (typeof result === 'string') {
        resolve(result);
      } else {
        reject(new Error('Failed to read file as data URL'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('FileReader error'));
    };
    
    reader.readAsDataURL(file);
  });
};

// Now you can use it with async/await
const handleFileChange = async (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  const file = event.target.files?.[0];
  
  if (!file) return;
  
  try {
    setLoading(true);
    const dataUrl = await readFileAsDataURL(file);
    setPreview(dataUrl);
  } catch (error) {
    console.error('Error reading file:', error);
    alert('Failed to read file');
  } finally {
    setLoading(false);
  }
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Reading Text Files</h4>
                    <p>FileReader is also useful for reading text files like JSON, CSV, or plain text:</p>
                    <pre><code class="language-typescript">const readFileAsText = (file: File): Promise&lt;string&gt; => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (e) => resolve(e.target?.result as string);
    reader.onerror = reject;
    reader.readAsText(file);
  });
};

// Usage
const file = event.target.files[0];
const text = await readFileAsText(file);
const data = JSON.parse(text); // If it's JSON</code></pre>
                </div>
            </section>

            <!-- Section 6: Image Previews with Object URLs -->
            <section id="section6" class="lesson-section">
                <h2>üîó Image Previews with Object URLs</h2>
                
                <p>While FileReader works great, there's an alternative approach that's often more efficient for image previews: <strong>Object URLs</strong> (also called Blob URLs). This method creates a temporary URL that points directly to the file in memory, without reading the entire file content.</p>

                <h3>What is URL.createObjectURL?</h3>

                <p>The <code>URL.createObjectURL()</code> method creates a special URL that represents a File or Blob object. This URL looks like: <code>blob:https://yoursite.com/uuid-here</code> and can be used directly in <code>&lt;img&gt;</code> tags, just like any other URL.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Object URL</h4>
                    <p style="color: white;"><strong>Object URL (Blob URL):</strong> A temporary URL that points to a File or Blob object in the browser's memory. It looks like <code style="color: #ffe;">blob:http://localhost:3000/abc-123-def</code> and remains valid as long as the document exists or until you explicitly revoke it with <code>URL.revokeObjectURL()</code>.</p>
                </div>

                <h3>FileReader vs Object URL Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>FileReader (Data URL)</th>
                            <th>Object URL</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Slower (must read/encode entire file)</td>
                            <td>Instant (creates reference only)</td>
                        </tr>
                        <tr>
                            <td><strong>Memory</strong></td>
                            <td>Higher (base64 ~33% larger)</td>
                            <td>Lower (file stays as-is)</td>
                        </tr>
                        <tr>
                            <td><strong>Cleanup</strong></td>
                            <td>Automatic (no cleanup needed)</td>
                            <td>Manual (must call revokeObjectURL)</td>
                        </tr>
                        <tr>
                            <td><strong>Persistence</strong></td>
                            <td>Data URL persists in string form</td>
                            <td>URL is temporary, file must exist</td>
                        </tr>
                        <tr>
                            <td><strong>Large Files</strong></td>
                            <td>Can be slow and memory-heavy</td>
                            <td>Efficient even for large files</td>
                        </tr>
                        <tr>
                            <td><strong>Best For</strong></td>
                            <td>Small files, need actual content</td>
                            <td>Preview only, especially large images</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Basic Object URL Example</h3>

                <pre><code class="language-typescript">// Plain JavaScript example
const file = event.target.files[0];

if (file && file.type.startsWith('image/')) {
  // Create object URL - instant, no reading required!
  const objectUrl = URL.createObjectURL(file);
  
  console.log('Object URL:', objectUrl);
  // Output: blob:http://localhost:3000/abc-123-def-456
  
  // Use it in an img tag
  imgElement.src = objectUrl;
  
  // IMPORTANT: Clean up when done
  // This releases the memory
  imgElement.onload = () => {
    URL.revokeObjectURL(objectUrl);
  };
}</code></pre>

                <h3>Object URL with React</h3>

                <pre><code class="language-typescript">import React, { useState, useEffect } from 'react';

const ImagePreviewObjectURL: React.FC = () => {
  const [selectedFile, setSelectedFile] = useState&lt;File | null&gt;(null);
  const [preview, setPreview] = useState&lt;string&gt;('');

  // Clean up object URL when component unmounts or file changes
  useEffect(() => {
    // Create object URL when file changes
    if (selectedFile) {
      const objectUrl = URL.createObjectURL(selectedFile);
      setPreview(objectUrl);

      // Cleanup function - revoke the object URL
      return () => {
        URL.revokeObjectURL(objectUrl);
      };
    } else {
      // No file selected
      setPreview('');
    }
  }, [selectedFile]);

  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const files = event.target.files;
    
    if (!files || files.length === 0) {
      setSelectedFile(null);
      return;
    }

    const file = files[0];
    
    // Validate it's an image
    if (!file.type.startsWith('image/')) {
      alert('Please select an image file');
      return;
    }

    setSelectedFile(file);
  };

  const clearSelection = () => {
    setSelectedFile(null);
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Image Upload with Object URL Preview&lt;/h3&gt;
      
      &lt;input
        type="file"
        accept="image/*"
        onChange={handleFileChange}
      /&gt;

      {preview && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;h4&gt;Preview:&lt;/h4&gt;
          &lt;img 
            src={preview} 
            alt="Preview" 
            style={{ 
              maxWidth: '400px', 
              maxHeight: '400px',
              border: '2px solid #ddd',
              borderRadius: '8px',
              display: 'block',
              marginBottom: '0.5rem'
            }} 
          /&gt;
          {selectedFile && (
            &lt;div&gt;
              &lt;p&gt;
                {selectedFile.name} - {(selectedFile.size / 1024).toFixed(2)} KB
              &lt;/p&gt;
              &lt;button onClick={clearSelection}&gt;Clear&lt;/button&gt;
            &lt;/div&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default ImagePreviewObjectURL;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Use useEffect for Cleanup</h4>
                    <p>The cleanup function in <code>useEffect</code> is perfect for revoking object URLs because:</p>
                    <ul>
                        <li>It runs when the component unmounts (preventing memory leaks)</li>
                        <li>It runs when <code>selectedFile</code> changes (cleaning up old URLs)</li>
                        <li>It keeps cleanup logic alongside URL creation</li>
                    </ul>
                    <p>Without cleanup, object URLs stay in memory even after the component is gone!</p>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Critical: Always Revoke Object URLs</h4>
                    <p>Object URLs hold references to file data in memory. If you create many object URLs without revoking them, you'll have a memory leak. Always revoke when:</p>
                    <ul>
                        <li>The component unmounts</li>
                        <li>A new file is selected (revoking the old URL)</li>
                        <li>The preview is closed or cleared</li>
                    </ul>
                    <pre><code class="language-typescript">// ‚ùå BAD: Memory leak
const url = URL.createObjectURL(file);
setPreview(url);
// URL never revoked!

// ‚úÖ GOOD: Cleanup with useEffect
useEffect(() => {
  if (file) {
    const url = URL.createObjectURL(file);
    setPreview(url);
    return () => URL.revokeObjectURL(url); // Cleanup!
  }
}, [file]);</code></pre>
                </div>

                <h3>When to Use Each Method</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Decision Guide</h4>
                    
                    <p><strong>Use Object URLs when:</strong></p>
                    <ul>
                        <li>Creating image/video previews</li>
                        <li>Working with large files</li>
                        <li>Performance is important</li>
                        <li>You only need to display the file, not manipulate its content</li>
                    </ul>

                    <p><strong>Use FileReader when:</strong></p>
                    <ul>
                        <li>You need the actual file content (for manipulation, sending to server as base64)</li>
                        <li>Reading text files (JSON, CSV, TXT)</li>
                        <li>You need the data URL to persist beyond component lifecycle</li>
                        <li>Working with very small files where the overhead doesn't matter</li>
                    </ul>
                </div>

                <!-- Interactive Object URL Memory Visualization -->
                <div class="card" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 0; margin: 2rem 0; overflow: hidden;">
                    <div style="background: rgba(102, 126, 234, 0.1); padding: 1rem 1.5rem; border-bottom: 1px solid rgba(102, 126, 234, 0.3);">
                        <h4 style="color: #667eea; margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                            <span>‚ö°</span> Interactive: Object URL Memory Leak Visualization
                        </h4>
                        <p style="color: #a0a0a0; margin: 0.5rem 0 0 0; font-size: 0.9rem;">See why revoking Object URLs matters ‚Äî watch memory grow without cleanup!</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <div id="object-url-memory-viz" style="font-family: system-ui, -apple-system, sans-serif;">
                            <!-- Memory Bar -->
                            <div style="margin-bottom: 1.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                    <span style="color: #e0e0e0; font-weight: 500;">Browser Memory Usage</span>
                                    <span id="memory-value" style="color: #667eea; font-weight: bold;">0 MB</span>
                                </div>
                                <div style="background: #2a2a4a; border-radius: 8px; height: 24px; overflow: hidden; position: relative;">
                                    <div id="memory-bar" style="background: linear-gradient(90deg, #667eea, #764ba2); height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 8px;"></div>
                                    <div id="memory-warning" style="position: absolute; right: 8px; top: 50%; transform: translateY(-50%); color: #ff6b6b; font-size: 0.8rem; font-weight: bold; display: none;">‚ö†Ô∏è LEAK!</div>
                                </div>
                                <div style="display: flex; justify-content: space-between; color: #666; font-size: 0.75rem; margin-top: 0.25rem;">
                                    <span>0 MB</span>
                                    <span>50 MB (Warning)</span>
                                    <span>100 MB</span>
                                </div>
                            </div>

                            <!-- URL List -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                                <div>
                                    <h5 style="color: #ff6b6b; margin: 0 0 0.5rem 0; font-size: 0.9rem;">‚ùå Without Cleanup</h5>
                                    <div id="url-list-bad" style="background: rgba(255, 107, 107, 0.1); border: 1px solid rgba(255, 107, 107, 0.3); border-radius: 8px; padding: 0.75rem; min-height: 120px; max-height: 150px; overflow-y: auto;">
                                        <p style="color: #666; font-size: 0.8rem; margin: 0; text-align: center;">URLs created here leak memory</p>
                                    </div>
                                </div>
                                <div>
                                    <h5 style="color: #4CAF50; margin: 0 0 0.5rem 0; font-size: 0.9rem;">‚úÖ With revokeObjectURL()</h5>
                                    <div id="url-list-good" style="background: rgba(76, 175, 80, 0.1); border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 8px; padding: 0.75rem; min-height: 120px; max-height: 150px; overflow-y: auto;">
                                        <p style="color: #666; font-size: 0.8rem; margin: 0; text-align: center;">URLs created and revoked ‚Äî no leak!</p>
                                    </div>
                                </div>
                            </div>

                            <!-- Stats -->
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-bottom: 1.5rem;">
                                <div style="background: rgba(255, 107, 107, 0.1); border-radius: 8px; padding: 0.75rem; text-align: center;">
                                    <div id="urls-created" style="color: #ff6b6b; font-size: 1.5rem; font-weight: bold;">0</div>
                                    <div style="color: #999; font-size: 0.7rem;">URLs Created</div>
                                </div>
                                <div style="background: rgba(255, 193, 7, 0.1); border-radius: 8px; padding: 0.75rem; text-align: center;">
                                    <div id="urls-leaked" style="color: #ffc107; font-size: 1.5rem; font-weight: bold;">0</div>
                                    <div style="color: #999; font-size: 0.7rem;">Leaked (Not Revoked)</div>
                                </div>
                                <div style="background: rgba(76, 175, 80, 0.1); border-radius: 8px; padding: 0.75rem; text-align: center;">
                                    <div id="urls-revoked" style="color: #4CAF50; font-size: 1.5rem; font-weight: bold;">0</div>
                                    <div style="color: #999; font-size: 0.7rem;">Properly Revoked</div>
                                </div>
                                <div style="background: rgba(102, 126, 234, 0.1); border-radius: 8px; padding: 0.75rem; text-align: center;">
                                    <div id="memory-saved" style="color: #667eea; font-size: 1.5rem; font-weight: bold;">0 MB</div>
                                    <div style="color: #999; font-size: 0.7rem;">Memory Saved</div>
                                </div>
                            </div>

                            <!-- Controls -->
                            <div style="display: flex; gap: 0.75rem; flex-wrap: wrap; justify-content: center;">
                                <button onclick="simulateFileSelect()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">üìÅ Simulate File Select</button>
                                <button onclick="simulateBulkUpload()" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">üì∏ Bulk Upload (10 files)</button>
                                <button onclick="resetMemoryDemo()" style="background: #333; color: white; border: 1px solid #555; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 0.9rem;">üîÑ Reset</button>
                            </div>

                            <!-- Insight -->
                            <div id="memory-insight" style="margin-top: 1rem; padding: 0.75rem; background: rgba(102, 126, 234, 0.1); border-radius: 8px; text-align: center; display: none;">
                                <p style="color: #667eea; margin: 0; font-size: 0.85rem;"></p>
                            </div>
                        </div>
                    </div>
                </div>

                <script>
                    // Object URL Memory Visualization State
                    let memoryState = {
                        urlsCreated: 0,
                        urlsLeaked: 0,
                        urlsRevoked: 0,
                        memoryUsed: 0,
                        memorySaved: 0
                    };

                    function updateMemoryDisplay() {
                        const memoryBar = document.getElementById('memory-bar');
                        const memoryValue = document.getElementById('memory-value');
                        const memoryWarning = document.getElementById('memory-warning');
                        const urlsCreated = document.getElementById('urls-created');
                        const urlsLeaked = document.getElementById('urls-leaked');
                        const urlsRevoked = document.getElementById('urls-revoked');
                        const memorySaved = document.getElementById('memory-saved');
                        const insight = document.getElementById('memory-insight');

                        // Update stats
                        urlsCreated.textContent = memoryState.urlsCreated;
                        urlsLeaked.textContent = memoryState.urlsLeaked;
                        urlsRevoked.textContent = memoryState.urlsRevoked;
                        memorySaved.textContent = memoryState.memorySaved.toFixed(1) + ' MB';

                        // Update memory bar
                        const percentage = Math.min((memoryState.memoryUsed / 100) * 100, 100);
                        memoryBar.style.width = percentage + '%';
                        memoryValue.textContent = memoryState.memoryUsed.toFixed(1) + ' MB';

                        // Color and warning based on memory usage
                        if (memoryState.memoryUsed > 50) {
                            memoryBar.style.background = 'linear-gradient(90deg, #ff6b6b, #ee5a24)';
                            memoryWarning.style.display = 'block';
                        } else if (memoryState.memoryUsed > 25) {
                            memoryBar.style.background = 'linear-gradient(90deg, #ffc107, #ff9800)';
                            memoryWarning.style.display = 'none';
                        } else {
                            memoryBar.style.background = 'linear-gradient(90deg, #667eea, #764ba2)';
                            memoryWarning.style.display = 'none';
                        }

                        // Show insight
                        if (memoryState.urlsLeaked > 5) {
                            insight.style.display = 'block';
                            insight.querySelector('p').textContent = 'üí° Notice how leaked URLs keep consuming memory! In a real app with many files, this causes performance issues and crashes.';
                        } else if (memoryState.urlsRevoked > 3 && memoryState.memorySaved > 5) {
                            insight.style.display = 'block';
                            insight.querySelector('p').textContent = '‚ú® Great! You\'ve saved ' + memoryState.memorySaved.toFixed(1) + ' MB by properly revoking Object URLs. This is the pattern to use in React with useEffect cleanup!';
                        } else {
                            insight.style.display = 'none';
                        }
                    }

                    function addUrlToList(listId, url, type) {
                        const list = document.getElementById(listId);
                        // Clear placeholder text on first add
                        if (list.querySelector('p')) {
                            list.innerHTML = '';
                        }
                        const item = document.createElement('div');
                        item.style.cssText = 'font-size: 0.7rem; color: ' + (type === 'leak' ? '#ff6b6b' : '#4CAF50') + '; padding: 0.25rem; border-bottom: 1px solid rgba(255,255,255,0.1); word-break: break-all;';
                        item.textContent = (type === 'leak' ? 'üî¥ ' : '‚úÖ ') + url.substring(0, 40) + '...';
                        list.appendChild(item);
                        list.scrollTop = list.scrollHeight;
                    }

                    function simulateFileSelect() {
                        // Simulate creating Object URL for a ~2MB image
                        const fileSize = 1.5 + Math.random() * 1; // 1.5-2.5 MB
                        const fakeUrl = 'blob:http://localhost/' + Math.random().toString(36).substring(2, 15);

                        // Bad side: create and leak
                        memoryState.urlsCreated++;
                        memoryState.urlsLeaked++;
                        memoryState.memoryUsed += fileSize;
                        addUrlToList('url-list-bad', fakeUrl, 'leak');

                        // Good side: create and immediately revoke
                        memoryState.urlsRevoked++;
                        memoryState.memorySaved += fileSize;
                        addUrlToList('url-list-good', fakeUrl + ' (revoked)', 'revoked');

                        updateMemoryDisplay();
                    }

                    function simulateBulkUpload() {
                        for (let i = 0; i < 10; i++) {
                            setTimeout(() => simulateFileSelect(), i * 100);
                        }
                    }

                    function resetMemoryDemo() {
                        memoryState = {
                            urlsCreated: 0,
                            urlsLeaked: 0,
                            urlsRevoked: 0,
                            memoryUsed: 0,
                            memorySaved: 0
                        };
                        document.getElementById('url-list-bad').innerHTML = '<p style="color: #666; font-size: 0.8rem; margin: 0; text-align: center;">URLs created here leak memory</p>';
                        document.getElementById('url-list-good').innerHTML = '<p style="color: #666; font-size: 0.8rem; margin: 0; text-align: center;">URLs created and revoked ‚Äî no leak!</p>';
                        updateMemoryDisplay();
                    }

                    // Initialize display
                    updateMemoryDisplay();
                </script>
            </section>

            <!-- Section 7: File Validation -->
            <section id="section7" class="lesson-section">
                <h2>‚úÖ File Validation</h2>
                
                <p>File validation is crucial for security, user experience, and preventing issues. You should validate files on the client side for immediate feedback, and always validate on the server side for security. Let's explore comprehensive client-side validation techniques.</p>

                <h3>Why Validate Files?</h3>

                <ul>
                    <li><strong>Security:</strong> Prevent malicious file uploads (executables, scripts disguised as images)</li>
                    <li><strong>User Experience:</strong> Provide immediate feedback before upload attempts</li>
                    <li><strong>Server Protection:</strong> Prevent overwhelming your server with huge files</li>
                    <li><strong>Storage Costs:</strong> Avoid storing files that are too large or wrong format</li>
                    <li><strong>Application Logic:</strong> Ensure files meet your app's requirements (dimensions, aspect ratio, etc.)</li>
                </ul>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Client-Side Validation is Not Security</h4>
                    <p>Never rely on client-side validation alone! Users can bypass it by modifying browser code or sending requests directly. Always validate files on the server side as well. Client-side validation is for UX, server-side validation is for security.</p>
                </div>

                <h3>Types of Validation</h3>

                <h4>1. File Type Validation</h4>

                <p>Check the file's MIME type and optionally its extension:</p>

                <pre><code class="language-typescript">const validateFileType = (
  file: File, 
  allowedTypes: string[]
): { valid: boolean; error?: string } => {
  // Check MIME type
  if (!allowedTypes.includes(file.type)) {
    return {
      valid: false,
      error: `File type ${file.type} is not allowed. Allowed types: ${allowedTypes.join(', ')}`
    };
  }
  
  return { valid: true };
};

// Usage
const allowedImageTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
const result = validateFileType(file, allowedImageTypes);

if (!result.valid) {
  alert(result.error);
}</code></pre>

                <h4>2. File Size Validation</h4>

                <p>Limit file size to prevent huge uploads:</p>

                <pre><code class="language-typescript">const validateFileSize = (
  file: File,
  maxSizeInMB: number
): { valid: boolean; error?: string } => {
  const maxSizeInBytes = maxSizeInMB * 1024 * 1024;
  
  if (file.size > maxSizeInBytes) {
    const fileSizeInMB = (file.size / (1024 * 1024)).toFixed(2);
    return {
      valid: false,
      error: `File size (${fileSizeInMB}MB) exceeds maximum allowed size (${maxSizeInMB}MB)`
    };
  }
  
  return { valid: true };
};

// Usage
const result = validateFileSize(file, 5); // Max 5MB

if (!result.valid) {
  alert(result.error);
}</code></pre>

                <h4>3. Image Dimension Validation</h4>

                <p>For images, you might need to check width, height, or aspect ratio:</p>

                <pre><code class="language-typescript">interface DimensionConstraints {
  minWidth?: number;
  maxWidth?: number;
  minHeight?: number;
  maxHeight?: number;
  aspectRatio?: number; // e.g., 16/9 or 1 for square
  aspectRatioTolerance?: number; // e.g., 0.1 for 10% tolerance
}

const validateImageDimensions = (
  file: File,
  constraints: DimensionConstraints
): Promise&lt;{ valid: boolean; error?: string; dimensions?: { width: number; height: number } }&gt; => {
  return new Promise((resolve) => {
    // Only works for images
    if (!file.type.startsWith('image/')) {
      resolve({ valid: false, error: 'File is not an image' });
      return;
    }

    // Create an image element to load the file
    const img = new Image();
    const objectUrl = URL.createObjectURL(file);

    img.onload = () => {
      // Clean up object URL
      URL.revokeObjectURL(objectUrl);

      const width = img.width;
      const height = img.height;
      const actualRatio = width / height;

      // Check minimum width
      if (constraints.minWidth && width < constraints.minWidth) {
        resolve({
          valid: false,
          error: `Image width (${width}px) is less than minimum (${constraints.minWidth}px)`,
          dimensions: { width, height }
        });
        return;
      }

      // Check maximum width
      if (constraints.maxWidth && width > constraints.maxWidth) {
        resolve({
          valid: false,
          error: `Image width (${width}px) exceeds maximum (${constraints.maxWidth}px)`,
          dimensions: { width, height }
        });
        return;
      }

      // Check minimum height
      if (constraints.minHeight && height < constraints.minHeight) {
        resolve({
          valid: false,
          error: `Image height (${height}px) is less than minimum (${constraints.minHeight}px)`,
          dimensions: { width, height }
        });
        return;
      }

      // Check maximum height
      if (constraints.maxHeight && height > constraints.maxHeight) {
        resolve({
          valid: false,
          error: `Image height (${height}px) exceeds maximum (${constraints.maxHeight}px)`,
          dimensions: { width, height }
        });
        return;
      }

      // Check aspect ratio
      if (constraints.aspectRatio) {
        const tolerance = constraints.aspectRatioTolerance || 0.01;
        const ratioDifference = Math.abs(actualRatio - constraints.aspectRatio);
        
        if (ratioDifference > tolerance) {
          resolve({
            valid: false,
            error: `Image aspect ratio (${actualRatio.toFixed(2)}) doesn't match required ratio (${constraints.aspectRatio.toFixed(2)})`,
            dimensions: { width, height }
          });
          return;
        }
      }

      // All checks passed!
      resolve({ valid: true, dimensions: { width, height } });
    };

    img.onerror = () => {
      URL.revokeObjectURL(objectUrl);
      resolve({ valid: false, error: 'Failed to load image' });
    };

    img.src = objectUrl;
  });
};

// Usage
const result = await validateImageDimensions(file, {
  minWidth: 800,
  minHeight: 600,
  maxWidth: 4000,
  maxHeight: 4000,
  aspectRatio: 16 / 9,
  aspectRatioTolerance: 0.1
});

if (!result.valid) {
  alert(result.error);
} else {
  console.log('Image dimensions:', result.dimensions);
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ How Image Dimension Validation Works</h4>
                    <p>To check image dimensions, we:</p>
                    <ol>
                        <li>Create an object URL from the file</li>
                        <li>Create an <code>&lt;img&gt;</code> element in memory (not in DOM)</li>
                        <li>Set the object URL as the image source</li>
                        <li>Wait for the image to load</li>
                        <li>Read the <code>width</code> and <code>height</code> properties</li>
                        <li>Revoke the object URL to free memory</li>
                    </ol>
                    <p>This all happens in memory without displaying anything to the user!</p>
                </div>

                <h3>Comprehensive File Validator</h3>

                <p>Let's combine all validation types into one comprehensive validator:</p>

                <pre><code class="language-typescript">interface FileValidationRules {
  allowedTypes?: string[];
  maxSizeInMB?: number;
  minSizeInKB?: number;
  imageConstraints?: DimensionConstraints;
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
  warnings?: string[];
}

const validateFile = async (
  file: File,
  rules: FileValidationRules
): Promise&lt;ValidationResult&gt; => {
  const errors: string[] = [];
  const warnings: string[] = [];

  // 1. Validate file type
  if (rules.allowedTypes && !rules.allowedTypes.includes(file.type)) {
    errors.push(
      `File type "${file.type}" is not allowed. ` +
      `Allowed types: ${rules.allowedTypes.join(', ')}`
    );
  }

  // 2. Validate file size (max)
  if (rules.maxSizeInMB) {
    const maxBytes = rules.maxSizeInMB * 1024 * 1024;
    if (file.size > maxBytes) {
      const sizeMB = (file.size / (1024 * 1024)).toFixed(2);
      errors.push(
        `File size (${sizeMB}MB) exceeds maximum (${rules.maxSizeInMB}MB)`
      );
    }
  }

  // 3. Validate file size (min)
  if (rules.minSizeInKB) {
    const minBytes = rules.minSizeInKB * 1024;
    if (file.size < minBytes) {
      const sizeKB = (file.size / 1024).toFixed(2);
      errors.push(
        `File size (${sizeKB}KB) is less than minimum (${rules.minSizeInKB}KB)`
      );
    }
  }

  // 4. Validate image dimensions (if applicable)
  if (rules.imageConstraints && file.type.startsWith('image/')) {
    const dimensionResult = await validateImageDimensions(
      file,
      rules.imageConstraints
    );
    
    if (!dimensionResult.valid && dimensionResult.error) {
      errors.push(dimensionResult.error);
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
};

// Usage Example
const handleFileSelection = async (file: File) => {
  const validationRules: FileValidationRules = {
    allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
    maxSizeInMB: 5,
    minSizeInKB: 10,
    imageConstraints: {
      minWidth: 800,
      minHeight: 600,
      maxWidth: 4000,
      maxHeight: 4000
    }
  };

  const result = await validateFile(file, validationRules);

  if (!result.valid) {
    alert('Validation failed:\n' + result.errors.join('\n'));
    return;
  }

  console.log('File passed validation!');
  // Proceed with upload...
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° User-Friendly Error Messages</h4>
                    <p>Always provide clear, actionable error messages:</p>
                    <ul>
                        <li>‚ùå Bad: "Invalid file"</li>
                        <li>‚úÖ Good: "File must be a JPEG or PNG image, maximum 5MB"</li>
                    </ul>
                    <p>Tell users exactly what went wrong and how to fix it!</p>
                </div>
            <!-- Section 8: Multiple File Uploads -->
            <section id="section8" class="lesson-section">
                <h2>üìö Multiple File Uploads</h2>
                
                <p>So far, we've focused on single file uploads. But what if users need to upload multiple files at once? Maybe they're uploading a photo album, multiple documents, or product images. Let's learn how to handle multiple file selections and display previews for each one.</p>

                <h3>Enabling Multiple File Selection</h3>

                <p>The HTML file input supports multiple file selection with the <code>multiple</code> attribute:</p>

                <pre><code class="language-html">&lt;input type="file" multiple accept="image/*" /&gt;</code></pre>

                <p>When <code>multiple</code> is present, users can select multiple files from the file picker (usually by holding Ctrl/Cmd or Shift). The <code>event.target.files</code> will then contain a <code>FileList</code> with all selected files.</p>

                <h3>Converting FileList to Array</h3>

                <p>Since <code>FileList</code> is array-like but not a true array, we need to convert it to use array methods:</p>

                <pre><code class="language-typescript">// Method 1: Array.from()
const filesArray = Array.from(event.target.files || []);

// Method 2: Spread operator
const filesArray = [...(event.target.files || [])];

// Method 3: Array.prototype.slice.call() (older approach)
const filesArray = Array.prototype.slice.call(event.target.files || []);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Convert to Array?</h4>
                    <p>Converting to an array allows you to use helpful methods like:</p>
                    <ul>
                        <li><code>.map()</code> - Transform each file</li>
                        <li><code>.filter()</code> - Remove invalid files</li>
                        <li><code>.forEach()</code> - Process each file</li>
                        <li><code>.some()</code> / <code>.every()</code> - Check conditions</li>
                    </ul>
                </div>

                <h3>Basic Multiple File Upload Component</h3>

                <pre><code class="language-typescript">import React, { useState } from 'react';

interface FileWithPreview {
  file: File;
  preview: string;
  id: string;
}

const MultipleFileUpload: React.FC = () => {
  const [files, setFiles] = useState&lt;FileWithPreview[]&gt;([]);

  const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const selectedFiles = event.target.files;
    
    if (!selectedFiles || selectedFiles.length === 0) {
      return;
    }

    // Convert FileList to array
    const filesArray = Array.from(selectedFiles);

    // Filter for images only
    const imageFiles = filesArray.filter(file => 
      file.type.startsWith('image/')
    );

    if (imageFiles.length === 0) {
      alert('Please select at least one image file');
      return;
    }

    // Create preview URLs for each file
    const filesWithPreviews: FileWithPreview[] = imageFiles.map(file => ({
      file,
      preview: URL.createObjectURL(file),
      id: `${file.name}-${Date.now()}-${Math.random()}`
    }));

    setFiles(filesWithPreviews);
  };

  const removeFile = (id: string) => {
    setFiles(prevFiles => {
      // Find the file to remove
      const fileToRemove = prevFiles.find(f => f.id === id);
      
      // Revoke its object URL to free memory
      if (fileToRemove) {
        URL.revokeObjectURL(fileToRemove.preview);
      }
      
      // Return filtered array
      return prevFiles.filter(f => f.id !== id);
    });
  };

  const clearAll = () => {
    // Revoke all object URLs
    files.forEach(f => URL.revokeObjectURL(f.preview));
    setFiles([]);
  };

  // Cleanup on unmount
  React.useEffect(() => {
    return () => {
      // Revoke all object URLs when component unmounts
      files.forEach(f => URL.revokeObjectURL(f.preview));
    };
  }, [files]);

  return (
    &lt;div&gt;
      &lt;h3&gt;Upload Multiple Images&lt;/h3&gt;
      
      &lt;input
        type="file"
        multiple
        accept="image/*"
        onChange={handleFileChange}
      /&gt;

      {files.length > 0 && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;div style={{ 
            display: 'flex', 
            justifyContent: 'space-between', 
            alignItems: 'center',
            marginBottom: '1rem'
          }}&gt;
            &lt;h4&gt;Selected Files: {files.length}&lt;/h4&gt;
            &lt;button onClick={clearAll}&gt;Clear All&lt;/button&gt;
          &lt;/div&gt;

          &lt;div style={{ 
            display: 'grid', 
            gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
            gap: '1rem'
          }}&gt;
            {files.map((fileItem) => (
              &lt;div 
                key={fileItem.id}
                style={{
                  border: '2px solid #ddd',
                  borderRadius: '8px',
                  padding: '0.5rem',
                  position: 'relative'
                }}
              &gt;
                &lt;img 
                  src={fileItem.preview} 
                  alt={fileItem.file.name}
                  style={{
                    width: '100%',
                    height: '150px',
                    objectFit: 'cover',
                    borderRadius: '4px'
                  }}
                /&gt;
                &lt;p style={{ 
                  fontSize: '0.875rem', 
                  marginTop: '0.5rem',
                  wordBreak: 'break-word'
                }}&gt;
                  {fileItem.file.name}
                &lt;/p&gt;
                &lt;p style={{ fontSize: '0.75rem', color: '#666' }}&gt;
                  {(fileItem.file.size / 1024).toFixed(2)} KB
                &lt;/p&gt;
                &lt;button 
                  onClick={() => removeFile(fileItem.id)}
                  style={{
                    width: '100%',
                    marginTop: '0.5rem',
                    padding: '0.25rem',
                    backgroundColor: '#f44336',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  }}
                &gt;
                  Remove
                &lt;/button&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default MultipleFileUpload;</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Patterns in Multiple File Handling</h4>
                    <ul>
                        <li><strong>Unique IDs:</strong> Generate unique IDs for each file (using name + timestamp + random) so React can track them properly</li>
                        <li><strong>Object URL Management:</strong> Store preview URLs alongside files and revoke them individually when removed</li>
                        <li><strong>Cleanup:</strong> Revoke all URLs on unmount to prevent memory leaks</li>
                        <li><strong>Grid Layout:</strong> Use CSS Grid for responsive preview gallery</li>
                    </ul>
                </div>

                <h3>Validating Multiple Files</h3>

                <p>When handling multiple files, you'll want to validate each one individually and provide feedback:</p>

                <pre><code class="language-typescript">interface ValidationError {
  fileName: string;
  error: string;
}

const handleMultipleFileValidation = async (
  files: File[],
  rules: FileValidationRules
): Promise&lt;{
  validFiles: File[];
  errors: ValidationError[];
}&gt; => {
  const validFiles: File[] = [];
  const errors: ValidationError[] = [];

  // Validate each file
  for (const file of files) {
    const result = await validateFile(file, rules);
    
    if (result.valid) {
      validFiles.push(file);
    } else {
      errors.push({
        fileName: file.name,
        error: result.errors.join(', ')
      });
    }
  }

  return { validFiles, errors };
};

// Usage in component
const handleFileChange = async (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  const selectedFiles = event.target.files;
  if (!selectedFiles || selectedFiles.length === 0) return;

  const filesArray = Array.from(selectedFiles);

  // Validate all files
  const { validFiles, errors } = await handleMultipleFileValidation(
    filesArray,
    {
      allowedTypes: ['image/jpeg', 'image/png', 'image/webp'],
      maxSizeInMB: 5,
      imageConstraints: {
        minWidth: 800,
        minHeight: 600
      }
    }
  );

  // Show errors if any
  if (errors.length > 0) {
    const errorMessage = errors
      .map(e => `${e.fileName}: ${e.error}`)
      .join('\n');
    alert(`Some files were invalid:\n\n${errorMessage}`);
  }

  // Process valid files
  if (validFiles.length > 0) {
    const filesWithPreviews = validFiles.map(file => ({
      file,
      preview: URL.createObjectURL(file),
      id: `${file.name}-${Date.now()}-${Math.random()}`
    }));

    setFiles(filesWithPreviews);
  }
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Performance Consideration</h4>
                    <p>Validating many large files (especially with dimension checks) can take time. Consider:</p>
                    <ul>
                        <li>Showing a loading indicator during validation</li>
                        <li>Processing files in batches</li>
                        <li>Using Web Workers for heavy validation</li>
                        <li>Setting reasonable limits on the number of files (e.g., max 10-20 at once)</li>
                    </ul>
                </div>

                <h3>Limiting the Number of Files</h3>

                <pre><code class="language-typescript">const MAX_FILES = 10;

const handleFileChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  const selectedFiles = event.target.files;
  if (!selectedFiles || selectedFiles.length === 0) return;

  // Check file count limit
  if (selectedFiles.length > MAX_FILES) {
    alert(`You can only upload up to ${MAX_FILES} files at once`);
    return;
  }

  // Also check total count if adding to existing files
  if (files.length + selectedFiles.length > MAX_FILES) {
    alert(
      `You already have ${files.length} files. ` +
      `You can only upload ${MAX_FILES - files.length} more.`
    );
    return;
  }

  // Process files...
};</code></pre>

                <h3>Adding Files Instead of Replacing</h3>

                <p>Sometimes users want to add more files to their existing selection rather than replacing it:</p>

                <pre><code class="language-typescript">const addMoreFiles = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  const selectedFiles = event.target.files;
  if (!selectedFiles || selectedFiles.length === 0) return;

  const filesArray = Array.from(selectedFiles);
  
  // Filter for images
  const imageFiles = filesArray.filter(file => file.type.startsWith('image/'));

  // Create new previews
  const newFilesWithPreviews = imageFiles.map(file => ({
    file,
    preview: URL.createObjectURL(file),
    id: `${file.name}-${Date.now()}-${Math.random()}`
  }));

  // Add to existing files (not replace)
  setFiles(prevFiles => [...prevFiles, ...newFilesWithPreviews]);
};</code></pre>
            </section>

            <!-- Section 9: Drag and Drop Basics -->
            <section id="section9" class="lesson-section">
                <h2>üéØ Drag and Drop Basics</h2>
                
                <p>Drag and drop provides a more intuitive user experience than clicking a file input button. Users can simply drag files from their file explorer and drop them onto your component. Let's learn how to implement this powerful feature!</p>

                <h3>Understanding Drag and Drop Events</h3>

                <p>The HTML Drag and Drop API provides several events for the drop zone (the area where users drop files):</p>

                <table>
                    <thead>
                        <tr>
                            <th>Event</th>
                            <th>When It Fires</th>
                            <th>What To Do</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>dragenter</code></td>
                            <td>When dragged item enters the drop zone</td>
                            <td>Add visual feedback (highlight border)</td>
                        </tr>
                        <tr>
                            <td><code>dragover</code></td>
                            <td>Continuously while item is over drop zone</td>
                            <td>Must call <code>preventDefault()</code> to allow dropping</td>
                        </tr>
                        <tr>
                            <td><code>dragleave</code></td>
                            <td>When dragged item leaves the drop zone</td>
                            <td>Remove visual feedback</td>
                        </tr>
                        <tr>
                            <td><code>drop</code></td>
                            <td>When item is dropped in the zone</td>
                            <td>Get files from <code>event.dataTransfer.files</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Critical: preventDefault()</h4>
                    <p>You <strong>must</strong> call <code>event.preventDefault()</code> in both the <code>dragover</code> and <code>drop</code> event handlers. Otherwise, the browser's default behavior (often opening the file in a new tab) will occur instead of your custom drop handling.</p>
                    <pre><code class="language-typescript">const handleDragOver = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
  e.preventDefault(); // ‚Üê Essential!
};</code></pre>
                </div>

                <h3>Basic Drag and Drop Implementation</h3>

                <pre><code class="language-typescript">import React, { useState } from 'react';

const BasicDragDrop: React.FC = () => {
  const [isDragging, setIsDragging] = useState(false);
  const [files, setFiles] = useState&lt;File[]&gt;([]);

  const handleDragEnter = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(true);
  };

  const handleDragLeave = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDragOver = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    // Get dropped files
    const droppedFiles = e.dataTransfer.files;
    
    if (droppedFiles && droppedFiles.length > 0) {
      const filesArray = Array.from(droppedFiles);
      setFiles(filesArray);
    }
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Drag and Drop File Upload&lt;/h3&gt;
      
      &lt;div
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        style={{
          border: isDragging 
            ? '3px dashed #667eea' 
            : '2px dashed #ccc',
          borderRadius: '8px',
          padding: '2rem',
          textAlign: 'center',
          backgroundColor: isDragging 
            ? '#f0f4ff' 
            : '#fafafa',
          transition: 'all 0.3s ease',
          cursor: 'pointer'
        }}
      &gt;
        {isDragging ? (
          &lt;p style={{ fontSize: '1.2rem', color: '#667eea' }}&gt;
            üì• Drop files here...
          &lt;/p&gt;
        ) : (
          &lt;div&gt;
            &lt;p style={{ fontSize: '1.2rem' }}&gt;
              üìÇ Drag and drop files here
            &lt;/p&gt;
            &lt;p style={{ color: '#666' }}&gt;
              or click to browse
            &lt;/p&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {files.length > 0 && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;h4&gt;Selected Files:&lt;/h4&gt;
          &lt;ul&gt;
            {files.map((file, index) => (
              &lt;li key={index}&gt;
                {file.name} - {(file.size / 1024).toFixed(2)} KB
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default BasicDragDrop;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why stopPropagation()?</h4>
                    <p>Calling <code>e.stopPropagation()</code> prevents the event from bubbling up to parent elements. This is important if you have nested drop zones or if parent elements also handle drag events. It ensures only your intended drop zone processes the event.</p>
                </div>

                <h3>Combining File Input with Drag and Drop</h3>

                <p>Best practice is to support both methods‚Äîdrag and drop AND the traditional file input‚Äîso users can choose their preferred method:</p>

                <pre><code class="language-typescript">const handleFileInput = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
  const selectedFiles = e.target.files;
  if (selectedFiles && selectedFiles.length > 0) {
    const filesArray = Array.from(selectedFiles);
    setFiles(filesArray);
  }
};

return (
  &lt;div
    onDragEnter={handleDragEnter}
    onDragLeave={handleDragLeave}
    onDragOver={handleDragOver}
    onDrop={handleDrop}
    onClick={() => fileInputRef.current?.click()}
    style={{ /* drop zone styles */ }}
  &gt;
    &lt;input
      ref={fileInputRef}
      type="file"
      multiple
      accept="image/*"
      onChange={handleFileInput}
      style={{ display: 'none' }}
    /&gt;
    
    &lt;p&gt;Drag and drop files or click to browse&lt;/p&gt;
  &lt;/div&gt;
);</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° UX Best Practices for Drag and Drop</h4>
                    <ul>
                        <li><strong>Visual Feedback:</strong> Change appearance when files are dragged over (border color, background)</li>
                        <li><strong>Clear Instructions:</strong> Tell users they can drag files OR click</li>
                        <li><strong>Icon/Illustration:</strong> Add a visual element (folder icon, upload icon) to make it obvious</li>
                        <li><strong>Accepted Types:</strong> Indicate what file types are accepted</li>
                        <li><strong>Hover State:</strong> Show the drop zone is interactive even without dragging</li>
                    </ul>
                </div>

                <h3>Handling dragenter/dragleave Issues</h3>

                <p>One common issue with drag and drop is that <code>dragleave</code> fires when the mouse enters child elements inside your drop zone, causing flickering. Here's a robust solution using a counter:</p>

                <pre><code class="language-typescript">const DragDropFixed: React.FC = () => {
  const [dragCounter, setDragCounter] = useState(0);
  const isDragging = dragCounter > 0;

  const handleDragEnter = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(prev => prev + 1);
  };

  const handleDragLeave = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(prev => prev - 1);
  };

  const handleDragOver = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(0); // Reset counter

    const droppedFiles = e.dataTransfer.files;
    // Process files...
  };

  return (
    &lt;div
      onDragEnter={handleDragEnter}
      onDragLeave={handleDragLeave}
      onDragOver={handleDragOver}
      onDrop={handleDrop}
      style={{
        border: isDragging ? '3px dashed #667eea' : '2px dashed #ccc',
        // ... other styles
      }}
    &gt;
      {/* Drop zone content */}
    &lt;/div&gt;
  );
};</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ The Drag Counter Pattern</h4>
                    <p style="color: white;"><strong>Drag Counter:</strong> Increment on <code>dragenter</code>, decrement on <code>dragleave</code>. This works because entering a child element fires both leave (for parent) and enter (for child), keeping the counter above zero. Only when you truly leave the entire drop zone does the counter return to zero.</p>
                </div>
            </section>

            <!-- Section 10: Complete Drag and Drop Component -->
            <section id="section10" class="lesson-section">
                <h2>üé® Complete Drag and Drop Component</h2>
                
                <p>Let's put everything together into a production-ready drag-and-drop file upload component with previews, validation, and both drag-drop and click-to-browse functionality:</p>

                <pre><code class="language-typescript">import React, { useState, useRef, useEffect } from 'react';

interface FileWithPreview {
  file: File;
  preview: string;
  id: string;
}

interface DragDropUploadProps {
  maxFiles?: number;
  maxSizeInMB?: number;
  acceptedTypes?: string[];
  onFilesChange?: (files: File[]) => void;
}

const DragDropUpload: React.FC&lt;DragDropUploadProps&gt; = ({
  maxFiles = 10,
  maxSizeInMB = 5,
  acceptedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
  onFilesChange
}) => {
  const [files, setFiles] = useState&lt;FileWithPreview[]&gt;([]);
  const [dragCounter, setDragCounter] = useState(0);
  const [errors, setErrors] = useState&lt;string[]&gt;([]);
  const fileInputRef = useRef&lt;HTMLInputElement&gt;(null);

  const isDragging = dragCounter > 0;

  // Cleanup object URLs on unmount
  useEffect(() => {
    return () => {
      files.forEach(f => URL.revokeObjectURL(f.preview));
    };
  }, [files]);

  // Notify parent of file changes
  useEffect(() => {
    if (onFilesChange) {
      onFilesChange(files.map(f => f.file));
    }
  }, [files, onFilesChange]);

  const validateAndProcessFiles = (newFiles: File[]) => {
    const validationErrors: string[] = [];
    const validFiles: File[] = [];

    // Check total file count
    if (files.length + newFiles.length > maxFiles) {
      validationErrors.push(
        `Maximum ${maxFiles} files allowed. ` +
        `You have ${files.length} and tried to add ${newFiles.length}.`
      );
      setErrors(validationErrors);
      return;
    }

    // Validate each file
    newFiles.forEach(file => {
      // Check file type
      if (!acceptedTypes.includes(file.type)) {
        validationErrors.push(
          `${file.name}: Invalid file type. ` +
          `Accepted types: ${acceptedTypes.join(', ')}`
        );
        return;
      }

      // Check file size
      const sizeInMB = file.size / (1024 * 1024);
      if (sizeInMB > maxSizeInMB) {
        validationErrors.push(
          `${file.name}: File too large (${sizeInMB.toFixed(2)}MB). ` +
          `Maximum size: ${maxSizeInMB}MB`
        );
        return;
      }

      validFiles.push(file);
    });

    // Update errors
    setErrors(validationErrors);

    // Add valid files
    if (validFiles.length > 0) {
      const filesWithPreviews: FileWithPreview[] = validFiles.map(file => ({
        file,
        preview: URL.createObjectURL(file),
        id: `${file.name}-${Date.now()}-${Math.random()}`
      }));

      setFiles(prev => [...prev, ...filesWithPreviews]);
    }
  };

  const handleDragEnter = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(prev => prev + 1);
  };

  const handleDragLeave = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(prev => prev - 1);
  };

  const handleDragOver = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: React.DragEvent&lt;HTMLDivElement&gt;) => {
    e.preventDefault();
    e.stopPropagation();
    setDragCounter(0);

    const droppedFiles = e.dataTransfer.files;
    if (droppedFiles && droppedFiles.length > 0) {
      const filesArray = Array.from(droppedFiles);
      validateAndProcessFiles(filesArray);
    }
  };

  const handleFileInput = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const selectedFiles = e.target.files;
    if (selectedFiles && selectedFiles.length > 0) {
      const filesArray = Array.from(selectedFiles);
      validateAndProcessFiles(filesArray);
    }
    
    // Reset input so the same file can be selected again
    e.target.value = '';
  };

  const removeFile = (id: string) => {
    setFiles(prev => {
      const fileToRemove = prev.find(f => f.id === id);
      if (fileToRemove) {
        URL.revokeObjectURL(fileToRemove.preview);
      }
      return prev.filter(f => f.id !== id);
    });
  };

  const clearAll = () => {
    files.forEach(f => URL.revokeObjectURL(f.preview));
    setFiles([]);
    setErrors([]);
  };

  const openFilePicker = () => {
    fileInputRef.current?.click();
  };

  return (
    &lt;div style={{ width: '100%' }}&gt;
      {/* Drop Zone */}
      &lt;div
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        onClick={openFilePicker}
        style={{
          border: isDragging 
            ? '3px dashed #667eea' 
            : '2px dashed #ccc',
          borderRadius: '12px',
          padding: '3rem 2rem',
          textAlign: 'center',
          backgroundColor: isDragging 
            ? '#f0f4ff' 
            : '#fafafa',
          transition: 'all 0.3s ease',
          cursor: 'pointer',
          marginBottom: '1rem'
        }}
      &gt;
        &lt;input
          ref={fileInputRef}
          type="file"
          multiple
          accept={acceptedTypes.join(',')}
          onChange={handleFileInput}
          style={{ display: 'none' }}
        /&gt;

        {isDragging ? (
          &lt;div&gt;
            &lt;p style={{ fontSize: '2rem', margin: 0 }}&gt;üì•&lt;/p&gt;
            &lt;p style={{ 
              fontSize: '1.2rem', 
              color: '#667eea',
              margin: '0.5rem 0 0 0'
            }}&gt;
              Drop your files here
            &lt;/p&gt;
          &lt;/div&gt;
        ) : (
          &lt;div&gt;
            &lt;p style={{ fontSize: '2rem', margin: 0 }}&gt;üìÅ&lt;/p&gt;
            &lt;p style={{ 
              fontSize: '1.2rem', 
              margin: '0.5rem 0',
              fontWeight: 500
            }}&gt;
              Drag and drop files here
            &lt;/p&gt;
            &lt;p style={{ color: '#666', margin: '0.25rem 0' }}&gt;
              or click to browse
            &lt;/p&gt;
            &lt;p style={{ 
              fontSize: '0.875rem', 
              color: '#999',
              margin: '1rem 0 0 0'
            }}&gt;
              Accepted: {acceptedTypes.map(t => t.split('/')[1]).join(', ')} 
              | Max {maxSizeInMB}MB | Up to {maxFiles} files
            &lt;/p&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Errors */}
      {errors.length > 0 && (
        &lt;div style={{
          backgroundColor: '#fee',
          border: '1px solid #fcc',
          borderRadius: '8px',
          padding: '1rem',
          marginBottom: '1rem'
        }}&gt;
          &lt;h4 style={{ margin: '0 0 0.5rem 0', color: '#c33' }}&gt;
            ‚ö†Ô∏è Validation Errors:
          &lt;/h4&gt;
          &lt;ul style={{ margin: 0, paddingLeft: '1.5rem' }}&gt;
            {errors.map((error, index) => (
              &lt;li key={index} style={{ color: '#c33' }}&gt;{error}&lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      )}

      {/* File Preview Grid */}
      {files.length > 0 && (
        &lt;div&gt;
          &lt;div style={{
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            marginBottom: '1rem'
          }}&gt;
            &lt;h4 style={{ margin: 0 }}&gt;
              Selected Files ({files.length}/{maxFiles})
            &lt;/h4&gt;
            &lt;button
              onClick={clearAll}
              style={{
                padding: '0.5rem 1rem',
                backgroundColor: '#f44336',
                color: 'white',
                border: 'none',
                borderRadius: '6px',
                cursor: 'pointer',
                fontSize: '0.875rem'
              }}
            &gt;
              Clear All
            &lt;/button&gt;
          &lt;/div&gt;

          &lt;div style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(auto-fill, minmax(200px, 1fr))',
            gap: '1rem'
          }}&gt;
            {files.map((fileItem) => (
              &lt;div
                key={fileItem.id}
                style={{
                  border: '2px solid #e0e0e0',
                  borderRadius: '8px',
                  padding: '0.5rem',
                  backgroundColor: 'white',
                  position: 'relative'
                }}
              &gt;
                &lt;img
                  src={fileItem.preview}
                  alt={fileItem.file.name}
                  style={{
                    width: '100%',
                    height: '150px',
                    objectFit: 'cover',
                    borderRadius: '6px',
                    marginBottom: '0.5rem'
                  }}
                /&gt;
                &lt;p style={{
                  fontSize: '0.875rem',
                  margin: '0 0 0.25rem 0',
                  fontWeight: 500,
                  wordBreak: 'break-word'
                }}&gt;
                  {fileItem.file.name}
                &lt;/p&gt;
                &lt;p style={{
                  fontSize: '0.75rem',
                  color: '#666',
                  margin: '0 0 0.5rem 0'
                }}&gt;
                  {(fileItem.file.size / 1024).toFixed(2)} KB
                &lt;/p&gt;
                &lt;button
                  onClick={(e) => {
                    e.stopPropagation();
                    removeFile(fileItem.id);
                  }}
                  style={{
                    width: '100%',
                    padding: '0.5rem',
                    backgroundColor: '#ff5252',
                    color: 'white',
                    border: 'none',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontSize: '0.875rem',
                    transition: 'background-color 0.2s'
                  }}
                  onMouseOver={(e) => {
                    e.currentTarget.style.backgroundColor = '#ff1744';
                  }}
                  onMouseOut={(e) => {
                    e.currentTarget.style.backgroundColor = '#ff5252';
                  }}
                &gt;
                  Remove
                &lt;/button&gt;
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default DragDropUpload;</code></pre>

                <h3>Using the Complete Component</h3>

                <pre><code class="language-typescript">import DragDropUpload from './DragDropUpload';

function App() {
  const handleFilesChange = (files: File[]) => {
    console.log('Selected files:', files);
    // Here you would typically upload these files
  };

  return (
    &lt;div style={{ padding: '2rem', maxWidth: '800px', margin: '0 auto' }}&gt;
      &lt;h1&gt;File Upload Demo&lt;/h1&gt;
      
      &lt;DragDropUpload
        maxFiles={5}
        maxSizeInMB={10}
        acceptedTypes={[
          'image/jpeg',
          'image/png',
          'image/webp',
          'image/gif'
        ]}
        onFilesChange={handleFilesChange}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Features of Our Complete Component</h4>
                    <ul>
                        <li><strong>Dual Input:</strong> Supports both drag-drop and click-to-browse</li>
                        <li><strong>Visual Feedback:</strong> Border and background change on drag</li>
                        <li><strong>Validation:</strong> File type and size validation with clear error messages</li>
                        <li><strong>Preview Grid:</strong> Responsive grid layout for file previews</li>
                        <li><strong>Individual Removal:</strong> Remove files one at a time</li>
                        <li><strong>Bulk Actions:</strong> Clear all files at once</li>
                        <li><strong>Memory Management:</strong> Properly revokes object URLs</li>
                        <li><strong>Configurable:</strong> Props for max files, size limits, accepted types</li>
                        <li><strong>Parent Communication:</strong> Callback when files change</li>
                        <li><strong>Accessible:</strong> Works with keyboard navigation</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Enhancement Ideas</h4>
                    <p>You could extend this component further with:</p>
                    <ul>
                        <li><strong>Upload Progress:</strong> Show progress bars during actual upload</li>
                        <li><strong>Image Editing:</strong> Crop, rotate, or resize before upload</li>
                        <li><strong>Dimension Validation:</strong> Check image dimensions</li>
                        <li><strong>Server Upload:</strong> Actually send files to a backend</li>
                        <li><strong>Reorder Files:</strong> Drag to reorder the file list</li>
                        <li><strong>Paste Support:</strong> Allow pasting images from clipboard</li>
                        <li><strong>Camera Capture:</strong> On mobile, open camera directly</li>
                        <li><strong>Chunked Upload:</strong> Split large files for reliable uploads</li>
                    </ul>
                </div>
            </section>
            <!-- Section 11: Upload Progress Tracking -->
            <section id="section11" class="lesson-section">
                <h2>üìä Upload Progress Tracking</h2>
                
                <p>When uploading files, especially large ones, users need feedback about what's happening. Is the upload progressing? How much longer will it take? A progress bar provides crucial visual feedback and reassures users that the upload is working. Let's implement upload progress tracking using XMLHttpRequest or the Fetch API with streams.</p>

                <h3>Upload Progress with XMLHttpRequest</h3>

                <p>The older <code>XMLHttpRequest</code> API has built-in support for upload progress tracking through the <code>progress</code> event:</p>

                <pre><code class="language-typescript">interface UploadProgress {
  fileName: string;
  progress: number; // 0-100
  loaded: number; // bytes uploaded
  total: number; // total bytes
}

const uploadFileWithProgress = (
  file: File,
  url: string,
  onProgress: (progress: UploadProgress) => void
): Promise&lt;void&gt; => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const formData = new FormData();
    formData.append('file', file);

    // Track upload progress
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        
        onProgress({
          fileName: file.name,
          progress: Math.round(percentComplete),
          loaded: e.loaded,
          total: e.total
        });
      }
    });

    // Handle completion
    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve();
      } else {
        reject(new Error(`Upload failed with status ${xhr.status}`));
      }
    });

    // Handle errors
    xhr.addEventListener('error', () => {
      reject(new Error('Upload failed due to network error'));
    });

    xhr.addEventListener('abort', () => {
      reject(new Error('Upload was cancelled'));
    });

    // Send the request
    xhr.open('POST', url);
    xhr.send(formData);
  });
};

// Usage
const handleUpload = async (file: File) => {
  try {
    await uploadFileWithProgress(
      file,
      '/api/upload',
      (progress) => {
        console.log(
          `${progress.fileName}: ${progress.progress}% ` +
          `(${progress.loaded}/${progress.total} bytes)`
        );
      }
    );
    console.log('Upload complete!');
  } catch (error) {
    console.error('Upload failed:', error);
  }
};</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ FormData</h4>
                    <p style="color: white;"><strong>FormData:</strong> A Web API that provides a way to construct key/value pairs representing form fields and their values, which can then be sent using XMLHttpRequest or fetch. It's the standard way to send files to a server. You append files and other data to it, then send it as the request body.</p>
                </div>

                <h3>React Component with Upload Progress</h3>

                <pre><code class="language-typescript">import React, { useState } from 'react';

interface FileUploadState {
  file: File;
  progress: number;
  status: 'pending' | 'uploading' | 'success' | 'error';
  error?: string;
}

const FileUploadWithProgress: React.FC = () => {
  const [uploadStates, setUploadStates] = useState&lt;
    Map&lt;string, FileUploadState&gt;
  &gt;(new Map());

  const uploadFile = async (file: File) => {
    const fileId = `${file.name}-${Date.now()}`;

    // Initialize upload state
    setUploadStates(prev => {
      const newMap = new Map(prev);
      newMap.set(fileId, {
        file,
        progress: 0,
        status: 'uploading'
      });
      return newMap;
    });

    try {
      await uploadFileWithProgress(
        file,
        '/api/upload',
        (progressInfo) => {
          setUploadStates(prev => {
            const newMap = new Map(prev);
            const state = newMap.get(fileId);
            if (state) {
              newMap.set(fileId, {
                ...state,
                progress: progressInfo.progress
              });
            }
            return newMap;
          });
        }
      );

      // Mark as success
      setUploadStates(prev => {
        const newMap = new Map(prev);
        const state = newMap.get(fileId);
        if (state) {
          newMap.set(fileId, {
            ...state,
            status: 'success',
            progress: 100
          });
        }
        return newMap;
      });
    } catch (error) {
      // Mark as error
      setUploadStates(prev => {
        const newMap = new Map(prev);
        const state = newMap.get(fileId);
        if (state) {
          newMap.set(fileId, {
            ...state,
            status: 'error',
            error: error instanceof Error ? error.message : 'Upload failed'
          });
        }
        return newMap;
      });
    }
  };

  const handleFileSelect = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    // Upload each file
    Array.from(files).forEach(file => {
      uploadFile(file);
    });

    // Reset input
    e.target.value = '';
  };

  return (
    &lt;div&gt;
      &lt;h3&gt;Upload Files with Progress&lt;/h3&gt;
      
      &lt;input
        type="file"
        multiple
        onChange={handleFileSelect}
      /&gt;

      {uploadStates.size > 0 && (
        &lt;div style={{ marginTop: '2rem' }}&gt;
          &lt;h4&gt;Uploads&lt;/h4&gt;
          
          {Array.from(uploadStates.entries()).map(([fileId, state]) => (
            &lt;div
              key={fileId}
              style={{
                border: '1px solid #ddd',
                borderRadius: '8px',
                padding: '1rem',
                marginBottom: '1rem'
              }}
            &gt;
              &lt;div style={{
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center',
                marginBottom: '0.5rem'
              }}&gt;
                &lt;span style={{ fontWeight: 500 }}&gt;
                  {state.file.name}
                &lt;/span&gt;
                &lt;span style={{
                  fontSize: '0.875rem',
                  color: state.status === 'success' 
                    ? '#4CAF50' 
                    : state.status === 'error' 
                    ? '#f44336' 
                    : '#666'
                }}&gt;
                  {state.status === 'uploading' && `${state.progress}%`}
                  {state.status === 'success' && '‚úì Complete'}
                  {state.status === 'error' && '‚úó Failed'}
                &lt;/span&gt;
              &lt;/div&gt;

              {/* Progress Bar */}
              &lt;div style={{
                width: '100%',
                height: '8px',
                backgroundColor: '#e0e0e0',
                borderRadius: '4px',
                overflow: 'hidden'
              }}&gt;
                &lt;div style={{
                  width: `${state.progress}%`,
                  height: '100%',
                  backgroundColor: state.status === 'error' 
                    ? '#f44336' 
                    : state.status === 'success'
                    ? '#4CAF50'
                    : '#667eea',
                  transition: 'width 0.3s ease'
                }} /&gt;
              &lt;/div&gt;

              {state.error && (
                &lt;p style={{ 
                  color: '#f44336', 
                  fontSize: '0.875rem',
                  marginTop: '0.5rem'
                }}&gt;
                  {state.error}
                &lt;/p&gt;
              )}
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
};

export default FileUploadWithProgress;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Progress Bar Best Practices</h4>
                    <ul>
                        <li><strong>Show Percentage:</strong> Display numeric progress (e.g., "45%") alongside the bar</li>
                        <li><strong>Color Coding:</strong> Use colors to indicate status (blue for uploading, green for success, red for error)</li>
                        <li><strong>File Name:</strong> Always show which file is being uploaded</li>
                        <li><strong>Error Messages:</strong> Display specific error messages when uploads fail</li>
                        <li><strong>Smooth Animation:</strong> Use CSS transitions for smooth progress bar updates</li>
                        <li><strong>Multiple Files:</strong> Show individual progress for each file in multi-file uploads</li>
                    </ul>
                </div>

                <h3>Cancellable Uploads</h3>

                <p>Users should be able to cancel long-running uploads. Here's how to implement cancellation:</p>

                <pre><code class="language-typescript">const uploadFileWithCancellation = (
  file: File,
  url: string,
  onProgress: (progress: UploadProgress) => void
): { promise: Promise&lt;void&gt;; cancel: () => void } => {
  const xhr = new XMLHttpRequest();
  const formData = new FormData();
  formData.append('file', file);

  const promise = new Promise&lt;void&gt;((resolve, reject) => {
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percentComplete = (e.loaded / e.total) * 100;
        onProgress({
          fileName: file.name,
          progress: Math.round(percentComplete),
          loaded: e.loaded,
          total: e.total
        });
      }
    });

    xhr.addEventListener('load', () => {
      if (xhr.status >= 200 && xhr.status < 300) {
        resolve();
      } else {
        reject(new Error(`Upload failed with status ${xhr.status}`));
      }
    });

    xhr.addEventListener('error', () => {
      reject(new Error('Upload failed due to network error'));
    });

    xhr.addEventListener('abort', () => {
      reject(new Error('Upload was cancelled'));
    });

    xhr.open('POST', url);
    xhr.send(formData);
  });

  // Return both the promise and a cancel function
  return {
    promise,
    cancel: () => xhr.abort()
  };
};

// Usage with cancel button
const FileUploadWithCancel: React.FC = () => {
  const [uploadController, setUploadController] = useState&lt;{
    cancel: () => void;
  } | null&gt;(null);

  const handleUpload = async (file: File) => {
    const controller = uploadFileWithCancellation(
      file,
      '/api/upload',
      (progress) => {
        console.log(`Progress: ${progress.progress}%`);
      }
    );

    setUploadController(controller);

    try {
      await controller.promise;
      console.log('Upload complete!');
      setUploadController(null);
    } catch (error) {
      console.error('Upload failed or cancelled:', error);
      setUploadController(null);
    }
  };

  const handleCancel = () => {
    if (uploadController) {
      uploadController.cancel();
    }
  };

  return (
    &lt;div&gt;
      {uploadController && (
        &lt;button onClick={handleCancel}&gt;
          Cancel Upload
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Modern Alternative: Fetch with AbortController</h4>
                    <p>The Fetch API doesn't support upload progress natively, but you can use AbortController for cancellation:</p>
                    <pre><code class="language-typescript">const controller = new AbortController();

fetch('/api/upload', {
  method: 'POST',
  body: formData,
  signal: controller.signal
});

// To cancel:
controller.abort();</code></pre>
                    <p>However, for upload progress, XMLHttpRequest is still the best choice.</p>
                </div>

                <h3>Simulated Upload for Testing</h3>

                <p>When developing, you might not have a backend ready. Here's a simulated upload function for testing:</p>

                <pre><code class="language-typescript">const simulateUpload = (
  file: File,
  onProgress: (progress: UploadProgress) => void,
  durationMs: number = 3000
): Promise&lt;void&gt; => {
  return new Promise((resolve) => {
    const startTime = Date.now();
    const interval = 100; // Update every 100ms

    const timer = setInterval(() => {
      const elapsed = Date.now() - startTime;
      const progress = Math.min((elapsed / durationMs) * 100, 100);

      onProgress({
        fileName: file.name,
        progress: Math.round(progress),
        loaded: Math.round((file.size * progress) / 100),
        total: file.size
      });

      if (progress >= 100) {
        clearInterval(timer);
        resolve();
      }
    }, interval);
  });
};</code></pre>
            </section>

            <!-- Section 12: Integration with React Hook Form -->
            <section id="section12" class="lesson-section">
                <h2>üìù Integration with React Hook Form</h2>
                
                <p>File uploads often need to be part of larger forms‚Äîthink profile updates with avatar uploads, or product listings with multiple images. Let's integrate our file upload component with React Hook Form for complete form management.</p>

                <h3>Basic File Input with React Hook Form</h3>

                <pre><code class="language-typescript">import { useForm } from 'react-hook-form';

interface FormData {
  name: string;
  email: string;
  avatar: FileList;
}

const ProfileForm: React.FC = () => {
  const { register, handleSubmit, formState: { errors } } = useForm&lt;FormData&gt;();

  const onSubmit = (data: FormData) => {
    console.log('Form data:', data);
    
    // Access the file
    if (data.avatar && data.avatar.length > 0) {
      const file = data.avatar[0];
      console.log('Avatar file:', file);
      
      // Here you would upload the file
    }
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        &lt;input {...register('name', { required: 'Name is required' })} /&gt;
        {errors.name && &lt;span&gt;{errors.name.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input
          type="email"
          {...register('email', { required: 'Email is required' })}
        /&gt;
        {errors.email && &lt;span&gt;{errors.email.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Avatar:&lt;/label&gt;
        &lt;input
          type="file"
          accept="image/*"
          {...register('avatar', {
            required: 'Avatar is required',
            validate: {
              fileSize: (files: FileList) => {
                if (!files || files.length === 0) return true;
                const file = files[0];
                const maxSize = 5 * 1024 * 1024; // 5MB
                return file.size <= maxSize || 'File must be less than 5MB';
              },
              fileType: (files: FileList) => {
                if (!files || files.length === 0) return true;
                const file = files[0];
                const allowedTypes = ['image/jpeg', 'image/png', 'image/webp'];
                return allowedTypes.includes(file.type) || 
                  'File must be JPEG, PNG, or WebP';
              }
            }
          })}
        /&gt;
        {errors.avatar && &lt;span&gt;{errors.avatar.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ File Validation with React Hook Form</h4>
                    <p>React Hook Form's <code>validate</code> option lets you add custom validation functions that receive the FileList. You can check file size, type, count, and even image dimensions (though that requires async validation).</p>
                </div>

                <h3>Custom Controller for File Upload Component</h3>

                <p>If you have a custom file upload component (like our drag-drop component), use React Hook Form's <code>Controller</code>:</p>

                <pre><code class="language-typescript">import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

// Define schema
const profileSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Invalid email address'),
  avatar: z
    .custom&lt;File&gt;((file) => file instanceof File, 'Avatar is required')
    .refine(
      (file) => file.size <= 5 * 1024 * 1024,
      'File must be less than 5MB'
    )
    .refine(
      (file) => ['image/jpeg', 'image/png', 'image/webp'].includes(file.type),
      'File must be JPEG, PNG, or WebP'
    )
});

type ProfileFormData = z.infer&lt;typeof profileSchema&gt;;

const ProfileFormWithCustomComponent: React.FC = () => {
  const {
    control,
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;ProfileFormData&gt;({
    resolver: zodResolver(profileSchema)
  });

  const onSubmit = async (data: ProfileFormData) => {
    console.log('Submitting:', data);
    
    // Upload the file
    const formData = new FormData();
    formData.append('name', data.name);
    formData.append('email', data.email);
    formData.append('avatar', data.avatar);

    try {
      const response = await fetch('/api/profile', {
        method: 'POST',
        body: formData
      });
      
      if (response.ok) {
        alert('Profile updated successfully!');
      }
    } catch (error) {
      console.error('Upload failed:', error);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;label&gt;Name:&lt;/label&gt;
        &lt;input {...register('name')} /&gt;
        {errors.name && &lt;span&gt;{errors.name.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Email:&lt;/label&gt;
        &lt;input type="email" {...register('email')} /&gt;
        {errors.email && &lt;span&gt;{errors.email.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Avatar:&lt;/label&gt;
        &lt;Controller
          name="avatar"
          control={control}
          render={({ field: { onChange, value } }) => (
            &lt;div&gt;
              &lt;input
                type="file"
                accept="image/*"
                onChange={(e) => {
                  const file = e.target.files?.[0];
                  if (file) {
                    onChange(file);
                  }
                }}
              /&gt;
              {value && (
                &lt;div style={{ marginTop: '0.5rem' }}&gt;
                  &lt;p&gt;Selected: {value.name}&lt;/p&gt;
                  &lt;img
                    src={URL.createObjectURL(value)}
                    alt="Preview"
                    style={{ maxWidth: '200px', maxHeight: '200px' }}
                  /&gt;
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          )}
        /&gt;
        {errors.avatar && &lt;span&gt;{errors.avatar.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Update Profile&lt;/button&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Controller Component</h4>
                    <p style="color: white;"><strong>Controller:</strong> A React Hook Form component that wraps controlled components (like custom inputs) and connects them to the form state. It provides <code>field</code> props (value, onChange, onBlur) that you use to connect your custom component to the form.</p>
                </div>

                <h3>Multiple File Upload with React Hook Form</h3>

                <pre><code class="language-typescript">import { z } from 'zod';

const gallerySchema = z.object({
  title: z.string().min(3, 'Title is required'),
  description: z.string().optional(),
  images: z
    .array(z.custom&lt;File&gt;((file) => file instanceof File))
    .min(1, 'At least one image is required')
    .max(10, 'Maximum 10 images allowed')
    .refine(
      (files) => files.every(file => file.size <= 5 * 1024 * 1024),
      'Each file must be less than 5MB'
    )
    .refine(
      (files) => files.every(file => 
        ['image/jpeg', 'image/png', 'image/webp'].includes(file.type)
      ),
      'All files must be JPEG, PNG, or WebP'
    )
});

type GalleryFormData = z.infer&lt;typeof gallerySchema&gt;;

const GalleryForm: React.FC = () => {
  const {
    control,
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;GalleryFormData&gt;({
    resolver: zodResolver(gallerySchema),
    defaultValues: {
      images: []
    }
  });

  const onSubmit = async (data: GalleryFormData) => {
    console.log('Gallery data:', data);

    // Create FormData for upload
    const formData = new FormData();
    formData.append('title', data.title);
    if (data.description) {
      formData.append('description', data.description);
    }
    
    // Append all images
    data.images.forEach((file, index) => {
      formData.append(`images[${index}]`, file);
    });

    // Upload to server
    try {
      const response = await fetch('/api/gallery', {
        method: 'POST',
        body: formData
      });
      
      if (response.ok) {
        alert('Gallery created successfully!');
      }
    } catch (error) {
      console.error('Upload failed:', error);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div&gt;
        &lt;label&gt;Gallery Title:&lt;/label&gt;
        &lt;input {...register('title')} /&gt;
        {errors.title && &lt;span&gt;{errors.title.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Description:&lt;/label&gt;
        &lt;textarea {...register('description')} /&gt;
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label&gt;Images:&lt;/label&gt;
        &lt;Controller
          name="images"
          control={control}
          render={({ field: { onChange, value } }) => (
            &lt;div&gt;
              &lt;input
                type="file"
                multiple
                accept="image/*"
                onChange={(e) => {
                  const files = e.target.files;
                  if (files) {
                    onChange(Array.from(files));
                  }
                }}
              /&gt;
              {value && value.length > 0 && (
                &lt;div style={{
                  display: 'grid',
                  gridTemplateColumns: 'repeat(auto-fill, minmax(150px, 1fr))',
                  gap: '1rem',
                  marginTop: '1rem'
                }}&gt;
                  {value.map((file, index) => (
                    &lt;div key={index}&gt;
                      &lt;img
                        src={URL.createObjectURL(file)}
                        alt={`Preview ${index}`}
                        style={{
                          width: '100%',
                          height: '150px',
                          objectFit: 'cover',
                          borderRadius: '8px'
                        }}
                      /&gt;
                      &lt;p style={{ fontSize: '0.75rem', marginTop: '0.25rem' }}&gt;
                        {file.name}
                      &lt;/p&gt;
                    &lt;/div&gt;
                  ))}
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          )}
        /&gt;
        {errors.images && &lt;span&gt;{errors.images.message}&lt;/span&gt;}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Create Gallery&lt;/button&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° FormData Best Practices</h4>
                    <ul>
                        <li><strong>Multiple Files:</strong> Use array notation like <code>images[0]</code>, <code>images[1]</code> or just append multiple times with the same key</li>
                        <li><strong>Mixed Content:</strong> FormData can contain both files and regular form fields</li>
                        <li><strong>No JSON:</strong> Don't try to JSON.stringify FormData‚Äîsend it as-is</li>
                        <li><strong>Content-Type:</strong> Don't set Content-Type header manually‚Äîbrowser sets it automatically with the correct boundary</li>
                    </ul>
                </div>
            </section>

            <!-- Section 13: Best Practices and Security -->
            <section id="section13" class="lesson-section">
                <h2>üîí Best Practices and Security</h2>
                
                <p>File uploads can be a security risk if not handled properly. Let's cover essential best practices and security considerations for safe file handling.</p>

                <h3>Client-Side Security Considerations</h3>

                <h4>1. Never Trust File Extensions or MIME Types</h4>

                <p>Malicious users can rename files or modify MIME types. Always validate on the server side:</p>

                <pre><code class="language-typescript">// ‚ùå BAD: Only checking extension
const isImage = filename.endsWith('.jpg');

// ‚ùå BAD: Only checking MIME type
const isImage = file.type.startsWith('image/');

// ‚úÖ BETTER: Check both (but still validate server-side!)
const isValidImage = (file: File): boolean => {
  const validTypes = ['image/jpeg', 'image/png', 'image/webp'];
  const validExtensions = ['.jpg', '.jpeg', '.png', '.webp'];
  
  const hasValidType = validTypes.includes(file.type);
  const hasValidExtension = validExtensions.some(ext => 
    file.name.toLowerCase().endsWith(ext)
  );
  
  return hasValidType && hasValidExtension;
};</code></pre>

                <h4>2. Validate File Content (Magic Numbers)</h4>

                <p>For extra security, check file "magic numbers" (file signatures in the first bytes):</p>

                <pre><code class="language-typescript">const checkFileSignature = async (file: File): Promise&lt;boolean&gt; => {
  // Read first few bytes
  const buffer = await file.slice(0, 4).arrayBuffer();
  const bytes = new Uint8Array(buffer);
  
  // Check magic numbers for common image formats
  // JPEG: FF D8 FF
  if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
    return true;
  }
  
  // PNG: 89 50 4E 47
  if (bytes[0] === 0x89 && bytes[1] === 0x50 && 
      bytes[2] === 0x4E && bytes[3] === 0x47) {
    return true;
  }
  
  // WebP: 52 49 46 46
  if (bytes[0] === 0x52 && bytes[1] === 0x49 && 
      bytes[2] === 0x46 && bytes[3] === 0x46) {
    return true;
  }
  
  return false;
};</code></pre>

                <h4>3. Limit File Sizes</h4>

                <pre><code class="language-typescript">// Set reasonable limits based on your use case
const MAX_FILE_SIZE = {
  avatar: 2 * 1024 * 1024,      // 2MB for avatars
  document: 10 * 1024 * 1024,   // 10MB for documents
  video: 100 * 1024 * 1024      // 100MB for videos
};</code></pre>

                <h4>4. Sanitize File Names</h4>

                <pre><code class="language-typescript">const sanitizeFileName = (filename: string): string => {
  return filename
    .toLowerCase()
    .replace(/[^a-z0-9.-]/g, '_')  // Replace invalid chars with underscore
    .replace(/_{2,}/g, '_')        // Replace multiple underscores with one
    .replace(/^_|_$/g, '');        // Remove leading/trailing underscores
};

// Usage
const safeFilename = sanitizeFileName(file.name);
// "My Photo (1).jpg" ‚Üí "my_photo_1.jpg"</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Critical Server-Side Security</h4>
                    <p>Remember: <strong>All client-side validation can be bypassed!</strong> Always validate files on the server:</p>
                    <ul>
                        <li>Re-validate file type, size, and content</li>
                        <li>Scan for malware/viruses</li>
                        <li>Store files outside the web root or serve through a CDN</li>
                        <li>Use random file names (don't trust user-provided names)</li>
                        <li>Set proper Content-Type headers when serving files</li>
                        <li>Implement rate limiting to prevent abuse</li>
                        <li>Use signed URLs for sensitive files</li>
                    </ul>
                </div>

                <h3>Performance Best Practices</h3>

                <h4>1. Use Object URLs for Previews</h4>

                <pre><code class="language-typescript">// ‚úÖ GOOD: Fast and memory-efficient
const url = URL.createObjectURL(file);
// Remember to revoke when done!
URL.revokeObjectURL(url);</code></pre>

                <h4>2. Compress Images Before Upload</h4>

                <p>Reduce file sizes client-side to save bandwidth and storage:</p>

                <pre><code class="language-typescript">const compressImage = (
  file: File,
  maxWidth: number = 1920,
  maxHeight: number = 1080,
  quality: number = 0.8
): Promise&lt;Blob&gt; => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    img.onload = () => {
      let { width, height } = img;

      // Calculate new dimensions
      if (width > maxWidth) {
        height = (height * maxWidth) / width;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width = (width * maxHeight) / height;
        height = maxHeight;
      }

      canvas.width = width;
      canvas.height = height;

      // Draw and compress
      ctx?.drawImage(img, 0, 0, width, height);
      
      canvas.toBlob(
        (blob) => {
          if (blob) {
            resolve(blob);
          } else {
            reject(new Error('Compression failed'));
          }
        },
        'image/jpeg',
        quality
      );

      URL.revokeObjectURL(img.src);
    };

    img.onerror = reject;
    img.src = URL.createObjectURL(file);
  });
};</code></pre>

                <h4>3. Lazy Load Preview Images</h4>

                <pre><code class="language-typescript">// Use loading="lazy" for preview images
&lt;img 
  src={preview} 
  alt="Preview" 
  loading="lazy"
  style={{ maxWidth: '200px' }}
/&gt;</code></pre>

                <h4>4. Debounce Validation</h4>

                <p>If validating dimensions or other async checks, debounce to avoid excessive processing:</p>

                <pre><code class="language-typescript">import { useState, useEffect } from 'react';

const useDebounce = &lt;T,&gt;(value: T, delay: number): T => {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};</code></pre>

                <h3>UX Best Practices</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Good User Experience</h4>
                    <ul>
                        <li><strong>Clear Instructions:</strong> Tell users what files are accepted and size limits</li>
                        <li><strong>Immediate Feedback:</strong> Show errors right away, not after form submission</li>
                        <li><strong>Progress Indication:</strong> Always show progress for uploads that take >2 seconds</li>
                        <li><strong>Cancellation:</strong> Allow users to cancel long uploads</li>
                        <li><strong>Error Recovery:</strong> Let users retry failed uploads without reselecting files</li>
                        <li><strong>Multiple Methods:</strong> Support both click and drag-drop</li>
                        <li><strong>Mobile-Friendly:</strong> Test on mobile devices, ensure touch targets are large enough</li>
                        <li><strong>Accessibility:</strong> Use proper labels, ARIA attributes, keyboard navigation</li>
                    </ul>
                </div>

                <h3>Accessibility Checklist</h3>

                <pre><code class="language-html">&lt;!-- ‚úÖ Good: Accessible file upload --&gt;
&lt;div role="region" aria-label="File upload"&gt;
  &lt;label htmlFor="file-upload" id="file-label"&gt;
    Upload your document
    &lt;span class="hint"&gt;(Max 5MB, PDF or Word)&lt;/span&gt;
  &lt;/label&gt;
  
  &lt;input
    id="file-upload"
    type="file"
    accept=".pdf,.doc,.docx"
    aria-describedby="file-hint file-error"
  /&gt;
  
  &lt;p id="file-hint" class="hint"&gt;
    Choose a file or drag and drop it here
  &lt;/p&gt;
  
  &lt;div id="file-error" role="alert" aria-live="polite"&gt;
    {/* Error messages appear here */}
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Testing Your File Upload</h4>
                    <p>Always test with:</p>
                    <ul>
                        <li>Various file sizes (tiny, normal, huge)</li>
                        <li>Different file types (valid and invalid)</li>
                        <li>Multiple files at once</li>
                        <li>Slow network conditions</li>
                        <li>Mobile devices and touch interactions</li>
                        <li>Screen readers and keyboard-only navigation</li>
                        <li>Edge cases (empty files, corrupted files, same file twice)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 14: Hands-On Exercises -->
            <section id="section14" class="lesson-section">
                <h2>üèãÔ∏è Hands-On Exercises</h2>
                
                <p>Now it's time to practice! Work through these exercises to solidify your understanding of file uploads in React.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Profile Picture Upload</h3>
                    <p><strong>Objective:</strong> Create a profile picture upload component with preview, validation, and crop suggestion.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Single image upload (click or drag-drop)</li>
                        <li>Validate: only JPEG/PNG, max 5MB, minimum 200x200px</li>
                        <li>Show preview in a circular frame (like a profile picture)</li>
                        <li>Display file name and size</li>
                        <li>Clear/remove button</li>
                        <li>Show error messages for invalid files</li>
                    </ol>
                    
                    <h4>Bonus Challenges:</h4>
                    <ul>
                        <li>Add a "crop to square" suggestion if image isn't square</li>
                        <li>Implement basic image compression before upload</li>
                        <li>Add a "take photo" option for mobile devices</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>URL.createObjectURL()</code> for the preview and <code>validateImageDimensions()</code> function from earlier for dimension checking. For the circular frame, use CSS: <code>border-radius: 50%; overflow: hidden;</code></p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <ol>
                            <li>Create state for file, preview URL, errors, and loading</li>
                            <li>Implement file selection handler with validation</li>
                            <li>Check dimensions using Image element</li>
                            <li>Create object URL for preview</li>
                            <li>Display preview in circular container</li>
                            <li>Implement clear function that revokes URL</li>
                            <li>Clean up URL in useEffect cleanup</li>
                        </ol>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Multi-Image Gallery Upload</h3>
                    <p><strong>Objective:</strong> Build a component for uploading multiple images for a photo gallery.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Support multiple image selection (up to 10 images)</li>
                        <li>Drag and drop support</li>
                        <li>Grid preview of all selected images</li>
                        <li>Individual remove button for each image</li>
                        <li>Add more images without replacing existing ones</li>
                        <li>Validate each image (type, size)</li>
                        <li>Show count (e.g., "5/10 images selected")</li>
                    </ol>
                    
                    <h4>Bonus Challenges:</h4>
                    <ul>
                        <li>Allow reordering images by drag-drop</li>
                        <li>Add "set as cover image" functionality</li>
                        <li>Implement batch actions (clear all, remove invalid)</li>
                        <li>Show total size of all images</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use an array of objects with structure <code>{ file: File, preview: string, id: string }</code>. For adding more files, use <code>setFiles(prev => [...prev, ...newFiles])</code> instead of replacing. Remember to revoke all URLs on unmount!</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Document Upload Form</h3>
                    <p><strong>Objective:</strong> Create a complete form with document upload using React Hook Form and Zod.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Form fields: title, description, category (dropdown)</li>
                        <li>File upload field for PDF documents</li>
                        <li>Validate: PDF only, max 10MB, required</li>
                        <li>Show document icon preview (since PDFs can't be image-previewed easily)</li>
                        <li>Integrate with React Hook Form using Controller</li>
                        <li>Use Zod for validation schema</li>
                        <li>Display validation errors properly</li>
                        <li>On submit, create FormData and log it</li>
                    </ol>
                    
                    <h4>Bonus Challenges:</h4>
                    <ul>
                        <li>Support multiple file formats (PDF, DOC, DOCX)</li>
                        <li>Show number of pages in PDF (use pdf.js library)</li>
                        <li>Implement upload progress simulation</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>z.custom&lt;File&gt;()</code> for file validation in Zod. For the document icon, you can use an emoji or SVG icon since PDFs can't be previewed as images directly without additional libraries.</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 4: Upload with Progress and Cancellation</h3>
                    <p><strong>Objective:</strong> Implement a file upload component with real-time progress tracking and ability to cancel.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>File selection (any type, max 50MB for testing)</li>
                        <li>Start upload button</li>
                        <li>Progress bar showing percentage</li>
                        <li>Display upload speed and time remaining estimates</li>
                        <li>Cancel button that actually stops the upload</li>
                        <li>Success message with uploaded file details</li>
                        <li>Error handling with retry option</li>
                        <li>Use simulated upload function (provided earlier)</li>
                    </ol>
                    
                    <h4>Bonus Challenges:</h4>
                    <ul>
                        <li>Implement chunked upload (split file into chunks)</li>
                        <li>Add resume capability for failed uploads</li>
                        <li>Queue multiple files and upload sequentially</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use the <code>simulateUpload</code> or <code>uploadFileWithProgress</code> functions from earlier. Store upload state including progress percentage, loaded bytes, and total bytes. Calculate speed as bytes/second and estimate remaining time.</p>
                    </details>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem; margin-top: 2rem;">
                    <h3 style="color: white;">üéØ Challenge Project</h3>
                    <p style="color: white;"><strong>Build a Complete Image Upload System</strong></p>
                    <p style="color: white;">Combine everything you've learned to create a production-ready image upload component with:</p>
                    <ul style="color: white; text-align: left;">
                        <li>Drag-and-drop interface</li>
                        <li>Multiple image support</li>
                        <li>Individual upload progress for each image</li>
                        <li>Image previews with zoom</li>
                        <li>Validation (type, size, dimensions)</li>
                        <li>Integration with React Hook Form</li>
                        <li>Mobile-responsive design</li>
                        <li>Accessibility features</li>
                    </ul>
                    <p style="color: white;">This will be a portfolio-worthy component!</p>
                </div>
            </section>

            <!-- Section 15: Summary and Additional Resources -->
            <section id="section15" class="lesson-section">
                <h2>üìö Summary and Next Steps</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>File Input Basics:</strong> Understanding the HTML file input, FileList, and File objects</li>
                        <li><strong>File Previews:</strong> Two approaches - FileReader (data URLs) and Object URLs (blob URLs)</li>
                        <li><strong>Validation:</strong> Client-side validation for file type, size, and image dimensions</li>
                        <li><strong>Multiple Files:</strong> Handling multiple file selection and managing arrays of files</li>
                        <li><strong>Drag and Drop:</strong> Implementing intuitive drag-drop interfaces with proper event handling</li>
                        <li><strong>Upload Progress:</strong> Tracking and displaying upload progress with XMLHttpRequest</li>
                        <li><strong>Form Integration:</strong> Using file uploads with React Hook Form and Zod validation</li>
                        <li><strong>Security:</strong> Understanding security risks and implementing proper validation</li>
                        <li><strong>Performance:</strong> Optimizing with Object URLs, compression, and lazy loading</li>
                        <li><strong>UX Best Practices:</strong> Creating accessible, user-friendly upload experiences</li>
                    </ul>
                </div>

                <h3>üìñ Additional Resources</h3>
                
                <h4>Official Documentation</h4>
                <ul>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/File" target="_blank">MDN: File API</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader" target="_blank">MDN: FileReader</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank">MDN: Drag and Drop API</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank">MDN: FormData</a></li>
                    <li><a href="https://react-hook-form.com/" target="_blank">React Hook Form Documentation</a></li>
                </ul>

                <h4>Libraries and Tools</h4>
                <ul>
                    <li><strong>react-dropzone:</strong> Popular drag-drop file upload library</li>
                    <li><strong>react-image-crop:</strong> Image cropping component</li>
                    <li><strong>compressor.js:</strong> Client-side image compression</li>
                    <li><strong>pdf.js:</strong> PDF viewing and manipulation</li>
                    <li><strong>uppy:</strong> Complete file upload solution with many features</li>
                </ul>

                <h4>Advanced Topics to Explore</h4>
                <ul>
                    <li><strong>Chunked Uploads:</strong> Splitting large files for reliable uploads</li>
                    <li><strong>Resumable Uploads:</strong> Continuing interrupted uploads</li>
                    <li><strong>Image Manipulation:</strong> Cropping, rotating, filters before upload</li>
                    <li><strong>WebRTC:</strong> Camera/video capture directly in the browser</li>
                    <li><strong>Service Workers:</strong> Background uploads that survive page refresh</li>
                    <li><strong>Direct-to-S3 Upload:</strong> Uploading directly to cloud storage</li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                
                <p>Now that you've mastered file uploads, you can:</p>
                
                <ul>
                    <li><strong>Build Real Applications:</strong> Add file upload features to your projects</li>
                    <li><strong>Explore Advanced Patterns:</strong> Learn about multi-step forms and wizards</li>
                    <li><strong>Backend Integration:</strong> Connect your uploads to real server endpoints</li>
                    <li><strong>Cloud Storage:</strong> Learn to upload directly to AWS S3, Cloudinary, or Firebase</li>
                    <li><strong>Image Processing:</strong> Explore client-side image manipulation libraries</li>
                </ul>

                <p>In the next lesson, we'll explore <strong>Advanced Form Patterns</strong> including multi-step forms, conditional fields, and form wizards!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem; margin-top: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've completed the File Uploads lesson!</p>
                    <p style="color: white;">You now have the skills to build professional file upload experiences in React with TypeScript. From basic file inputs to complete drag-and-drop systems with validation and progress tracking, you're ready to handle any file upload requirement in your applications!</p>
                    <p style="color: white; margin-top: 1rem;">Keep practicing and building! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_7_3_form_validation_zod_d.html" class="prev-lesson">‚Üê Previous: Lesson 7.3 Form Validation with Zod</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_7_5_advanced_form_patterns.html" class="next-lesson">Next: Lesson 7.5 Advanced Form Patterns ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals through comprehensive React and TypeScript education.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
