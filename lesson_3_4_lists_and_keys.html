<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master rendering lists in React - Learn the key prop, array methods, CRUD operations, and list performance optimization with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>Lists and Keys - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module3">Module 3: State and Interactivity</a></li>
            <li aria-current="page">Lesson 3.4: Lists and Keys</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üìú Lists and Keys</h1>
                <p class="lead">Real applications work with collections of data - users, products, posts, comments, messages, and more. Rendering lists efficiently is a fundamental React skill. But there's a catch: React needs a special "key" prop to track items in lists. Get it wrong, and you'll have bugs that are hard to debug. Get it right, and your lists will be fast, predictable, and bug-free. In this lesson, you'll master rendering lists, understand why keys matter, and learn how to perform CRUD operations on dynamic lists. Let's make lists awesome! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Render arrays of data using map()</li>
                        <li>Understand why the key prop is critical</li>
                        <li>Choose appropriate keys for different scenarios</li>
                        <li>Implement CRUD operations on lists</li>
                        <li>Use filter(), reduce(), and other array methods</li>
                        <li>Type arrays properly with TypeScript</li>
                        <li>Handle empty lists gracefully</li>
                        <li>Optimize list rendering performance</li>
                        <li>Build dynamic, interactive lists</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 70-85 minutes</p>
                    <p><strong>Project:</strong> Build an enhanced todo list with filtering, sorting, and search</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Rendering Lists</a></li>
                        <li><a href="#section2" class="toc-link">The Key Prop</a></li>
                        <li><a href="#section3" class="toc-link">Choosing Good Keys</a></li>
                        <li><a href="#section4" class="toc-link">Array Methods (map, filter, reduce)</a></li>
                        <li><a href="#section5" class="toc-link">CRUD Operations</a></li>
                        <li><a href="#section6" class="toc-link">Typing Lists with TypeScript</a></li>
                        <li><a href="#section7" class="toc-link">Empty States and Conditional Lists</a></li>
                        <li><a href="#section8" class="toc-link">List Performance</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Rendering Lists -->
            <section id="section1" class="lesson-section">
                <h2>üìã Rendering Lists</h2>
                <p>In React, you render lists by transforming arrays of data into arrays of JSX elements using JavaScript's map() function.</p>

                <h3>Basic List Rendering</h3>
                <div class="card">
                    <h4>Simple Array to JSX</h4>
                    <pre><code class="language-typescript">const SimpleList: React.FC = () => {
    const fruits = ['Apple', 'Banana', 'Cherry', 'Date'];
    
    return (
        &lt;ul&gt;
            {fruits.map((fruit, index) => (
                &lt;li key={index}&gt;{fruit}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};

// Renders:
// ‚Ä¢ Apple
// ‚Ä¢ Banana
// ‚Ä¢ Cherry
// ‚Ä¢ Date</code></pre>
                </div>

                <h3>How map() Works</h3>
                <div class="card">
                    <h4>Understanding the Transformation</h4>
                    <pre><code class="language-typescript">// What we start with
const numbers = [1, 2, 3];

// map() transforms each item
const doubled = numbers.map(num => num * 2);
// [2, 4, 6]

// In React, we transform data into JSX
const listItems = numbers.map(num => &lt;li&gt;{num}&lt;/li&gt;);
// [&lt;li&gt;1&lt;/li&gt;, &lt;li&gt;2&lt;/li&gt;, &lt;li&gt;3&lt;/li&gt;]

// JSX expression:
&lt;ul&gt;{listItems}&lt;/ul&gt;</code></pre>
                </div>

                <h3>Rendering Objects</h3>
                <div class="card">
                    <h4>Lists of Objects</h4>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
}

const UserList: React.FC = () => {
    const users: User[] = [
        { id: 1, name: 'Alice', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="284944414b4d684d50494558444d064b4745">[email&#160;protected]</a>' },
        { id: 2, name: 'Bob', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84e6ebe6c4e1fce5e9f4e8e1aae7ebe9">[email&#160;protected]</a>' },
        { id: 3, name: 'Charlie', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="64070c0516080d0124011c05091408014a070b09">[email&#160;protected]</a>' }
    ];
    
    return (
        &lt;div&gt;
            {users.map(user => (
                &lt;div key={user.id} style={{ padding: '1rem', border: '1px solid #ddd', marginBottom: '0.5rem' }}&gt;
                    &lt;h3&gt;{user.name}&lt;/h3&gt;
                    &lt;p&gt;{user.email}&lt;/p&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Common Pattern: Extract to Component</h3>
                <div class="card">
                    <h4>Keep It Clean</h4>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
}

// Individual item component
interface UserCardProps {
    user: User;
}

const UserCard: React.FC&lt;UserCardProps&gt; = ({ user }) => (
    &lt;div style={{ padding: '1rem', border: '1px solid #ddd', marginBottom: '0.5rem' }}&gt;
        &lt;h3&gt;{user.name}&lt;/h3&gt;
        &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
);

// List component
const UserList: React.FC = () => {
    const users: User[] = [
        { id: 1, name: 'Alice', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4b2a2722282e0b2e332a263b272e65282426">[email&#160;protected]</a>' },
        { id: 2, name: 'Bob', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e0828f82a08598818d908c85ce838f8d">[email&#160;protected]</a>' },
        { id: 3, name: 'Charlie', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3c5f545d4e5055597c59445d514c5059125f5351">[email&#160;protected]</a>' }
    ];
    
    return (
        &lt;div&gt;
            {users.map(user => (
                &lt;UserCard key={user.id} user={user} /&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                    <p>‚úÖ This is cleaner and more maintainable!</p>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>The pattern is always the same:</p>
                    <ol>
                        <li>Have an array of data</li>
                        <li>Use <code>.map()</code> to transform each item</li>
                        <li>Return JSX for each item</li>
                        <li>Add a unique <code>key</code> prop</li>
                    </ol>
                </div>
            </section>

            <!-- Section 2: The Key Prop -->
            <section id="section2" class="lesson-section">
                <h2>üîë The Key Prop</h2>
                <p>The key prop is one of React's most misunderstood features. Let's demystify it!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Key Prop:</strong> A special attribute that helps React identify which items have changed, been added, or been removed. Keys give list items a stable identity.</p>
                </div>

                <h3>Why Keys Matter</h3>
                <div class="card">
                    <h4>What Happens Without Keys?</h4>
                    <pre><code class="language-typescript">// ‚ùå Bad: No keys
&lt;ul&gt;
    {items.map(item => &lt;li&gt;{item}&lt;/li&gt;)}
&lt;/ul&gt;

// React console warning:
// Warning: Each child in a list should have a unique "key" prop.</code></pre>
                    <p>Without keys, React doesn't know which element is which. This causes:</p>
                    <ul>
                        <li>‚ö†Ô∏è React warns in console</li>
                        <li>‚ö†Ô∏è Potential rendering bugs</li>
                        <li>‚ö†Ô∏è Poor performance on updates</li>
                        <li>‚ö†Ô∏è State can get mixed up</li>
                    </ul>
                </div>

                <h3>How Keys Work</h3>
                <pre class="mermaid">
graph TD
    A[Array Changes] --> B{React compares keys}
    B -->|Same key| C[Update element]
    B -->|New key| D[Create new element]
    B -->|Key removed| E[Delete element]
    B -->|Key moved| F[Move element]
    
    style C fill:#4CAF50,color:#fff
    style D fill:#2196F3,color:#fff
    style E fill:#f44336,color:#fff
    style F fill:#FF9800,color:#fff
</pre>

                <h3>Keys Must Be Unique Among Siblings</h3>
                <div class="card">
                    <h4>Uniqueness Rules</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Unique keys among siblings
&lt;ul&gt;
    {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
    ))}
&lt;/ul&gt;

// ‚úÖ Also good: Different lists can reuse keys
&lt;div&gt;
    &lt;ul&gt;
        {users.map(user => &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;)}

                <h3>üé® How Keys Help React Track Items</h3>
                <svg viewBox="0 0 850 420" style="width: 100%; max-width: 850px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <defs>
                        <marker id="keyArrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#667eea"/>
                        </marker>
                    </defs>
                    
                    <text x="425" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="15">Keys Tell React Which Items Changed</text>
                    
                    <!-- WITH GOOD KEYS -->
                    <g transform="translate(20, 50)">
                        <rect x="0" y="0" width="390" height="350" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <rect x="0" y="0" width="390" height="35" rx="10" fill="#4CAF50"/>
                        <rect x="0" y="25" width="390" height="10" fill="#4CAF50"/>
                        <text x="195" y="25" text-anchor="middle" fill="white" font-weight="bold" font-size="13">‚úÖ With Stable Keys (IDs)</text>
                        
                        <!-- Before state -->
                        <text x="20" y="60" fill="#333" font-size="11" font-weight="bold">Before: ["A", "B", "C"]</text>
                        <rect x="20" y="70" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="60" y="90" text-anchor="middle" fill="#333" font-size="10">key="a" ‚Üí A</text>
                        <rect x="110" y="70" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="150" y="90" text-anchor="middle" fill="#333" font-size="10">key="b" ‚Üí B</text>
                        <rect x="200" y="70" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="240" y="90" text-anchor="middle" fill="#333" font-size="10">key="c" ‚Üí C</text>
                        
                        <!-- Arrow -->
                        <text x="195" y="125" text-anchor="middle" fill="#666" font-size="10">Insert "D" at position 1</text>
                        <line x1="195" y1="130" x2="195" y2="150" stroke="#667eea" stroke-width="2" marker-end="url(#keyArrow)"/>
                        
                        <!-- After state -->
                        <text x="20" y="175" fill="#333" font-size="11" font-weight="bold">After: ["A", "D", "B", "C"]</text>
                        <rect x="20" y="185" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="60" y="205" text-anchor="middle" fill="#4CAF50" font-size="10">key="a" ‚Üí A</text>
                        <text x="60" y="220" text-anchor="middle" fill="#999" font-size="8">Reused ‚úì</text>
                        
                        <rect x="110" y="185" width="80" height="30" rx="4" fill="#C8E6C9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="150" y="205" text-anchor="middle" fill="#2E7D32" font-size="10" font-weight="bold">key="d" ‚Üí D</text>
                        <text x="150" y="220" text-anchor="middle" fill="#2E7D32" font-size="8">NEW! ‚úì</text>
                        
                        <rect x="200" y="185" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="240" y="205" text-anchor="middle" fill="#4CAF50" font-size="10">key="b" ‚Üí B</text>
                        <text x="240" y="220" text-anchor="middle" fill="#999" font-size="8">Moved ‚úì</text>
                        
                        <rect x="290" y="185" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="330" y="205" text-anchor="middle" fill="#4CAF50" font-size="10">key="c" ‚Üí C</text>
                        <text x="330" y="220" text-anchor="middle" fill="#999" font-size="8">Moved ‚úì</text>
                        
                        <!-- Result -->
                        <rect x="20" y="260" width="350" height="75" rx="6" fill="#C8E6C9"/>
                        <text x="195" y="285" text-anchor="middle" fill="#2E7D32" font-size="11" font-weight="bold">Result: React understands!</text>
                        <text x="195" y="305" text-anchor="middle" fill="#333" font-size="10">‚Ä¢ Creates 1 new element (D)</text>
                        <text x="195" y="320" text-anchor="middle" fill="#333" font-size="10">‚Ä¢ Reuses A, moves B and C</text>
                    </g>
                    
                    <!-- WITH INDEX KEYS -->
                    <g transform="translate(440, 50)">
                        <rect x="0" y="0" width="390" height="350" rx="10" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                        <rect x="0" y="0" width="390" height="35" rx="10" fill="#f44336"/>
                        <rect x="0" y="25" width="390" height="10" fill="#f44336"/>
                        <text x="195" y="25" text-anchor="middle" fill="white" font-weight="bold" font-size="13">‚ö†Ô∏è With Index as Key</text>
                        
                        <!-- Before state -->
                        <text x="20" y="60" fill="#333" font-size="11" font-weight="bold">Before: ["A", "B", "C"]</text>
                        <rect x="20" y="70" width="80" height="30" rx="4" fill="white" stroke="#f44336" stroke-width="2"/>
                        <text x="60" y="90" text-anchor="middle" fill="#333" font-size="10">key=0 ‚Üí A</text>
                        <rect x="110" y="70" width="80" height="30" rx="4" fill="white" stroke="#f44336" stroke-width="2"/>
                        <text x="150" y="90" text-anchor="middle" fill="#333" font-size="10">key=1 ‚Üí B</text>
                        <rect x="200" y="70" width="80" height="30" rx="4" fill="white" stroke="#f44336" stroke-width="2"/>
                        <text x="240" y="90" text-anchor="middle" fill="#333" font-size="10">key=2 ‚Üí C</text>
                        
                        <!-- Arrow -->
                        <text x="195" y="125" text-anchor="middle" fill="#666" font-size="10">Insert "D" at position 1</text>
                        <line x1="195" y1="130" x2="195" y2="150" stroke="#667eea" stroke-width="2" marker-end="url(#keyArrow)"/>
                        
                        <!-- After state -->
                        <text x="20" y="175" fill="#333" font-size="11" font-weight="bold">After: ["A", "D", "B", "C"]</text>
                        <rect x="20" y="185" width="80" height="30" rx="4" fill="white" stroke="#4CAF50" stroke-width="2"/>
                        <text x="60" y="205" text-anchor="middle" fill="#4CAF50" font-size="10">key=0 ‚Üí A</text>
                        <text x="60" y="220" text-anchor="middle" fill="#999" font-size="8">OK ‚úì</text>
                        
                        <rect x="110" y="185" width="80" height="30" rx="4" fill="#FFCDD2" stroke="#f44336" stroke-width="2"/>
                        <text x="150" y="205" text-anchor="middle" fill="#c62828" font-size="10">key=1 ‚Üí D</text>
                        <text x="150" y="220" text-anchor="middle" fill="#c62828" font-size="8">Was B! ‚úó</text>
                        
                        <rect x="200" y="185" width="80" height="30" rx="4" fill="#FFCDD2" stroke="#f44336" stroke-width="2"/>
                        <text x="240" y="205" text-anchor="middle" fill="#c62828" font-size="10">key=2 ‚Üí B</text>
                        <text x="240" y="220" text-anchor="middle" fill="#c62828" font-size="8">Was C! ‚úó</text>
                        
                        <rect x="290" y="185" width="80" height="30" rx="4" fill="#FFCDD2" stroke="#f44336" stroke-width="2"/>
                        <text x="330" y="205" text-anchor="middle" fill="#c62828" font-size="10">key=3 ‚Üí C</text>
                        <text x="330" y="220" text-anchor="middle" fill="#c62828" font-size="8">NEW! ‚úó</text>
                        
                        <!-- Result -->
                        <rect x="20" y="260" width="350" height="75" rx="6" fill="#FFCDD2"/>
                        <text x="195" y="285" text-anchor="middle" fill="#c62828" font-size="11" font-weight="bold">Result: React is confused!</text>
                        <text x="195" y="305" text-anchor="middle" fill="#333" font-size="10">‚Ä¢ Updates 3 elements (B‚ÜíD, C‚ÜíB, new C)</text>
                        <text x="195" y="320" text-anchor="middle" fill="#333" font-size="10">‚Ä¢ State in B,C components may be wrong!</text>
                    </g>
                </svg>
    &lt;/ul&gt;
    &lt;ul&gt;
        {posts.map(post => &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;)}
    &lt;/ul&gt;
&lt;/div&gt;

// ‚ùå Bad: Duplicate keys in same list
&lt;ul&gt;
    &lt;li key="1"&gt;Item 1&lt;/li&gt;
    &lt;li key="1"&gt;Item 2&lt;/li&gt;  {/* Duplicate key! */}
&lt;/ul&gt;</code></pre>
                </div>

                <h3>The Index as Key Problem</h3>
                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Warning: Using Index as Key</h4>
                    <pre><code class="language-typescript">// ‚ö†Ô∏è Problematic in many cases
{items.map((item, index) => (
    &lt;li key={index}&gt;{item}&lt;/li&gt;
))}</code></pre>
                    
                    <p><strong>Why it's problematic:</strong></p>
                    <p>Imagine you have a list: ["A", "B", "C"]</p>
                    <pre><code>key=0: A
key=1: B
key=2: C</code></pre>
                    
                    <p>You remove "A". Now you have: ["B", "C"]</p>
                    <pre><code>key=0: B  (was key=1 before!)
key=1: C  (was key=2 before!)</code></pre>
                    
                    <p>React thinks items at key=0 and key=1 changed content, when really you just deleted one item!</p>
                    
                    <p><strong>When index as key is okay:</strong></p>
                    <ul>
                        <li>‚úÖ List is static (never changes)</li>
                        <li>‚úÖ Items are never reordered</li>
                        <li>‚úÖ Items are never deleted</li>
                        <li>‚úÖ Items have no state or controlled inputs</li>
                    </ul>
                    
                    <p><strong>When NOT to use index:</strong></p>
                    <ul>
                        <li>‚ùå Items can be added/removed</li>
                        <li>‚ùå List can be sorted/filtered</li>
                        <li>‚ùå Items have input fields</li>
                        <li>‚ùå Items have local component state</li>
                    </ul>
                </div>

                <h3>Example: The Bug Index Keys Can Cause</h3>
                <div class="card">
                    <h4>Demonstration of the Problem</h4>
                    <pre><code class="language-typescript">interface TodoItemProps {
    text: string;
}

const TodoItem: React.FC&lt;TodoItemProps&gt; = ({ text }) => {
    const [done, setDone] = useState(false);
    
    return (
        &lt;div&gt;
            &lt;input
                type="checkbox"
                checked={done}
                onChange={() => setDone(!done)}
            /&gt;
            {text}
        &lt;/div&gt;
    );
};

// ‚ùå Using index as key
const BadTodoList: React.FC = () => {
    const [todos, setTodos] = useState(['Task A', 'Task B', 'Task C']);
    
    return (
        &lt;div&gt;
            {todos.map((todo, index) => (
                &lt;TodoItem key={index} text={todo} /&gt;  {/* Bug! */}
            ))}
            &lt;button onClick={() => setTodos(todos.slice(1))}&gt;
                Remove first item
            &lt;/button&gt;
        &lt;/div&gt;
    );
};

// What happens:
// 1. Check "Task A"
// 2. Remove first item
// 3. Now "Task B" appears checked! (because it has the old key=0)</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Fix: Use Stable IDs</h4>
                    <pre><code class="language-typescript">interface Todo {
    id: number;  // or string
    text: string;
}

const GoodTodoList: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([
        { id: 1, text: 'Task A' },
        { id: 2, text: 'Task B' },
        { id: 3, text: 'Task C' }
    ]);
    
    return (
        &lt;div&gt;
            {todos.map(todo => (
                &lt;TodoItem key={todo.id} text={todo.text} /&gt;  {/* ‚úÖ Correct! */}
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                </div>
            </section>

            <!-- Section 3: Choosing Good Keys -->
            <section id="section3" class="lesson-section">
                <h2>üéØ Choosing Good Keys</h2>
                <p>A good key is stable, unique, and consistent. Let's learn how to choose keys properly.</p>

                <h3>Best Key Sources</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Source</th>
                            <th>When to Use</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Database ID</strong></td>
                            <td>Data from backend with IDs</td>
                            <td><code>key={user.id}</code></td>
                        </tr>
                        <tr>
                            <td><strong>UUID/GUID</strong></td>
                            <td>Generated unique IDs</td>
                            <td><code>key={item.uuid}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Unique Property</strong></td>
                            <td>Natural unique identifier</td>
                            <td><code>key={user.email}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Generated on Creation</strong></td>
                            <td>Client-side items</td>
                            <td><code>key={Date.now()}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Composite Key</strong></td>
                            <td>Multiple properties unique</td>
                            <td><code>key={`${cat}-${id}`}</code></td>
                        </tr>
                        <tr>
                            <td><strong>Index</strong></td>
                            <td>Static, never-changing list</td>
                            <td><code>key={index}</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Generating Keys for New Items</h3>
                <div class="card">
                    <h4>Pattern: Add ID When Creating</h4>
                    <pre><code class="language-typescript">interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

const TodoApp: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    
    const addTodo = (text: string) => {
        const newTodo: Todo = {
            id: Date.now(),  // Simple unique ID
            text: text,
            completed: false
        };
        setTodos([...todos, newTodo]);
    };
    
    return (
        &lt;ul&gt;
            {todos.map(todo => (
                &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};</code></pre>
                </div>

                <h3>Better ID Generation</h3>
                <div class="card">
                    <h4>Using Libraries or Crypto</h4>
                    <pre><code class="language-typescript">// Option 1: Use crypto.randomUUID() (modern browsers)
const id = crypto.randomUUID();
// "36b8f84d-df4e-4d49-b662-bcde71a8764f"

// Option 2: Use nanoid library
import { nanoid } from 'nanoid';
const id = nanoid();
// "V1StGXR8_Z5jdHi6B-myT"

// Option 3: Simple counter (if single user)
let nextId = 1;
const generateId = () => nextId++;

const addTodo = (text: string) => {
    const newTodo = {
        id: generateId(),  // or crypto.randomUUID()
        text,
        completed: false
    };
    setTodos([...todos, newTodo]);
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Guidelines</h4>
                    <ul>
                        <li><strong>Stable:</strong> Same item always has same key</li>
                        <li><strong>Unique:</strong> No two siblings share a key</li>
                        <li><strong>Consistent:</strong> Key doesn't change between renders</li>
                        <li><strong>Not Random:</strong> Don't use <code>Math.random()</code> as keys!</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistakes</h4>
                    <pre><code class="language-typescript">// ‚ùå Bad: Random key (changes every render!)
key={Math.random()}

// ‚ùå Bad: Non-unique key
key="same-key-for-all"

// ‚ùå Bad: Duplicate keys
items.map(item => &lt;li key={1}&gt;...&lt;/li&gt;)

// ‚ùå Bad: Complex object as key (must be string/number)
key={{id: 1}}</code></pre>
                </div>
            </section>


                <h3>üé® Keys Quick Reference</h3>
                <svg viewBox="0 0 800 320" style="width: 100%; max-width: 800px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <text x="400" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="15">Choosing the Right Key</text>
                    
                    <!-- GOOD Keys -->
                    <g transform="translate(20, 50)">
                        <rect x="0" y="0" width="370" height="250" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <rect x="0" y="0" width="370" height="30" rx="10" fill="#4CAF50"/>
                        <rect x="0" y="20" width="370" height="10" fill="#4CAF50"/>
                        <text x="185" y="22" text-anchor="middle" fill="white" font-weight="bold" font-size="12">‚úÖ Good Keys</text>
                        
                        <text x="20" y="55" fill="#2E7D32" font-size="11" font-weight="bold">Database IDs:</text>
                        <rect x="20" y="62" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="78" fill="#9cdcfe" font-size="10" font-family="monospace">key={user.id}</text>
                        
                        <text x="20" y="105" fill="#2E7D32" font-size="11" font-weight="bold">UUIDs:</text>
                        <rect x="20" y="112" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="128" fill="#9cdcfe" font-size="10" font-family="monospace">key={crypto.randomUUID()}</text>
                        <text x="260" y="128" fill="#6a9955" font-size="9" font-family="monospace">// on creation</text>
                        
                        <text x="20" y="155" fill="#2E7D32" font-size="11" font-weight="bold">Unique Properties:</text>
                        <rect x="20" y="162" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="178" fill="#9cdcfe" font-size="10" font-family="monospace">key={email}</text>
                        <text x="100" y="178" fill="#6a9955" font-size="9" font-family="monospace">// if guaranteed unique</text>
                        
                        <text x="20" y="205" fill="#2E7D32" font-size="11" font-weight="bold">Composite Keys:</text>
                        <rect x="20" y="212" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="228" fill="#9cdcfe" font-size="10" font-family="monospace">key={`${category}-${id}`}</text>
                    </g>
                    
                    <!-- BAD Keys -->
                    <g transform="translate(410, 50)">
                        <rect x="0" y="0" width="370" height="250" rx="10" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                        <rect x="0" y="0" width="370" height="30" rx="10" fill="#f44336"/>
                        <rect x="0" y="20" width="370" height="10" fill="#f44336"/>
                        <text x="185" y="22" text-anchor="middle" fill="white" font-weight="bold" font-size="12">‚ùå Bad Keys</text>
                        
                        <text x="20" y="55" fill="#c62828" font-size="11" font-weight="bold">Index (for dynamic lists):</text>
                        <rect x="20" y="62" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="78" fill="#9cdcfe" font-size="10" font-family="monospace">key={index}</text>
                        <text x="100" y="78" fill="#f44336" font-size="9" font-family="monospace">// changes when list changes!</text>
                        
                        <text x="20" y="105" fill="#c62828" font-size="11" font-weight="bold">Random Values:</text>
                        <rect x="20" y="112" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="128" fill="#9cdcfe" font-size="10" font-family="monospace">key={Math.random()}</text>
                        <text x="155" y="128" fill="#f44336" font-size="9" font-family="monospace">// new key every render!</text>
                        
                        <text x="20" y="155" fill="#c62828" font-size="11" font-weight="bold">Same Key for All:</text>
                        <rect x="20" y="162" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="178" fill="#9cdcfe" font-size="10" font-family="monospace">key="item"</text>
                        <text x="95" y="178" fill="#f44336" font-size="9" font-family="monospace">// duplicates cause bugs!</text>
                        
                        <text x="20" y="205" fill="#c62828" font-size="11" font-weight="bold">Objects as Keys:</text>
                        <rect x="20" y="212" width="330" height="22" rx="3" fill="#1e1e1e"/>
                        <text x="30" y="228" fill="#9cdcfe" font-size="10" font-family="monospace">key={{id: 1}}</text>
                        <text x="120" y="228" fill="#f44336" font-size="9" font-family="monospace">// must be string/number!</text>
                    </g>
                </svg>
            <!-- Section 4: Array Methods (map, filter, reduce) -->
            <section id="section4" class="lesson-section">
                <h2>üîß Array Methods (map, filter, reduce)</h2>
                <p>JavaScript's array methods are essential for working with lists in React. Let's master the most important ones!</p>

                <h3>map() - Transform Each Item</h3>
                <div class="card">
                    <h4>Converting Data to JSX</h4>
                    <pre><code class="language-typescript">// map() creates a new array by transforming each element
const numbers = [1, 2, 3, 4, 5];

// Example 1: Double each number
const doubled = numbers.map(n => n * 2);
// [2, 4, 6, 8, 10]

// Example 2: Convert to JSX
const listItems = numbers.map(n => &lt;li key={n}&gt;{n}&lt;/li&gt;);
// [&lt;li&gt;1&lt;/li&gt;, &lt;li&gt;2&lt;/li&gt;, ...]

// Example 3: Extract properties
interface User {
    id: number;
    name: string;
    email: string;
}

const users: User[] = [
    { id: 1, name: 'Alice', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c2a3aeaba1a782a7baa3afb2aea7eca1adaf">[email&#160;protected]</a>' },
    { id: 2, name: 'Bob', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0c6e636e4c69746d617c6069226f6361">[email&#160;protected]</a>' }
];

const names = users.map(user => user.name);
// ['Alice', 'Bob']

const userCards = users.map(user => (
    &lt;div key={user.id}&gt;
        &lt;h3&gt;{user.name}&lt;/h3&gt;
        &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
));</code></pre>
                </div>

                <h3>filter() - Select Items</h3>
                <div class="card">
                    <h4>Filtering Lists</h4>
                    <pre><code class="language-typescript">// filter() creates a new array with items that pass a test
const numbers = [1, 2, 3, 4, 5, 6];

// Example 1: Get even numbers
const evens = numbers.filter(n => n % 2 === 0);
// [2, 4, 6]

// Example 2: Filter completed todos
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

const todos: Todo[] = [
    { id: 1, text: 'Learn React', completed: true },
    { id: 2, text: 'Build app', completed: false },
    { id: 3, text: 'Deploy', completed: false }
];

const completed = todos.filter(todo => todo.completed);
// [{ id: 1, text: 'Learn React', completed: true }]

const active = todos.filter(todo => !todo.completed);
// [{ id: 2, ... }, { id: 3, ... }]

// Example 3: Search functionality
const searchTerm = 'react';
const searchResults = todos.filter(todo => 
    todo.text.toLowerCase().includes(searchTerm.toLowerCase())
);
// [{ id: 1, text: 'Learn React', completed: true }]</code></pre>
                </div>

                <h3>reduce() - Compute Single Value</h3>
                <div class="card">
                    <h4>Aggregating Data</h4>
                    <pre><code class="language-typescript">// reduce() combines all elements into a single value
const numbers = [1, 2, 3, 4, 5];

// Example 1: Sum
const sum = numbers.reduce((total, num) => total + num, 0);
// 15

// Example 2: Count completed todos
const completedCount = todos.reduce((count, todo) => 
    count + (todo.completed ? 1 : 0), 0
);

// Example 3: Calculate total price
interface CartItem {
    id: number;
    name: string;
    price: number;
    quantity: number;
}

const cart: CartItem[] = [
    { id: 1, name: 'Book', price: 12.99, quantity: 2 },
    { id: 2, name: 'Pen', price: 1.99, quantity: 5 }
];

const total = cart.reduce((sum, item) => 
    sum + (item.price * item.quantity), 0
);
// 35.93

// Example 4: Group by property
const grouped = todos.reduce((groups, todo) => {
    const key = todo.completed ? 'completed' : 'active';
    if (!groups[key]) groups[key] = [];
    groups[key].push(todo);
    return groups;
}, {} as Record&lt;string, Todo[]&gt;);
// { completed: [...], active: [...] }</code></pre>
                </div>

                <h3>Chaining Array Methods</h3>
                <div class="card">
                    <h4>Combining Operations</h4>
                    <pre><code class="language-typescript">// You can chain methods for powerful transformations
const todos: Todo[] = [
    { id: 1, text: 'Learn React', completed: true },
    { id: 2, text: 'Build App', completed: false },
    { id: 3, text: 'Learn TypeScript', completed: true },
    { id: 4, text: 'Deploy', completed: false }
];

// Example 1: Filter then map
const completedTexts = todos
    .filter(todo => todo.completed)
    .map(todo => todo.text);
// ['Learn React', 'Learn TypeScript']

// Example 2: Filter, map, then render
const ActiveTodoList: React.FC = () => {
    return (
        &lt;ul&gt;
            {todos
                .filter(todo => !todo.completed)
                .map(todo => (
                    &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
                ))
            }
        &lt;/ul&gt;
    );
};

// Example 3: Search, filter, sort, map
const searchTerm = 'learn';

const searchResults = todos
    .filter(todo => todo.text.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => a.text.localeCompare(b.text))
    .map(todo => (
        &lt;div key={todo.id}&gt;
            &lt;strong&gt;{todo.text}&lt;/strong&gt;
            &lt;span&gt;{todo.completed ? ' ‚úì' : ''}&lt;/span&gt;
        &lt;/div&gt;
    ));</code></pre>
                </div>

                <h3>Other Useful Array Methods</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Purpose</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>find()</code></td>
                            <td>Get first matching item</td>
                            <td><code>todos.find(t => t.id === 2)</code></td>
                        </tr>
                        <tr>
                            <td><code>findIndex()</code></td>
                            <td>Get index of first match</td>
                            <td><code>todos.findIndex(t => t.id === 2)</code></td>
                        </tr>
                        <tr>
                            <td><code>some()</code></td>
                            <td>Check if any item matches</td>
                            <td><code>todos.some(t => t.completed)</code></td>
                        </tr>
                        <tr>
                            <td><code>every()</code></td>
                            <td>Check if all items match</td>
                            <td><code>todos.every(t => t.completed)</code></td>
                        </tr>
                        <tr>
                            <td><code>slice()</code></td>
                            <td>Get portion of array</td>
                            <td><code>todos.slice(0, 5)</code></td>
                        </tr>
                        <tr>
                            <td><code>sort()</code></td>
                            <td>Sort array (copy first!)</td>
                            <td><code>[...todos].sort((a,b) => ...)</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Array Methods Cheat Sheet</h4>
                    <ul>
                        <li><strong>map():</strong> Transform each item ‚Üí new array</li>
                        <li><strong>filter():</strong> Select items that match ‚Üí new array</li>
                        <li><strong>reduce():</strong> Combine all items ‚Üí single value</li>
                        <li><strong>find():</strong> Get first match ‚Üí single item or undefined</li>
                        <li><strong>some():</strong> Any item matches? ‚Üí boolean</li>
                        <li><strong>every():</strong> All items match? ‚Üí boolean</li>
                    </ul>
                </div>
            </section>

                <h3>üéÆ Interactive Demo: Array Methods in Action</h3>
                <p>Watch how map, filter, and reduce transform arrays:</p>
                
                <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <canvas id="arrayMethodsCanvas" width="750" height="340" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; border: 1px solid #ddd; border-radius: 8px; background: white;"></canvas>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                        <button id="mapBtn" style="padding: 0.5rem 1rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">map() √ó 2</button>
                        <button id="filterBtn" style="padding: 0.5rem 1rem; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">filter() even</button>
                        <button id="reduceBtn" style="padding: 0.5rem 1rem; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">reduce() sum</button>
                        <button id="resetArrayBtn" style="padding: 0.5rem 1rem; background: #9e9e9e; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                    </div>
                </div>
                
                <script>
                (function() {
                    const canvas = document.getElementById('arrayMethodsCanvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    const originalArray = [1, 2, 3, 4, 5, 6];
                    let currentOperation = null;
                    let resultArray = [];
                    let reduceResult = null;
                    
                    function draw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.fillText('Array Methods Visualization', canvas.width / 2, 25);
                        
                        // Original array
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#667eea';
                        ctx.textAlign = 'left';
                        ctx.fillText('Original Array:', 50, 60);
                        
                        originalArray.forEach((num, i) => {
                            const x = 50 + i * 70;
                            ctx.beginPath();
                            ctx.roundRect(x, 70, 55, 40, 6);
                            ctx.fillStyle = '#E3F2FD';
                            ctx.fill();
                            ctx.strokeStyle = '#2196F3';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            ctx.font = 'bold 18px system-ui';
                            ctx.fillStyle = '#1565C0';
                            ctx.textAlign = 'center';
                            ctx.fillText(num.toString(), x + 27, 98);
                        });
                        
                        // Code display
                        ctx.beginPath();
                        ctx.roundRect(500, 50, 220, 65, 6);
                        ctx.fillStyle = '#1e1e1e';
                        ctx.fill();
                        
                        ctx.font = '10px monospace';
                        ctx.textAlign = 'left';
                        ctx.fillStyle = '#9cdcfe';
                        ctx.fillText('const arr = [1,2,3,4,5,6];', 515, 75);
                        
                        if (currentOperation === 'map') {
                            ctx.fillStyle = '#dcdcaa';
                            ctx.fillText('arr.map(n => n * 2)', 515, 95);
                            ctx.fillStyle = '#6a9955';
                            ctx.fillText('// ‚Üí [2,4,6,8,10,12]', 515, 110);
                        } else if (currentOperation === 'filter') {
                            ctx.fillStyle = '#dcdcaa';
                            ctx.fillText('arr.filter(n => n % 2 === 0)', 515, 95);
                            ctx.fillStyle = '#6a9955';
                            ctx.fillText('// ‚Üí [2,4,6]', 515, 110);
                        } else if (currentOperation === 'reduce') {
                            ctx.fillStyle = '#dcdcaa';
                            ctx.fillText('arr.reduce((s,n) => s+n, 0)', 515, 95);
                            ctx.fillStyle = '#6a9955';
                            ctx.fillText('// ‚Üí 21', 515, 110);
                        } else {
                            ctx.fillStyle = '#6a9955';
                            ctx.fillText('// Click a method to see it work!', 515, 95);
                        }
                        
                        // Arrow
                        if (currentOperation) {
                            ctx.strokeStyle = '#667eea';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(375, 130);
                            ctx.lineTo(375, 170);
                            ctx.stroke();
                            
                            ctx.beginPath();
                            ctx.moveTo(375, 170);
                            ctx.lineTo(370, 160);
                            ctx.lineTo(380, 160);
                            ctx.closePath();
                            ctx.fillStyle = '#667eea';
                            ctx.fill();
                            
                            // Operation label
                            const labels = { map: 'map(n => n * 2)', filter: 'filter(n => n % 2 === 0)', reduce: 'reduce((sum, n) => sum + n, 0)' };
                            ctx.font = '11px monospace';
                            ctx.fillStyle = '#667eea';
                            ctx.textAlign = 'center';
                            ctx.fillText(labels[currentOperation], 375, 155);
                        }
                        
                        // Result
                        ctx.font = 'bold 12px system-ui';
                        ctx.textAlign = 'left';
                        
                        if (currentOperation === 'map') {
                            ctx.fillStyle = '#2196F3';
                            ctx.fillText('Result (new array):', 50, 200);
                            resultArray.forEach((num, i) => {
                                const x = 50 + i * 70;
                                ctx.beginPath();
                                ctx.roundRect(x, 210, 55, 40, 6);
                                ctx.fillStyle = '#BBDEFB';
                                ctx.fill();
                                ctx.strokeStyle = '#2196F3';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                                
                                ctx.font = 'bold 18px system-ui';
                                ctx.fillStyle = '#1565C0';
                                ctx.textAlign = 'center';
                                ctx.fillText(num.toString(), x + 27, 238);
                            });
                        } else if (currentOperation === 'filter') {
                            ctx.fillStyle = '#4CAF50';
                            ctx.fillText('Result (filtered):', 50, 200);
                            resultArray.forEach((num, i) => {
                                const x = 50 + i * 70;
                                ctx.beginPath();
                                ctx.roundRect(x, 210, 55, 40, 6);
                                ctx.fillStyle = '#C8E6C9';
                                ctx.fill();
                                ctx.strokeStyle = '#4CAF50';
                                ctx.lineWidth = 2;
                                ctx.stroke();
                                
                                ctx.font = 'bold 18px system-ui';
                                ctx.fillStyle = '#2E7D32';
                                ctx.textAlign = 'center';
                                ctx.fillText(num.toString(), x + 27, 238);
                            });
                            
                            // Show rejected items
                            ctx.font = '10px system-ui';
                            ctx.fillStyle = '#999';
                            ctx.textAlign = 'left';
                            ctx.fillText('Rejected: 1, 3, 5 (odd numbers)', 50, 270);
                        } else if (currentOperation === 'reduce') {
                            ctx.fillStyle = '#FF9800';
                            ctx.fillText('Result (single value):', 50, 200);
                            
                            ctx.beginPath();
                            ctx.roundRect(50, 210, 100, 60, 8);
                            ctx.fillStyle = '#FFE0B2';
                            ctx.fill();
                            ctx.strokeStyle = '#FF9800';
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            ctx.font = 'bold 28px system-ui';
                            ctx.fillStyle = '#E65100';
                            ctx.textAlign = 'center';
                            ctx.fillText(reduceResult.toString(), 100, 250);
                            
                            // Show calculation
                            ctx.font = '10px system-ui';
                            ctx.fillStyle = '#666';
                            ctx.textAlign = 'left';
                            ctx.fillText('1 + 2 + 3 + 4 + 5 + 6 = 21', 50, 290);
                        }
                        
                        // Key insight
                        ctx.beginPath();
                        ctx.roundRect(50, 305, 650, 25, 4);
                        ctx.fillStyle = '#FFF8E1';
                        ctx.fill();
                        ctx.font = '11px system-ui';
                        ctx.fillStyle = '#E65100';
                        ctx.textAlign = 'left';
                        ctx.fillText('üí° map() & filter() return new arrays. reduce() returns a single value. Original array unchanged!', 60, 322);
                    }
                    
                    document.getElementById('mapBtn').addEventListener('click', () => {
                        currentOperation = 'map';
                        resultArray = originalArray.map(n => n * 2);
                        draw();
                    });
                    
                    document.getElementById('filterBtn').addEventListener('click', () => {
                        currentOperation = 'filter';
                        resultArray = originalArray.filter(n => n % 2 === 0);
                        draw();
                    });
                    
                    document.getElementById('reduceBtn').addEventListener('click', () => {
                        currentOperation = 'reduce';
                        reduceResult = originalArray.reduce((sum, n) => sum + n, 0);
                        draw();
                    });
                    
                    document.getElementById('resetArrayBtn').addEventListener('click', () => {
                        currentOperation = null;
                        resultArray = [];
                        reduceResult = null;
                        draw();
                    });
                    
                    draw();
                })();
                </script>

            <!-- Section 5: CRUD Operations -->
            <section id="section5" class="lesson-section">
                <h2>‚úèÔ∏è CRUD Operations</h2>
                <p>Let's implement Create, Read, Update, and Delete operations on lists!</p>

                <h3>Complete CRUD Example</h3>
                <div class="card">
                    <h4>Full Todo App with CRUD</h4>
                    <pre><code class="language-typescript">import React, { useState } from 'react';

interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

const TodoApp: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([
        { id: 1, text: 'Learn React', completed: false },
        { id: 2, text: 'Build App', completed: false }
    ]);
    const [inputText, setInputText] = useState('');

    // CREATE - Add new todo
    const addTodo = () => {
        if (inputText.trim() === '') return;
        
        const newTodo: Todo = {
            id: Date.now(),
            text: inputText,
            completed: false
        };
        
        setTodos([...todos, newTodo]);
        setInputText('');
    };

    // READ - Already handled by rendering the list
    
    // UPDATE - Toggle completion
    const toggleTodo = (id: number) => {
        setTodos(todos.map(todo =>
            todo.id === id
                ? { ...todo, completed: !todo.completed }
                : todo
        ));
    };

    // UPDATE - Edit text
    const updateTodoText = (id: number, newText: string) => {
        setTodos(todos.map(todo =>
            todo.id === id
                ? { ...todo, text: newText }
                : todo
        ));
    };

    // DELETE - Remove todo
    const deleteTodo = (id: number) => {
        setTodos(todos.filter(todo => todo.id !== id));
    };

    // DELETE - Clear completed
    const clearCompleted = () => {
        setTodos(todos.filter(todo => !todo.completed));
    };

    return (
        &lt;div style={{ maxWidth: '600px', margin: '0 auto', padding: '2rem' }}&gt;
            &lt;h1&gt;Todo List&lt;/h1&gt;
            
            {/* CREATE */}
            &lt;div style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}&gt;
                &lt;input
                    value={inputText}
                    onChange={(e) => setInputText(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && addTodo()}
                    placeholder="Add a todo..."
                    style={{ flex: 1, padding: '0.5rem' }}
                /&gt;
                &lt;button onClick={addTodo} style={{ padding: '0.5rem 1rem' }}&gt;
                    Add
                &lt;/button&gt;
            &lt;/div&gt;

            {/* READ - Display list */}
            &lt;ul style={{ listStyle: 'none', padding: 0 }}&gt;
                {todos.map(todo => (
                    &lt;li
                        key={todo.id}
                        style={{
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.5rem',
                            padding: '0.5rem',
                            background: '#f5f5f5',
                            marginBottom: '0.5rem',
                            borderRadius: '4px'
                        }}
                    &gt;
                        {/* UPDATE - Toggle */}
                        &lt;input
                            type="checkbox"
                            checked={todo.completed}
                            onChange={() => toggleTodo(todo.id)}
                        /&gt;
                        
                        &lt;span
                            style={{
                                flex: 1,
                                textDecoration: todo.completed ? 'line-through' : 'none',
                                color: todo.completed ? '#999' : '#000'
                            }}
                        &gt;
                            {todo.text}
                        &lt;/span&gt;
                        

                <h3>üéÆ Interactive Demo: CRUD in Action</h3>
                <p>See Create, Read, Update, Delete operations on a live list:</p>
                
                <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <canvas id="crudCanvas" width="750" height="320" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; border: 1px solid #ddd; border-radius: 8px; background: white;"></canvas>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                        <button id="createBtn" style="padding: 0.5rem 1rem; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">‚ûï Create</button>
                        <button id="updateBtn" style="padding: 0.5rem 1rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">‚úèÔ∏è Update First</button>
                        <button id="deleteBtn" style="padding: 0.5rem 1rem; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer;">üóëÔ∏è Delete Last</button>
                        <button id="resetCrudBtn" style="padding: 0.5rem 1rem; background: #9e9e9e; color: white; border: none; border-radius: 4px; cursor: pointer;">Reset</button>
                    </div>
                </div>
                
                <script>
                (function() {
                    const canvas = document.getElementById('crudCanvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    let nextId = 4;
                    let items = [
                        { id: 1, text: 'Learn React', done: false },
                        { id: 2, text: 'Build App', done: true },
                        { id: 3, text: 'Deploy', done: false }
                    ];
                    let lastOperation = null;
                    let lastCode = '';
                    
                    function draw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.fillText('CRUD Operations Demo', canvas.width / 2, 25);
                        
                        // Items list
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#667eea';
                        ctx.textAlign = 'left';
                        ctx.fillText('üìã Items State:', 30, 55);
                        
                        if (items.length === 0) {
                            ctx.font = '12px system-ui';
                            ctx.fillStyle = '#999';
                            ctx.fillText('Empty! Click Create to add items.', 30, 85);
                        } else {
                            items.forEach((item, i) => {
                                const y = 70 + i * 45;
                                const isHighlighted = (lastOperation === 'create' && i === items.length - 1) ||
                                                     (lastOperation === 'update' && i === 0);
                                
                                ctx.beginPath();
                                ctx.roundRect(30, y, 280, 38, 6);
                                ctx.fillStyle = isHighlighted ? '#E3F2FD' : '#f5f5f5';
                                ctx.fill();
                                ctx.strokeStyle = isHighlighted ? '#2196F3' : '#ddd';
                                ctx.lineWidth = isHighlighted ? 2 : 1;
                                ctx.stroke();
                                
                                ctx.font = '10px monospace';
                                ctx.fillStyle = '#667eea';
                                ctx.fillText('id: ' + item.id, 45, y + 15);
                                
                                ctx.font = '11px system-ui';
                                ctx.fillStyle = item.done ? '#999' : '#333';
                                ctx.fillText(item.text, 45, y + 30);
                                
                                ctx.fillStyle = item.done ? '#4CAF50' : '#999';
                                ctx.fillText(item.done ? '‚úì' : '‚óã', 280, y + 22);
                            });
                        }
                        
                        // Code panel
                        ctx.beginPath();
                        ctx.roundRect(350, 50, 370, 180, 8);
                        ctx.fillStyle = '#1e1e1e';
                        ctx.fill();
                        
                        ctx.font = 'bold 11px system-ui';
                        ctx.fillStyle = '#888';
                        ctx.textAlign = 'left';
                        ctx.fillText(lastOperation ? lastOperation.toUpperCase() + ' Operation:' : 'Click a button to see code:', 365, 75);
                        
                        ctx.font = '10px monospace';
                        if (lastCode) {
                            const lines = lastCode.split('\n');
                            lines.forEach((line, i) => {
                                if (line.startsWith('//')) {
                                    ctx.fillStyle = '#6a9955';
                                } else if (line.includes('setItems') || line.includes('const')) {
                                    ctx.fillStyle = '#dcdcaa';
                                } else {
                                    ctx.fillStyle = '#d4d4d4';
                                }
                                ctx.fillText(line, 365, 100 + i * 16);
                            });
                        }
                        
                        // Operation badges
                        const ops = [
                            { name: 'CREATE', color: '#4CAF50', desc: '[...items, newItem]' },
                            { name: 'READ', color: '#9C27B0', desc: 'items.map(...)' },
                            { name: 'UPDATE', color: '#2196F3', desc: 'items.map(i => i.id === id ? {...} : i)' },
                            { name: 'DELETE', color: '#f44336', desc: 'items.filter(i => i.id !== id)' }
                        ];
                        
                        ctx.font = '9px system-ui';
                        ops.forEach((op, i) => {
                            const x = 350 + i * 92;
                            ctx.beginPath();
                            ctx.roundRect(x, 250, 85, 45, 4);
                            ctx.fillStyle = op.name.toLowerCase() === lastOperation ? op.color : '#f5f5f5';
                            ctx.fill();
                            
                            ctx.font = 'bold 10px system-ui';
                            ctx.fillStyle = op.name.toLowerCase() === lastOperation ? 'white' : op.color;
                            ctx.textAlign = 'center';
                            ctx.fillText(op.name, x + 42, 268);
                            
                            ctx.font = '8px system-ui';
                            ctx.fillStyle = op.name.toLowerCase() === lastOperation ? '#fff' : '#666';
                            ctx.fillText(op.desc.substring(0, 15) + '...', x + 42, 285);
                        });
                    }
                    
                    document.getElementById('createBtn').addEventListener('click', () => {
                        const newItem = { id: nextId++, text: 'New Task ' + (nextId - 1), done: false };
                        items = [...items, newItem];
                        lastOperation = 'create';
                        lastCode = '// Add new item\nconst newItem = {\n  id: ' + newItem.id + ',\n  text: "' + newItem.text + '",\n  done: false\n};\nsetItems([...items, newItem]);';
                        draw();
                    });
                    
                    document.getElementById('updateBtn').addEventListener('click', () => {
                        if (items.length > 0) {
                            const id = items[0].id;
                            items = items.map(item => item.id === id ? { ...item, done: !item.done } : item);
                            lastOperation = 'update';
                            lastCode = '// Toggle first item\nsetItems(items.map(item =>\n  item.id === ' + id + '\n    ? { ...item, done: !' + !items[0].done + ' }\n    : item\n));';
                            draw();
                        }
                    });
                    
                    document.getElementById('deleteBtn').addEventListener('click', () => {
                        if (items.length > 0) {
                            const id = items[items.length - 1].id;
                            items = items.filter(item => item.id !== id);
                            lastOperation = 'delete';
                            lastCode = '// Remove last item\nsetItems(\n  items.filter(item =>\n    item.id !== ' + id + '\n  )\n);';
                            draw();
                        }
                    });
                    
                    document.getElementById('resetCrudBtn').addEventListener('click', () => {
                        nextId = 4;
                        items = [
                            { id: 1, text: 'Learn React', done: false },
                            { id: 2, text: 'Build App', done: true },
                            { id: 3, text: 'Deploy', done: false }
                        ];
                        lastOperation = null;
                        lastCode = '';
                        draw();
                    });
                    
                    draw();
                })();
                </script>
                        {/* DELETE */}
                        &lt;button
                            onClick={() => deleteTodo(todo.id)}
                            style={{
                                background: '#f44336',
                                color: 'white',
                                border: 'none',
                                padding: '0.25rem 0.5rem',
                                borderRadius: '4px',
                                cursor: 'pointer'
                            }}
                        &gt;
                            Delete
                        &lt;/button&gt;
                    &lt;/li&gt;
                ))}
            &lt;/ul&gt;

            {/* Additional actions */}
            &lt;div style={{ marginTop: '1rem', display: 'flex', justifyContent: 'space-between' }}&gt;
                &lt;span&gt;{todos.filter(t => !t.completed).length} items left&lt;/span&gt;
                &lt;button onClick={clearCompleted}&gt;Clear completed&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

export default TodoApp;</code></pre>
                </div>

                <h3>CRUD Operation Patterns</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Pattern</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Create (Add)</strong></td>
                            <td>Spread and append</td>
                            <td><code>[...items, newItem]</code></td>
                        </tr>
                        <tr>
                            <td><strong>Read (Display)</strong></td>
                            <td>Map to JSX</td>
                            <td><code>items.map(item => &lt;li&gt;...&lt;/li&gt;)</code></td>
                        </tr>
                        <tr>
                            <td><strong>Update</strong></td>
                            <td>Map and replace</td>
                            <td><code>items.map(i => i.id === id ? updated : i)</code></td>
                        </tr>
                        <tr>
                            <td><strong>Delete</strong></td>
                            <td>Filter out</td>
                            <td><code>items.filter(i => i.id !== id)</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Bulk Operations</h3>
                <div class="card">
                    <h4>Operating on Multiple Items</h4>
                    <pre><code class="language-typescript">// Select/deselect all
const [todos, setTodos] = useState&lt;Todo[]&gt;([]);

const toggleAll = () => {
    const allCompleted = todos.every(todo => todo.completed);
    setTodos(todos.map(todo => ({
        ...todo,
        completed: !allCompleted
    })));
};

// Delete multiple
const deleteMultiple = (idsToDelete: number[]) => {
    setTodos(todos.filter(todo => !idsToDelete.includes(todo.id)));
};

// Update multiple
const markSelectedAsCompleted = (selectedIds: number[]) => {
    setTodos(todos.map(todo =>
        selectedIds.includes(todo.id)
            ? { ...todo, completed: true }
            : todo
    ));
};</code></pre>
                </div>

                <h3>Optimistic Updates</h3>
                <div class="card">
                    <h4>Update UI Immediately</h4>
                    <pre><code class="language-typescript">const deleteTodoWithAPI = async (id: number) => {
    // 1. Update UI immediately (optimistic)
    const previousTodos = todos;
    setTodos(todos.filter(todo => todo.id !== id));
    
    try {
        // 2. Send request to server
        await api.deleteTodo(id);
        // Success! UI is already updated
    } catch (error) {
        // 3. If error, revert UI
        setTodos(previousTodos);
        alert('Failed to delete todo');
    }
};</code></pre>
                </div>
            </section>

            <!-- Section 6: Typing Lists with TypeScript -->
            <section id="section6" class="lesson-section">
                <h2>üìò Typing Lists with TypeScript</h2>
                <p>TypeScript makes working with lists safer and more predictable. Let's type everything properly!</p>

                <h3>Array Type Annotations</h3>
                <div class="card">
                    <h4>Different Ways to Type Arrays</h4>
                    <pre><code class="language-typescript">// Method 1: Type[]
const numbers: number[] = [1, 2, 3];
const strings: string[] = ['a', 'b', 'c'];

// Method 2: Array&lt;Type&gt;
const numbers: Array&lt;number&gt; = [1, 2, 3];
const strings: Array&lt;string&gt; = ['a', 'b', 'c'];

// Interface arrays
interface User {
    id: number;
    name: string;
}

const users: User[] = [];
// or
const users: Array&lt;User&gt; = [];

// Union type arrays
type Status = 'pending' | 'active' | 'completed';
const statuses: Status[] = ['pending', 'active'];

// Array of objects inline
const items: Array&lt;{ id: number; name: string }&gt; = [
    { id: 1, name: 'Item 1' }
];</code></pre>
                </div>

                <h3>Typing Props with Lists</h3>
                <div class="card">
                    <h4>List Component Types</h4>
                    <pre><code class="language-typescript">interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

// List component props
interface TodoListProps {
    todos: Todo[];
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

const TodoList: React.FC&lt;TodoListProps&gt; = ({ todos, onToggle, onDelete }) => {
    return (
        &lt;ul&gt;
            {todos.map(todo => (
                &lt;TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={onToggle}
                    onDelete={onDelete}
                /&gt;
            ))}
        &lt;/ul&gt;
    );
};

// Item component props
interface TodoItemProps {
    todo: Todo;
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

const TodoItem: React.FC&lt;TodoItemProps&gt; = ({ todo, onToggle, onDelete }) => {
    return (
        &lt;li&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    );
};</code></pre>
                </div>

                <h3>Typing Array Methods</h3>
                <div class="card">
                    <h4>Type-Safe Transformations</h4>
                    <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
}

const products: Product[] = [
    { id: 1, name: 'Book', price: 12.99, category: 'books' },
    { id: 2, name: 'Pen', price: 1.99, category: 'stationery' }
];

// TypeScript infers types in callbacks
const names = products.map(product => product.name);
// Type: string[]

const expensive = products.filter(product => product.price > 10);
// Type: Product[]

const total = products.reduce((sum, product) => sum + product.price, 0);
// Type: number

// Explicit typing when needed
const formatted = products.map((product): string => {
    return `${product.name}: $${product.price}`;
});
// Type: string[]</code></pre>
                </div>

                <h3>Generic List Components</h3>
                <div class="card">
                    <h4>Reusable Type-Safe Lists</h4>
                    <pre><code class="language-typescript">// Generic list component
interface ListProps&lt;T&gt; {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
    getKey: (item: T) => string | number;
}

function List&lt;T&gt;({ items, renderItem, getKey }: ListProps&lt;T&gt;) {
    return (
        &lt;ul&gt;
            {items.map(item => (
                &lt;li key={getKey(item)}&gt;
                    {renderItem(item)}
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

// Usage with User type
interface User {
    id: number;
    name: string;
    email: string;
}

const users: User[] = [
    { id: 1, name: 'Alice', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b0d1dcd9d3d5f0d5c8d1ddc0dcd59ed3dfdd">[email&#160;protected]</a>' },
    { id: 2, name: 'Bob', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="32505d5072574a535f425e571c515d5f">[email&#160;protected]</a>' }
];

const UserList: React.FC = () => (
    &lt;List
        items={users}
        renderItem={(user) => (
            &lt;div&gt;
                &lt;strong&gt;{user.name}&lt;/strong&gt;
                &lt;p&gt;{user.email}&lt;/p&gt;
            &lt;/div&gt;
        )}
        getKey={(user) => user.id}
    /&gt;
);

// Usage with Product type
interface Product {
    id: string;
    name: string;
    price: number;
}

const products: Product[] = [
    { id: 'p1', name: 'Book', price: 12.99 }
];

const ProductList: React.FC = () => (
    &lt;List
        items={products}
        renderItem={(product) => (
            &lt;span&gt;{product.name}: ${product.price}&lt;/span&gt;
        )}
        getKey={(product) => product.id}
    /&gt;
);</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Benefits for Lists</h4>
                    <ul>
                        <li><strong>Autocomplete:</strong> IDE suggests available properties</li>
                        <li><strong>Type safety:</strong> Catches errors at compile time</li>
                        <li><strong>Refactor confidence:</strong> Rename properties safely</li>
                        <li><strong>Documentation:</strong> Types document what data looks like</li>
                        <li><strong>Inference:</strong> Often don't need explicit types in callbacks</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Empty States and Conditional Lists -->
            <section id="section7" class="lesson-section">
                <h2>üóÇÔ∏è Empty States and Conditional Lists</h2>
                <p>Handling empty lists gracefully is important for good UX. Let's learn proper empty state patterns.</p>

                <h3>Checking for Empty Lists</h3>
                <div class="card">
                    <h4>Basic Empty State</h4>
                    <pre><code class="language-typescript">const TodoList: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    
    // Check if empty
    if (todos.length === 0) {
        return (
            &lt;div style={{ textAlign: 'center', padding: '3rem' }}&gt;
                &lt;p style={{ fontSize: '3rem' }}&gt;üìù&lt;/p&gt;
                &lt;h3&gt;No todos yet&lt;/h3&gt;
                &lt;p&gt;Add your first todo to get started!&lt;/p&gt;
            &lt;/div&gt;
        );
    }
    
    return (
        &lt;ul&gt;
            {todos.map(todo => (
                &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};</code></pre>
                </div>

                <h3>Conditional Rendering Patterns</h3>
                <div class="card">
                    <h4>Different Empty State Approaches</h4>
                    <pre><code class="language-typescript">// Pattern 1: Ternary operator
&lt;div&gt;
    {todos.length === 0 ? (
        &lt;p&gt;No todos yet!&lt;/p&gt;
    ) : (
        &lt;ul&gt;
            {todos.map(todo => &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}
        &lt;/ul&gt;
    )}
&lt;/div&gt;

// Pattern 2: Logical && operator
&lt;div&gt;
    {todos.length === 0 && &lt;p&gt;No todos yet!&lt;/p&gt;}
    {todos.length > 0 && (
        &lt;ul&gt;
            {todos.map(todo => &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}
        &lt;/ul&gt;
    )}
&lt;/div&gt;

// Pattern 3: Early return (component level)
const TodoList: React.FC&lt;{ todos: Todo[] }&gt; = ({ todos }) => {
    if (todos.length === 0) {
        return &lt;EmptyState /&gt;;
    }
    
    return (
        &lt;ul&gt;
            {todos.map(todo => &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
};</code></pre>
                </div>

                <h3>Rich Empty States</h3>
                <div class="card">
                    <h4>Engaging Empty State Component</h4>
                    <pre><code class="language-typescript">interface EmptyStateProps {
    icon?: string;
    title: string;
    description: string;
    action?: {
        label: string;
        onClick: () => void;
    };
}

const EmptyState: React.FC&lt;EmptyStateProps&gt; = ({ 
    icon = 'üì≠', 
    title, 
    description, 
    action 
}) => {
    return (
        &lt;div style={{
            textAlign: 'center',
            padding: '3rem',
            background: '#f5f5f5',
            borderRadius: '8px',
            margin: '2rem 0'
        }}&gt;
            &lt;div style={{ fontSize: '4rem', marginBottom: '1rem' }}&gt;
                {icon}
            &lt;/div&gt;
            &lt;h3 style={{ marginBottom: '0.5rem' }}&gt;{title}&lt;/h3&gt;
            &lt;p style={{ color: '#666', marginBottom: '1rem' }}&gt;{description}&lt;/p&gt;
            {action && (
                &lt;button
                    onClick={action.onClick}
                    style={{
                        padding: '0.75rem 1.5rem',
                        background: '#667eea',
                        color: 'white',
                        border: 'none',
                        borderRadius: '4px',
                        cursor: 'pointer',
                        fontSize: '1rem'
                    }}
                &gt;
                    {action.label}
                &lt;/button&gt;
            )}
        &lt;/div&gt;
    );
};

// Usage
const MyTodos: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [showAddForm, setShowAddForm] = useState(false);
    
    if (todos.length === 0) {
        return (
            &lt;EmptyState
                icon="‚ú®"
                title="No todos yet"
                description="Get started by adding your first todo item"
                action={{
                    label: 'Add Todo',
                    onClick: () => setShowAddForm(true)
                }}
            /&gt;
        );
    }
    
    return &lt;TodoList todos={todos} /&gt;;
};</code></pre>
                </div>

                <h3>Filtered Empty States</h3>
                <div class="card">
                    <h4>Different Empty Messages</h4>
                    <pre><code class="language-typescript">const FilteredTodoList: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [filter, setFilter] = useState&lt;'all' | 'active' | 'completed'&gt;('all');
    const [searchTerm, setSearchTerm] = useState('');
    
    // Apply filters
    const filteredTodos = todos
        .filter(todo => {
            if (filter === 'active') return !todo.completed;
            if (filter === 'completed') return todo.completed;
            return true;
        })
        .filter(todo => 
            todo.text.toLowerCase().includes(searchTerm.toLowerCase())
        );
    
    // Different messages based on context
    const getEmptyMessage = () => {
        if (todos.length === 0) {
            return 'No todos yet. Add one to get started!';
        }
        if (searchTerm) {
            return `No todos found matching "${searchTerm}"`;
        }
        if (filter === 'completed') {
            return 'No completed todos yet. Keep working!';
        }
        if (filter === 'active') {
            return 'All done! No active todos.';
        }
        return 'No todos found.';
    };
    
    return (
        &lt;div&gt;
            {filteredTodos.length === 0 ? (
                &lt;p style={{ textAlign: 'center', color: '#666', padding: '2rem' }}&gt;
                    {getEmptyMessage()}
                &lt;/p&gt;
            ) : (
                &lt;ul&gt;
                    {filteredTodos.map(todo => (
                        &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
                    ))}
                &lt;/ul&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Empty State Best Practices</h4>
                    <ul>
                        <li><strong>Always handle empty lists</strong> - Don't show blank space</li>
                        <li><strong>Be contextual</strong> - Different messages for different situations</li>
                        <li><strong>Provide guidance</strong> - Tell users what they can do</li>
                        <li><strong>Add visual interest</strong> - Use icons or illustrations</li>
                        <li><strong>Include actions</strong> - Make it easy to add first item</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: List Performance -->
            <section id="section8" class="lesson-section">
                <h2>‚ö° List Performance</h2>
                <p>For small lists (< 100 items), performance is rarely an issue. But let's learn optimization techniques for larger lists!</p>

                <h3>Why Keys Matter for Performance</h3>
                <div class="card">
                    <h4>React's Reconciliation Process</h4>
                    <p>When your list changes, React uses keys to:</p>
                    <ul>
                        <li>Determine which elements changed</li>
                        <li>Reuse existing DOM nodes when possible</li>
                        <li>Only update what actually changed</li>
                    </ul>
                    
                    <p><strong>With good keys:</strong></p>
                    <pre><code>// List before: [A, B, C]
&lt;li key="a"&gt;A&lt;/li&gt;
&lt;li key="b"&gt;B&lt;/li&gt;
&lt;li key="c"&gt;C&lt;/li&gt;

// Add D at position 1: [A, D, B, C]
&lt;li key="a"&gt;A&lt;/li&gt;
&lt;li key="d"&gt;D&lt;/li&gt;  // ‚úÖ New element created
&lt;li key="b"&gt;B&lt;/li&gt;  // ‚úÖ Reused, just moved
&lt;li key="c"&gt;C&lt;/li&gt;  // ‚úÖ Reused, just moved</code></pre>

                    <p><strong>With index as keys:</strong></p>
                    <pre><code>// List before: [A, B, C]
&lt;li key="0"&gt;A&lt;/li&gt;
&lt;li key="1"&gt;B&lt;/li&gt;
&lt;li key="2"&gt;C&lt;/li&gt;

// Add D at position 1: [A, D, B, C]
&lt;li key="0"&gt;A&lt;/li&gt;  // ‚úÖ Reused
&lt;li key="1"&gt;D&lt;/li&gt;  // ‚ö†Ô∏è Updated (was B)
&lt;li key="2"&gt;B&lt;/li&gt;  // ‚ö†Ô∏è Updated (was C)
&lt;li key="3"&gt;C&lt;/li&gt;  // ‚ö†Ô∏è New element</code></pre>
                </div>

                <h3>Virtual Scrolling for Long Lists</h3>
                <div class="card">
                    <h4>Only Render Visible Items</h4>
                    <p>For very long lists (1000+ items), use virtual scrolling libraries:</p>
                    <pre><code class="language-typescript">// Using react-window library
import { FixedSizeList } from 'react-window';

interface RowProps {
    index: number;
    style: React.CSSProperties;
}

const LargeList: React.FC = () => {
    const items = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);
    
    const Row: React.FC&lt;RowProps&gt; = ({ index, style }) => (
        &lt;div style={style}&gt;
            {items[index]}
        &lt;/div&gt;
    );
    
    return (
        &lt;FixedSizeList
            height={400}
            itemCount={items.length}
            itemSize={35}
            width="100%"
        &gt;
            {Row}
        &lt;/FixedSizeList&gt;
    );
};</code></pre>
                    <p>This renders only the visible items, dramatically improving performance!</p>
                </div>

                <h3>Memoization with React.memo</h3>
                <div class="card">
                    <h4>Prevent Unnecessary Re-renders</h4>
                    <pre><code class="language-typescript">interface TodoItemProps {
    todo: Todo;
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

// Without memo: Re-renders even if props haven't changed
const TodoItem: React.FC&lt;TodoItemProps&gt; = ({ todo, onToggle, onDelete }) => {
    console.log('TodoItem rendered:', todo.id);
    return (
        &lt;li&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            {todo.text}
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    );
};

// With memo: Only re-renders if props change
const TodoItem = React.memo&lt;TodoItemProps&gt;(({ todo, onToggle, onDelete }) => {
    console.log('TodoItem rendered:', todo.id);
    return (

                <h3>üé® Performance Impact of Keys</h3>
                <svg viewBox="0 0 800 340" style="width: 100%; max-width: 800px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <text x="400" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="15">Keys & Performance: DOM Operations Comparison</text>
                    
                    <!-- With Good Keys -->
                    <g transform="translate(20, 50)">
                        <rect x="0" y="0" width="370" height="270" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <rect x="0" y="0" width="370" height="30" rx="10" fill="#4CAF50"/>
                        <rect x="0" y="20" width="370" height="10" fill="#4CAF50"/>
                        <text x="185" y="22" text-anchor="middle" fill="white" font-weight="bold" font-size="12">‚úÖ Stable Keys (IDs)</text>
                        
                        <text x="20" y="55" fill="#333" font-size="10">Scenario: Insert item at position 1 in 1000-item list</text>
                        
                        <!-- DOM Operations -->
                        <rect x="20" y="70" width="330" height="90" rx="6" fill="white" stroke="#4CAF50"/>
                        <text x="35" y="90" fill="#2E7D32" font-size="11" font-weight="bold">DOM Operations:</text>
                        <text x="35" y="110" fill="#333" font-size="10">‚úì 1 element created (new item)</text>
                        <text x="35" y="128" fill="#333" font-size="10">‚úì 999 elements unchanged</text>
                        <text x="35" y="146" fill="#333" font-size="10">‚úì Browser just inserts node</text>
                        
                        <!-- Performance bar -->
                        <text x="20" y="180" fill="#2E7D32" font-size="11" font-weight="bold">Performance:</text>
                        <rect x="20" y="190" width="330" height="20" rx="4" fill="#E0E0E0"/>
                        <rect x="20" y="190" width="33" height="20" rx="4" fill="#4CAF50"/>
                        <text x="60" y="205" fill="#333" font-size="10">~1ms (fast!)</text>
                        
                        <!-- State preservation -->
                        <rect x="20" y="220" width="330" height="40" rx="4" fill="#C8E6C9"/>
                        <text x="185" y="237" text-anchor="middle" fill="#2E7D32" font-size="10" font-weight="bold">‚úì Component state preserved</text>
                        <text x="185" y="252" text-anchor="middle" fill="#333" font-size="9">Input values, scroll positions, etc. kept</text>
                    </g>
                    
                    <!-- With Index Keys -->
                    <g transform="translate(410, 50)">
                        <rect x="0" y="0" width="370" height="270" rx="10" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                        <rect x="0" y="0" width="370" height="30" rx="10" fill="#f44336"/>
                        <rect x="0" y="20" width="370" height="10" fill="#f44336"/>
                        <text x="185" y="22" text-anchor="middle" fill="white" font-weight="bold" font-size="12">‚ö†Ô∏è Index as Key</text>
                        
                        <text x="20" y="55" fill="#333" font-size="10">Same scenario: Insert at position 1</text>
                        
                        <!-- DOM Operations -->
                        <rect x="20" y="70" width="330" height="90" rx="6" fill="white" stroke="#f44336"/>
                        <text x="35" y="90" fill="#c62828" font-size="11" font-weight="bold">DOM Operations:</text>
                        <text x="35" y="110" fill="#333" font-size="10">‚úó 999 elements updated (content changed)</text>
                        <text x="35" y="128" fill="#333" font-size="10">‚úó 1 element created at end</text>
                        <text x="35" y="146" fill="#333" font-size="10">‚úó Browser updates almost everything</text>
                        
                        <!-- Performance bar -->
                        <text x="20" y="180" fill="#c62828" font-size="11" font-weight="bold">Performance:</text>
                        <rect x="20" y="190" width="330" height="20" rx="4" fill="#E0E0E0"/>
                        <rect x="20" y="190" width="297" height="20" rx="4" fill="#f44336"/>
                        <text x="60" y="205" fill="white" font-size="10">~90ms (slow!)</text>
                        
                        <!-- State loss -->
                        <rect x="20" y="220" width="330" height="40" rx="4" fill="#FFCDD2"/>
                        <text x="185" y="237" text-anchor="middle" fill="#c62828" font-size="10" font-weight="bold">‚úó Component state LOST</text>
                        <text x="185" y="252" text-anchor="middle" fill="#333" font-size="9">Inputs reset, forms cleared, bugs!</text>
                    </g>
                </svg>
        &lt;li&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            {todo.text}
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    );
});</code></pre>
                </div>

                <h3>Performance Tips</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tip</th>
                            <th>Why It Helps</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Use stable keys (IDs)</td>
                            <td>React can efficiently track items</td>
                        </tr>
                        <tr>
                            <td>Extract list items to components</td>
                            <td>Easier to optimize individual items</td>
                        </tr>
                        <tr>
                            <td>Use React.memo for items</td>
                            <td>Prevents unnecessary re-renders</td>
                        </tr>
                        <tr>
                            <td>Virtualize very long lists</td>
                            <td>Only render visible items</td>
                        </tr>
                        <tr>
                            <td>Debounce search/filter</td>
                            <td>Reduces re-renders during typing</td>
                        </tr>
                        <tr>
                            <td>Paginate or lazy load</td>
                            <td>Load data as needed</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Optimize</h4>
                    <p>Don't optimize prematurely! Consider optimization when:</p>
                    <ul>
                        <li>List has 500+ items</li>
                        <li>Items are complex components</li>
                        <li>You notice lag when typing or scrolling</li>
                        <li>Profiling shows list is a bottleneck</li>
                    </ul>
                    <p>For most lists under 100 items, basic React is plenty fast!</p>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to build! These exercises will solidify your list skills.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: User Directory</h3>
                    <p><strong>Goal:</strong> Build a searchable, sortable user list.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Display list of users (name, email, role)</li>
                        <li>Search by name or email</li>
                        <li>Sort by name (A-Z, Z-A)</li>
                        <li>Filter by role (Admin, User, Guest)</li>
                        <li>Show empty state when no results</li>
                        <li>Use proper keys</li>
                    </ul>

                    <details>
                        <summary>üí° Starter Data</summary>
                        <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    role: 'Admin' | 'User' | 'Guest';
}

const users: User[] = [
    { id: 1, name: 'Alice Johnson', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="afcec3c6cccaefcad7cec2dfc3ca81ccc0c2">[email&#160;protected]</a>', role: 'Admin' },
    { id: 2, name: 'Bob Smith', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="15777a7755706d74786579703b767a78">[email&#160;protected]</a>', role: 'User' },
    { id: 3, name: 'Charlie Brown', email: '<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="45262d2437292c2005203d24283529206b262a28">[email&#160;protected]</a>', role: 'Guest' },
    // Add more...
];</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Shopping Cart</h3>
                    <p><strong>Goal:</strong> Build a shopping cart with quantity controls.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Display cart items with image, name, price, quantity</li>
                        <li>Increase/decrease quantity buttons</li>
                        <li>Remove item button</li>
                        <li>Calculate and display subtotal per item</li>
                        <li>Calculate and display total</li>
                        <li>Empty cart state with "Start Shopping" button</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <pre><code class="language-typescript">interface CartItem {
    id: string;
    name: string;
    price: number;
    quantity: number;
    imageUrl: string;
}

const updateQuantity = (id: string, change: number) => {
    setCart(cart.map(item =>
        item.id === id
            ? { ...item, quantity: Math.max(1, item.quantity + change) }
            : item
    ));
};</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Dynamic Task Board</h3>
                    <p><strong>Goal:</strong> Build a Kanban-style task board.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Three columns: "To Do", "In Progress", "Done"</li>
                        <li>Add tasks to "To Do"</li>
                        <li>Move tasks between columns (buttons or drag)</li>
                        <li>Delete tasks</li>
                        <li>Show count of tasks in each column</li>
                        <li>Each column has its own empty state</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <pre><code class="language-typescript">type Status = 'todo' | 'inProgress' | 'done';

interface Task {
    id: number;
    text: string;
    status: Status;
}

const moveTask = (id: number, newStatus: Status) => {
    setTasks(tasks.map(task =>
        task.id === id ? { ...task, status: newStatus } : task
    ));
};

const todoTasks = tasks.filter(t => t.status === 'todo');</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>‚ú® Best Practices</h2>
                <p>Follow these guidelines for clean, performant lists.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 1. Always Use Keys</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Unique, stable key
{items.map(item => &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}

// ‚ùå Bad: No key
{items.map(item => &lt;li&gt;{item.name}&lt;/li&gt;)}

// ‚ö†Ô∏è Avoid: Index as key (unless list is truly static)
{items.map((item, i) => &lt;li key={i}&gt;{item.name}&lt;/li&gt;)}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 2. Extract List Items to Components</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Clean and reusable
{users.map(user => (
    &lt;UserCard key={user.id} user={user} /&gt;
))}

// ‚ùå Bad: Complex JSX inline
{users.map(user => (
    &lt;div key={user.id}&gt;
        &lt;img src={user.avatar} /&gt;
        &lt;h3&gt;{user.name}&lt;/h3&gt;
        &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;button&gt;View Profile&lt;/button&gt;
        {/* 20 more lines... */}
    &lt;/div&gt;
))}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 3. Handle Empty States</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Helpful empty state
{items.length === 0 ? (
    &lt;EmptyState
        title="No items yet"
        description="Add your first item to get started"
    /&gt;
) : (
    &lt;ItemList items={items} /&gt;
)}

// ‚ùå Bad: Blank page
{items.map(item => &lt;Item key={item.id} {...item} /&gt;)}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 4. Type Your Lists</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Fully typed
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

const [todos, setTodos] = useState&lt;Todo[]&gt;([]);

// ‚ùå Bad: No types
const [todos, setTodos] = useState([]);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 5. Use Derived State</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Calculate filtered list
const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
const [filter, setFilter] = useState('all');

const filteredTodos = todos.filter(todo => {
    if (filter === 'active') return !todo.completed;
    if (filter === 'completed') return todo.completed;
    return true;
});

// ‚ùå Bad: Store filtered list in state
const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
const [filteredTodos, setFilteredTodos] = useState&lt;Todo[]&gt;([]);</code></pre>
                </div>

                <h3>Lists Checklist</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Check</th>
                            <th>Done?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Every list item has a unique key</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>Keys are stable (not random or index when list changes)</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>Empty state is handled gracefully</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>Complex list items extracted to components</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>List and items are properly typed</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>Using array methods correctly (map, filter, etc.)</td>
                            <td>‚òê</td>
                        </tr>
                        <tr>
                            <td>Filtered/sorted lists are derived, not stored</td>
                            <td>‚òê</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 11: Summary -->
            <section id="section11" class="lesson-section">
                <h2>üìö Summary</h2>
                <p>Congratulations! You've mastered lists and keys in React - a fundamental skill for building dynamic applications.</p>

                <div class="card">
                    <h3>What You Learned</h3>
                    
                    <p><strong>üìã Rendering Lists</strong></p>
                    <ul>
                        <li>Using map() to transform arrays into JSX</li>
                        <li>Rendering arrays of objects</li>
                        <li>Extracting list items to components</li>
                    </ul>

                    <p><strong>üîë The Key Prop</strong></p>
                    <ul>
                        <li>Why keys are critical for React's reconciliation</li>
                        <li>How keys help React track elements</li>
                        <li>Problems with using index as key</li>
                        <li>When index keys are acceptable</li>
                    </ul>

                    <p><strong>üéØ Choosing Keys</strong></p>
                    <ul>
                        <li>Best sources for keys (database IDs, UUIDs)</li>
                        <li>Generating keys for new items</li>
                        <li>Keys must be unique among siblings</li>
                        <li>Keys must be stable and consistent</li>
                    </ul>

                    <p><strong>üîß Array Methods</strong></p>
                    <ul>
                        <li>map() for transforming data</li>
                        <li>filter() for selecting items</li>
                        <li>reduce() for aggregating values</li>
                        <li>Chaining methods for complex operations</li>
                    </ul>

                    <p><strong>‚úèÔ∏è CRUD Operations</strong></p>
                    <ul>
                        <li>Create: Adding items to lists</li>
                        <li>Read: Displaying lists</li>
                        <li>Update: Modifying items</li>
                        <li>Delete: Removing items</li>
                    </ul>

                    <p><strong>üìò TypeScript</strong></p>
                    <ul>
                        <li>Typing arrays and list components</li>
                        <li>Type-safe array methods</li>
                        <li>Generic list components</li>
                    </ul>

                    <p><strong>‚ö° Performance</strong></p>
                    <ul>
                        <li>How keys affect performance</li>
                        <li>Virtual scrolling for long lists</li>
                        <li>Memoization with React.memo</li>
                        <li>When to optimize</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Keys are mandatory</strong> - React needs them to track list items</li>
                        <li><strong>Use stable IDs</strong> - Database IDs or generated UUIDs are best</li>
                        <li><strong>Index as key is risky</strong> - Only use for static lists</li>
                        <li><strong>map() is your friend</strong> - Transform data to JSX</li>
                        <li><strong>Handle empty states</strong> - Don't leave users confused</li>
                        <li><strong>Type everything</strong> - TypeScript makes lists safer</li>
                    </ul>
                </div>

                <h3>üöÄ Next Steps</h3>
                <p>Now that you've mastered lists, you're ready for more advanced rendering patterns:</p>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üìñ Coming Up Next</h4>
                    <p><strong>Lesson 3.5: Conditional Rendering Patterns</strong></p>
                    <ul>
                        <li>Advanced conditional rendering techniques</li>
                        <li>Ternary operators vs logical && operators</li>
                        <li>Switch statements in JSX</li>
                        <li>Early returns and guard clauses</li>
                    </ul>
                </div>

                <h3>üí™ Practice Projects</h3>
                <p>Build these to master lists:</p>
                <ul>
                    <li><strong>Contact Manager</strong> - CRUD for contacts with search and groups</li>
                    <li><strong>Expense Tracker</strong> - List of transactions with categories and totals</li>
                    <li><strong>Recipe Box</strong> - Recipes with ingredients lists and instructions</li>
                    <li><strong>Music Playlist</strong> - Songs with play counts and favorites</li>
                    <li><strong>Issue Tracker</strong> - Bugs/features with status, priority, and assignees</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚ú® Remember</h4>
                    <p>Lists are everywhere in React applications. The patterns you learned here - proper keys, array methods, CRUD operations - are skills you'll use every single day as a React developer. Master these fundamentals, and you'll be able to build any kind of dynamic, data-driven interface!</p>
                </div>

                <div class="card">
                    <h3>üìö Additional Resources</h3>
                    <ul>
                        <li><a href="https://react.dev/learn/rendering-lists" target="_blank" rel="noopener noreferrer">React Docs: Rendering Lists</a></li>
                        <li><a href="https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key" target="_blank" rel="noopener noreferrer">React Docs: Keys</a></li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener noreferrer">MDN: Array Methods</a></li>
                        <li><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener noreferrer">react-window: Virtual Scrolling</a></li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                    <li><strong>Issue Tracker</strong> - Bugs/features with status, priority, and assignees</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚ú® Remember</h4>
                    <p>Lists are everywhere in React applications. The patterns you learned here - proper keys, array methods, CRUD operations - are skills you'll use every single day as a React developer. Master these fundamentals, and you'll be able to build any kind of dynamic, data-driven interface!</p>
                </div>

                <div class="card">
                    <h3>üìö Additional Resources</h3>
                    <ul>
                        <li><a href="https://react.dev/learn/rendering-lists" target="_blank" rel="noopener noreferrer">React Docs: Rendering Lists</a></li>
                        <li><a href="https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key" target="_blank" rel="noopener noreferrer">React Docs: Keys</a></li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener noreferrer">MDN: Array Methods</a></li>
                        <li><a href="https://github.com/bvaughn/react-window" target="_blank" rel="noopener noreferrer">react-window: Virtual Scrolling</a></li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                    <h3 style="color: white;">üéâ Congratulation                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've completed Lesson 3.4 and mastered lists and keys in React! You can now render dynamic lists, choose proper keys, perform CRUD operations, and optimize list performance. This is essential knowledge for building real-world applications. Excellent work! üöÄ</p>
                </div>
            </section>

        </div>
    </main>

    <!-- Lesson Navigation -->
    <div class="lesson-nav">
        <a href="lesson_3_3_forms_in_react.html" class="lesson-nav-btn lesson-nav-prev">
            <span>‚Üê Previous</span>
            <small>Lesson 3.3: Forms in React</small>
        </a>
        <a href="index.html" class="lesson-nav-btn lesson-nav-home">
            <span>‚åÇ</span>
            <small>Home</small>
        </a>
        <a href="lesson_3_5_conditional_rendering.html" class="lesson-nav-btn lesson-nav-next">
            <span>Next ‚Üí</span>
            <small>Lesson 3.5: Conditional Rendering</small>
        </a>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">Modules</a> |
                <a href="https://github.com/practicalace" target="_blank" rel="noopener noreferrer">GitHub</a>
            </p>
        </div>
    </footer>

    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
