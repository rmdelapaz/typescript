<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Custom Hooks in React with TypeScript - Learn to create reusable hook logic, build custom hooks for data fetching, form handling, and more. Extract and share logic between components effectively.">
    <meta name="author" content="PracticalAce">
    <title>Custom Hooks - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module4">Module 4: Side Effects and Data Fetching</a></li>
            <li aria-current="page">Lesson 4.3: Custom Hooks</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üé£ Custom Hooks</h1>
                <p class="lead">You've been using React's built-in hooks like useState and useEffect. But what if you could create your own hooks? Custom hooks are JavaScript functions that let you extract and reuse stateful logic between components. Instead of copying and pasting the same useState and useEffect code everywhere, you can package it into a reusable hook with a name like useFetch, useForm, or useLocalStorage. Custom hooks are one of React's most powerful features‚Äîthey let you build your own abstractions and share logic elegantly. Let's learn how to create them! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what custom hooks are and why they're useful</li>
                        <li>Follow the rules of hooks when creating custom hooks</li>
                        <li>Extract stateful logic into reusable custom hooks</li>
                        <li>Build custom hooks for data fetching</li>
                        <li>Create hooks for form handling and validation</li>
                        <li>Build utility hooks (useLocalStorage, useDebounce, etc.)</li>
                        <li>Type custom hooks properly with TypeScript</li>
                        <li>Compose multiple hooks together</li>
                        <li>Test and debug custom hooks</li>
                        <li>Share hooks across your application</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a collection of reusable custom hooks</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What Are Custom Hooks?</a></li>
                        <li><a href="#section2" class="toc-link">Rules of Hooks</a></li>
                        <li><a href="#section3" class="toc-link">Your First Custom Hook</a></li>
                        <li><a href="#section4" class="toc-link">Data Fetching Hooks</a></li>
                        <li><a href="#section5" class="toc-link">Form Handling Hooks</a></li>
                        <li><a href="#section6" class="toc-link">Utility Hooks</a></li>
                        <li><a href="#section7" class="toc-link">Hook Composition</a></li>
                        <li><a href="#section8" class="toc-link">TypeScript Best Practices</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What Are Custom Hooks? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What Are Custom Hooks?</h2>
                <p>Custom hooks are JavaScript functions that use React's built-in hooks. They let you extract component logic into reusable functions.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Custom Hook:</strong> A JavaScript function whose name starts with "use" and that may call other hooks. Custom hooks let you reuse stateful logic between components without changing your component hierarchy.</p>
                </div>

                <h3>The Problem: Duplicated Logic</h3>
                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Without Custom Hooks</h4>
                    <pre><code class="language-typescript">// Component A: Fetching user data
const UserProfile: React.FC = () => {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        fetch('https://api.example.com/user')
            .then(res => res.json())
            .then(setUser)
            .catch(setError)
            .finally(() => setIsLoading(false));
    }, []);
    
    // ... render logic
};

// Component B: Fetching posts data
const PostsList: React.FC = () => {
    const [posts, setPosts] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
        fetch('https://api.example.com/posts')
            .then(res => res.json())
            .then(setPosts)
            .catch(setError)
            .finally(() => setIsLoading(false));
    }, []);
    
    // ... render logic
};

// Problem: Same logic duplicated in both components! üòû</code></pre>
                </div>

                <h3>The Solution: Custom Hook</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ With Custom Hook</h4>
                    <pre><code class="language-typescript">// hooks/useFetch.ts
function useFetch&lt;T&gt;(url: string) {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    useEffect(() => {
        fetch(url)
            .then(res => res.json())
            .then(setData)
            .catch(setError)
            .finally(() => setIsLoading(false));
    }, [url]);
    
    return { data, isLoading, error };
}

// Component A: Clean and simple!
const UserProfile: React.FC = () => {
    const { data: user, isLoading, error } = useFetch&lt;User&gt;('/api/user');
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    
    return &lt;div&gt;{user?.name}&lt;/div&gt;;
};

// Component B: Reusing the same hook!
const PostsList: React.FC = () => {
    const { data: posts, isLoading, error } = useFetch&lt;Post[]&gt;('/api/posts');
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    
    return &lt;ul&gt;{posts?.map(post => &lt;li key={post.id}&gt;{post.title}&lt;/li&gt;)}&lt;/ul&gt;;
};</code></pre>
                </div>

                <h3>Benefits of Custom Hooks</h3>
                <div class="card">
                    <h4>Why Use Custom Hooks?</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Benefit</th>
                                <th>Description</th>
                                <th>Example</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Reusability</strong></td>
                                <td>Write logic once, use everywhere</td>
                                <td>useFetch in all components</td>
                            </tr>
                            <tr>
                                <td><strong>Separation of Concerns</strong></td>
                                <td>Logic separate from UI</td>
                                <td>Form logic vs form UI</td>
                            </tr>
                            <tr>
                                <td><strong>Testability</strong></td>
                                <td>Test logic independently</td>
                                <td>Test useFetch without UI</td>
                            </tr>
                            <tr>
                                <td><strong>Readability</strong></td>
                                <td>Self-documenting code</td>
                                <td>useAuth vs 50 lines of auth code</td>
                            </tr>
                            <tr>
                                <td><strong>Composition</strong></td>
                                <td>Combine hooks together</td>
                                <td>useAuth + useFetch</td>
                            </tr>
                            <tr>
                                <td><strong>Sharing</strong></td>
                                <td>Share across projects/teams</td>
                                <td>Hook libraries</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Custom Hooks vs Other Patterns</h3>
                <pre class="mermaid">
graph TD
    A[Need to Share Logic] --> B{What Kind?}
    
    B -->|Stateful Logic| C[Custom Hook]
    B -->|UI Structure| D[Component]
    B -->|Pure Functions| E[Utility Function]
    B -->|Complex State| F[Context + Custom Hook]
    
    C --> G[useFetch, useForm, useAuth]
    D --> H[Modal, Card, Button]
    E --> I[formatDate, validateEmail]
    F --> J[useTheme, useCart]
    
    style C fill:#4CAF50,color:#fff
    style A fill:#667eea,color:#fff
</pre>

                <h3>When to Create a Custom Hook</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Guidelines</h4>
                    <ul>
                        <li><strong>‚úÖ DO create a hook when:</strong>
                            <ul>
                                <li>Logic is duplicated across multiple components</li>
                                <li>Logic uses other React hooks (useState, useEffect, etc.)</li>
                                <li>Logic would make components cleaner if extracted</li>
                                <li>Logic is complex and deserves a descriptive name</li>
                            </ul>
                        </li>
                        <li><strong>‚ùå DON'T create a hook when:</strong>
                            <ul>
                                <li>Logic is only used once (wait until you need it twice)</li>
                                <li>Logic doesn't use any React hooks (use regular function)</li>
                                <li>Logic is very simple (1-2 lines)</li>
                                <li>You're just wrapping a single hook with no additional logic</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Rules of Hooks -->
            <section id="section2" class="lesson-section">
                <h2>üìú Rules of Hooks</h2>
                <p>Custom hooks must follow the same rules as built-in hooks. These rules are enforced by ESLint and are crucial for hooks to work correctly.</p>

                <h3>Rule 1: Only Call Hooks at the Top Level</h3>
                <div class="card">
                    <h4>Don't Call Hooks Inside Loops, Conditions, or Nested Functions</h4>
                    <pre><code class="language-typescript">// ‚ùå WRONG: Hook inside condition
function useUser(id: number | null) {
    if (id) {
        const [user, setUser] = useState(null); // ERROR!
    }
}

// ‚ùå WRONG: Hook inside loop
function useMultipleUsers(ids: number[]) {
    const users = ids.map(id => {
        const [user, setUser] = useState(null); // ERROR!
        return user;
    });
}

// ‚úÖ CORRECT: Hook at top level
function useUser(id: number | null) {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        if (id) {
            // Condition inside effect is fine
            fetchUser(id).then(setUser);
        }
    }, [id]);
    
    return user;
}</code></pre>
                </div>

                <h3>Rule 2: Only Call Hooks from React Functions</h3>
                <div class="card">
                    <h4>Call Hooks from Components or Custom Hooks Only</h4>
                    <pre><code class="language-typescript">// ‚ùå WRONG: Hook in regular function
function fetchUser(id: number) {
    const [user, setUser] = useState(null); // ERROR!
    // Regular functions can't use hooks
}

// ‚úÖ CORRECT: Hook in custom hook
function useUser(id: number) {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        fetchUser(id).then(setUser);
    }, [id]);
    
    return user;
}

// ‚úÖ CORRECT: Hook in component
const UserProfile: React.FC = () => {
    const user = useUser(1);
    return &lt;div&gt;{user?.name}&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>Rule 3: Custom Hook Names Must Start with "use"</h3>
                <div class="card">
                    <h4>Naming Convention is Mandatory</h4>
                    <pre><code class="language-typescript">// ‚ùå WRONG: Doesn't start with "use"
function fetchData(url: string) {
    const [data, setData] = useState(null);
    // ...
}

// ‚ùå WRONG: Starts with "use" but not camelCase
function use_data(url: string) {
    const [data, setData] = useState(null);
    // ...
}

// ‚úÖ CORRECT: Starts with "use" in camelCase
function useData(url: string) {
    const [data, setData] = useState(null);
    // ...
}

// ‚úÖ CORRECT: More specific name
function useFetchUser(userId: number) {
    const [user, setUser] = useState(null);
    // ...
}</code></pre>
                </div>

                <h3>Why These Rules Matter</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Understanding the Rules</h4>
                    <p>React relies on the order hooks are called to maintain state correctly. Breaking these rules causes:</p>
                    <ul>
                        <li><strong>State corruption:</strong> React loses track of which state belongs to which hook</li>
                        <li><strong>Unpredictable behavior:</strong> Different renders may have different hook orders</li>
                        <li><strong>Hard-to-debug errors:</strong> Subtle bugs that only appear sometimes</li>
                    </ul>
                    
                    <pre><code class="language-typescript">// Why order matters:
function MyComponent() {
    // First render:
    const [count, setCount] = useState(0);    // Hook 1
    const [name, setName] = useState('');     // Hook 2
    
    // React internally tracks: [0, '']
    
    // If you conditionally skip a hook:
    if (someCondition) {
        const [count, setCount] = useState(0); // Sometimes Hook 1
    }
    const [name, setName] = useState('');      // Sometimes Hook 1, sometimes Hook 2!
    
    // React's internal state gets confused! üí•
}</code></pre>
                </div>

                <h3>ESLint Plugin</h3>
                <div class="card">
                    <h4>Automatic Rule Enforcement</h4>
                    <pre><code class="language-bash"># Install ESLint plugin for hooks
npm install eslint-plugin-react-hooks --save-dev</code></pre>
                    
                    <pre><code class="language-json">// .eslintrc.json
{
  "plugins": ["react-hooks"],
  "rules": {
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn"
  }
}</code></pre>
                    
                    <p>This plugin will catch hook violations automatically!</p>
                </div>
            </section>

            <!-- Section 3: Your First Custom Hook -->
            <section id="section3" class="lesson-section">
                <h2>üé® Your First Custom Hook</h2>
                <p>Let's build a simple custom hook step-by-step to understand the pattern.</p>

                <h3>Example: useCounter Hook</h3>
                <div class="card">
                    <h4>Step 1: Identify Reusable Logic</h4>
                    <pre><code class="language-typescript">// This counter logic appears in multiple components
const Counter: React.FC = () => {
    const [count, setCount] = useState(0);
    
    const increment = () => setCount(prev => prev + 1);
    const decrement = () => setCount(prev => prev - 1);
    const reset = () => setCount(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={increment}&gt;+&lt;/button&gt;
            &lt;button onClick={decrement}&gt;-&lt;/button&gt;
            &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card">
                    <h4>Step 2: Extract Logic into Hook</h4>
                    <pre><code class="language-typescript">// hooks/useCounter.ts
import { useState } from 'react';

function useCounter(initialValue: number = 0) {
    const [count, setCount] = useState(initialValue);
    
    const increment = () => setCount(prev => prev + 1);
    const decrement = () => setCount(prev => prev - 1);
    const reset = () => setCount(initialValue);
    
    return { count, increment, decrement, reset };
}

export default useCounter;</code></pre>
                </div>

                <div class="card">
                    <h4>Step 3: Use the Hook</h4>
                    <pre><code class="language-typescript">import useCounter from './hooks/useCounter';

const Counter: React.FC = () => {
    const { count, increment, decrement, reset } = useCounter(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={increment}&gt;+&lt;/button&gt;
            &lt;button onClick={decrement}&gt;-&lt;/button&gt;
            &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
        &lt;/div&gt;
    );
};

// Now reusable everywhere!
const AnotherComponent: React.FC = () => {
    const likes = useCounter(0);
    const views = useCounter(100);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Likes: {likes.count}&lt;/p&gt;
            &lt;button onClick={likes.increment}&gt;üëç&lt;/button&gt;
            
            &lt;p&gt;Views: {views.count}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Enhancing the Hook</h3>
                <div class="card">
                    <h4>Adding More Features</h4>
                    <pre><code class="language-typescript">// Enhanced useCounter with more options
interface UseCounterOptions {
    min?: number;
    max?: number;
    step?: number;
}

function useCounter(initialValue: number = 0, options: UseCounterOptions = {}) {
    const { min, max, step = 1 } = options;
    const [count, setCount] = useState(initialValue);
    
    const increment = () => {
        setCount(prev => {
            const next = prev + step;
            if (max !== undefined && next > max) return max;
            return next;
        });
    };
    
    const decrement = () => {
        setCount(prev => {
            const next = prev - step;
            if (min !== undefined && next < min) return min;
            return next;
        });
    };
    
    const reset = () => setCount(initialValue);
    
    const set = (value: number) => {
        if (min !== undefined && value < min) {
            setCount(min);
        } else if (max !== undefined && value > max) {
            setCount(max);
        } else {
            setCount(value);
        }
    };
    
    return { count, increment, decrement, reset, set };
}

// Usage with options
const Counter: React.FC = () => {
    const { count, increment, decrement } = useCounter(0, {
        min: 0,
        max: 10,
        step: 2
    });
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={increment}&gt;+2&lt;/button&gt;
            &lt;button onClick={decrement}&gt;-2&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Hook Anatomy</h3>
                <pre class="mermaid">
graph TD
    A[Custom Hook Function] --> B[Parameters/Config]
    A --> C[Internal State - useState]
    A --> D[Side Effects - useEffect]
    A --> E[Helper Functions]
    A --> F[Return Values/Methods]
    
    F --> G[State Values]
    F --> H[Update Functions]
    F --> I[Utility Methods]
    
    style A fill:#667eea,color:#fff
    style F fill:#4CAF50,color:#fff
</pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Hook Pattern</h4>
                    <pre><code class="language-typescript">function useCustomHook(parameters) {
    // 1. Internal state
    const [state, setState] = useState(initialValue);
    
    // 2. Side effects
    useEffect(() => {
        // Effects based on parameters or state
    }, [dependencies]);
    
    // 3. Helper functions
    const helperFunction = () => {
        // Logic that uses/updates state
    };
    
    // 4. Return value (object or array)
    return { state, helperFunction };
    // or
    return [state, helperFunction];
}</code></pre>
                </div>
            </section>

            <!-- Section 4: Data Fetching Hooks -->
            <section id="section4" class="lesson-section">
                <h2>üåê Data Fetching Hooks</h2>
                <p>One of the most common uses for custom hooks is abstracting data fetching logic. Let's build progressively better versions!</p>

                <h3>Basic useFetch Hook</h3>
                <div class="card">
                    <h4>Simple Data Fetching</h4>
                    <pre><code class="language-typescript">// hooks/useFetch.ts
import { useState, useEffect } from 'react';

interface UseFetchResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
}

function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    useEffect(() => {
        const fetchData = async () => {
            try {
                setIsLoading(true);
                const response = await fetch(url);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
            } catch (err) {
                setError(err instanceof Error ? err : new Error('An error occurred'));
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
    }, [url]);
    
    return { data, isLoading, error };
}

export default useFetch;

// Usage
const UserProfile: React.FC = () => {
    const { data: user, isLoading, error } = useFetch&lt;User&gt;(
        'https://jsonplaceholder.typicode.com/users/1'
    );
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    
    return &lt;div&gt;{user?.name}&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>Enhanced useFetch with Cancellation</h3>
                <div class="card">
                    <h4>Adding AbortController</h4>
                    <pre><code class="language-typescript">function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                setError(null);
                
                const response = await fetch(url, {
                    signal: controller.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
            } catch (err) {
                // Don't set error if aborted
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        // Cleanup: cancel request
        return () => {
            controller.abort();
        };
    }, [url]);
    
    return { data, isLoading, error };
}</code></pre>
                </div>

                <h3>Advanced useFetch with Refetch</h3>
                <div class="card">
                    <h4>Adding Manual Refetch Capability</h4>
                    <pre><code class="language-typescript">interface UseFetchResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
    refetch: () => void;
}

function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    const [refetchIndex, setRefetchIndex] = useState(0);
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                setError(null);
                
                const response = await fetch(url, {
                    signal: controller.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        return () => controller.abort();
    }, [url, refetchIndex]); // Refetch when refetchIndex changes
    
    const refetch = () => {
        setRefetchIndex(prev => prev + 1);
    };
    
    return { data, isLoading, error, refetch };
}

// Usage
const UserProfile: React.FC = () => {
    const { data: user, isLoading, error, refetch } = useFetch&lt;User&gt;('/api/user');
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;button onClick={refetch}&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Configurable useFetch</h3>
                <div class="card">
                    <h4>Adding Options and POST Support</h4>
                    <pre><code class="language-typescript">interface UseFetchOptions {
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
    headers?: Record&lt;string, string&gt;;
    body?: any;
    enabled?: boolean; // Only fetch if true
}

interface UseFetchResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
    refetch: () => void;
}

function useFetch&lt;T&gt;(
    url: string,
    options: UseFetchOptions = {}
): UseFetchResult&lt;T&gt; {
    const { method = 'GET', headers, body, enabled = true } = options;
    
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(enabled);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    const [refetchIndex, setRefetchIndex] = useState(0);
    
    useEffect(() => {
        if (!enabled) {
            setIsLoading(false);
            return;
        }
        
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                setError(null);
                
                const fetchOptions: RequestInit = {
                    method,
                    headers: {
                        'Content-Type': 'application/json',
                        ...headers
                    },
                    signal: controller.signal
                };
                
                if (body && method !== 'GET') {
                    fetchOptions.body = JSON.stringify(body);
                }
                
                const response = await fetch(url, fetchOptions);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        return () => controller.abort();
    }, [url, method, enabled, refetchIndex]);
    
    const refetch = () => {
        setRefetchIndex(prev => prev + 1);
    };
    
    return { data, isLoading, error, refetch };
}

// Usage examples
const UserProfile: React.FC = () => {
    // Simple GET
    const { data: user } = useFetch&lt;User&gt;('/api/user');
    
    // POST request
    const createUser = useFetch&lt;User&gt;('/api/users', {
        method: 'POST',
        body: { name: 'John', email: 'john@example.com' },
        enabled: false // Don't fetch on mount
    });
    
    // Conditional fetch
    const [shouldFetch, setShouldFetch] = useState(false);
    const { data: posts } = useFetch&lt;Post[]&gt;('/api/posts', {
        enabled: shouldFetch
    });
    
    return &lt;div&gt;...&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>useAPI Hook for Multiple Endpoints</h3>
                <div class="card">
                    <h4>RESTful API Helper</h4>
                    <pre><code class="language-typescript">interface UseAPIResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
    get: (id?: string | number) => Promise&lt;void&gt;;
    post: (body: Partial&lt;T&gt;) => Promise&lt;void&gt;;
    put: (id: string | number, body: Partial&lt;T&gt;) => Promise&lt;void&gt;;
    del: (id: string | number) => Promise&lt;void&gt;;
}

function useAPI&lt;T&gt;(baseUrl: string): UseAPIResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    const request = async (url: string, options: RequestInit = {}) => {
        try {
            setIsLoading(true);
            setError(null);
            
            const response = await fetch(url, {
                headers: {
                    'Content-Type': 'application/json',
                    ...options.headers
                },
                ...options
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const json = await response.json();
            setData(json);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('An error occurred'));
            throw err;
        } finally {
            setIsLoading(false);
        }
    };
    
    const get = async (id?: string | number) => {
        const url = id ? `${baseUrl}/${id}` : baseUrl;
        await request(url);
    };
    
    const post = async (body: Partial&lt;T&gt;) => {
        await request(baseUrl, {
            method: 'POST',
            body: JSON.stringify(body)
        });
    };
    
    const put = async (id: string | number, body: Partial&lt;T&gt;) => {
        await request(`${baseUrl}/${id}`, {
            method: 'PUT',
            body: JSON.stringify(body)
        });
    };
    
    const del = async (id: string | number) => {
        await request(`${baseUrl}/${id}`, {
            method: 'DELETE'
        });
    };
    
    return { data, isLoading, error, get, post, put, del };
}

// Usage
const UserManager: React.FC = () => {
    const users = useAPI&lt;User&gt;('https://api.example.com/users');
    
    const loadUser = () => {
        users.get(1); // GET /users/1
    };
    
    const createUser = () => {
        users.post({ name: 'John', email: 'john@example.com' });
    };
    
    const updateUser = () => {
        users.put(1, { name: 'John Smith' });
    };
    
    const deleteUser = () => {
        users.del(1);
    };
    
    return (
        &lt;div&gt;
            &lt;button onClick={loadUser}&gt;Load User&lt;/button&gt;
            &lt;button onClick={createUser}&gt;Create User&lt;/button&gt;
            {users.data && &lt;div&gt;{users.data.name}&lt;/div&gt;}
        &lt;/div&gt;
    );
};</code></pre>
                </div>
            </section>

            <!-- Section 5: Form Handling Hooks -->
            <section id="section5" class="lesson-section">
                <h2>üìù Form Handling Hooks</h2>
                <p>Form handling is repetitive‚Äîlet's create hooks to make it easier!</p>

                <h3>useForm Hook</h3>
                <div class="card">
                    <h4>Simple Form State Management</h4>
                    <pre><code class="language-typescript">interface UseFormResult&lt;T&gt; {
    values: T;
    handleChange: (e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;) => void;
    handleSubmit: (callback: (values: T) => void) => (e: React.FormEvent) => void;
    reset: () => void;
}

function useForm&lt;T extends Record&lt;string, any&gt;&gt;(
    initialValues: T
): UseFormResult&lt;T&gt; {
    const [values, setValues] = useState&lt;T&gt;(initialValues);
    
    const handleChange = (
        e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;
    ) => {
        const { name, value, type } = e.target;
        
        setValues(prev => ({
            ...prev,
            [name]: type === 'number' ? Number(value) : value
        }));
    };
    
    const handleSubmit = (callback: (values: T) => void) => {
        return (e: React.FormEvent) => {
            e.preventDefault();
            callback(values);
        };
    };
    
    const reset = () => {
        setValues(initialValues);
    };
    
    return { values, handleChange, handleSubmit, reset };
}

// Usage
interface LoginForm {
    email: string;
    password: string;
}

const LoginPage: React.FC = () => {
    const form = useForm&lt;LoginForm&gt;({
        email: '',
        password: ''
    });
    
    const onSubmit = (values: LoginForm) => {
        console.log('Login:', values);
        // Call login API
    };
    
    return (
        &lt;form onSubmit={form.handleSubmit(onSubmit)}&gt;
            &lt;input
                type="email"
                name="email"
                value={form.values.email}
                onChange={form.handleChange}
                placeholder="Email"
            /&gt;
            
            &lt;input
                type="password"
                name="password"
                value={form.values.password}
                onChange={form.handleChange}
                placeholder="Password"
            /&gt;
            
            &lt;button type="submit"&gt;Login&lt;/button&gt;
            &lt;button type="button" onClick={form.reset}&gt;Reset&lt;/button&gt;
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <h3>useForm with Validation</h3>
                <div class="card">
                    <h4>Adding Validation Logic</h4>
                    <pre><code class="language-typescript">type ValidationRules&lt;T&gt; = {
    [K in keyof T]?: (value: T[K]) => string | undefined;
};

interface UseFormWithValidationResult&lt;T&gt; {
    values: T;
    errors: Partial&lt;Record&lt;keyof T, string&gt;&gt;;
    handleChange: (e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;) => void;
    handleSubmit: (callback: (values: T) => void) => (e: React.FormEvent) => void;
    reset: () => void;
    isValid: boolean;
}

function useFormWithValidation&lt;T extends Record&lt;string, any&gt;&gt;(
    initialValues: T,
    validationRules: ValidationRules&lt;T&gt;
): UseFormWithValidationResult&lt;T&gt; {
    const [values, setValues] = useState&lt;T&gt;(initialValues);
    const [errors, setErrors] = useState&lt;Partial&lt;Record&lt;keyof T, string&gt;&gt;&gt;({});
    const [touched, setTouched] = useState&lt;Partial&lt;Record&lt;keyof T, boolean&gt;&gt;&gt;({});
    
    const validate = (name: keyof T, value: any): string | undefined => {
        const rule = validationRules[name];
        return rule ? rule(value) : undefined;
    };
    
    const handleChange = (
        e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;
    ) => {
        const { name, value, type } = e.target;
        const fieldName = name as keyof T;
        const fieldValue = type === 'number' ? Number(value) : value;
        
        setValues(prev => ({
            ...prev,
            [fieldName]: fieldValue
        }));
        
        // Validate on change if field was touched
        if (touched[fieldName]) {
            const error = validate(fieldName, fieldValue);
            setErrors(prev => ({
                ...prev,
                [fieldName]: error
            }));
        }
    };
    
    const handleBlur = (name: keyof T) => {
        setTouched(prev => ({ ...prev, [name]: true }));
        const error = validate(name, values[name]);
        setErrors(prev => ({ ...prev, [name]: error }));
    };
    
    const validateAll = (): boolean => {
        const newErrors: Partial&lt;Record&lt;keyof T, string&gt;&gt; = {};
        let isValid = true;
        
        Object.keys(validationRules).forEach(key => {
            const fieldName = key as keyof T;
            const error = validate(fieldName, values[fieldName]);
            if (error) {
                newErrors[fieldName] = error;
                isValid = false;
            }
        });
        
        setErrors(newErrors);
        return isValid;
    };
    
    const handleSubmit = (callback: (values: T) => void) => {
        return (e: React.FormEvent) => {
            e.preventDefault();
            
            if (validateAll()) {
                callback(values);
            }
        };
    };
    
    const reset = () => {
        setValues(initialValues);
        setErrors({});
        setTouched({});
    };
    
    const isValid = Object.keys(errors).length === 0;
    
    return {
        values,
        errors,
        handleChange,
        handleSubmit,
        reset,
        isValid
    };
}

// Usage
interface SignupForm {
    username: string;
    email: string;
    password: string;
    confirmPassword: string;
}

const SignupPage: React.FC = () => {
    const form = useFormWithValidation&lt;SignupForm&gt;(
        {
            username: '',
            email: '',
            password: '',
            confirmPassword: ''
        },
        {
            username: (value) => {
                if (!value) return 'Username is required';
                if (value.length < 3) return 'Username must be at least 3 characters';
                return undefined;
            },
            email: (value) => {
                if (!value) return 'Email is required';
                if (!/\S+@\S+\.\S+/.test(value)) return 'Email is invalid';
                return undefined;
            },
            password: (value) => {
                if (!value) return 'Password is required';
                if (value.length < 8) return 'Password must be at least 8 characters';
                return undefined;
            },
            confirmPassword: (value) => {
                if (value !== form.values.password) return 'Passwords do not match';
                return undefined;
            }
        }
    );
    
    const onSubmit = (values: SignupForm) => {
        console.log('Signup:', values);
    };
    
    return (
        &lt;form onSubmit={form.handleSubmit(onSubmit)}&gt;
            &lt;div&gt;
                &lt;input
                    type="text"
                    name="username"
                    value={form.values.username}
                    onChange={form.handleChange}
                    placeholder="Username"
                /&gt;
                {form.errors.username && &lt;span&gt;{form.errors.username}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="email"
                    name="email"
                    value={form.values.email}
                    onChange={form.handleChange}
                    placeholder="Email"
                /&gt;
                {form.errors.email && &lt;span&gt;{form.errors.email}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="password"
                    name="password"
                    value={form.values.password}
                    onChange={form.handleChange}
                    placeholder="Password"
                /&gt;
                {form.errors.password && &lt;span&gt;{form.errors.password}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="password"
                    name="confirmPassword"
                    value={form.values.confirmPassword}
                    onChange={form.handleChange}
                    placeholder="Confirm Password"
                /&gt;
                {form.errors.confirmPassword && &lt;span&gt;{form.errors.confirmPassword}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;button type="submit" disabled={!form.isValid}&gt;Sign Up&lt;/button&gt;
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <h3>useInput Hook</h3>
                <div class="card">
                    <h4>Single Input State Management</h4>
                    <pre><code class="language-typescript">interface UseInputResult {
    value: string;
    onChange: (e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;) => void;
    reset: () => void;
    setValue: (value: string) => void;
}

function useInput(initialValue: string = ''): UseInputResult {
    const [value, setValue] = useState(initialValue);
    
    const onChange = (
        e: React.ChangeEvent&lt;HTMLInputElement | HTMLTextAreaElement&gt;
    ) => {
        setValue(e.target.value);
    };
    
    const reset = () => {
        setValue(initialValue);
    };
    
    return { value, onChange, reset, setValue };
}

// Usage
const SearchBar: React.FC = () => {
    const search = useInput('');
    const email = useInput('user@example.com');
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={search.value}
                onChange={search.onChange}
                placeholder="Search..."
            /&gt;
            
            &lt;input
                type="email"
                value={email.value}
                onChange={email.onChange}
            /&gt;
            
            &lt;button onClick={search.reset}&gt;Clear Search&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>
            </section>

            <!-- Section 6: Utility Hooks -->
            <section id="section6" class="lesson-section">
                <h2>üõ†Ô∏è Utility Hooks</h2>
                <p>Let's build some useful utility hooks that solve common problems!</p>

                <h3>useLocalStorage Hook</h3>
                <div class="card">
                    <h4>Persistent State with localStorage</h4>
                    <pre><code class="language-typescript">function useLocalStorage&lt;T&gt;(
    key: string,
    initialValue: T
): [T, (value: T | ((prev: T) => T)) => void] {
    // Get initial value from localStorage or use initialValue
    const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        } catch (error) {
            console.error(error);
            return initialValue;
        }
    });
    
    // Return a wrapped version of useState's setter function that
    // persists the new value to localStorage
    const setValue = (value: T | ((prev: T) => T)) => {
        try {
            // Allow value to be a function so we have same API as useState
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
            console.error(error);
        }
    };
    
    return [storedValue, setValue];
}

// Usage
const Settings: React.FC = () => {
    const [theme, setTheme] = useLocalStorage&lt;'light' | 'dark'&gt;('theme', 'light');
    const [language, setLanguage] = useLocalStorage('language', 'en');
    
    return (
        &lt;div&gt;
            &lt;select value={theme} onChange={(e) => setTheme(e.target.value as 'light' | 'dark')}&gt;
                &lt;option value="light"&gt;Light&lt;/option&gt;
                &lt;option value="dark"&gt;Dark&lt;/option&gt;
            &lt;/select&gt;
            
            &lt;p&gt;Current theme: {theme}&lt;/p&gt;
            &lt;p&gt;Refresh the page - theme persists!&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>useDebounce Hook</h3>
                <div class="card">
                    <h4>Delay Value Updates</h4>
                    <pre><code class="language-typescript">function useDebounce&lt;T&gt;(value: T, delay: number = 500): T {
    const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
    
    useEffect(() => {
        // Set up timeout to update debounced value
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);
        
        // Clean up timeout if value changes before delay
        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);
    
    return debouncedValue;
}

// Usage: Search with debounce
const SearchComponent: React.FC = () => {
    const [searchTerm, setSearchTerm] = useState('');
    const debouncedSearchTerm = useDebounce(searchTerm, 500);
    const [results, setResults] = useState([]);
    
    // Effect only runs when debounced value changes
    useEffect(() => {
        if (debouncedSearchTerm) {
            fetch(`/api/search?q=${debouncedSearchTerm}`)
                .then(res => res.json())
                .then(setResults);
        }
    }, [debouncedSearchTerm]);
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Search..."
            /&gt;
            &lt;p&gt;Searching for: {debouncedSearchTerm}&lt;/p&gt;
            &lt;ul&gt;
                {results.map((result: any) => (
                    &lt;li key={result.id}&gt;{result.name}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>useToggle Hook</h3>
                <div class="card">
                    <h4>Boolean State Toggle</h4>
                    <pre><code class="language-typescript">function useToggle(initialValue: boolean = false): [boolean, () => void, (value: boolean) => void] {
    const [value, setValue] = useState(initialValue);
    
    const toggle = () => {
        setValue(prev => !prev);
    };
    
    return [value, toggle, setValue];
}

// Usage
const Modal: React.FC = () => {
    const [isOpen, toggleOpen, setIsOpen] = useToggle(false);
    
    return (
        &lt;div&gt;
            &lt;button onClick={toggleOpen}&gt;Toggle Modal&lt;/button&gt;
            &lt;button onClick={() => setIsOpen(true)}&gt;Open Modal&lt;/button&gt;
            &lt;button onClick={() => setIsOpen(false)}&gt;Close Modal&lt;/button&gt;
            
            {isOpen && (
                &lt;div className="modal"&gt;
                    &lt;h2&gt;Modal Content&lt;/h2&gt;
                    &lt;button onClick={toggleOpen}&gt;Close&lt;/button&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>useWindowSize Hook</h3>
                <div class="card">
                    <h4>Track Window Dimensions</h4>
                    <pre><code class="language-typescript">interface WindowSize {
    width: number;
    height: number;
}

function useWindowSize(): WindowSize {
    const [windowSize, setWindowSize] = useState&lt;WindowSize&gt;({
        width: window.innerWidth,
        height: window.innerHeight
    });
    
    useEffect(() => {
        const handleResize = () => {
            setWindowSize({
                width: window.innerWidth,
                height: window.innerHeight
            });
        };
        
        window.addEventListener('resize', handleResize);
        
        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, []);
    
    return windowSize;
}

// Usage
const ResponsiveComponent: React.FC = () => {
    const { width, height } = useWindowSize();
    
    return (
        &lt;div&gt;
            &lt;p&gt;Window size: {width} x {height}&lt;/p&gt;
            {width < 768 ? (
                &lt;MobileView /&gt;
            ) : (
                &lt;DesktopView /&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>usePrevious Hook</h3>
                <div class="card">
                    <h4>Access Previous Value</h4>
                    <pre><code class="language-typescript">function usePrevious&lt;T&gt;(value: T): T | undefined {
    const ref = useRef&lt;T&gt;();
    
    useEffect(() => {
        ref.current = value;
    }, [value]);
    
    return ref.current;
}

// Usage
const Counter: React.FC = () => {
    const [count, setCount] = useState(0);
    const previousCount = usePrevious(count);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Current: {count}&lt;/p&gt;
            &lt;p&gt;Previous: {previousCount}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>useOnClickOutside Hook</h3>
                <div class="card">
                    <h4>Detect Clicks Outside Element</h4>
                    <pre><code class="language-typescript">function useOnClickOutside&lt;T extends HTMLElement&gt;(
    ref: React.RefObject&lt;T&gt;,
    handler: (event: MouseEvent | TouchEvent) => void
) {
    useEffect(() => {
        const listener = (event: MouseEvent | TouchEvent) => {
            // Do nothing if clicking ref's element or descendent elements
            if (!ref.current || ref.current.contains(event.target as Node)) {
                return;
            }
            handler(event);
        };
        
        document.addEventListener('mousedown', listener);
        document.addEventListener('touchstart', listener);
        
        return () => {
            document.removeEventListener('mousedown', listener);
            document.removeEventListener('touchstart', listener);
        };
    }, [ref, handler]);
}

// Usage
const Dropdown: React.FC = () => {
    const [isOpen, setIsOpen] = useState(false);
    const ref = useRef&lt;HTMLDivElement&gt;(null);
    
    useOnClickOutside(ref, () => setIsOpen(false));
    
    return (
        &lt;div ref={ref}&gt;
            &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
                Toggle Dropdown
            &lt;/button&gt;
            {isOpen && (
                &lt;ul className="dropdown"&gt;
                    &lt;li&gt;Option 1&lt;/li&gt;
                    &lt;li&gt;Option 2&lt;/li&gt;
                    &lt;li&gt;Option 3&lt;/li&gt;
                &lt;/ul&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>useInterval Hook</h3>
                <div class="card">
                    <h4>Declarative setInterval</h4>
                    <pre><code class="language-typescript">function useInterval(callback: () => void, delay: number | null) {
    const savedCallback = useRef(callback);
    
    // Remember the latest callback
    useEffect(() => {
        savedCallback.current = callback;
    }, [callback]);
    
    // Set up the interval
    useEffect(() => {
        if (delay === null) return;
        
        const tick = () => {
            savedCallback.current();
        };
        
        const id = setInterval(tick, delay);
        
        return () => clearInterval(id);
    }, [delay]);
}

// Usage
const Timer: React.FC = () => {
    const [seconds, setSeconds] = useState(0);
    const [isRunning, setIsRunning] = useState(true);
    
    useInterval(() => {
        setSeconds(seconds + 1);
    }, isRunning ? 1000 : null); // Pass null to pause
    
    return (
        &lt;div&gt;
            &lt;p&gt;Seconds: {seconds}&lt;/p&gt;
            &lt;button onClick={() => setIsRunning(!isRunning)}&gt;
                {isRunning ? 'Pause' : 'Resume'}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>
            </section>

            <!-- Section 7: Hook Composition -->
            <section id="section7" class="lesson-section">
                <h2>üîó Hook Composition</h2>
                <p>The real power of custom hooks comes from composing them together. Let's learn how to build complex functionality by combining simple hooks!</p>

                <h3>Basic Composition</h3>
                <div class="card">
                    <h4>Using Multiple Hooks Together</h4>
                    <pre><code class="language-typescript">// useUserProfile combines fetch and localStorage
function useUserProfile(userId: number) {
    // Use existing hooks
    const { data, isLoading, error, refetch } = useFetch&lt;User&gt;(
        `https://api.example.com/users/${userId}`
    );
    
    const [cachedUser, setCachedUser] = useLocalStorage&lt;User | null&gt;(
        `user-${userId}`,
        null
    );
    
    // Cache data when it loads
    useEffect(() => {
        if (data) {
            setCachedUser(data);
        }
    }, [data, setCachedUser]);
    
    // Return cached data while loading
    return {
        user: data || cachedUser,
        isLoading,
        error,
        refetch
    };
}

// Usage
const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const { user, isLoading, error, refetch } = useUserProfile(userId);
    
    if (isLoading && !user) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;button onClick={refetch}&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Advanced Composition Example</h3>
                <div class="card">
                    <h4>useAuth Hook</h4>
                    <pre><code class="language-typescript">interface User {
    id: number;
    email: string;
    name: string;
}

interface UseAuthResult {
    user: User | null;
    isLoading: boolean;
    isAuthenticated: boolean;
    login: (email: string, password: string) => Promise&lt;void&gt;;
    logout: () => void;
    register: (email: string, password: string, name: string) => Promise&lt;void&gt;;
}

function useAuth(): UseAuthResult {
    // Compose multiple hooks
    const [user, setUser] = useLocalStorage&lt;User | null&gt;('user', null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    // Check if authenticated
    const isAuthenticated = user !== null;
    
    const login = async (email: string, password: string) => {
        try {
            setIsLoading(true);
            setError(null);
            
            const response = await fetch('/api/auth/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            });
            
            if (!response.ok) {
                throw new Error('Login failed');
            }
            
            const userData = await response.json();
            setUser(userData);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Login failed'));
            throw err;
        } finally {
            setIsLoading(false);
        }
    };
    
    const logout = () => {
        setUser(null);
    };
    
    const register = async (email: string, password: string, name: string) => {
        try {
            setIsLoading(true);
            setError(null);
            
            const response = await fetch('/api/auth/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password, name })
            });
            
            if (!response.ok) {
                throw new Error('Registration failed');
            }
            
            const userData = await response.json();
            setUser(userData);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('Registration failed'));
            throw err;
        } finally {
            setIsLoading(false);
        }
    };
    
    return {
        user,
        isLoading,
        isAuthenticated,
        login,
        logout,
        register
    };
}

// Usage
const LoginPage: React.FC = () => {
    const auth = useAuth();
    const form = useForm({ email: '', password: '' });
    
    const handleLogin = async (values: typeof form.values) => {
        try {
            await auth.login(values.email, values.password);
            // Redirect to dashboard
        } catch (err) {
            alert('Login failed');
        }
    };
    
    if (auth.isAuthenticated) {
        return &lt;div&gt;Welcome, {auth.user?.name}!&lt;/div&gt;;
    }
    
    return (
        &lt;form onSubmit={form.handleSubmit(handleLogin)}&gt;
            &lt;input
                type="email"
                name="email"
                value={form.values.email}
                onChange={form.handleChange}
                placeholder="Email"
            /&gt;
            &lt;input
                type="password"
                name="password"
                value={form.values.password}
                onChange={form.handleChange}
                placeholder="Password"
            /&gt;
            &lt;button type="submit" disabled={auth.isLoading}&gt;
                {auth.isLoading ? 'Logging in...' : 'Login'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <h3>Hook Composition Pattern</h3>
                <pre class="mermaid">
graph TD
    A[useAuth Hook] --> B[useLocalStorage]
    A --> C[useState]
    A --> D[fetch API]
    
    E[useUserProfile Hook] --> F[useFetch]
    E --> G[useLocalStorage]
    E --> H[useEffect]
    
    I[useSearchWithDebounce] --> J[useDebounce]
    I --> K[useFetch]
    I --> L[useState]
    
    style A fill:#667eea,color:#fff
    style E fill:#667eea,color:#fff
    style I fill:#667eea,color:#fff
</pre>

                <h3>Building a Shopping Cart Hook</h3>
                <div class="card">
                    <h4>useShoppingCart - Complex Composition</h4>
                    <pre><code class="language-typescript">interface CartItem {
    id: number;
    name: string;
    price: number;
    quantity: number;
}

interface UseShoppingCartResult {
    items: CartItem[];
    total: number;
    itemCount: number;
    addItem: (item: Omit&lt;CartItem, 'quantity'&gt;) => void;
    removeItem: (id: number) => void;
    updateQuantity: (id: number, quantity: number) => void;
    clear: () => void;
}

function useShoppingCart(): UseShoppingCartResult {
    // Compose with localStorage for persistence
    const [items, setItems] = useLocalStorage&lt;CartItem[]&gt;('cart', []);
    
    const addItem = (newItem: Omit&lt;CartItem, 'quantity'&gt;) => {
        setItems(prevItems => {
            const existingItem = prevItems.find(item => item.id === newItem.id);
            
            if (existingItem) {
                // Increase quantity if item exists
                return prevItems.map(item =>
                    item.id === newItem.id
                        ? { ...item, quantity: item.quantity + 1 }
                        : item
                );
            } else {
                // Add new item with quantity 1
                return [...prevItems, { ...newItem, quantity: 1 }];
            }
        });
    };
    
    const removeItem = (id: number) => {
        setItems(prevItems => prevItems.filter(item => item.id !== id));
    };
    
    const updateQuantity = (id: number, quantity: number) => {
        if (quantity <= 0) {
            removeItem(id);
            return;
        }
        
        setItems(prevItems =>
            prevItems.map(item =>
                item.id === id ? { ...item, quantity } : item
            )
        );
    };
    
    const clear = () => {
        setItems([]);
    };
    
    // Calculate totals (derived state)
    const total = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    const itemCount = items.reduce((count, item) => count + item.quantity, 0);
    
    return {
        items,
        total,
        itemCount,
        addItem,
        removeItem,
        updateQuantity,
        clear
    };
}

// Usage
const ShoppingCart: React.FC = () => {
    const cart = useShoppingCart();
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Shopping Cart ({cart.itemCount} items)&lt;/h2&gt;
            
            {cart.items.length === 0 ? (
                &lt;p&gt;Your cart is empty&lt;/p&gt;
            ) : (
                &lt;&gt;
                    &lt;ul&gt;
                        {cart.items.map(item => (
                            &lt;li key={item.id}&gt;
                                &lt;span&gt;{item.name}&lt;/span&gt;
                                &lt;span&gt;${item.price}&lt;/span&gt;
                                &lt;input
                                    type="number"
                                    value={item.quantity}
                                    onChange={(e) => 
                                        cart.updateQuantity(item.id, parseInt(e.target.value))
                                    }
                                /&gt;
                                &lt;button onClick={() => cart.removeItem(item.id)}&gt;
                                    Remove
                                &lt;/button&gt;
                            &lt;/li&gt;
                        ))}
                    &lt;/ul&gt;
                    
                    &lt;div&gt;
                        &lt;h3&gt;Total: ${cart.total.toFixed(2)}&lt;/h3&gt;
                        &lt;button onClick={cart.clear}&gt;Clear Cart&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Composition Best Practices</h4>
                    <ul>
                        <li><strong>Keep hooks focused:</strong> Each hook should do one thing well</li>
                        <li><strong>Compose for complexity:</strong> Build complex hooks from simple ones</li>
                        <li><strong>Return consistent shapes:</strong> Objects with named properties are clearer than arrays</li>
                        <li><strong>Document dependencies:</strong> Make it clear which hooks are used</li>
                        <li><strong>Avoid deep nesting:</strong> Extract nested logic into separate hooks</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: TypeScript Best Practices -->
            <section id="section8" class="lesson-section">
                <h2>üìò TypeScript Best Practices</h2>
                <p>Let's ensure our custom hooks are properly typed for maximum safety and developer experience!</p>

                <h3>Generic Hooks</h3>
                <div class="card">
                    <h4>Making Hooks Reusable with Generics</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Generic hook
function useFetch&lt;T&gt;(url: string) {
    const [data, setData] = useState&lt;T | null&gt;(null);
    // ...
    return { data, isLoading, error };
}

// Usage with type inference
const { data } = useFetch&lt;User&gt;('/api/user');
// data is typed as User | null

// ‚ùå Bad: No generics
function useFetch(url: string) {
    const [data, setData] = useState(null); // data is 'any'
    // ...
    return { data, isLoading, error };
}</code></pre>
                </div>

                <h3>Return Type Patterns</h3>
                <div class="card">
                    <h4>Tuple vs Object Returns</h4>
                    <pre><code class="language-typescript">// Pattern 1: Tuple (like useState)
function useToggle(initial: boolean): [boolean, () => void] {
    const [value, setValue] = useState(initial);
    const toggle = () => setValue(v => !v);
    return [value, toggle];
}

// Usage - order matters
const [isOpen, toggleOpen] = useToggle(false);

// Pattern 2: Object (more descriptive)
function useToggle(initial: boolean) {
    const [value, setValue] = useState(initial);
    const toggle = () => setValue(v => !v);
    return { value, toggle, setValue };
}

// Usage - names matter
const { value: isOpen, toggle: toggleOpen } = useToggle(false);

// Guidelines:
// - Use tuples for 2-3 simple values (like useState)
// - Use objects for 4+ values or complex APIs
// - Use objects when names provide clarity</code></pre>
                </div>

                <h3>Typing Hook Parameters</h3>
                <div class="card">
                    <h4>Parameter Types and Defaults</h4>
                    <pre><code class="language-typescript">// Simple parameters
function useCounter(initialValue: number = 0) {
    // ...
}

// Options object (recommended for many parameters)
interface UseCounterOptions {
    min?: number;
    max?: number;
    step?: number;
}

function useCounter(
    initialValue: number = 0,
    options: UseCounterOptions = {}
) {
    const { min, max, step = 1 } = options;
    // ...
}

// Callback parameters
interface UseEffectOnceCallback {
    (): void | (() => void); // Can return cleanup function
}

function useEffectOnce(effect: UseEffectOnceCallback) {
    useEffect(effect, []);
}</code></pre>
                </div>

                <h3>Complex Return Types</h3>
                <div class="card">
                    <h4>Defining Return Type Interfaces</h4>
                    <pre><code class="language-typescript">// Define clear return type interface
interface UseFetchResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
    refetch: () => void;
}

function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    // Implementation
    return { data, isLoading, error, refetch };
}

// Benefits:
// 1. Clear API documentation
// 2. Better autocomplete
// 3. Easier to maintain
// 4. Consistent return shape</code></pre>
                </div>

                <h3>Type Guards in Hooks</h3>
                <div class="card">
                    <h4>Narrowing Types</h4>
                    <pre><code class="language-typescript">function useFetchUser(userId: number | null) {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    
    useEffect(() => {
        // Type guard
        if (userId === null) return;
        
        // TypeScript knows userId is number here
        fetch(`/api/users/${userId}`)
            .then(res => res.json())
            .then(setUser);
    }, [userId]);
    
    return user;
}

// Discriminated unions
type FetchState&lt;T&gt; =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: Error };

function useFetch&lt;T&gt;(url: string) {
    const [state, setState] = useState&lt;FetchState&lt;T&gt;&gt;({ status: 'idle' });
    
    // TypeScript knows the shape based on status
    if (state.status === 'success') {
        console.log(state.data); // data exists here
    }
    
    return state;
}</code></pre>
                </div>

                <h3>Utility Types in Hooks</h3>
                <div class="card">
                    <h4>Using TypeScript Utility Types</h4>
                    <pre><code class="language-typescript">// Partial - make all properties optional
interface User {
    id: number;
    name: string;
    email: string;
}

function useUpdateUser(userId: number) {
    const update = async (updates: Partial&lt;User&gt;) => {
        // Can update just name, or just email, etc.
        await fetch(`/api/users/${userId}`, {
            method: 'PATCH',
            body: JSON.stringify(updates)
        });
    };
    
    return { update };
}

// Pick - select specific properties
type UserProfile = Pick&lt;User, 'name' | 'email'&gt;;

function useUserProfile() {
    const [profile, setProfile] = useState&lt;UserProfile | null&gt;(null);
    return { profile, setProfile };
}

// Omit - exclude specific properties
type CreateUserData = Omit&lt;User, 'id'&gt;;

function useCreateUser() {
    const create = async (data: CreateUserData) => {
        // id will be generated by server
        await fetch('/api/users', {
            method: 'POST',
            body: JSON.stringify(data)
        });
    };
    
    return { create };
}

// Record - create object type
function useKeyValueStore&lt;T&gt;() {
    const [store, setStore] = useState&lt;Record&lt;string, T&gt;&gt;({});
    
    const set = (key: string, value: T) => {
        setStore(prev => ({ ...prev, [key]: value }));
    };
    
    return { store, set };
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Hook Checklist</h4>
                    <ul>
                        <li>‚òê Use generics for reusable hooks</li>
                        <li>‚òê Define clear return type interfaces</li>
                        <li>‚òê Type all parameters explicitly</li>
                        <li>‚òê Use utility types (Partial, Pick, Omit) appropriately</li>
                        <li>‚òê Provide default values for optional parameters</li>
                        <li>‚òê Use discriminated unions for complex state</li>
                        <li>‚òê Export types alongside hooks</li>
                        <li>‚òê Document types with JSDoc comments</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Let's build some custom hooks to practice what you've learned!</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: useAsync Hook</h3>
                    <p>Create a hook that handles any async function with loading and error states.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept an async function as parameter</li>
                        <li>Track loading, error, and data states</li>
                        <li>Provide an execute function to run the async function</li>
                        <li>Handle errors properly</li>
                        <li>Type with TypeScript generics</li>
                    </ul>

                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">interface UseAsyncResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: Error | null;
    execute: (...args: any[]) => Promise&lt;void&gt;;
}

function useAsync&lt;T&gt;(asyncFunction: (...args: any[]) => Promise&lt;T&gt;): UseAsyncResult&lt;T&gt; {
    // Your code here!
}

// Usage example
const MyComponent: React.FC = () => {
    const fetchUser = async (id: number) => {
        const response = await fetch(`/api/users/${id}`);
        return response.json();
    };
    
    const { data, isLoading, error, execute } = useAsync(fetchUser);
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => execute(1)}&gt;Load User&lt;/button&gt;
            {isLoading && &lt;div&gt;Loading...&lt;/div&gt;}
            {error && &lt;div&gt;Error: {error.message}&lt;/div&gt;}
            {data && &lt;div&gt;User: {data.name}&lt;/div&gt;}
        &lt;/div&gt;
    );
};</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use useState for data, loading, and error. Create an execute function that wraps the async function in try-catch.</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">function useAsync&lt;T&gt;(
    asyncFunction: (...args: any[]) => Promise&lt;T&gt;
): UseAsyncResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState&lt;Error | null&gt;(null);
    
    const execute = async (...args: any[]) => {
        try {
            setIsLoading(true);
            setError(null);
            
            const result = await asyncFunction(...args);
            setData(result);
        } catch (err) {
            setError(err instanceof Error ? err : new Error('An error occurred'));
        } finally {
            setIsLoading(false);
        }
    };
    
    return { data, isLoading, error, execute };
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: useMediaQuery Hook</h3>
                    <p>Create a hook that tracks whether a media query matches.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept a media query string (e.g., "(min-width: 768px)")</li>
                        <li>Return true/false based on whether query matches</li>
                        <li>Update when window resizes</li>
                        <li>Clean up event listener</li>
                    </ul>

                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">function useMediaQuery(query: string): boolean {
    // Your code here!
}

// Usage
const MyComponent: React.FC = () => {
    const isMobile = useMediaQuery('(max-width: 768px)');
    const isTablet = useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
    const isDesktop = useMediaQuery('(min-width: 1025px)');
    
    return (
        &lt;div&gt;
            {isMobile && &lt;MobileView /&gt;}
            {isTablet && &lt;TabletView /&gt;}
            {isDesktop && &lt;DesktopView /&gt;}
        &lt;/div&gt;
    );
};</code></pre>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">function useMediaQuery(query: string): boolean {
    const [matches, setMatches] = useState(() => {
        return window.matchMedia(query).matches;
    });
    
    useEffect(() => {
        const mediaQuery = window.matchMedia(query);
        
        const handleChange = (e: MediaQueryListEvent) => {
            setMatches(e.matches);
        };
        
        // Modern browsers
        mediaQuery.addEventListener('change', handleChange);
        
        return () => {
            mediaQuery.removeEventListener('change', handleChange);
        };
    }, [query]);
    
    return matches;
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: useUndoRedo Hook</h3>
                    <p>Create a hook that provides undo/redo functionality for any state.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Track history of state changes</li>
                        <li>Provide undo and redo functions</li>
                        <li>Provide canUndo and canRedo boolean flags</li>
                        <li>Limit history size (e.g., last 10 states)</li>
                        <li>Type with generics</li>
                    </ul>
                    
                    <p><strong>Bonus:</strong> Add a reset function and a history array to see all past states!</p>
                </div>
            </section>


            <!-- Section 8: TypeScript Best Practices -->
            <section id="section8" class="lesson-section">
                <h2>üìò TypeScript Best Practices for Custom Hooks</h2>
                <p>TypeScript makes custom hooks even more powerful by adding type safety. Let's explore best practices for typing your custom hooks!</p>

                <h3>1. Generic Hooks for Flexibility</h3>
                <p>Use generics to make your hooks work with any type of data:</p>

                <div class="card">
                    <pre><code class="language-typescript">// ‚úÖ Good: Generic hook that works with any type
function useLocalStorage<T>(key: string, initialValue: T) {
    const [storedValue, setStoredValue] = useState<T>(() => {
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        } catch (error) {
            console.error(error);
            return initialValue;
        }
    });

    const setValue = (value: T | ((val: T) => T)) => {
        try {
            const valueToStore = value instanceof Function ? value(storedValue) : value;
            setStoredValue(valueToStore);
            window.localStorage.setItem(key, JSON.stringify(valueToStore));
        } catch (error) {
            console.error(error);
        }
    };

    return [storedValue, setValue] as const;
}

// Usage with different types
const [name, setName] = useLocalStorage<string>('name', 'Guest');
const [age, setAge] = useLocalStorage<number>('age', 0);
const [settings, setSettings] = useLocalStorage<UserSettings>('settings', defaultSettings);</code></pre>
                </div>

                <h3>2. Proper Return Types</h3>
                <p>Be explicit about what your hooks return:</p>

                <div class="card">
                    <pre><code class="language-typescript">// ‚ùå Bad: Return type is inferred as (string | Dispatch<SetStateAction<string>>)[]
function useInput(initialValue: string) {
    const [value, setValue] = useState(initialValue);
    const reset = () => setValue(initialValue);
    return [value, setValue, reset];
}

// ‚úÖ Good: Explicit return type with const assertion
function useInput(initialValue: string) {
    const [value, setValue] = useState(initialValue);
    const reset = () => setValue(initialValue);
    return [value, setValue, reset] as const;
}

// ‚úÖ Also Good: Return an object for better clarity
interface UseInputReturn {
    value: string;
    setValue: Dispatch<SetStateAction<string>>;
    reset: () => void;
}

function useInput(initialValue: string): UseInputReturn {
    const [value, setValue] = useState(initialValue);
    const reset = () => setValue(initialValue);
    return { value, setValue, reset };
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Tuple vs Object Returns</h4>
                    <p><strong>Use tuples (arrays)</strong> when:</p>
                    <ul>
                        <li>Returning 2-3 simple values (like useState)</li>
                        <li>Users might want to rename the values</li>
                    </ul>
                    <p><strong>Use objects</strong> when:</p>
                    <ul>
                        <li>Returning many values (4+)</li>
                        <li>Values have clear semantic names</li>
                        <li>You want to add more return values later without breaking code</li>
                    </ul>
                </div>

                <h3>3. Type Optional Parameters</h3>
                <div class="card">
                    <pre><code class="language-typescript">interface UseFetchOptions {
    method?: 'GET' | 'POST' | 'PUT' | 'DELETE';
    headers?: Record<string, string>;
    body?: any;
    immediate?: boolean; // Fetch immediately or wait for manual trigger
}

function useFetch<T>(url: string, options?: UseFetchOptions) {
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(options?.immediate ?? true);
    const [error, setError] = useState<Error | null>(null);

    const execute = useCallback(async () => {
        setLoading(true);
        setError(null);
        
        try {
            const response = await fetch(url, {
                method: options?.method ?? 'GET',
                headers: options?.headers,
                body: options?.body ? JSON.stringify(options.body) : undefined,
            });
            
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            
            const result = await response.json();
            setData(result);
        } catch (err) {
            setError(err as Error);
        } finally {
            setLoading(false);
        }
    }, [url, options]);

    useEffect(() => {
        if (options?.immediate ?? true) {
            execute();
        }
    }, [execute, options?.immediate]);

    return { data, loading, error, refetch: execute };
}</code></pre>
                </div>

                <h3>4. Type Function Parameters</h3>
                <div class="card">
                    <pre><code class="language-typescript">// ‚úÖ Type callback functions properly
interface UseAsyncOptions<T> {
    onSuccess?: (data: T) => void;
    onError?: (error: Error) => void;
    initialData?: T;
}

function useAsync<T>(
    asyncFunction: () => Promise<T>,
    options?: UseAsyncOptions<T>
) {
    const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
    const [data, setData] = useState<T | undefined>(options?.initialData);
    const [error, setError] = useState<Error | null>(null);

    const execute = useCallback(async () => {
        setStatus('loading');
        setData(undefined);
        setError(null);

        try {
            const result = await asyncFunction();
            setData(result);
            setStatus('success');
            options?.onSuccess?.(result);
        } catch (err) {
            setError(err as Error);
            setStatus('error');
            options?.onError?.(err as Error);
        }
    }, [asyncFunction, options]);

    return { execute, status, data, error };
}</code></pre>
                </div>

                <h3>5. Discriminated Unions for Complex State</h3>
                <div class="card">
                    <pre><code class="language-typescript">// ‚úÖ Use discriminated unions for complex async state
type AsyncState<T> =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: Error };

function useAsyncState<T>(asyncFn: () => Promise<T>) {
    const [state, setState] = useState<AsyncState<T>>({ status: 'idle' });

    const execute = useCallback(async () => {
        setState({ status: 'loading' });
        
        try {
            const data = await asyncFn();
            setState({ status: 'success', data });
        } catch (error) {
            setState({ status: 'error', error: error as Error });
        }
    }, [asyncFn]);

    return { state, execute };
}

// Usage - TypeScript knows which properties are available!
const { state, execute } = useAsyncState<User>(() => fetchUser(id));

if (state.status === 'success') {
    console.log(state.data.name); // TypeScript knows 'data' exists here
}

if (state.status === 'error') {
    console.log(state.error.message); // TypeScript knows 'error' exists here
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Hook Checklist</h4>
                    <ul>
                        <li>‚úÖ Use generics for flexible, reusable hooks</li>
                        <li>‚úÖ Use <code>as const</code> for tuple returns</li>
                        <li>‚úÖ Create interfaces for complex options</li>
                        <li>‚úÖ Type all parameters and return values</li>
                        <li>‚úÖ Use discriminated unions for complex state</li>
                        <li>‚úÖ Use optional chaining for optional parameters</li>
                        <li>‚úÖ Document your hooks with JSDoc comments</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to build your own custom hooks! These exercises will solidify your understanding.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: useToggle Hook</h3>
                    <p>Create a simple hook that manages boolean state with toggle functionality.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept an optional initial value (default false)</li>
                        <li>Return the current value and a toggle function</li>
                        <li>Add optional setTrue and setFalse functions</li>
                        <li>Type everything properly</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Think about what useState returns and how you can enhance it with additional functions. Use <code>as const</code> for the return tuple!</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">function useToggle(initialValue: boolean = false) {
    const [value, setValue] = useState(initialValue);
    
    const toggle = useCallback(() => {
        setValue(v => !v);
    }, []);
    
    const setTrue = useCallback(() => {
        setValue(true);
    }, []);
    
    const setFalse = useCallback(() => {
        setValue(false);
    }, []);
    
    return [value, toggle, setTrue, setFalse] as const;
}

// Usage
const [isOpen, toggle, open, close] = useToggle(false);

return (
    <div>
        <button onClick={toggle}>Toggle</button>
        <button onClick={open}>Open</button>
        <button onClick={close}>Close</button>
        {isOpen && <p>Content is visible!</p>}
    </div>
);</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: useArray Hook</h3>
                    <p>Create a hook that provides helpful methods for managing array state.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept an initial array</li>
                        <li>Return the array and helper methods:</li>
                        <li>push(item) - add to end</li>
                        <li>remove(index) - remove by index</li>
                        <li>filter(callback) - filter items</li>
                        <li>update(index, newItem) - update specific item</li>
                        <li>clear() - empty the array</li>
                        <li>Use generics for type safety</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use <code>useCallback</code> for each helper function to prevent unnecessary re-renders. Remember to spread the array to create new references!</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">interface UseArrayReturn<T> {
    array: T[];
    set: (newArray: T[]) => void;
    push: (item: T) => void;
    remove: (index: number) => void;
    filter: (callback: (item: T) => boolean) => void;
    update: (index: number, newItem: T) => void;
    clear: () => void;
}

function useArray<T>(initialValue: T[]): UseArrayReturn<T> {
    const [array, setArray] = useState<T[]>(initialValue);

    const push = useCallback((item: T) => {
        setArray(arr => [...arr, item]);
    }, []);

    const remove = useCallback((index: number) => {
        setArray(arr => arr.filter((_, i) => i !== index));
    }, []);

    const filter = useCallback((callback: (item: T) => boolean) => {
        setArray(arr => arr.filter(callback));
    }, []);

    const update = useCallback((index: number, newItem: T) => {
        setArray(arr => arr.map((item, i) => (i === index ? newItem : item)));
    }, []);

    const clear = useCallback(() => {
        setArray([]);
    }, []);

    return {
        array,
        set: setArray,
        push,
        remove,
        filter,
        update,
        clear,
    };
}

// Usage
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

const TodoList: React.FC = () => {
    const { array: todos, push, remove, update } = useArray<Todo>([]);

    const addTodo = (text: string) => {
        push({ id: Date.now(), text, completed: false });
    };

    const toggleTodo = (index: number) => {
        const todo = todos[index];
        update(index, { ...todo, completed: !todo.completed });
    };

    return (
        <div>
            {todos.map((todo, index) => (
                <div key={todo.id}>
                    <input
                        type="checkbox"
                        checked={todo.completed}
                        onChange={() => toggleTodo(index)}
                    />
                    <span>{todo.text}</span>
                    <button onClick={() => remove(index)}>Delete</button>
                </div>
            ))}
        </div>
    );
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: useAsync Hook</h3>
                    <p>Build a comprehensive async operation hook with status management.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Manage loading, success, and error states</li>
                        <li>Accept an async function to execute</li>
                        <li>Provide execute function to manually trigger</li>
                        <li>Return status, data, error, and execute</li>
                        <li>Support optional immediate execution</li>
                        <li>Use proper TypeScript generics</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Consider using a status enum or union type. Don't forget to handle cleanup to prevent state updates on unmounted components!</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">type AsyncStatus = 'idle' | 'loading' | 'success' | 'error';

interface UseAsyncReturn<T> {
    execute: () => Promise<void>;
    status: AsyncStatus;
    data: T | null;
    error: Error | null;
    isLoading: boolean;
    isSuccess: boolean;
    isError: boolean;
}

function useAsync<T>(
    asyncFunction: () => Promise<T>,
    immediate: boolean = false
): UseAsyncReturn<T> {
    const [status, setStatus] = useState<AsyncStatus>('idle');
    const [data, setData] = useState<T | null>(null);
    const [error, setError] = useState<Error | null>(null);

    const execute = useCallback(async () => {
        setStatus('loading');
        setData(null);
        setError(null);

        try {
            const response = await asyncFunction();
            setData(response);
            setStatus('success');
        } catch (err) {
            setError(err as Error);
            setStatus('error');
        }
    }, [asyncFunction]);

    useEffect(() => {
        if (immediate) {
            execute();
        }
    }, [execute, immediate]);

    return {
        execute,
        status,
        data,
        error,
        isLoading: status === 'loading',
        isSuccess: status === 'success',
        isError: status === 'error',
    };
}

// Usage
const UserProfile: React.FC<{ userId: string }> = ({ userId }) => {
    const fetchUser = useCallback(
        () => fetch(`/api/users/${userId}`).then(res => res.json()),
        [userId]
    );

    const { data: user, isLoading, isError, error, execute } = useAsync<User>(
        fetchUser,
        true // Fetch immediately
    );

    if (isLoading) return <div>Loading...</div>;
    if (isError) return <div>Error: {error?.message}</div>;
    if (!user) return null;

    return (
        <div>
            <h2>{user.name}</h2>
            <p>{user.email}</p>
            <button onClick={execute}>Refresh</button>
        </div>
    );
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: usePagination Hook</h3>
                    <p>Create a comprehensive pagination hook for managing paginated data.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Track current page, total pages, items per page</li>
                        <li>Provide functions: nextPage, previousPage, goToPage, setItemsPerPage</li>
                        <li>Calculate: hasNextPage, hasPreviousPage, startIndex, endIndex</li>
                        <li>Accept total items count</li>
                        <li>Return current page data slice</li>
                        <li>Prevent going beyond page bounds</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use <code>Math.ceil(totalItems / itemsPerPage)</code> to calculate total pages. Remember to clamp page numbers between 1 and totalPages!</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">interface UsePaginationOptions {
    initialPage?: number;
    initialItemsPerPage?: number;
}

interface UsePaginationReturn<T> {
    currentPage: number;
    totalPages: number;
    itemsPerPage: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
    startIndex: number;
    endIndex: number;
    currentData: T[];
    nextPage: () => void;
    previousPage: () => void;
    goToPage: (page: number) => void;
    setItemsPerPage: (items: number) => void;
}

function usePagination<T>(
    data: T[],
    options: UsePaginationOptions = {}
): UsePaginationReturn<T> {
    const { initialPage = 1, initialItemsPerPage = 10 } = options;
    
    const [currentPage, setCurrentPage] = useState(initialPage);
    const [itemsPerPage, setItemsPerPageState] = useState(initialItemsPerPage);

    const totalPages = Math.ceil(data.length / itemsPerPage);

    // Ensure current page is within bounds
    useEffect(() => {
        if (currentPage > totalPages && totalPages > 0) {
            setCurrentPage(totalPages);
        }
    }, [currentPage, totalPages]);

    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = Math.min(startIndex + itemsPerPage, data.length);
    const currentData = data.slice(startIndex, endIndex);

    const hasNextPage = currentPage < totalPages;
    const hasPreviousPage = currentPage > 1;

    const nextPage = useCallback(() => {
        setCurrentPage(page => Math.min(page + 1, totalPages));
    }, [totalPages]);

    const previousPage = useCallback(() => {
        setCurrentPage(page => Math.max(page - 1, 1));
    }, []);

    const goToPage = useCallback((page: number) => {
        setCurrentPage(Math.max(1, Math.min(page, totalPages)));
    }, [totalPages]);

    const setItemsPerPage = useCallback((items: number) => {
        setItemsPerPageState(items);
        setCurrentPage(1); // Reset to first page when changing items per page
    }, []);

    return {
        currentPage,
        totalPages,
        itemsPerPage,
        hasNextPage,
        hasPreviousPage,
        startIndex,
        endIndex,
        currentData,
        nextPage,
        previousPage,
        goToPage,
        setItemsPerPage,
    };
}

// Usage
interface Product {
    id: number;
    name: string;
    price: number;
}

const ProductList: React.FC<{ products: Product[] }> = ({ products }) => {
    const {
        currentData,
        currentPage,
        totalPages,
        hasNextPage,
        hasPreviousPage,
        nextPage,
        previousPage,
        goToPage,
        setItemsPerPage,
    } = usePagination(products, { initialItemsPerPage: 20 });

    return (
        <div>
            <div>
                <label>
                    Items per page:
                    <select onChange={(e) => setItemsPerPage(Number(e.target.value))}>
                        <option value="10">10</option>
                        <option value="20">20</option>
                        <option value="50">50</option>
                    </select>
                </label>
            </div>

            <div>
                {currentData.map(product => (
                    <div key={product.id}>
                        <h3>{product.name}</h3>
                        <p>${product.price}</p>
                    </div>
                ))}
            </div>

            <div>
                <button onClick={previousPage} disabled={!hasPreviousPage}>
                    Previous
                </button>
                <span>
                    Page {currentPage} of {totalPages}
                </span>
                <button onClick={nextPage} disabled={!hasNextPage}>
                    Next
                </button>
            </div>

            <div>
                {Array.from({ length: totalPages }, (_, i) => i + 1).map(page => (
                    <button
                        key={page}
                        onClick={() => goToPage(page)}
                        style={{
                            fontWeight: page === currentPage ? 'bold' : 'normal'
                        }}
                    >
                        {page}
                    </button>
                ))}
            </div>
        </div>
    );
};</code></pre>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>üåü Best Practices</h2>

                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Always prefix custom hooks with "use"</strong> - This is required for React to recognize them as hooks and enforce the Rules of Hooks. <code>useFetch</code>, not <code>fetchData</code>.</li>
                    <li><strong>Keep hooks focused and single-purpose</strong> - A hook should do one thing well. <code>useLocalStorage</code> manages local storage, <code>useFetch</code> handles fetching. Don't create mega-hooks that do everything.</li>
                    <li><strong>Use TypeScript generics</strong> - Make your hooks reusable with different data types by using generics: <code>function useFetch&lt;T&gt;(url: string): T</code></li>
                    <li><strong>Memoize functions with useCallback</strong> - Wrap returned functions in <code>useCallback</code> to prevent unnecessary re-renders in components that use your hook.</li>
                    <li><strong>Handle cleanup properly</strong> - Always clean up subscriptions, timers, and event listeners in <code>useEffect</code> return functions to prevent memory leaks.</li>
                    <li><strong>Provide clear return values</strong> - Use descriptive names and consistent return patterns. Return objects for many values, tuples for 2-3 values.</li>
                    <li><strong>Document your hooks</strong> - Add JSDoc comments explaining parameters, return values, and usage examples. Other developers (including future you!) will thank you.</li>
                    <li><strong>Test your hooks</strong> - Use React Testing Library's <code>renderHook</code> to test custom hooks in isolation.</li>
                </ul>

                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't call hooks conditionally</strong> - Never put hooks inside if statements, loops, or nested functions. React relies on hook call order to track state correctly.</li>
                    <li><strong>Don't forget dependencies</strong> - Always include all values used inside <code>useEffect</code> or <code>useCallback</code> in the dependency array. Use ESLint's exhaustive-deps rule!</li>
                    <li><strong>Don't create overly complex hooks</strong> - If your hook has 10+ parameters or returns 15+ values, it's doing too much. Break it into smaller hooks.</li>
                    <li><strong>Don't ignore cleanup</strong> - Forgetting to clean up event listeners, intervals, or subscriptions leads to memory leaks and bugs.</li>
                    <li><strong>Don't use hooks in regular functions</strong> - Custom hooks can only be called from React components or other custom hooks, never from regular JavaScript functions.</li>
                    <li><strong>Don't mutate state directly</strong> - Always create new objects/arrays when updating state: <code>setState([...arr, newItem])</code>, not <code>arr.push(newItem)</code>.</li>
                    <li><strong>Don't return inconsistent types</strong> - If your hook returns an object, always return an object with the same keys, even if some values are null/undefined.</li>
                </ul>

                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Create a hooks directory</strong> - Keep all custom hooks in a <code>hooks/</code> or <code>src/hooks/</code> directory for easy organization and imports.</li>
                    <li><strong>Start with common patterns</strong> - Build a library of reusable hooks for common needs: <code>useFetch</code>, <code>useLocalStorage</code>, <code>useDebounce</code>, <code>useToggle</code>.</li>
                    <li><strong>Compose hooks together</strong> - Build complex hooks by combining simpler ones. For example, <code>useForm</code> might use <code>useLocalStorage</code> and <code>useValidation</code> internally.</li>
                    <li><strong>Use discriminated unions for complex state</strong> - Instead of separate loading/error/data states, use a single state with a discriminated union for type safety.</li>
                    <li><strong>Provide sensible defaults</strong> - Make hooks easy to use with good default values for optional parameters.</li>
                    <li><strong>Consider returning both the state and a reset function</strong> - Many hooks benefit from a way to reset to initial state: <code>const [value, setValue, reset] = useInput()</code>.</li>
                    <li><strong>Use the react-hooks ESLint plugin</strong> - It catches mistakes like missing dependencies and conditional hook calls automatically.</li>
                    <li><strong>Learn from the community</strong> - Check out libraries like <code>react-use</code>, <code>usehooks-ts</code>, and <code>ahooks</code> for inspiration and patterns.</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Hook Recipe Template</h4>
                    <pre><code class="language-typescript">/**
 * Hook description: What does this hook do?
 * 
 * @param param1 - Description of first parameter
 * @param options - Optional configuration
 * @returns Description of return value
 * 
 * @example
 * const { data, loading } = useYourHook('example');
 */
function useYourHook<T>(
    param1: string,
    options?: YourHookOptions
): YourHookReturn<T> {
    // 1. State declarations
    const [state, setState] = useState<T | null>(null);
    const [loading, setLoading] = useState(false);
    
    // 2. Helper functions (memoized)
    const doSomething = useCallback(() => {
        // Implementation
    }, [/* dependencies */]);
    
    // 3. Side effects
    useEffect(() => {
        // Effect logic
        
        return () => {
            // Cleanup
        };
    }, [/* dependencies */]);
    
    // 4. Return value
    return {
        state,
        loading,
        doSomething,
    };
}</code></pre>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Pitfalls</h4>
                    <ul>
                        <li><strong>Stale closures:</strong> Functions inside <code>useEffect</code> or <code>useCallback</code> capture old state values. Always include them in dependencies or use functional updates.</li>
                        <li><strong>Infinite loops:</strong> Forgetting dependencies or creating new objects/arrays in the dependency array causes infinite re-renders.</li>
                        <li><strong>Memory leaks:</strong> Not cleaning up subscriptions, timers, or event listeners in the effect cleanup function.</li>
                        <li><strong>Race conditions:</strong> Multiple async operations completing out of order. Use abort controllers or track the latest request.</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Summary -->
            <section id="section11" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Custom hooks extract reusable stateful logic</strong> - They let you share logic between components without prop drilling or wrapper components.</li>
                        <li><strong>Always start with "use"</strong> - This naming convention is required and tells React to enforce the Rules of Hooks.</li>
                        <li><strong>Hooks compose beautifully</strong> - Build complex hooks by combining simpler ones, creating powerful abstractions.</li>
                        <li><strong>TypeScript makes hooks better</strong> - Use generics for flexibility, proper types for safety, and discriminated unions for complex state.</li>
                        <li><strong>Follow the Rules of Hooks</strong> - Only call hooks at the top level and only from React functions.</li>
                        <li><strong>Clean up effects properly</strong> - Prevent memory leaks by cleaning up subscriptions, listeners, and timers.</li>
                        <li><strong>Return consistent, well-typed values</strong> - Use tuples for 2-3 values, objects for more complex returns.</li>
                        <li><strong>Common hook patterns solve common problems</strong> - useFetch, useLocalStorage, useDebounce, useToggle are building blocks for most apps.</li>
                        <li><strong>Test your hooks</strong> - Use React Testing Library's renderHook to test hooks in isolation.</li>
                        <li><strong>Custom hooks are a superpower</strong> - They're one of React's most powerful features for creating clean, reusable code!</li>
                    </ul>
                </div>
                
                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://react.dev/learn/reusing-logic-with-custom-hooks" target="_blank">React Docs: Reusing Logic with Custom Hooks</a></li>
                    <li><a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/hooks" target="_blank">React TypeScript Cheatsheet: Hooks</a></li>
                    <li><a href="https://usehooks.com/" target="_blank">useHooks - Collection of Custom Hooks</a></li>
                    <li><a href="https://github.com/streamich/react-use" target="_blank">react-use - Essential React Hooks Library</a></li>
                    <li><a href="https://github.com/juliencrn/usehooks-ts" target="_blank">usehooks-ts - TypeScript Custom Hooks</a></li>
                    <li><a href="https://testing-library.com/docs/react-testing-library/api/#renderhook" target="_blank">Testing Library: Testing Custom Hooks</a></li>
                </ul>
                
                <h3>üöÄ What's Next?</h3>
                <p>You've mastered custom hooks! You can now extract complex logic into reusable functions, build your own hook library, and create cleaner, more maintainable React applications.</p>
                
                <p>In <strong>Module 5: Advanced Hooks and Patterns</strong>, we'll explore:</p>
                <ul>
                    <li><strong>useReducer</strong> for complex state logic</li>
                    <li><strong>useContext</strong> for sharing state across the component tree</li>
                    <li><strong>useMemo and useCallback</strong> for performance optimization</li>
                    <li><strong>useRef</strong> for accessing DOM elements and storing mutable values</li>
                    <li><strong>Advanced patterns</strong> like compound components and render props</li>
                </ul>

                <!-- Quiz Section -->
                <div class="card quiz-container">
                    <h3>üéØ Quick Quiz</h3>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What is the required naming convention for custom hooks?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Hooks aren't classes">
                                A) Start with "hook" (hookFetch)
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! The 'use' prefix is required so React can identify and enforce the Rules of Hooks.">
                                B) Start with "use" (useFetch)
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="This is for components, not hooks">
                                C) Start with a capital letter (Fetch)
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="No special prefix is needed for regular functions">
                                D) No specific naming requirement
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> When should you use a custom hook?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Hooks are for reusable logic, not single-use code">
                                A) For any component logic, always
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Simple UI can stay in components">
                                B) For all render logic
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Custom hooks are perfect for extracting and sharing stateful logic that you use in multiple places.">
                                C) When you have stateful logic used in multiple components
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Hooks need React hooks inside them">
                                D) For regular JavaScript functions
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> What should a custom hook that manages pagination return?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="That's only one part of pagination">
                                A) Just the current page number
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! A pagination hook should provide the current data slice, page information, and functions to navigate pages.">
                                B) Current page data, page info, and navigation functions
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Hooks should return everything needed to use them">
                                C) Only the navigation functions
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="The whole dataset isn't what you need from pagination">
                                D) The entire dataset
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 4:</strong> How should you handle cleanup in custom hooks?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Cleanup is important for preventing bugs!">
                                A) Cleanup isn't necessary in hooks
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Return a cleanup function from useEffect to remove listeners, clear timers, and cancel subscriptions.">
                                B) Return a cleanup function from useEffect
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="componentWillUnmount is for class components">
                                C) Use componentWillUnmount
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="setTimeout isn't for cleanup">
                                D) Use setTimeout to delay cleanup
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 5:</strong> What's the best way to type a generic custom hook in TypeScript?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="'any' defeats the purpose of TypeScript">
                                A) Use 'any' for all types
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Generics like <T> make hooks flexible while maintaining type safety, allowing them to work with any data type.">
                                B) Use generics like &lt;T&gt; for flexibility
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="String is too specific for most hooks">
                                C) Always use string
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="We need TypeScript's type system">
                                D) Don't use types at all
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem; margin-top: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've completed Lesson 4.3: Custom Hooks! You now have the power to create reusable logic that makes your React applications cleaner, more maintainable, and more powerful.</p>
                    <p style="color: white; margin-top: 1rem;">Custom hooks are one of React's most elegant features. Use them wisely! üé£</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_4_2_data_fetching_basics.html" class="prev-lesson">‚Üê Previous: Data Fetching Basics</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href=""lesson_4_4_advanced_data_fetching.html"" class="next-lesson">Next: Module Project - Data Dashboard ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
