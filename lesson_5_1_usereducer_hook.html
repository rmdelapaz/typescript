<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React's useReducer Hook - Learn when and how to use useReducer for complex state logic, understand the reducer pattern, and properly type reducers with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>useReducer Hook - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.1: useReducer Hook</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>‚öôÔ∏è useReducer Hook</h1>
                <p class="lead">Welcome to Module 5! You've mastered useState, but what happens when your state logic gets complicated? When you have multiple pieces of related state that need to update together? When the next state depends on the previous state in complex ways? That's where useReducer shines! The useReducer Hook is like useState's more sophisticated older sibling - it helps you manage complex state logic in a predictable, testable way. If you've ever felt overwhelmed by managing multiple useState calls or struggled with state updates that depend on each other, you're about to discover a powerful solution. Let's level up your state management game! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand when to choose useReducer over useState</li>
                        <li>Grasp the reducer pattern and its benefits</li>
                        <li>Create reducer functions with proper TypeScript typing</li>
                        <li>Define action types and action creators</li>
                        <li>Implement useReducer for complex state management</li>
                        <li>Handle multiple related state updates with a single reducer</li>
                        <li>Type reducers, actions, and state correctly with TypeScript</li>
                        <li>Refactor useState logic to useReducer when appropriate</li>
                        <li>Debug reducer logic and understand common patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Refactor a todo application from useState to useReducer</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Introduction to useReducer</a></li>
                        <li><a href="#section2" class="toc-link">The Reducer Pattern</a></li>
                        <li><a href="#section3" class="toc-link">useState vs useReducer</a></li>
                        <li><a href="#section4" class="toc-link">Basic useReducer Syntax</a></li>
                        <li><a href="#section5" class="toc-link">Typing Reducers with TypeScript</a></li>
                        <li><a href="#section6" class="toc-link">Actions and Action Types</a></li>
                        <li><a href="#section7" class="toc-link">Simple Counter Example</a></li>
                        <li><a href="#section8" class="toc-link">Complex State Example</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Common Patterns</a></li>
                        <li><a href="#section11" class="toc-link">Best Practices</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction to useReducer -->
            <section id="section1" class="lesson-section">
                <h2>‚öôÔ∏è Introduction to useReducer</h2>
                <p>The useReducer Hook is an alternative to useState for managing state in React components. While useState is perfect for simple state, useReducer excels when you have complex state logic that involves multiple sub-values or when the next state depends on the previous one in non-trivial ways.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>useReducer:</strong> A React Hook that lets you manage state through a reducer function. It accepts a reducer function and an initial state, and returns the current state paired with a dispatch function to trigger state updates.</p>
                </div>

                <h3>Why useReducer?</h3>
                <p>Think of useReducer as a more structured way to manage state. Instead of directly setting state values, you dispatch actions that describe what happened, and a reducer function determines how the state should change. This pattern brings several benefits:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of useReducer</h4>
                    <ul>
                        <li><strong>Predictable State Updates</strong> - All state changes happen in one place (the reducer)</li>
                        <li><strong>Easier to Test</strong> - Reducers are pure functions that are simple to unit test</li>
                        <li><strong>Better for Complex Logic</strong> - When state updates involve multiple pieces of state</li>
                        <li><strong>Action History</strong> - Easy to log actions for debugging or implement undo/redo</li>
                        <li><strong>Centralized Logic</strong> - All state update logic lives in the reducer, not scattered across components</li>
                        <li><strong>Type Safety</strong> - TypeScript can ensure you're dispatching valid actions</li>
                    </ul>
                </div>

                <h3>Real-World Analogy</h3>
                <p>Think of useReducer like a restaurant kitchen:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Restaurant</th>
                            <th>useReducer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Customer (You)</td>
                            <td>Your component</td>
                        </tr>
                        <tr>
                            <td>Order (Menu Item)</td>
                            <td>Action (describes what should happen)</td>
                        </tr>
                        <tr>
                            <td>Waiter</td>
                            <td>Dispatch function</td>
                        </tr>
                        <tr>
                            <td>Chef & Kitchen</td>
                            <td>Reducer function</td>
                        </tr>
                        <tr>
                            <td>Prepared Food</td>
                            <td>New state</td>
                        </tr>
                    </tbody>
                </table>

                <p>You (the component) don't go into the kitchen and cook the food yourself (directly modify state). Instead, you give an order to the waiter (dispatch an action), who takes it to the kitchen (reducer), where the chef (reducer logic) prepares your meal (calculates new state) following a recipe (reducer function logic). The result comes back to you (updated state triggers re-render).</p>

                <div class="mermaid">
                graph LR
                    A[Component] -->|dispatch action| B[Reducer Function]
                    B -->|returns new state| C[Updated State]
                    C -->|triggers re-render| A
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style B fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                    style C fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Concept</h4>
                    <p>The fundamental idea behind useReducer is <strong>separation of concerns</strong>: your component describes <em>what</em> should happen (by dispatching actions), while the reducer specifies <em>how</em> the state should change. This makes your code more maintainable and easier to reason about.</p>
                </div>

                <h3>The useReducer Signature</h3>
                <p>Here's what useReducer looks like at a glance:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
                </div>

                <p>Let's break down each part:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Part</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>state</code></td>
                            <td>The current state value (like useState)</td>
                        </tr>
                        <tr>
                            <td><code>dispatch</code></td>
                            <td>Function to trigger state updates by sending actions</td>
                        </tr>
                        <tr>
                            <td><code>reducer</code></td>
                            <td>Function that takes (state, action) and returns new state</td>
                        </tr>
                        <tr>
                            <td><code>initialState</code></td>
                            <td>The starting state value</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 2: The Reducer Pattern -->
            <section id="section2" class="lesson-section">
                <h2>üîÑ The Reducer Pattern</h2>
                <p>Before diving into useReducer specifically, let's understand the reducer pattern itself. This pattern comes from functional programming and is used in many contexts, including Redux, Array.reduce(), and now React Hooks.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Reducer:</strong> A pure function that takes the current state and an action, then returns a new state. The name "reducer" comes from Array.reduce() - it "reduces" a collection of actions over time into a single state value.</p>
                </div>

                <h3>Anatomy of a Reducer</h3>
                <p>Every reducer follows this basic structure:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function reducer(state, action) {
    // Examine the action
    switch (action.type) {
        case 'ACTION_TYPE_1':
            // Return new state based on this action
            return { ...state, /* changes */ };
        
        case 'ACTION_TYPE_2':
            // Return new state for different action
            return { ...state, /* changes */ };
        
        default:
            // Always return current state for unknown actions
            return state;
    }
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Reducer Rules</h4>
                    <p>Reducers must follow these important rules:</p>
                    <ol>
                        <li><strong>Pure Function</strong> - Same inputs always produce same output, no side effects</li>
                        <li><strong>No Mutations</strong> - Never modify state directly; always return a new state object</li>
                        <li><strong>Synchronous</strong> - No async operations, promises, or API calls inside reducers</li>
                        <li><strong>Return State</strong> - Always return a state value (even if unchanged)</li>
                    </ol>
                </div>

                <h3>Understanding Actions</h3>
                <p>Actions are plain JavaScript objects that describe what happened. By convention, actions have a <code>type</code> property that identifies the action, and often include additional data:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Simple action with just a type
{ type: 'INCREMENT' }

// Action with additional data (payload)
{ type: 'ADD_TODO', payload: { id: 1, text: 'Learn useReducer' } }

// Action with multiple properties
{ 
    type: 'UPDATE_USER',
    id: 123,
    name: 'John Doe',
    email: 'john@example.com'
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Naming Convention</h4>
                    <p>Action types are typically written in SCREAMING_SNAKE_CASE (all uppercase with underscores). This makes them stand out in your code and clearly indicates they're constants.</p>
                </div>

                <h3>The Reducer Flow</h3>
                <p>Here's how data flows through a reducer:</p>

                <div class="mermaid">
                sequenceDiagram
                    participant Component
                    participant Dispatch
                    participant Reducer
                    participant State
                    
                    Component->>Dispatch: dispatch({ type: 'ACTION' })
                    Dispatch->>Reducer: Call with (currentState, action)
                    Reducer->>Reducer: Calculate new state
                    Reducer->>State: Return new state
                    State->>Component: Trigger re-render with new state
                </div>

                <h3>Example: Array.reduce() vs Reducer Pattern</h3>
                <p>To understand why it's called a "reducer," let's see how Array.reduce() works similarly:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Array.reduce() example
const numbers = [1, 2, 3, 4, 5];

const sum = numbers.reduce(
    (accumulator, currentValue) => accumulator + currentValue,
    0  // initial value
);
// Result: 15

// This is conceptually similar to:
// state = 0 (initial)
// action = 1 ‚Üí state = 0 + 1 = 1
// action = 2 ‚Üí state = 1 + 2 = 3
// action = 3 ‚Üí state = 3 + 3 = 6
// action = 4 ‚Üí state = 6 + 4 = 10
// action = 5 ‚Üí state = 10 + 5 = 15

// useReducer does the same thing, but with actions over time!
const counterReducer = (state, action) => {
    if (action.type === 'INCREMENT') {
        return state + 1;
    }
    return state;
};

// dispatch({ type: 'INCREMENT' })  ‚Üí state goes from 0 to 1
// dispatch({ type: 'INCREMENT' })  ‚Üí state goes from 1 to 2
// dispatch({ type: 'INCREMENT' })  ‚Üí state goes from 2 to 3</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Insight</h4>
                    <p>Both Array.reduce() and useReducer "reduce" a collection of values into a single result. Array.reduce() processes an array of values immediately, while useReducer processes actions over time as they're dispatched. The pattern is the same!</p>
                </div>
            </section>

            <!-- Section 3: useState vs useReducer -->
            <section id="section3" class="lesson-section">
                <h2>‚öñÔ∏è useState vs useReducer</h2>
                <p>Both useState and useReducer manage state, but they're suited for different scenarios. Understanding when to use each is key to writing clean, maintainable React code.</p>

                <h3>When to Use useState</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use useState When:</h4>
                    <ul>
                        <li>State is simple (single primitive value or simple object)</li>
                        <li>State updates are independent of each other</li>
                        <li>Few state variables (typically 1-3)</li>
                        <li>State update logic is straightforward</li>
                        <li>No complex relationships between state values</li>
                    </ul>
                    
                    <p><strong>Example Scenarios:</strong></p>
                    <ul>
                        <li>Toggle state (boolean)</li>
                        <li>Form input value (string)</li>
                        <li>Counter (number)</li>
                        <li>Single selection (string or number)</li>
                    </ul>
                </div>

                <h3>When to Use useReducer</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Use useReducer When:</h4>
                    <ul>
                        <li>State is complex (multiple related sub-values)</li>
                        <li>Next state depends on previous state in complex ways</li>
                        <li>Many state updates from different actions</li>
                        <li>State update logic is getting complicated</li>
                        <li>You want to separate state logic from component logic</li>
                        <li>Testing state logic independently is important</li>
                    </ul>
                    
                    <p><strong>Example Scenarios:</strong></p>
                    <ul>
                        <li>Todo list with add, remove, toggle, filter operations</li>
                        <li>Shopping cart with add, remove, update quantity, apply coupon</li>
                        <li>Form with multiple fields and validation rules</li>
                        <li>Multi-step wizard with navigation and data</li>
                        <li>Complex UI state (modals, tabs, accordions)</li>
                    </ul>
                </div>

                <h3>Side-by-Side Comparison</h3>
                <p>Let's see the same counter implemented with both hooks:</p>

                <h4>With useState</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Increment
            &lt;/button&gt;
            &lt;button onClick={() => setCount(count - 1)}&gt;
                Decrement
            &lt;/button&gt;
            &lt;button onClick={() => setCount(0)}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h4>With useReducer</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// Reducer function (lives outside component)
function counterReducer(state: number, action: { type: string }) {
    switch (action.type) {
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state - 1;
        case 'RESET':
            return 0;
        default:
            return state;
    }
}

function Counter() {
    const [count, dispatch] = useReducer(counterReducer, 0);

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => dispatch({ type: 'INCREMENT' })}&gt;
                Increment
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'DECREMENT' })}&gt;
                Decrement
            &lt;/button&gt;
            &lt;button onClick={() => dispatch({ type: 'RESET' })}&gt;
                Reset
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <p>For this simple counter, useState is actually better - less code, more straightforward. But let's see what happens when we add more complexity:</p>

                <h4>Complex Counter with useState</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ComplexCounter() {
    const [count, setCount] = useState(0);
    const [step, setStep] = useState(1);
    const [history, setHistory] = useState&lt;number[]&gt;([0]);

    const increment = () => {
        const newCount = count + step;
        setCount(newCount);
        setHistory([...history, newCount]);
    };

    const decrement = () => {
        const newCount = count - step;
        setCount(newCount);
        setHistory([...history, newCount]);
    };

    const reset = () => {
        setCount(0);
        setHistory([0]);
    };

    const undo = () => {
        if (history.length > 1) {
            const newHistory = history.slice(0, -1);
            setHistory(newHistory);
            setCount(newHistory[newHistory.length - 1]);
        }
    };

    // This is getting messy! Three related state values,
    // and we have to keep them in sync manually.
}</code></pre>
                </div>

                <h4>Complex Counter with useReducer</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface CounterState {
    count: number;
    step: number;
    history: number[];
}

type CounterAction =
    | { type: 'INCREMENT' }
    | { type: 'DECREMENT' }
    | { type: 'RESET' }
    | { type: 'UNDO' }
    | { type: 'SET_STEP'; payload: number };

function counterReducer(state: CounterState, action: CounterAction): CounterState {
    switch (action.type) {
        case 'INCREMENT': {
            const newCount = state.count + state.step;
            return {
                ...state,
                count: newCount,
                history: [...state.history, newCount]
            };
        }
        case 'DECREMENT': {
            const newCount = state.count - state.step;
            return {
                ...state,
                count: newCount,
                history: [...state.history, newCount]
            };
        }
        case 'RESET':
            return {
                ...state,
                count: 0,
                history: [0]
            };
        case 'UNDO':
            if (state.history.length > 1) {
                const newHistory = state.history.slice(0, -1);
                return {
                    ...state,
                    count: newHistory[newHistory.length - 1],
                    history: newHistory
                };
            }
            return state;
        case 'SET_STEP':
            return {
                ...state,
                step: action.payload
            };
        default:
            return state;
    }
}

function ComplexCounter() {
    const [state, dispatch] = useReducer(counterReducer, {
        count: 0,
        step: 1,
        history: [0]
    });

    // Much cleaner component code!
    // All the complex logic is in the reducer.
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Takeaway</h4>
                    <p>As your state becomes more complex, useReducer helps you:</p>
                    <ul>
                        <li>Keep related state values together</li>
                        <li>Ensure state updates are consistent</li>
                        <li>Make the component code cleaner</li>
                        <li>Test state logic independently</li>
                        <li>Scale without the mess</li>
                    </ul>
                </div>

                <h3>Decision Tree</h3>
                <p>Use this decision tree to choose between useState and useReducer:</p>

                <div class="mermaid">
                graph TD
                    A[Need to manage state?] --> B{State is simple?}
                    B -->|Yes| C{1-2 state values?}
                    B -->|No| D[Use useReducer]
                    C -->|Yes| E{Independent updates?}
                    C -->|No| D
                    E -->|Yes| F[Use useState]
                    E -->|No| D
                    
                    style F fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>
            </section>

            <!-- Section 4: Basic useReducer Syntax -->
            <section id="section4" class="lesson-section">
                <h2>üìù Basic useReducer Syntax</h2>
                <p>Now that you understand the concepts, let's dive into the actual syntax of useReducer. We'll start simple and build up complexity gradually.</p>

                <h3>The Basic Pattern</h3>
                <p>Here's the fundamental structure of using useReducer:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// Step 1: Define your reducer function
function reducer(state, action) {
    switch (action.type) {
        case 'ACTION_NAME':
            return newState;
        default:
            return state;
    }
}

// Step 2: Use it in your component
function MyComponent() {
    const [state, dispatch] = useReducer(reducer, initialState);
    
    // Step 3: Dispatch actions to update state
    const handleClick = () => {
        dispatch({ type: 'ACTION_NAME' });
    };
    
    return (
        &lt;div&gt;
            {/* Use state and dispatch in your JSX */}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Breaking Down the Parts</h3>
                <p>Let's examine each piece in detail:</p>

                <h4>1. The Reducer Function</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function reducer(state, action) {
    // state: current state value
    // action: object describing what happened
    
    // Return the new state based on the action
    return newState;
}</code></pre>
                </div>

                <p>The reducer function:</p>
                <ul>
                    <li>Takes two parameters: current <code>state</code> and an <code>action</code></li>
                    <li>Returns the new state (or current state if action is unrecognized)</li>
                    <li>Is typically defined outside the component (so it's not recreated on every render)</li>
                    <li>Should be a pure function (no side effects)</li>
                </ul>

                <h4>2. The useReducer Call</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Description</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>reducer</code></td>
                            <td>The reducer function</td>
                            <td><code>counterReducer</code></td>
                        </tr>
                        <tr>
                            <td><code>initialState</code></td>
                            <td>Starting state value</td>
                            <td><code>0</code> or <code>{ count: 0 }</code></td>
                        </tr>
                        <tr>
                            <td><code>state</code></td>
                            <td>Current state (returned)</td>
                            <td>Use like <code>{state.count}</code></td>
                        </tr>
                        <tr>
                            <td><code>dispatch</code></td>
                            <td>Function to trigger updates (returned)</td>
                            <td><code>dispatch({ type: 'INCREMENT' })</code></td>
                        </tr>
                    </tbody>
                </table>

                <h4>3. Dispatching Actions</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Simple action
dispatch({ type: 'INCREMENT' });

// Action with data
dispatch({ type: 'SET_NAME', payload: 'John' });

// Action with multiple properties
dispatch({
    type: 'UPDATE_USER',
    id: 123,
    name: 'John Doe'
});</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Understanding Dispatch</h4>
                    <p>The <code>dispatch</code> function is stable - it doesn't change between renders. This makes it safe to pass to child components or include in dependency arrays. React guarantees the same dispatch function will be used throughout the component's lifetime.</p>
                </div>

                <h3>Lazy Initialization (Optional)</h3>
                <p>Sometimes calculating the initial state is expensive. You can pass a third parameter - an init function:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Expensive initial state calculation
function init(initialCount: number) {
    // This only runs once on mount
    return {
        count: initialCount,
        history: [initialCount],
        timestamp: Date.now()
    };
}

// Use it like this:
const [state, dispatch] = useReducer(reducer, 10, init);

// Now 'init' is called with 10 as argument
// Result: { count: 10, history: [10], timestamp: 1234567890 }</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When to Use Lazy Initialization</h4>
                    <p>Use the init function when:</p>
                    <ul>
                        <li>Initial state calculation is expensive (reading from localStorage, complex computations)</li>
                        <li>Initial state depends on props (but you want to compute it only once)</li>
                        <li>You want to extract and reuse the initialization logic</li>
                    </ul>
                    <p>Don't use it for simple initial states - it adds unnecessary complexity.</p>
                </div>

                <h3>Complete Minimal Example</h3>
                <p>Here's a complete working example to see everything together:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// Reducer function
function counterReducer(state: number, action: { type: string }) {
    switch (action.type) {
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state - 1;
        default:
            return state;
    }
}

// Component
function Counter() {
    // Hook call
    const [count, dispatch] = useReducer(counterReducer, 0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;
                +1
            &lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;
                -1
            &lt;/button&gt;
        &lt;/div&gt;
    );
}

export default Counter;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What's Happening Here</h4>
                    <ol>
                        <li>Component mounts with initial state <code>0</code></li>
                        <li>User clicks "+1" button</li>
                        <li><code>dispatch({ type: 'INCREMENT' })</code> is called</li>
                        <li>Reducer receives <code>(0, { type: 'INCREMENT' })</code></li>
                        <li>Reducer returns <code>1</code></li>
                        <li>React updates state to <code>1</code> and re-renders</li>
                        <li>Component shows "Count: 1"</li>
                    </ol>
                </div>
            </section>

            <!-- Section 5: Typing Reducers with TypeScript -->
            <section id="section5" class="lesson-section">
                <h2>üî∑ Typing Reducers with TypeScript</h2>
                <p>TypeScript makes useReducer even more powerful by ensuring type safety for your state and actions. Let's learn how to properly type everything for maximum safety and great developer experience.</p>

                <h3>Why Type Your Reducers?</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Typed Reducers</h4>
                    <ul>
                        <li><strong>Catch Errors Early</strong> - TypeScript will warn you about invalid action types</li>
                        <li><strong>Autocomplete</strong> - Your editor suggests valid action types and payloads</li>
                        <li><strong>Refactoring Safety</strong> - Rename actions and TypeScript finds all usages</li>
                        <li><strong>Documentation</strong> - Types serve as documentation for your state shape</li>
                        <li><strong>Confidence</strong> - Know your reducer handles all cases correctly</li>
                    </ul>
                </div>

                <h3>Basic Typing Pattern</h3>
                <p>Here's the fundamental pattern for typing reducers:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// 1. Define your state type
interface State {
    // your state properties
}

// 2. Define your action types
type Action = 
    | { type: 'ACTION_ONE' }
    | { type: 'ACTION_TWO', payload: string }
    | { type: 'ACTION_THREE', payload: number };

// 3. Type your reducer
function reducer(state: State, action: Action): State {
    switch (action.type) {
        case 'ACTION_ONE':
            return { ...state };
        case 'ACTION_TWO':
            // TypeScript knows action.payload is a string here!
            return { ...state, value: action.payload };
        case 'ACTION_THREE':
            // TypeScript knows action.payload is a number here!
            return { ...state, count: action.payload };
        default:
            return state;
    }
}

// 4. Use with typed state and dispatch
const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
                </div>

                <h3>Step-by-Step Example: Typed Counter</h3>
                <p>Let's build a fully-typed counter with multiple operations:</p>

                <h4>Step 1: Define State Type</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface CounterState {
    count: number;
    step: number;
}</code></pre>
                </div>

                <h4>Step 2: Define Action Types</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Using discriminated union types
type CounterAction =
    | { type: 'INCREMENT' }
    | { type: 'DECREMENT' }
    | { type: 'RESET' }
    | { type: 'SET_STEP'; step: number }
    | { type: 'SET_COUNT'; count: number };

// TypeScript now knows all possible actions!</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Discriminated Unions</h4>
                    <p>The pipe (<code>|</code>) operator creates a union type - the action can be any one of these types. TypeScript uses the <code>type</code> property to discriminate between them, giving you perfect autocomplete and type checking!</p>
                </div>

                <h4>Step 3: Type the Reducer</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function counterReducer(
    state: CounterState,
    action: CounterAction
): CounterState {
    switch (action.type) {
        case 'INCREMENT':
            return {
                ...state,
                count: state.count + state.step
            };
        
        case 'DECREMENT':
            return {
                ...state,
                count: state.count - state.step
            };
        
        case 'RESET':
            return {
                ...state,
                count: 0
            };
        
        case 'SET_STEP':
            // TypeScript knows action.step exists and is a number!
            return {
                ...state,
                step: action.step
            };
        
        case 'SET_COUNT':
            // TypeScript knows action.count exists and is a number!
            return {
                ...state,
                count: action.count
            };
        
        default:
            // This ensures we handle all action types
            const exhaustiveCheck: never = action;
            return state;
    }
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è The Exhaustive Check Pattern</h4>
                    <p>The <code>const exhaustiveCheck: never = action;</code> line is a clever TypeScript pattern. If you forget to handle an action type, TypeScript will error because <code>action</code> won't be <code>never</code>. This ensures you handle all cases!</p>
                </div>

                <h4>Step 4: Use in Component</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

function Counter() {
    const [state, dispatch] = useReducer(counterReducer, {
        count: 0,
        step: 1
    });

    return (
        &lt;div&gt;
            &lt;p&gt;Count: {state.count}&lt;/p&gt;
            &lt;p&gt;Step: {state.step}&lt;/p&gt;
            
            &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;
                + {state.step}
            &lt;/button&gt;
            
            &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;
                - {state.step}
            &lt;/button&gt;
            
            &lt;button onClick={() =&gt; dispatch({ type: 'RESET' })}&gt;
                Reset
            &lt;/button&gt;
            
            &lt;input
                type="number"
                value={state.step}
                onChange={(e) =&gt; dispatch({
                    type: 'SET_STEP',
                    step: Number(e.target.value)
                })}
            /&gt;
            
            {/* TypeScript will error if you dispatch invalid action! */}
            {/* dispatch({ type: 'INVALID' }) // ‚ùå Error! */}
            {/* dispatch({ type: 'SET_STEP' }) // ‚ùå Error! Missing 'step' */}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Advanced Typing Patterns</h3>

                <h4>Pattern 1: Using Constants for Action Types</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Define action type constants
const INCREMENT = 'INCREMENT' as const;
const DECREMENT = 'DECREMENT' as const;
const SET_COUNT = 'SET_COUNT' as const;

// Use them in your action types
type CounterAction =
    | { type: typeof INCREMENT }
    | { type: typeof DECREMENT }
    | { type: typeof SET_COUNT; count: number };

// Benefits: Refactor-safe, reusable, no magic strings
dispatch({ type: INCREMENT }); // Works!
dispatch({ type: 'INCREMENT' }); // Also works!</code></pre>
                </div>

                <h4>Pattern 2: Payload Convention</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Many developers use 'payload' for action data
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } };

// Usage
dispatch({
    type: 'ADD_TODO',
    payload: { text: 'Learn useReducer' }
});</code></pre>
                </div>

                <h4>Pattern 3: Generic Reducer Type</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Create a generic reducer type
type Reducer&lt;S, A&gt; = (state: S, action: A) => S;

// Use it to type your reducer
const counterReducer: Reducer&lt;CounterState, CounterAction&gt; = (state, action) => {
    // TypeScript infers parameter types!
    switch (action.type) {
        // ...
    }
};</code></pre>
                </div>

                <h3>Type Inference with useReducer</h3>
                <p>TypeScript can infer types from your reducer, but explicit typing is often better:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// TypeScript infers types from reducer
const [state, dispatch] = useReducer(counterReducer, { count: 0, step: 1 });
// state is inferred as CounterState
// dispatch is inferred as Dispatch&lt;CounterAction&gt;

// You can also be explicit (recommended for clarity)
const [state, dispatch] = useReducer&lt;CounterState, CounterAction&gt;(
    counterReducer,
    { count: 0, step: 1 }
);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Typing Best Practices</h4>
                    <ul>
                        <li>Always type your state interface/type</li>
                        <li>Use discriminated unions for actions</li>
                        <li>Include the exhaustive check in default case</li>
                        <li>Use <code>as const</code> for action type constants</li>
                        <li>Consider using payload convention for consistency</li>
                        <li>Let TypeScript infer types where it's clear</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Actions and Action Types -->
            <section id="section6" class="lesson-section">
                <h2>üé¨ Actions and Action Types</h2>
                <p>Actions are the messages you send to your reducer to describe what should happen. Understanding how to structure actions effectively is key to writing clean, maintainable code with useReducer.</p>

                <h3>Anatomy of an Action</h3>
                <p>An action is just a plain JavaScript object, but it follows certain conventions:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Minimal action - just a type
{ type: 'RESET' }

// Action with data
{
    type: 'ADD_TODO',
    payload: {
        id: 1,
        text: 'Learn useReducer',
        completed: false
    }
}

// Action with multiple properties (alternative to payload)
{
    type: 'UPDATE_USER',
    id: 123,
    name: 'John Doe',
    email: 'john@example.com'
}</code></pre>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Action Structure</h4>
                    <p style="color: white;"><strong>Required:</strong></p>
                    <ul style="color: white;">
                        <li><code>type</code> - A string describing the action (REQUIRED)</li>
                    </ul>
                    <p style="color: white;"><strong>Optional:</strong></p>
                    <ul style="color: white;">
                        <li><code>payload</code> - Data needed for the action (COMMON)</li>
                        <li>Other properties - Additional data (LESS COMMON)</li>
                    </ul>
                </div>

                <h3>Naming Action Types</h3>
                <p>Good action type names make your code self-documenting. Follow these conventions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Convention</th>
                            <th>Example</th>
                            <th>Why?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>SCREAMING_SNAKE_CASE</td>
                            <td><code>ADD_TODO</code></td>
                            <td>Standard in Redux, stands out as constant</td>
                        </tr>
                        <tr>
                            <td>Verb + Noun</td>
                            <td><code>FETCH_USER</code></td>
                            <td>Describes the action clearly</td>
                        </tr>
                        <tr>
                            <td>Past tense events</td>
                            <td><code>USER_LOADED</code></td>
                            <td>For completed actions/events</td>
                        </tr>
                        <tr>
                            <td>Domain prefixes</td>
                            <td><code>TODO_ADDED</code></td>
                            <td>Organizes actions by feature</td>
                        </tr>
                    </tbody>
                </table>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Good action type names
'ADD_TODO'           // Clear action
'TOGGLE_TODO'        // Specific operation
'DELETE_TODO'        // No ambiguity
'FILTER_TODOS'       // Describes intent
'SET_LOADING'        // Clear state change

// ‚ùå Poor action type names
'TODO'               // What about todo?
'UPDATE'             // Update what?
'CHANGE'             // Too vague
'CLICK'              // Describes UI, not intent
'handleClick'        // Not a constant name</code></pre>
                </div>

                <h3>Action Creator Functions</h3>
                <p>Instead of manually creating action objects everywhere, use action creator functions:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Without action creators (not recommended)
dispatch({ type: 'ADD_TODO', payload: { id: 1, text: 'Learn', completed: false } });
dispatch({ type: 'ADD_TODO', payload: { id: 2, text: 'Practice', completed: false } });

// With action creators (recommended!)
function addTodo(id: number, text: string) {
    return {
        type: 'ADD_TODO' as const,
        payload: {
            id,
            text,
            completed: false
        }
    };
}

// Usage - much cleaner!
dispatch(addTodo(1, 'Learn'));
dispatch(addTodo(2, 'Practice'));</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Action Creators</h4>
                    <ul>
                        <li><strong>Consistency</strong> - All actions have the same structure</li>
                        <li><strong>Reusability</strong> - One function, many uses</li>
                        <li><strong>Type Safety</strong> - TypeScript checks parameters</li>
                        <li><strong>Testability</strong> - Easy to test action creation</li>
                        <li><strong>Refactoring</strong> - Change structure in one place</li>
                        <li><strong>Documentation</strong> - Function signature documents required data</li>
                    </ul>
                </div>

                <h3>Complete Action Creators Example</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Action types
type TodoAction =
    | ReturnType&lt;typeof addTodo&gt;
    | ReturnType&lt;typeof toggleTodo&gt;
    | ReturnType&lt;typeof deleteTodo&gt;
    | ReturnType&lt;typeof updateTodoText&gt;;

// Action creators
function addTodo(text: string) {
    return {
        type: 'ADD_TODO' as const,
        payload: {
            id: Date.now(),
            text,
            completed: false
        }
    };
}

function toggleTodo(id: number) {
    return {
        type: 'TOGGLE_TODO' as const,
        payload: { id }
    };
}

function deleteTodo(id: number) {
    return {
        type: 'DELETE_TODO' as const,
        payload: { id }
    };
}

function updateTodoText(id: number, text: string) {
    return {
        type: 'UPDATE_TODO_TEXT' as const,
        payload: { id, text }
    };
}

// Usage in component
function TodoList() {
    const [state, dispatch] = useReducer(todoReducer, initialState);

    const handleAdd = (text: string) => {
        dispatch(addTodo(text));
    };

    const handleToggle = (id: number) => {
        dispatch(toggleTodo(id));
    };

    // TypeScript ensures you pass correct parameters!
    // dispatch(addTodo()); // ‚ùå Error: missing text parameter
    // dispatch(toggleTodo('hello')); // ‚ùå Error: id must be number
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° ReturnType Utility</h4>
                    <p>The <code>ReturnType&lt;typeof function&gt;</code> utility type extracts the return type of a function. This lets TypeScript infer your action types from your action creators automatically - no duplicate type definitions!</p>
                </div>

                <h3>Action Patterns</h3>

                <h4>Pattern 1: Simple Actions (No Data)</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// For actions that don't need data
const reset = () => ({ type: 'RESET' as const });
const clearAll = () => ({ type: 'CLEAR_ALL' as const });

dispatch(reset());
dispatch(clearAll());</code></pre>
                </div>

                <h4>Pattern 2: Payload Actions</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// For actions with a single piece of data
const setName = (name: string) => ({
    type: 'SET_NAME' as const,
    payload: name
});

const setAge = (age: number) => ({
    type: 'SET_AGE' as const,
    payload: age
});

dispatch(setName('John'));
dispatch(setAge(30));</code></pre>
                </div>

                <h4>Pattern 3: Object Payload Actions</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// For actions with complex data
const updateUser = (updates: Partial&lt;User&gt;) => ({
    type: 'UPDATE_USER' as const,
    payload: updates
});

dispatch(updateUser({
    name: 'John Doe',
    email: 'john@example.com'
}));</code></pre>
                </div>

                <h4>Pattern 4: Multiple Property Actions</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Alternative to payload (less common but valid)
const moveItem = (from: number, to: number) => ({
    type: 'MOVE_ITEM' as const,
    from,
    to
});

dispatch(moveItem(0, 3));</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Action Best Practices</h4>
                    <ul>
                        <li>Keep actions simple - they describe what happened, not how to handle it</li>
                        <li>Use action creators for consistency</li>
                        <li>Name actions descriptively (verb + noun)</li>
                        <li>Keep payload data minimal - only what's needed</li>
                        <li>Don't put functions or promises in actions</li>
                        <li>Group related actions with prefixes (TODO_ADD, TODO_DELETE)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Simple Counter Example -->
            <section id="section7" class="lesson-section">
                <h2>üî¢ Simple Counter Example</h2>
                <p>Let's put everything we've learned together by building a complete counter application with useReducer. We'll start simple and gradually add features to see how useReducer scales.</p>

                <h3>Basic Counter</h3>
                <p>Here's a simple counter with increment and decrement:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// State type
type CounterState = number;

// Action types
type CounterAction =
    | { type: 'INCREMENT' }
    | { type: 'DECREMENT' }
    | { type: 'RESET' };

// Reducer function
function counterReducer(state: CounterState, action: CounterAction): CounterState {
    switch (action.type) {
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state - 1;
        case 'RESET':
            return 0;
        default:
            return state;
    }
}

// Component
function Counter() {
    const [count, dispatch] = useReducer(counterReducer, 0);

    return (
        &lt;div className="counter"&gt;
            &lt;h2&gt;Counter&lt;/h2&gt;
            &lt;p className="count-display"&gt;{count}&lt;/p&gt;
            
            &lt;div className="button-group"&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;
                    -1
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'RESET' })}&gt;
                    Reset
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;
                    +1
                &lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default Counter;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Have</h4>
                    <ul>
                        <li>Type-safe state and actions</li>
                        <li>Clear separation: reducer handles logic, component handles UI</li>
                        <li>Three actions: INCREMENT, DECREMENT, RESET</li>
                        <li>Simple initial state (0)</li>
                    </ul>
                </div>

                <h3>Enhanced Counter with Step</h3>
                <p>Let's add the ability to change the increment/decrement step:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// State type - now an object with count and step
interface CounterState {
    count: number;
    step: number;
}

// Action types - added SET_STEP
type CounterAction =
    | { type: 'INCREMENT' }
    | { type: 'DECREMENT' }
    | { type: 'RESET' }
    | { type: 'SET_STEP'; payload: number };

// Reducer - handles multiple pieces of state
function counterReducer(state: CounterState, action: CounterAction): CounterState {
    switch (action.type) {
        case 'INCREMENT':
            return {
                ...state,
                count: state.count + state.step
            };
        
        case 'DECREMENT':
            return {
                ...state,
                count: state.count - state.step
            };
        
        case 'RESET':
            return {
                ...state,
                count: 0
            };
        
        case 'SET_STEP':
            return {
                ...state,
                step: action.payload
            };
        
        default:
            return state;
    }
}

// Component
function Counter() {
    const [state, dispatch] = useReducer(counterReducer, {
        count: 0,
        step: 1
    });

    return (
        &lt;div className="counter"&gt;
            &lt;h2&gt;Enhanced Counter&lt;/h2&gt;
            &lt;p className="count-display"&gt;Count: {state.count}&lt;/p&gt;
            &lt;p className="step-display"&gt;Step: {state.step}&lt;/p&gt;
            
            &lt;div className="button-group"&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;
                    -{state.step}
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'RESET' })}&gt;
                    Reset
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;
                    +{state.step}
                &lt;/button&gt;
            &lt;/div&gt;

            &lt;div className="step-control"&gt;
                &lt;label&gt;
                    Change Step:
                    &lt;input
                        type="number"
                        value={state.step}
                        onChange={(e) =&gt; dispatch({
                            type: 'SET_STEP',
                            payload: Number(e.target.value)
                        })}
                        min="1"
                    /&gt;
                &lt;/label&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default Counter;</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Improvements</h4>
                    <ul>
                        <li><strong>Object State</strong> - Now tracking two related values (count and step)</li>
                        <li><strong>Spread Operator</strong> - Using <code>...state</code> to preserve other state values</li>
                        <li><strong>Dynamic Step</strong> - Increment/decrement by user-defined amount</li>
                        <li><strong>Single Reducer</strong> - All state logic in one place</li>
                    </ul>
                </div>

                <h3>Advanced Counter with History</h3>
                <p>Now let's add undo functionality by tracking history:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer } from 'react';

// State type with history
interface CounterState {
    count: number;
    step: number;
    history: number[];
}

// Action types with undo
type CounterAction =
    | { type: 'INCREMENT' }
    | { type: 'DECREMENT' }
    | { type: 'RESET' }
    | { type: 'SET_STEP'; payload: number }
    | { type: 'UNDO' };

// Reducer with history management
function counterReducer(state: CounterState, action: CounterAction): CounterState {
    switch (action.type) {
        case 'INCREMENT': {
            const newCount = state.count + state.step;
            return {
                ...state,
                count: newCount,
                history: [...state.history, newCount]
            };
        }
        
        case 'DECREMENT': {
            const newCount = state.count - state.step;
            return {
                ...state,
                count: newCount,
                history: [...state.history, newCount]
            };
        }
        
        case 'RESET':
            return {
                ...state,
                count: 0,
                history: [0]
            };
        
        case 'SET_STEP':
            return {
                ...state,
                step: action.payload
            };
        
        case 'UNDO':
            // Can't undo if only initial value in history
            if (state.history.length <= 1) {
                return state;
            }
            
            // Remove last history entry
            const newHistory = state.history.slice(0, -1);
            // Get the previous count value
            const previousCount = newHistory[newHistory.length - 1];
            
            return {
                ...state,
                count: previousCount,
                history: newHistory
            };
        
        default:
            return state;
    }
}

// Component
function Counter() {
    const [state, dispatch] = useReducer(counterReducer, {
        count: 0,
        step: 1,
        history: [0]
    });

    const canUndo = state.history.length > 1;

    return (
        &lt;div className="counter"&gt;
            &lt;h2&gt;Counter with History&lt;/h2&gt;
            &lt;p className="count-display"&gt;Count: {state.count}&lt;/p&gt;
            &lt;p className="step-display"&gt;Step: {state.step}&lt;/p&gt;
            
            &lt;div className="button-group"&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'DECREMENT' })}&gt;
                    -{state.step}
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'RESET' })}&gt;
                    Reset
                &lt;/button&gt;
                &lt;button onClick={() =&gt; dispatch({ type: 'INCREMENT' })}&gt;
                    +{state.step}
                &lt;/button&gt;
                &lt;button 
                    onClick={() =&gt; dispatch({ type: 'UNDO' })}
                    disabled={!canUndo}
                &gt;
                    ‚Ü∂ Undo
                &lt;/button&gt;
            &lt;/div&gt;

            &lt;div className="step-control"&gt;
                &lt;label&gt;
                    Change Step:
                    &lt;input
                        type="number"
                        value={state.step}
                        onChange={(e) =&gt; dispatch({
                            type: 'SET_STEP',
                            payload: Number(e.target.value)
                        })}
                        min="1"
                    /&gt;
                &lt;/label&gt;
            &lt;/div&gt;

            &lt;div className="history"&gt;
                &lt;h3&gt;History&lt;/h3&gt;
                &lt;p&gt;{state.history.join(' ‚Üí ')}&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default Counter;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Advanced Features</h4>
                    <ul>
                        <li><strong>History Tracking</strong> - Array of all previous counts</li>
                        <li><strong>Undo Capability</strong> - Go back to previous state</li>
                        <li><strong>UI State</strong> - Disable undo when no history</li>
                        <li><strong>Consistent Updates</strong> - History updates with every change</li>
                    </ul>
                    <p>This would be very messy with multiple useState calls! useReducer keeps everything organized.</p>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Notice the Pattern</h4>
                    <p>See how we use curly braces <code>{ }</code> in some case blocks? This creates a block scope, allowing us to declare variables like <code>newCount</code> without conflicts between cases. Without the braces, you'd get "variable already declared" errors!</p>
                </div>
            </section>

            <!-- Section 8: Complex State Example -->
            <section id="section8" class="lesson-section">
                <h2>üìù Complex State Example: Todo List</h2>
                <p>Now let's tackle a real-world example that truly showcases useReducer's power: a todo list with multiple features. This example will demonstrate why useReducer is superior to useState for complex state.</p>

                <h3>Todo List Requirements</h3>
                <div class="card">
                    <h4>Features We'll Build</h4>
                    <ul>
                        <li>‚ûï Add new todos</li>
                        <li>‚úì Toggle todo completion</li>
                        <li>üóëÔ∏è Delete todos</li>
                        <li>‚úèÔ∏è Edit todo text</li>
                        <li>üîΩ Filter todos (all, active, completed)</li>
                        <li>üßπ Clear completed todos</li>
                    </ul>
                </div>

                <h3>Step 1: Define Types</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Todo item type
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

// Filter type
type FilterType = 'all' | 'active' | 'completed';

// State type
interface TodoState {
    todos: Todo[];
    filter: FilterType;
}

// Action types
type TodoAction =
    | { type: 'ADD_TODO'; payload: { text: string } }
    | { type: 'TOGGLE_TODO'; payload: { id: number } }
    | { type: 'DELETE_TODO'; payload: { id: number } }
    | { type: 'EDIT_TODO'; payload: { id: number; text: string } }
    | { type: 'SET_FILTER'; payload: { filter: FilterType } }
    | { type: 'CLEAR_COMPLETED' };</code></pre>
                </div>

                <h3>Step 2: Create Action Creators</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Action creators
const addTodo = (text: string) => ({
    type: 'ADD_TODO' as const,
    payload: { text }
});

const toggleTodo = (id: number) => ({
    type: 'TOGGLE_TODO' as const,
    payload: { id }
});

const deleteTodo = (id: number) => ({
    type: 'DELETE_TODO' as const,
    payload: { id }
});

const editTodo = (id: number, text: string) => ({
    type: 'EDIT_TODO' as const,
    payload: { id, text }
});

const setFilter = (filter: FilterType) => ({
    type: 'SET_FILTER' as const,
    payload: { filter }
});

const clearCompleted = () => ({
    type: 'CLEAR_COMPLETED' as const
});</code></pre>
                </div>

                <h3>Step 3: Implement Reducer</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function todoReducer(state: TodoState, action: TodoAction): TodoState {
    switch (action.type) {
        case 'ADD_TODO':
            return {
                ...state,
                todos: [
                    ...state.todos,
                    {
                        id: Date.now(),
                        text: action.payload.text,
                        completed: false
                    }
                ]
            };
        
        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };
        
        case 'DELETE_TODO':
            return {
                ...state,
                todos: state.todos.filter(todo => todo.id !== action.payload.id)
            };
        
        case 'EDIT_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, text: action.payload.text }
                        : todo
                )
            };
        
        case 'SET_FILTER':
            return {
                ...state,
                filter: action.payload.filter
            };
        
        case 'CLEAR_COMPLETED':
            return {
                ...state,
                todos: state.todos.filter(todo => !todo.completed)
            };
        
        default:
            return state;
    }
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Reducer Patterns Used</h4>
                    <ul>
                        <li><strong>Immutable Updates</strong> - Using spread operator and array methods</li>
                        <li><strong>Array Mapping</strong> - Update specific items without mutation</li>
                        <li><strong>Array Filtering</strong> - Remove items by creating new array</li>
                        <li><strong>Conditional Updates</strong> - Only update matching items</li>
                    </ul>
                </div>

                <h3>Step 4: Build Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useReducer, useState } from 'react';

function TodoList() {
    const [state, dispatch] = useReducer(todoReducer, {
        todos: [],
        filter: 'all'
    });

    const [inputValue, setInputValue] = useState('');

    // Filter todos based on current filter
    const filteredTodos = state.todos.filter(todo => {
        if (state.filter === 'active') return !todo.completed;
        if (state.filter === 'completed') return todo.completed;
        return true; // 'all'
    });

    // Handle add todo
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (inputValue.trim()) {
            dispatch(addTodo(inputValue));
            setInputValue('');
        }
    };

    // Count active todos
    const activeTodoCount = state.todos.filter(t => !t.completed).length;

    return (
        &lt;div className="todo-app"&gt;
            &lt;h1&gt;üìù Todo List&lt;/h1&gt;

            {/* Add Todo Form */}
            &lt;form onSubmit={handleSubmit}&gt;
                &lt;input
                    type="text"
                    value={inputValue}
                    onChange={(e) =&gt; setInputValue(e.target.value)}
                    placeholder="What needs to be done?"
                /&gt;
                &lt;button type="submit"&gt;Add&lt;/button&gt;
            &lt;/form&gt;

            {/* Filter Buttons */}
            &lt;div className="filters"&gt;
                &lt;button
                    onClick={() =&gt; dispatch(setFilter('all'))}
                    className={state.filter === 'all' ? 'active' : ''}
                &gt;
                    All ({state.todos.length})
                &lt;/button&gt;
                &lt;button
                    onClick={() =&gt; dispatch(setFilter('active'))}
                    className={state.filter === 'active' ? 'active' : ''}
                &gt;
                    Active ({activeTodoCount})
                &lt;/button&gt;
                &lt;button
                    onClick={() =&gt; dispatch(setFilter('completed'))}
                    className={state.filter === 'completed' ? 'active' : ''}
                &gt;
                    Completed ({state.todos.length - activeTodoCount})
                &lt;/button&gt;
            &lt;/div&gt;

            {/* Todo List */}
            &lt;ul className="todo-list"&gt;
                {filteredTodos.map(todo =&gt; (
                    &lt;TodoItem
                        key={todo.id}
                        todo={todo}
                        onToggle={() =&gt; dispatch(toggleTodo(todo.id))}
                        onDelete={() =&gt; dispatch(deleteTodo(todo.id))}
                        onEdit={(text) =&gt; dispatch(editTodo(todo.id, text))}
                    /&gt;
                ))}
            &lt;/ul&gt;

            {/* Footer */}
            {state.todos.length > 0 && (
                &lt;div className="footer"&gt;
                    &lt;span&gt;{activeTodoCount} item(s) left&lt;/span&gt;
                    {activeTodoCount &lt; state.todos.length && (
                        &lt;button onClick={() =&gt; dispatch(clearCompleted())}&gt;
                            Clear Completed
                        &lt;/button&gt;
                    )}
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}

export default TodoList;</code></pre>
                </div>

                <h3>Step 5: TodoItem Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useState } from 'react';

interface TodoItemProps {
    todo: Todo;
    onToggle: () => void;
    onDelete: () => void;
    onEdit: (text: string) => void;
}

function TodoItem({ todo, onToggle, onDelete, onEdit }: TodoItemProps) {
    const [isEditing, setIsEditing] = useState(false);
    const [editValue, setEditValue] = useState(todo.text);

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (editValue.trim()) {
            onEdit(editValue);
            setIsEditing(false);
        }
    };

    const handleCancel = () => {
        setEditValue(todo.text);
        setIsEditing(false);
    };

    if (isEditing) {
        return (
            &lt;li className="todo-item editing"&gt;
                &lt;form onSubmit={handleSubmit}&gt;
                    &lt;input
                        type="text"
                        value={editValue}
                        onChange={(e) =&gt; setEditValue(e.target.value)}
                        autoFocus
                    /&gt;
                    &lt;button type="submit"&gt;Save&lt;/button&gt;
                    &lt;button type="button" onClick={handleCancel}&gt;
                        Cancel
                    &lt;/button&gt;
                &lt;/form&gt;
            &lt;/li&gt;
        );
    }

    return (
        &lt;li className={`todo-item ${todo.completed ? 'completed' : ''}`}&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={onToggle}
            /&gt;
            &lt;span 
                onDoubleClick={() =&gt; setIsEditing(true)}
                style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}
            &gt;
                {todo.text}
            &lt;/span&gt;
            &lt;button onClick={onDelete}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    );
}

export default TodoItem;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We Achieved</h4>
                    <p>This todo app demonstrates:</p>
                    <ul>
                        <li><strong>Complex State Management</strong> - Todos array + filter state</li>
                        <li><strong>Multiple Operations</strong> - 6 different actions</li>
                        <li><strong>Derived State</strong> - Filtered todos, counts</li>
                        <li><strong>Component Composition</strong> - TodoItem separated for clarity</li>
                        <li><strong>Type Safety</strong> - Full TypeScript coverage</li>
                        <li><strong>Clean Code</strong> - Component focuses on UI, reducer handles logic</li>
                    </ul>
                </div>

                <h3>Comparing useState vs useReducer</h3>
                <p>Imagine implementing this todo app with useState:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// With useState - messy and error-prone!
function TodoList() {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [filter, setFilter] = useState&lt;FilterType&gt;('all');

    const addTodo = (text: string) => {
        setTodos([...todos, {
            id: Date.now(),
            text,
            completed: false
        }]);
    };

    const toggleTodo = (id: number) => {
        setTodos(todos.map(todo =>
            todo.id === id ? { ...todo, completed: !todo.completed } : todo
        ));
    };

    const deleteTodo = (id: number) => {
        setTodos(todos.filter(todo => todo.id !== id));
    };

    // ... more functions scattered throughout component
    // Logic is mixed with UI code
    // Harder to test
    // More prone to stale closure bugs
}</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// With useReducer - clean and organized!
function TodoList() {
    const [state, dispatch] = useReducer(todoReducer, initialState);

    // All logic is in reducer
    // Component focuses on rendering
    // Easy to test reducer independently
    // No stale closure issues
    // Actions clearly describe intent
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Takeaway</h4>
                    <p>For the todo app, useReducer provides:</p>
                    <ul>
                        <li><strong>Better Organization</strong> - All state logic in one place</li>
                        <li><strong>Easier Testing</strong> - Test reducer functions independently</li>
                        <li><strong>Clearer Intent</strong> - Action types describe what's happening</li>
                        <li><strong>Fewer Bugs</strong> - Centralized logic prevents inconsistencies</li>
                        <li><strong>Scalability</strong> - Easy to add new actions</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Now it's your turn! These exercises will help you master useReducer. Start with the easier ones and work your way up.</p>

                <h3>Exercise 1: Traffic Light Controller</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Build a traffic light controller that cycles through: üî¥ Red ‚Üí üü¢ Green ‚Üí üü° Yellow ‚Üí üî¥ Red</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Use useReducer to manage the current light state</li>
                        <li>Add a "Next" button to cycle to the next light</li>
                        <li>Display the current light with appropriate colors</li>
                        <li>Add a counter showing how many times lights have changed</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Your state might look like:</p>
                        <pre><code>interface TrafficLightState {
    currentLight: 'red' | 'green' | 'yellow';
    changeCount: number;
}</code></pre>
                        <p>You'll need actions like: 'NEXT_LIGHT'</p>
                    </div>
                </details>

                <details>
                    <summary><strong>‚úÖ Solution</strong></summary>
                    <div style="margin-top: 1rem;">
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">import { useReducer } from 'react';

type LightColor = 'red' | 'green' | 'yellow';

interface TrafficLightState {
    currentLight: LightColor;
    changeCount: number;
}

type TrafficLightAction = { type: 'NEXT_LIGHT' };

function trafficLightReducer(
    state: TrafficLightState,
    action: TrafficLightAction
): TrafficLightState {
    switch (action.type) {
        case 'NEXT_LIGHT': {
            let nextLight: LightColor;
            
            switch (state.currentLight) {
                case 'red':
                    nextLight = 'green';
                    break;
                case 'green':
                    nextLight = 'yellow';
                    break;
                case 'yellow':
                    nextLight = 'red';
                    break;
            }
            
            return {
                currentLight: nextLight,
                changeCount: state.changeCount + 1
            };
        }
        default:
            return state;
    }
}

function TrafficLight() {
    const [state, dispatch] = useReducer(trafficLightReducer, {
        currentLight: 'red',
        changeCount: 0
    });

    const lightColors = {
        red: '#ff0000',
        green: '#00ff00',
        yellow: '#ffff00'
    };

    return (
        &lt;div&gt;
            &lt;h2&gt;üö¶ Traffic Light&lt;/h2&gt;
            &lt;div
                style={{
                    width: '100px',
                    height: '100px',
                    borderRadius: '50%',
                    backgroundColor: lightColors[state.currentLight],
                    margin: '20px auto'
                }}
            /&gt;
            &lt;p&gt;Current: {state.currentLight.toUpperCase()}&lt;/p&gt;
            &lt;p&gt;Changes: {state.changeCount}&lt;/p&gt;
            &lt;button onClick={() =&gt; dispatch({ type: 'NEXT_LIGHT' })}&gt;
                Next Light
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </div>
                </details>

                <h3>Exercise 2: Shopping Cart</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Build a shopping cart with add, remove, and quantity update functionality.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Add items to cart (with name and price)</li>
                        <li>Remove items from cart</li>
                        <li>Increase/decrease item quantity</li>
                        <li>Display total price</li>
                        <li>Clear entire cart</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Your state might look like:</p>
                        <pre><code>interface CartItem {
    id: string;
    name: string;
    price: number;
    quantity: number;
}

interface CartState {
    items: CartItem[];
}</code></pre>
                        <p>Actions: ADD_ITEM, REMOVE_ITEM, UPDATE_QUANTITY, CLEAR_CART</p>
                    </div>
                </details>

                <h3>Exercise 3: Form Wizard</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Challenge</h4>
                    <p>Create a multi-step form wizard (personal info ‚Üí address ‚Üí confirmation).</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Three steps with different form fields</li>
                        <li>Next/Previous navigation</li>
                        <li>Form data persists across steps</li>
                        <li>Validation before moving to next step</li>
                        <li>Submit on final step</li>
                    </ul>
                </div>

                <details>
                    <summary><strong>üí° Hint</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p>Your state might include:</p>
                        <pre><code>interface WizardState {
    currentStep: number;
    formData: {
        name: string;
        email: string;
        address: string;
        city: string;
        // ... more fields
    };
    errors: Record&lt;string, string&gt;;
}</code></pre>
                    </div>
                </details>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Practice Tips</h4>
                    <ul>
                        <li>Start by defining your state and action types</li>
                        <li>Write the reducer before the component</li>
                        <li>Test your reducer with simple console.log calls</li>
                        <li>Add one action at a time and test it</li>
                        <li>Use TypeScript to catch errors early</li>
                        <li>Think about what actions users will trigger</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Common Patterns -->
            <section id="section10" class="lesson-section">
                <h2>üé® Common Patterns</h2>
                <p>Now that you understand useReducer, let's explore common patterns that will help you write better reducer code. These patterns have been refined by the React community and are widely used in production applications.</p>

                <h3>Pattern 1: Action Creator Pattern</h3>
                <p>Always use action creator functions instead of creating action objects manually:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Not recommended - manual action objects
dispatch({ type: 'ADD_TODO', payload: { text: 'Learn React' } });
dispatch({ type: 'ADD_TODO', payload: { text: 'Build project' } });

// ‚úÖ Recommended - action creators
const addTodo = (text: string) => ({
    type: 'ADD_TODO' as const,
    payload: { text }
});

dispatch(addTodo('Learn React'));
dispatch(addTodo('Build project'));</code></pre>
                </div>

                <p><strong>Benefits:</strong> Type safety, consistency, easier refactoring, less repetition</p>

                <h3>Pattern 2: State Normalization</h3>
                <p>For collections, use objects instead of arrays for better performance:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Array (slower for lookups)
interface State {
    todos: Todo[];
}

// Finding a todo requires iteration
const todo = state.todos.find(t => t.id === 5);

// ‚úÖ Normalized object (O(1) lookups)
interface State {
    todos: {
        byId: Record&lt;number, Todo&gt;;
        allIds: number[];
    };
}

// Direct access - much faster!
const todo = state.todos.byId[5];</code></pre>
                </div>

                <p><strong>When to use:</strong> Large collections (100+ items), frequent lookups, performance-critical apps</p>

                <h3>Pattern 3: Derived State</h3>
                <p>Don't store computed values in state - calculate them during render:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Storing derived state (redundant, can get out of sync)
interface TodoState {
    todos: Todo[];
    completedCount: number;  // Don't do this!
    activeCount: number;     // Don't do this!
}

// ‚úÖ Calculate during render
interface TodoState {
    todos: Todo[];
}

function TodoList() {
    const [state, dispatch] = useReducer(todoReducer, initialState);
    
    // Calculate on each render (React is fast!)
    const completedCount = state.todos.filter(t => t.completed).length;
    const activeCount = state.todos.length - completedCount;
    
    // ...
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why This Works</h4>
                    <p>React renders are fast! Computing derived values on each render is usually cheaper than keeping them in sync. If calculations are truly expensive, use <code>useMemo</code> later.</p>
                </div>

                <h3>Pattern 4: Reducer Composition</h3>
                <p>Split large reducers into smaller, focused reducers:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Split by domain
function todosReducer(todos: Todo[], action: TodoAction): Todo[] {
    switch (action.type) {
        case 'ADD_TODO':
            return [...todos, newTodo];
        case 'TOGGLE_TODO':
            return todos.map(/* ... */);
        default:
            return todos;
    }
}

function filterReducer(filter: FilterType, action: FilterAction): FilterType {
    switch (action.type) {
        case 'SET_FILTER':
            return action.payload;
        default:
            return filter;
    }
}

// Combine them
function appReducer(state: AppState, action: AppAction): AppState {
    return {
        todos: todosReducer(state.todos, action),
        filter: filterReducer(state.filter, action)
    };
}</code></pre>
                </div>

                <p><strong>When to use:</strong> Large applications, multiple domains, team collaboration</p>

                <h3>Pattern 5: Immer for Immutable Updates</h3>
                <p>Use Immer library to write "mutable" code that's actually immutable:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-bash"># Install Immer
npm install immer use-immer</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useImmerReducer } from 'use-immer';

// Without Immer - complex spread operators
function todoReducer(state: TodoState, action: TodoAction): TodoState {
    switch (action.type) {
        case 'TOGGLE_TODO':
            return {
                ...state,
                todos: state.todos.map(todo =>
                    todo.id === action.payload.id
                        ? { ...todo, completed: !todo.completed }
                        : todo
                )
            };
    }
}

// With Immer - looks like mutations but isn't!
function todoReducer(draft: TodoState, action: TodoAction) {
    switch (action.type) {
        case 'TOGGLE_TODO': {
            const todo = draft.todos.find(t => t.id === action.payload.id);
            if (todo) {
                todo.completed = !todo.completed;
            }
            break;
        }
    }
}

// Use it
const [state, dispatch] = useImmerReducer(todoReducer, initialState);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Immer Benefits</h4>
                    <ul>
                        <li>Simpler, more readable code</li>
                        <li>Less boilerplate (no spread operators everywhere)</li>
                        <li>Still immutable under the hood</li>
                        <li>Great for deeply nested updates</li>
                    </ul>
                </div>

                <h3>Pattern 6: Async Actions with useReducer</h3>
                <p>Handle async operations by dispatching multiple actions:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// State includes loading and error
interface DataState {
    data: User | null;
    loading: boolean;
    error: string | null;
}

type DataAction =
    | { type: 'FETCH_START' }
    | { type: 'FETCH_SUCCESS'; payload: User }
    | { type: 'FETCH_ERROR'; payload: string };

function dataReducer(state: DataState, action: DataAction): DataState {
    switch (action.type) {
        case 'FETCH_START':
            return {
                ...state,
                loading: true,
                error: null
            };
        case 'FETCH_SUCCESS':
            return {
                data: action.payload,
                loading: false,
                error: null
            };
        case 'FETCH_ERROR':
            return {
                ...state,
                loading: false,
                error: action.payload
            };
        default:
            return state;
    }
}

// In component
function UserProfile({ userId }: { userId: number }) {
    const [state, dispatch] = useReducer(dataReducer, {
        data: null,
        loading: false,
        error: null
    });

    const fetchUser = async () => {
        dispatch({ type: 'FETCH_START' });
        
        try {
            const response = await fetch(`/api/users/${userId}`);
            const user = await response.json();
            dispatch({ type: 'FETCH_SUCCESS', payload: user });
        } catch (error) {
            dispatch({ type: 'FETCH_ERROR', payload: error.message });
        }
    };

    useEffect(() => {
        fetchUser();
    }, [userId]);

    if (state.loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (state.error) return &lt;div&gt;Error: {state.error}&lt;/div&gt;;
    if (!state.data) return &lt;div&gt;No data&lt;/div&gt;;
    
    return &lt;div&gt;{state.data.name}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Note</h4>
                    <p>Reducers must be synchronous! Async logic goes in the component (or custom hook), which then dispatches actions to the reducer. The reducer only handles state updates.</p>
                </div>

                <h3>Pattern 7: Lazy Initialization</h3>
                <p>Use lazy initialization for expensive initial state calculations:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Init function - only runs once
function init(initialCount: number): CounterState {
    // Expensive calculation (e.g., reading from localStorage)
    const savedCount = localStorage.getItem('count');
    
    return {
        count: savedCount ? parseInt(savedCount) : initialCount,
        history: []
    };
}

// Use lazy initialization
const [state, dispatch] = useReducer(reducer, 10, init);
// init(10) is called once on mount</code></pre>
                </div>

                <h3>Pattern 8: Middleware Pattern</h3>
                <p>Add logging or analytics by wrapping dispatch:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function useReducerWithMiddleware&lt;S, A&gt;(
    reducer: (state: S, action: A) => S,
    initialState: S
) {
    const [state, dispatch] = useReducer(reducer, initialState);

    // Enhanced dispatch with logging
    const enhancedDispatch = (action: A) => {
        console.log('Previous State:', state);
        console.log('Action:', action);
        
        dispatch(action);
        
        // State updates after this
        console.log('New State:', state);
    };

    return [state, enhancedDispatch] as const;
}

// Use it
const [state, dispatch] = useReducerWithMiddleware(todoReducer, initialState);</code></pre>
                </div>
            </section>

            <!-- Section 11: Best Practices -->
            <section id="section11" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                <p>Follow these best practices to write clean, maintainable useReducer code that scales well.</p>

                <h3>Do's ‚úÖ</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Keep Reducers Pure</h4>
                    <p>Reducers must be pure functions with no side effects:</p>
                    <ul>
                        <li>Same inputs always produce same outputs</li>
                        <li>No API calls, no timers, no random numbers</li>
                        <li>No mutations - always return new state</li>
                    </ul>
                    <div class="code-block">
                        <button class="copy-button">Copy</button>
                        <pre><code class="language-typescript">// ‚úÖ Pure - always returns same result
function reducer(state: number, action: Action) {
    return state + 1;
}

// ‚ùå Impure - side effects
function reducer(state: number, action: Action) {
    console.log(state);  // Side effect!
    fetch('/api');       // Side effect!
    return state + Math.random();  // Not deterministic!
}</code></pre>
                    </div>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use TypeScript</h4>
                    <p>Type everything for safety and great developer experience:</p>
                    <ul>
                        <li>Define state interface</li>
                        <li>Use discriminated unions for actions</li>
                        <li>Type the reducer function</li>
                        <li>Use exhaustive checks in default case</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use Action Creators</h4>
                    <p>Always create helper functions for actions:</p>
                    <ul>
                        <li>Ensures consistency</li>
                        <li>Provides type safety</li>
                        <li>Makes refactoring easier</li>
                        <li>Documents what data is needed</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Handle All Cases</h4>
                    <p>Always include a default case that returns current state:</p>
                    <div class="code-block">
                        <button class="copy-button">Copy</button>
                        <pre><code class="language-typescript">function reducer(state: State, action: Action): State {
    switch (action.type) {
        case 'ACTION_1':
            return newState;
        case 'ACTION_2':
            return newState;
        default:
            // Always return state for unknown actions
            return state;
    }
}</code></pre>
                    </div>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Keep State Minimal</h4>
                    <p>Only store what you can't calculate:</p>
                    <ul>
                        <li>Don't store derived values</li>
                        <li>Don't duplicate data</li>
                        <li>Calculate computed values during render</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Name Actions Clearly</h4>
                    <p>Use descriptive, action-oriented names:</p>
                    <ul>
                        <li>Use SCREAMING_SNAKE_CASE</li>
                        <li>Start with verb (ADD_TODO, not TODO_ADDED)</li>
                        <li>Be specific (UPDATE_USER_EMAIL vs UPDATE)</li>
                        <li>Group related actions (TODO_ADD, TODO_DELETE)</li>
                    </ul>
                </div>

                <h3>Don'ts ‚ùå</h3>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Mutate State</h4>
                    <p>Never modify state directly - always return a new object:</p>
                    <div class="code-block">
                        <button class="copy-button">Copy</button>
                        <pre><code class="language-typescript">// ‚ùå Mutation - breaks React!
function reducer(state: State, action: Action): State {
    state.count++;  // Don't do this!
    return state;
}

// ‚úÖ Create new state
function reducer(state: State, action: Action): State {
    return { ...state, count: state.count + 1 };
}</code></pre>
                    </div>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Put Too Much in One Reducer</h4>
                    <p>Split large reducers into smaller ones:</p>
                    <ul>
                        <li>Keep reducers focused on one domain</li>
                        <li>Split when reducer exceeds ~100 lines</li>
                        <li>Use reducer composition pattern</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Overthink It</h4>
                    <p>Start with useState, refactor to useReducer when:</p>
                    <ul>
                        <li>State updates become complex</li>
                        <li>Multiple related state values</li>
                        <li>State logic scattered across component</li>
                        <li>Bugs from stale closures</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Use for Everything</h4>
                    <p>useState is fine for:</p>
                    <ul>
                        <li>Simple, independent state</li>
                        <li>Single values</li>
                        <li>State that doesn't interact with other state</li>
                        <li>Form inputs without complex validation</li>
                    </ul>
                </div>

                <h3>Testing Reducers</h3>
                <p>Reducers are easy to test because they're pure functions:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// counterReducer.test.ts
import { counterReducer } from './counterReducer';

describe('counterReducer', () => {
    it('should increment count', () => {
        const state = { count: 0, step: 1 };
        const action = { type: 'INCREMENT' as const };
        
        const newState = counterReducer(state, action);
        
        expect(newState.count).toBe(1);
    });

    it('should not mutate original state', () => {
        const state = { count: 0, step: 1 };
        const action = { type: 'INCREMENT' as const };
        
        counterReducer(state, action);
        
        expect(state.count).toBe(0); // Original unchanged
    });

    it('should handle unknown actions', () => {
        const state = { count: 5, step: 1 };
        const action = { type: 'UNKNOWN' as any };
        
        const newState = counterReducer(state, action);
        
        expect(newState).toBe(state); // Same reference
    });
});</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Testing Benefits</h4>
                    <ul>
                        <li>No need to render components</li>
                        <li>No need to mock APIs</li>
                        <li>Fast, focused tests</li>
                        <li>Easy to test edge cases</li>
                        <li>High confidence in state logic</li>
                    </ul>
                </div>

                <h3>Performance Considerations</h3>

                <div class="card">
                    <h4>When useReducer Helps Performance</h4>
                    <ul>
                        <li><strong>Callback Stability</strong> - dispatch never changes (safe in deps)</li>
                        <li><strong>Deep Updates</strong> - Update nested state without re-creating callbacks</li>
                        <li><strong>Multiple Updates</strong> - Batch related state changes</li>
                    </ul>
                </div>

                <div class="card">
                    <h4>Performance Tips</h4>
                    <ul>
                        <li>Use React.memo for expensive child components</li>
                        <li>Pass dispatch instead of callbacks to children</li>
                        <li>Split large state into multiple reducers</li>
                        <li>Consider Context + useReducer for global state</li>
                    </ul>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                <p>Congratulations! You've mastered the useReducer Hook. Let's recap what you've learned.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>useReducer is for complex state</strong> - When useState gets messy, reach for useReducer</li>
                        <li><strong>Reducers are pure functions</strong> - Take (state, action), return new state</li>
                        <li><strong>Actions describe what happened</strong> - Use action creators for consistency</li>
                        <li><strong>TypeScript makes it better</strong> - Type safety prevents bugs</li>
                        <li><strong>Separation of concerns</strong> - Reducer handles logic, component handles UI</li>
                        <li><strong>Easy to test</strong> - Pure functions are simple to unit test</li>
                        <li><strong>Scales well</strong> - Add features without increasing complexity</li>
                    </ul>
                </div>

                <h3>What You Learned</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>What You Can Do</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Reducer Pattern</strong></td>
                            <td>Understand how reducers work and why they're useful</td>
                        </tr>
                        <tr>
                            <td><strong>useReducer Syntax</strong></td>
                            <td>Use useReducer correctly with proper TypeScript types</td>
                        </tr>
                        <tr>
                            <td><strong>Actions</strong></td>
                            <td>Create action types and action creator functions</td>
                        </tr>
                        <tr>
                            <td><strong>Complex State</strong></td>
                            <td>Manage multi-piece state with a single reducer</td>
                        </tr>
                        <tr>
                            <td><strong>Patterns</strong></td>
                            <td>Apply common patterns for better code</td>
                        </tr>
                        <tr>
                            <td><strong>Best Practices</strong></td>
                            <td>Write maintainable, testable reducer code</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use Each Hook</h3>
                <div class="mermaid">
                graph TD
                    A[Need to manage state?] --> B{State is simple?}
                    B -->|Yes| C{Single value?}
                    B -->|No| D[useReducer]
                    C -->|Yes| E[useState]
                    C -->|No| F{Updates depend on previous state?}
                    F -->|Complex dependency| D
                    F -->|Simple| E
                    
                    style E fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <h3>Next Steps</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üöÄ Continue Learning</h4>
                    <p>Now that you know useReducer, you're ready for:</p>
                    <ul>
                        <li><strong>Lesson 5.2: useContext</strong> - Share state across components</li>
                        <li><strong>Context + useReducer</strong> - Global state management pattern</li>
                        <li><strong>useRef</strong> - Mutable values and DOM access</li>
                        <li><strong>Performance Hooks</strong> - useMemo and useCallback</li>
                    </ul>
                </div>

                <h3>Practice Projects</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Solidify Your Knowledge</h4>
                    <p>Build these projects to master useReducer:</p>
                    <ol>
                        <li><strong>Kanban Board</strong> - Drag and drop tasks between columns</li>
                        <li><strong>Expense Tracker</strong> - Add, edit, delete expenses with categories</li>
                        <li><strong>Quiz App</strong> - Multiple questions, score tracking, timer</li>
                        <li><strong>Chat Application</strong> - Messages, users, typing indicators</li>
                        <li><strong>E-commerce Cart</strong> - Products, quantities, coupons, checkout</li>
                    </ol>
                </div>

                <h3>Common Questions</h3>
                
                <details>
                    <summary><strong>Q: Should I always use useReducer instead of useState?</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p><strong>A:</strong> No! useState is perfect for simple state. Use useReducer when state logic becomes complex, you have multiple related state values, or updates depend on previous state in non-trivial ways.</p>
                    </div>
                </details>

                <details>
                    <summary><strong>Q: Can I have multiple useReducer calls in one component?</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p><strong>A:</strong> Yes! You can use multiple useReducer hooks for different domains of state. For example, one for form data and another for UI state.</p>
                    </div>
                </details>

                <details>
                    <summary><strong>Q: How do I handle async operations with useReducer?</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p><strong>A:</strong> Async logic goes outside the reducer (in the component or custom hook). Dispatch actions before and after the async operation (FETCH_START, FETCH_SUCCESS, FETCH_ERROR).</p>
                    </div>
                </details>

                <details>
                    <summary><strong>Q: Is useReducer better for performance?</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p><strong>A:</strong> Not necessarily. The main benefit is the stable dispatch function, which is safe to pass to children and include in dependency arrays. For actual performance optimization, use React.memo, useMemo, and useCallback.</p>
                    </div>
                </details>

                <details>
                    <summary><strong>Q: Should I use Redux or useReducer?</strong></summary>
                    <div style="margin-top: 1rem;">
                        <p><strong>A:</strong> For component-level or small app state, useReducer is great. For large apps with complex global state, time-travel debugging needs, or extensive middleware requirements, Redux might be better. Many apps don't need Redux anymore thanks to useReducer + Context!</p>
                    </div>
                </details>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 2rem;">
                    <h2 style="color: white; margin-bottom: 1rem;">üéâ Congratulations! üéâ</h2>
                    <p style="color: white; font-size: 1.2rem;">
                        You've completed the useReducer lesson and gained a powerful tool for managing complex state. You can now build scalable React applications with confidence!
                    </p>
                    <p style="color: white; margin-top: 1.5rem;">
                        <strong>Keep practicing, keep building, and keep learning!</strong> üöÄ
                    </p>
                </div>
            </section>

        </main>
    </div>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson Navigation">
        <a href="module_project_4_weather_dashboard.html" class="nav-button prev-lesson">
            <span class="nav-arrow">‚Üê</span>
            <span class="nav-label">
                <small>Previous</small>
                <strong>Module 4 Project</strong>
            </span>
        </a>
        <a href="index.html" class="nav-button home-lesson">
            <span class="nav-icon">üè†</span>
            <span class="nav-label">
                <small>Back to</small>
                <strong>Home</strong>
            </span>
        </a>
        <a href="lesson_5_2_usecontext_hook.html" class="nav-button next-lesson">
            <span class="nav-label">
                <small>Next Lesson</small>
                <strong>useContext Hook</strong>
            </span>
            <span class="nav-arrow">‚Üí</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org" target="_blank">TypeScript Docs</a> |
                <a href="https://react.dev/reference/react/useReducer" target="_blank">useReducer Reference</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
