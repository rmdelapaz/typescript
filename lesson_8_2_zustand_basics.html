<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn Zustand, the lightweight and powerful state management library for React. Master creating stores, using selectors, middleware, TypeScript integration, and best practices for building scalable applications.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.2: Zustand Basics - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.2: Zustand Basics</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üêª Lesson 8.2: Zustand Basics</h1>
                <p class="lead">Welcome to hands-on state management with Zustand! If you found Redux overwhelming or Context API limiting, Zustand is the refreshing middle ground you've been looking for. With a tiny bundle size (~1KB), zero boilerplate, and incredible TypeScript support, Zustand has quickly become one of the most popular state management libraries in the React ecosystem. In this lesson, you'll learn everything you need to build production-ready applications with Zustand.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Install and set up Zustand in a React TypeScript project</li>
                        <li>Create type-safe stores with proper TypeScript interfaces</li>
                        <li>Use stores in components with optimal selector patterns</li>
                        <li>Implement actions and update state immutably</li>
                        <li>Understand and apply Zustand middleware (persist, devtools, immer)</li>
                        <li>Create computed/derived values efficiently</li>
                        <li>Organize stores in a scalable way</li>
                        <li>Debug Zustand state with Redux DevTools</li>
                        <li>Apply Zustand best practices for performance</li>
                        <li>Migrate from Context API or other state solutions to Zustand</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Prerequisites:</strong> Lesson 8.1 (State Management Overview), Modules 1-5</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What is Zustand?</a></li>
                        <li><a href="#section2" class="toc-link">Installation and Setup</a></li>
                        <li><a href="#section3" class="toc-link">Creating Your First Store</a></li>
                        <li><a href="#section4" class="toc-link">Using Stores in Components</a></li>
                        <li><a href="#section5" class="toc-link">TypeScript Integration</a></li>
                        <li><a href="#section6" class="toc-link">Selectors and Performance</a></li>
                        <li><a href="#section7" class="toc-link">Actions and State Updates</a></li>
                        <li><a href="#section8" class="toc-link">Middleware</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What is Zustand? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What is Zustand?</h2>
                
                <p>Zustand (German for "state") is a small, fast, and scalable state management solution for React. Created by Poimandres (the team behind React Three Fiber and other innovative React libraries), Zustand takes a minimalist approach to state management.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Zustand</strong> is a hook-based state management library that provides a simple API for creating global stores without the complexity of Redux or the performance issues of Context.</p>
                </div>

                <h3>Why Choose Zustand?</h3>

                <div class="mermaid">
                    graph TB
                    A[Why Zustand?] --> B[Simplicity]
                    A --> C[Performance]
                    A --> D[Size]
                    A --> E[DX]
                    
                    B --> B1[No boilerplate<br/>No providers<br/>Just hooks]
                    C --> C1[Fine-grained updates<br/>Only re-render what changed<br/>Fast by default]
                    D --> D1[~1KB gzipped<br/>Zero dependencies<br/>Tree-shakeable]
                    E --> E1[Great TypeScript<br/>Redux DevTools<br/>Easy to learn]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>Zustand vs Other Solutions</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Zustand</th>
                            <th>Context API</th>
                            <th>Redux Toolkit</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Bundle Size</strong></td>
                            <td>~1KB ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>0KB (built-in) ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>~20KB ‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>Boilerplate</strong></td>
                            <td>Minimal ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Low ‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Moderate ‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>Learning Curve</strong></td>
                            <td>Very easy ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Easy ‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Moderate ‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Excellent ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Can be slow ‚≠ê‚≠ê</td>
                            <td>Excellent ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>TypeScript</strong></td>
                            <td>First-class ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Good ‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>First-class ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>DevTools</strong></td>
                            <td>Redux DevTools ‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>None ‚≠ê</td>
                            <td>Redux DevTools ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                        </tr>
                        <tr>
                            <td><strong>Provider Needed</strong></td>
                            <td>No ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Yes ‚≠ê‚≠ê</td>
                            <td>Yes ‚≠ê‚≠ê</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use Zustand</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Perfect For</h4>
                    <ul>
                        <li><strong>Most applications:</strong> Medium to large React apps</li>
                        <li><strong>Replacing Context:</strong> When Context causes performance issues</li>
                        <li><strong>Simpler than Redux:</strong> When Redux feels like overkill</li>
                        <li><strong>Quick prototypes:</strong> When you need global state fast</li>
                        <li><strong>Client-side state:</strong> UI state, cart, user preferences, etc.</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Consider Alternatives When</h4>
                    <ul>
                        <li><strong>Very large enterprise apps:</strong> Redux Toolkit's structure might be better</li>
                        <li><strong>Time-travel debugging is critical:</strong> Redux has better DevTools</li>
                        <li><strong>Team is already familiar with Redux:</strong> Stick with what works</li>
                        <li><strong>You only have 2-3 global values:</strong> Context API might be sufficient</li>
                    </ul>
                </div>

                <h3>Core Philosophy</h3>

                <p>Zustand follows these principles:</p>

                <ol>
                    <li><strong>No providers:</strong> Stores are just hooks you can use anywhere</li>
                    <li><strong>No actions/reducers required:</strong> Direct function calls to update state</li>
                    <li><strong>Immutability is optional:</strong> Use immer middleware if you prefer mutations</li>
                    <li><strong>Fine-grained subscriptions:</strong> Components only re-render when their selected data changes</li>
                    <li><strong>Outside React:</strong> Stores can be read/updated outside components</li>
                </ol>

                <pre><code class="language-typescript">// This is valid Zustand - dead simple!
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));

function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);
  
  return &lt;button onClick={increment}&gt;{count}&lt;/button&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Magic of Zustand</h4>
                    <p>Notice what's NOT in the code above:</p>
                    <ul>
                        <li>‚ùå No Provider wrapper</li>
                        <li>‚ùå No action types or action creators</li>
                        <li>‚ùå No reducer functions</li>
                        <li>‚ùå No dispatch calls</li>
                        <li>‚ùå No connect or mapStateToProps</li>
                    </ul>
                    <p>Just a hook that returns state and functions. That's it!</p>
                </div>
            </section>

            <!-- Section 2: Installation and Setup -->
            <section id="section2" class="lesson-section">
                <h2>‚öôÔ∏è Installation and Setup</h2>
                
                <p>Getting started with Zustand is incredibly simple. Let's set up a new project and install Zustand.</p>

                <h3>Step 1: Create a React + TypeScript Project</h3>

                <p>If you don't have a project yet, create one with Vite:</p>

                <pre><code class="language-bash"># Create new project with Vite
npm create vite@latest my-zustand-app -- --template react-ts

# Navigate to project
cd my-zustand-app

# Install dependencies
npm install</code></pre>

                <h3>Step 2: Install Zustand</h3>

                <pre><code class="language-bash"># Install Zustand
npm install zustand

# That's it! No additional dependencies needed</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Installation Complete!</h4>
                    <p>Zustand has zero dependencies and works out of the box. No configuration files, no setup steps‚Äîyou're ready to create stores!</p>
                </div>

                <h3>Optional: Install DevTools</h3>

                <p>For debugging, you can use Redux DevTools browser extension:</p>

                <ol>
                    <li><strong>Install Redux DevTools Extension:</strong>
                        <ul>
                            <li><a href="https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd" target="_blank" rel="noopener noreferrer">Chrome</a></li>
                            <li><a href="https://addons.mozilla.org/en-US/firefox/addon/reduxdevtools/" target="_blank" rel="noopener noreferrer">Firefox</a></li>
                        </ul>
                    </li>
                    <li><strong>Enable in Zustand:</strong> Use the devtools middleware (we'll cover this later)</li>
                </ol>

                <h3>Project Structure</h3>

                <p>Here's a recommended folder structure for organizing Zustand stores:</p>

                <pre><code class="language-plaintext">src/
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îú‚îÄ‚îÄ useAuthStore.ts      # User authentication store
‚îÇ   ‚îú‚îÄ‚îÄ useCartStore.ts      # Shopping cart store
‚îÇ   ‚îú‚îÄ‚îÄ useUIStore.ts        # UI state (theme, sidebar, etc.)
‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # Re-export all stores
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ App.tsx
‚îî‚îÄ‚îÄ main.tsx</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Organization Tip</h4>
                    <p>Keep each store in its own file. This makes code easier to find, test, and maintain. The <code>index.ts</code> file can re-export everything for convenient imports:</p>
                    <pre><code class="language-typescript">// src/stores/index.ts
export { useAuthStore } from './useAuthStore';
export { useCartStore } from './useCartStore';
export { useUIStore } from './useUIStore';

// Now you can import like:
// import { useAuthStore, useCartStore } from '@/stores';</code></pre>
                </div>

                <h3>Verify Installation</h3>

                <p>Let's create a quick test to make sure everything works:</p>

                <pre><code class="language-typescript">// src/stores/useCounterStore.ts
import { create } from 'zustand';

interface CounterStore {
  count: number;
  increment: () => void;
}

export const useCounterStore = create&lt;CounterStore&gt;((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));</code></pre>

                <pre><code class="language-typescript">// src/App.tsx
import { useCounterStore } from './stores/useCounterStore';

function App() {
  const count = useCounterStore((state) => state.count);
  const increment = useCounterStore((state) => state.increment);

  return (
    &lt;div&gt;
      &lt;h1&gt;Count: {count}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}

export default App;</code></pre>

                <pre><code class="language-bash"># Run your app
npm run dev</code></pre>

                <p>If you see a counter that increments when you click the button, congratulations! Zustand is working perfectly.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéâ You're All Set!</h4>
                    <p style="color: white;">Zustand is installed and working. That's literally all the setup required‚Äîno providers, no configuration files, no boilerplate. Let's dive into creating real stores!</p>
                </div>
            </section>

            <!-- Section 3: Creating Your First Store -->
            <section id="section3" class="lesson-section">
                <h2>üèóÔ∏è Creating Your First Store</h2>
                
                <p>Let's learn how to create Zustand stores step by step, starting simple and building up to more complex patterns.</p>

                <h3>The Basics: A Simple Counter Store</h3>

                <p>The most basic Zustand store looks like this:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';

// Create a store
const useCounterStore = create((set) => ({
  // Initial state
  count: 0,
  
  // Actions
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));</code></pre>

                <p>Let's break down what's happening:</p>

                <ol>
                    <li><strong><code>create</code>:</strong> Function from Zustand that creates a store</li>
                    <li><strong>Store function:</strong> Receives <code>set</code> (and <code>get</code>) as arguments</li>
                    <li><strong><code>set</code>:</strong> Function to update state (like setState)</li>
                    <li><strong>Return object:</strong> Contains both state and actions</li>
                </ol>

                <h3>Anatomy of a Zustand Store</h3>

                <div class="mermaid">
                    graph LR
                    A[create Function] --> B[Store Creator]
                    B --> C[set Function]
                    B --> D[get Function]
                    C --> E[Update State]
                    D --> F[Read State]
                    E --> G[Store Object]
                    F --> G
                    G --> H[State Values]
                    G --> I[Action Functions]
                    
                    style A fill:#667eea,color:#fff
                    style G fill:#4CAF50,color:#fff
                </div>

                <h3>The <code>set</code> Function</h3>

                <p>The <code>set</code> function is how you update state. It has two forms:</p>

                <h4>1. Object Merge (Partial Update)</h4>

                <pre><code class="language-typescript">const useStore = create((set) => ({
  count: 0,
  name: 'Alice',
  
  // Only updates count, name stays the same
  increment: () => set({ count: 1 })
}));</code></pre>

                <p><strong>Note:</strong> Zustand automatically merges the object with existing state (shallow merge).</p>

                <h4>2. Function Form (Access Previous State)</h4>

                <pre><code class="language-typescript">const useStore = create((set) => ({
  count: 0,
  
  // Access previous state to compute new state
  increment: () => set((state) => ({ count: state.count + 1 }))
}));</code></pre>

                <p><strong>Use this form when:</strong> The new state depends on the old state.</p>

                <h3>The <code>get</code> Function</h3>

                <p>The <code>get</code> function lets you read the current state inside actions:</p>

                <pre><code class="language-typescript">const useStore = create((set, get) => ({
  count: 0,
  multiplier: 2,
  
  increment: () => set((state) => ({ count: state.count + 1 })),
  
  // Use get to read other state values
  incrementByMultiplier: () => {
    const { count, multiplier } = get();
    set({ count: count + multiplier });
  },
  
  // Or directly in computations
  doubleCount: () => {
    set({ count: get().count * 2 });
  }
}));</code></pre>

                <h3>Real-World Example: Todo Store</h3>

                <p>Let's create a more practical example:</p>

                <pre><code class="language-typescript">// src/stores/useTodoStore.ts
import { create } from 'zustand';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodoStore {
  todos: Todo[];
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  deleteTodo: (id: string) => void;
}

export const useTodoStore = create&lt;TodoStore&gt;((set) => ({
  todos: [],
  
  addTodo: (text) => set((state) => ({
    todos: [
      ...state.todos,
      {
        id: Date.now().toString(),
        text,
        completed: false
      }
    ]
  })),
  
  toggleTodo: (id) => set((state) => ({
    todos: state.todos.map(todo =>
      todo.id === id 
        ? { ...todo, completed: !todo.completed }
        : todo
    )
  })),
  
  deleteTodo: (id) => set((state) => ({
    todos: state.todos.filter(todo => todo.id !== id)
  }))
}));</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practices Shown</h4>
                    <ul>
                        <li><strong>TypeScript interface:</strong> Defines the store shape</li>
                        <li><strong>Immutable updates:</strong> Using spread operators and array methods</li>
                        <li><strong>Clear action names:</strong> Self-documenting function names</li>
                        <li><strong>Consistent patterns:</strong> All actions follow the same structure</li>
                    </ul>
                </div>

                <h3>Store with Complex State</h3>

                <p>Stores can contain nested objects, arrays, and multiple pieces of state:</p>

                <pre><code class="language-typescript">// src/stores/useShopStore.ts
import { create } from 'zustand';

interface Product {
  id: string;
  name: string;
  price: number;
}

interface CartItem extends Product {
  quantity: number;
}

interface ShopStore {
  products: Product[];
  cart: CartItem[];
  loading: boolean;
  error: string | null;
  
  setProducts: (products: Product[]) => void;
  addToCart: (product: Product) => void;
  removeFromCart: (productId: string) => void;
  updateQuantity: (productId: string, quantity: number) => void;
  clearCart: () => void;
}

export const useShopStore = create&lt;ShopStore&gt;((set, get) => ({
  products: [],
  cart: [],
  loading: false,
  error: null,
  
  setProducts: (products) => set({ products }),
  
  addToCart: (product) => set((state) => {
    const existingItem = state.cart.find(item => item.id === product.id);
    
    if (existingItem) {
      // Increment quantity if already in cart
      return {
        cart: state.cart.map(item =>
          item.id === product.id
            ? { ...item, quantity: item.quantity + 1 }
            : item
        )
      };
    } else {
      // Add new item
      return {
        cart: [...state.cart, { ...product, quantity: 1 }]
      };
    }
  }),
  
  removeFromCart: (productId) => set((state) => ({
    cart: state.cart.filter(item => item.id !== productId)
  })),
  
  updateQuantity: (productId, quantity) => set((state) => ({
    cart: state.cart.map(item =>
      item.id === productId
        ? { ...item, quantity }
        : item
    )
  })),
  
  clearCart: () => set({ cart: [] })
}));</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Notice the Patterns</h4>
                    <ul>
                        <li><strong>Conditional logic:</strong> Can check existing state before updating</li>
                        <li><strong>Multiple updates:</strong> Can update several pieces of state at once</li>
                        <li><strong>Immutable arrays:</strong> Using map, filter, spread to avoid mutations</li>
                        <li><strong>TypeScript safety:</strong> Full type checking on all operations</li>
                    </ul>
                </div>

                <h3>Common Store Patterns</h3>

                <h4>Loading and Error States</h4>

                <pre><code class="language-typescript">const useDataStore = create((set) => ({
  data: null,
  loading: false,
  error: null,
  
  fetchData: async () => {
    set({ loading: true, error: null });
    
    try {
      const response = await fetch('/api/data');
      const data = await response.json();
      set({ data, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  }
}));</code></pre>

                <h4>Reset Functionality</h4>

                <pre><code class="language-typescript">const initialState = {
  count: 0,
  name: ''
};

const useStore = create((set) => ({
  ...initialState,
  
  increment: () => set((state) => ({ count: state.count + 1 })),
  setName: (name: string) => set({ name }),
  
  // Reset to initial state
  reset: () => set(initialState)
}));</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't mutate state directly!</p>
                    <pre><code class="language-typescript">// ‚ùå BAD - Mutating state
addTodo: (text) => {
  const { todos } = get();
  todos.push({ id: Date.now().toString(), text, completed: false });
  set({ todos }); // Same reference, React won't re-render!
}

// ‚úÖ GOOD - Creating new array
addTodo: (text) => set((state) => ({
  todos: [...state.todos, { id: Date.now().toString(), text, completed: false }]
}));</code></pre>
                </div>
            </section>

            <!-- Section 4: Using Stores in Components -->
            <section id="section4" class="lesson-section">
                <h2>‚öõÔ∏è Using Stores in Components</h2>
                
                <p>Now that we know how to create stores, let's learn how to use them in React components.</p>

                <h3>Basic Usage</h3>

                <p>Using a Zustand store is as simple as calling a hook:</p>

                <pre><code class="language-typescript">import { useTodoStore } from '@/stores';

function TodoList() {
  // Get state and actions from the store
  const todos = useTodoStore((state) => state.todos);
  const toggleTodo = useTodoStore((state) => state.toggleTodo);
  const deleteTodo = useTodoStore((state) => state.deleteTodo);
  
  return (
    &lt;ul&gt;
      {todos.map(todo => (
        &lt;li key={todo.id}&gt;
          &lt;input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleTodo(todo.id)}
          /&gt;
          &lt;span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt;
            {todo.text}
          &lt;/span&gt;
          &lt;button onClick={() => deleteTodo(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>The Selector Pattern</h3>

                <p>The function you pass to the store hook is called a <strong>selector</strong>. It determines what part of the state the component subscribes to:</p>

                <pre><code class="language-typescript">// This component ONLY re-renders when todos array changes
const todos = useTodoStore((state) => state.todos);

// This component ONLY re-renders when toggleTodo function changes (never!)
const toggleTodo = useTodoStore((state) => state.toggleTodo);</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ The Power of Selectors</h4>
                    <p style="color: white;">Selectors are the key to Zustand's performance. Components only re-render when the specific data they select changes, not when ANY part of the store changes.</p>
                </div>

                <h3>Multiple Selectors</h3>

                <p>You can call the store hook multiple times in one component:</p>

                <pre><code class="language-typescript">function TodoStats() {
  const todos = useTodoStore((state) => state.todos);
  const totalCount = todos.length;
  const completedCount = todos.filter(t => t.completed).length;
  
  return (
    &lt;div&gt;
      &lt;p&gt;Total: {totalCount}&lt;/p&gt;
      &lt;p&gt;Completed: {completedCount}&lt;/p&gt;
      &lt;p&gt;Remaining: {totalCount - completedCount}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Selecting Multiple Values</h3>

                <p>When you need multiple values, you have options:</p>

                <h4>Option 1: Separate Selectors (Best Performance)</h4>

                <pre><code class="language-typescript">function UserProfile() {
  const name = useAuthStore((state) => state.user?.name);
  const email = useAuthStore((state) => state.user?.email);
  const avatar = useAuthStore((state) => state.user?.avatar);
  
  // Component only re-renders when name, email, or avatar changes
  return &lt;div&gt;{name} - {email}&lt;/div&gt;;
}</code></pre>

                <h4>Option 2: Object Selector (Good for Related Data)</h4>

                <pre><code class="language-typescript">function UserProfile() {
  const { name, email, avatar } = useAuthStore((state) => ({
    name: state.user?.name,
    email: state.user?.email,
    avatar: state.user?.avatar
  }));
  
  // Re-renders when ANY of these three values change
  return &lt;div&gt;{name} - {email}&lt;/div&gt;;
}</code></pre>

                <h4>Option 3: Entire Store (Use Sparingly)</h4>

                <pre><code class="language-typescript">// ‚ö†Ô∏è WARNING: Re-renders on ANY store change
function DebugPanel() {
  const store = useAuthStore(); // Gets entire store
  
  return &lt;pre&gt;{JSON.stringify(store, null, 2)}&lt;/pre&gt;;
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Performance Tip</h4>
                    <p>Generally, use separate selectors (Option 1) for best performance. Group related data in one selector (Option 2) only when those values truly change together.</p>
                </div>

                <h3>Using Actions</h3>

                <p>Actions are just functions in your store, so using them is straightforward:</p>

                <pre><code class="language-typescript">function AddTodoForm() {
  const [text, setText] = useState('');
  const addTodo = useTodoStore((state) => state.addTodo);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (text.trim()) {
      addTodo(text);
      setText('');
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input 
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="Add a todo..."
      /&gt;
      &lt;button type="submit"&gt;Add&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h3>Accessing Store Outside Components</h3>

                <p>Sometimes you need to read or update the store from outside a React component:</p>

                <pre><code class="language-typescript">// Access store state
const currentTodos = useTodoStore.getState().todos;

// Update store state
useTodoStore.getState().addTodo('New todo from outside React');

// Subscribe to changes
const unsubscribe = useTodoStore.subscribe((state) => {
  console.log('Todos changed:', state.todos);
});

// Later: clean up subscription
unsubscribe();</code></pre>

                <p><strong>Use cases:</strong></p>
                <ul>
                    <li>Event handlers outside components</li>
                    <li>WebSocket callbacks</li>
                    <li>Service workers</li>
                    <li>Testing</li>
                </ul>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip: Custom Selector Hooks</h4>
                    <p>Create custom hooks for commonly used selectors:</p>
                    <pre><code class="language-typescript">// In your store file
export const useTodos = () => useTodoStore((state) => state.todos);
export const useCompletedTodos = () => 
  useTodoStore((state) => state.todos.filter(t => t.completed));
export const useActiveTodos = () =>
  useTodoStore((state) => state.todos.filter(t => !t.completed));

// In components
function ActiveTodoList() {
  const activeTodos = useActiveTodos();
  return &lt;ul&gt;{/* ... */}&lt;/ul&gt;;
}</code></pre>
                </div>
            </section>
            <!-- Section 5: TypeScript Integration -->
            <section id="section5" class="lesson-section">
                <h2>üìò TypeScript Integration</h2>
                
                <p>One of Zustand's greatest strengths is its first-class TypeScript support. Let's explore how to build fully type-safe stores that catch errors at compile time and provide excellent IDE autocomplete.</p>

                <h3>Basic TypeScript Store Pattern</h3>

                <p>The recommended pattern uses an interface to define your store's shape:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';

// 1. Define the state interface
interface UserState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
  
  // Action types
  login: (email: string, password: string) => Promise&lt;void&gt;;
  logout: () => void;
  setUser: (user: User) => void;
}

// 2. Define data types
interface User {
  id: string;
  email: string;
  name: string;
  role: 'admin' | 'user' | 'guest';
}

// 3. Create the store with full typing
export const useUserStore = create&lt;UserState&gt;()((set, get) => ({
  // Initial state
  user: null,
  isLoading: false,
  error: null,
  
  // Actions with full type safety
  login: async (email, password) => {
    set({ isLoading: true, error: null });
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password })
      });
      
      if (!response.ok) throw new Error('Login failed');
      
      const user = await response.json();
      set({ user, isLoading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      });
    }
  },
  
  logout: () => {
    set({ user: null });
  },
  
  setUser: (user) => {
    set({ user });
  }
}));</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Separate State and Actions</h4>
                    <p>For better organization, you can separate your state and action types:</p>
                    <pre><code class="language-typescript">interface UserState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

interface UserActions {
  login: (email: string, password: string) => Promise&lt;void&gt;;
  logout: () => void;
  setUser: (user: User) => void;
}

type UserStore = UserState & UserActions;

export const useUserStore = create&lt;UserStore&gt;()((set, get) => ({
  // ... implementation
}));</code></pre>
                </div>

                <h3>Generic Type Helpers</h3>

                <p>Create reusable type helpers for common patterns:</p>

                <pre><code class="language-typescript">// Async state wrapper
interface AsyncState&lt;T&gt; {
  data: T | null;
  isLoading: boolean;
  error: string | null;
}

// Helper to create async state
function createAsyncState&lt;T&gt;(): AsyncState&lt;T&gt; {
  return {
    data: null,
    isLoading: false,
    error: null
  };
}

// Usage in store
interface ProductStore {
  products: AsyncState&lt;Product[]&gt;;
  selectedProduct: AsyncState&lt;Product&gt;;
  fetchProducts: () => Promise&lt;void&gt;;
  fetchProduct: (id: string) => Promise&lt;void&gt;;
}

export const useProductStore = create&lt;ProductStore&gt;()((set) => ({
  products: createAsyncState(),
  selectedProduct: createAsyncState(),
  
  fetchProducts: async () => {
    set({ products: { ...createAsyncState(), isLoading: true } });
    try {
      const response = await fetch('/api/products');
      const data = await response.json();
      set({ products: { data, isLoading: false, error: null } });
    } catch (error) {
      set({ 
        products: { 
          data: null, 
          isLoading: false, 
          error: error instanceof Error ? error.message : 'Failed to fetch' 
        } 
      });
    }
  },
  
  fetchProduct: async (id) => {
    set({ selectedProduct: { ...createAsyncState(), isLoading: true } });
    try {
      const response = await fetch(`/api/products/${id}`);
      const data = await response.json();
      set({ selectedProduct: { data, isLoading: false, error: null } });
    } catch (error) {
      set({ 
        selectedProduct: { 
          data: null, 
          isLoading: false, 
          error: error instanceof Error ? error.message : 'Failed to fetch' 
        } 
      });
    }
  }
}));</code></pre>

                <h3>Type-Safe Selectors</h3>

                <p>Ensure your selectors are fully typed:</p>

                <pre><code class="language-typescript">// ‚úÖ Typed selector
const user = useUserStore((state) => state.user);
// TypeScript knows: user is User | null

// ‚úÖ Typed action
const login = useUserStore((state) => state.login);
// TypeScript knows: login is (email: string, password: string) => Promise&lt;void&gt;

// ‚úÖ Computed value with proper typing
const isAdmin = useUserStore((state) => state.user?.role === 'admin');
// TypeScript knows: isAdmin is boolean

// ‚ùå This would be a TypeScript error:
const wrong = useUserStore((state) => state.nonexistent);
// Error: Property 'nonexistent' does not exist</code></pre>

                <h3>Immer Integration for Complex Updates</h3>

                <p>When working with nested objects, Immer middleware makes TypeScript updates much easier:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartStore {
  items: CartItem[];
  addItem: (item: Omit&lt;CartItem, 'quantity'&gt;) => void;
  updateQuantity: (id: string, quantity: number) => void;
  removeItem: (id: string) => void;
  clearCart: () => void;
}

export const useCartStore = create&lt;CartStore&gt;()(
  immer((set) => ({
    items: [],
    
    addItem: (item) => {
      set((state) => {
        // With Immer, we can "mutate" directly - it's actually immutable under the hood
        const existingItem = state.items.find(i => i.id === item.id);
        if (existingItem) {
          existingItem.quantity += 1;
        } else {
          state.items.push({ ...item, quantity: 1 });
        }
      });
    },
    
    updateQuantity: (id, quantity) => {
      set((state) => {
        const item = state.items.find(i => i.id === id);
        if (item) {
          item.quantity = quantity;
        }
      });
    },
    
    removeItem: (id) => {
      set((state) => {
        state.items = state.items.filter(i => i.id !== id);
      });
    },
    
    clearCart: () => {
      set((state) => {
        state.items = [];
      });
    }
  }))
);</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Immer</strong> is a library that lets you write "mutating" code that actually produces immutable updates. It's perfect for complex nested state in Zustand stores, making TypeScript updates much cleaner and less error-prone.</p>
                </div>

                <h3>Discriminated Unions for State Machines</h3>

                <p>Use TypeScript's discriminated unions to model complex state:</p>

                <pre><code class="language-typescript">// Define all possible states using discriminated union
type RequestState&lt;T&gt; =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: string };

interface DataStore&lt;T&gt; {
  state: RequestState&lt;T&gt;;
  fetch: () => Promise&lt;void&gt;;
  reset: () => void;
}

// Example: User profile store
export const useProfileStore = create&lt;DataStore&lt;UserProfile&gt;&gt;()((set) => ({
  state: { status: 'idle' },
  
  fetch: async () => {
    set({ state: { status: 'loading' } });
    
    try {
      const response = await fetch('/api/profile');
      const data = await response.json();
      set({ state: { status: 'success', data } });
    } catch (error) {
      set({ 
        state: { 
          status: 'error', 
          error: error instanceof Error ? error.message : 'Unknown error' 
        } 
      });
    }
  },
  
  reset: () => {
    set({ state: { status: 'idle' } });
  }
}));

// Usage in components with full type safety
function ProfileComponent() {
  const state = useProfileStore((state) => state.state);
  
  // TypeScript narrows the type based on status
  if (state.status === 'loading') {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  
  if (state.status === 'error') {
    return &lt;div&gt;Error: {state.error}&lt;/div&gt;; // TypeScript knows state.error exists
  }
  
  if (state.status === 'success') {
    return &lt;div&gt;{state.data.name}&lt;/div&gt;; // TypeScript knows state.data exists
  }
  
  return &lt;div&gt;Click to load profile&lt;/div&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Benefits of Discriminated Unions</h4>
                    <ul>
                        <li><strong>Type Safety:</strong> TypeScript ensures you handle all possible states</li>
                        <li><strong>No Impossible States:</strong> Can't have both loading and data at the same time</li>
                        <li><strong>Better Autocomplete:</strong> IDE knows exactly what properties are available</li>
                        <li><strong>Exhaustiveness Checking:</strong> TypeScript warns if you miss a case</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Selectors and Performance -->
            <section id="section6" class="lesson-section">
                <h2>‚ö° Selectors and Performance</h2>
                
                <p>Selectors are the key to performance in Zustand. Understanding how they work and when components re-render is crucial for building fast applications.</p>

                <h3>How Selectors Work</h3>

                <p>Zustand uses shallow equality comparison by default. A component re-renders when the selected value changes:</p>

                <div class="mermaid">
graph TD
    A[Component calls useStore selector] --> B{Has selected value changed?}
    B -->|Yes - Different reference| C[Component re-renders]
    B -->|No - Same reference| D[Component does not re-render]
    C --> E[Shallow comparison using Object.is]
    D --> E
    
    style A fill:#e3f2fd
    style C fill:#ffcdd2
    style D fill:#c8e6c9
</div>

                <!-- Interactive Selector Re-render Visualization -->
                <div class="card" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 1.5rem; font-weight: bold;">
                        ‚ö° Interactive: See Which Components Re-render
                    </div>
                    <div style="padding: 1.5rem;">
                        <p style="color: #b8c5d6; margin-bottom: 1rem; font-size: 0.95rem;">
                            Click the buttons below to update different parts of the store. Watch which components flash (re-render) vs stay static. This demonstrates why selective subscriptions are crucial for performance.
                        </p>
                        
                        <div id="rerender-demo" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem;">
                            <!-- Store State -->
                            <div style="background: #0d1b2a; border-radius: 8px; padding: 1rem;">
                                <h4 style="color: #667eea; margin: 0 0 1rem 0; font-size: 0.9rem;">üì¶ Store State</h4>
                                <div style="font-family: monospace; font-size: 0.85rem; color: #8892b0;">
                                    <div style="margin-bottom: 0.5rem;">count: <span id="store-count" style="color: #64ffda;">0</span></div>
                                    <div style="margin-bottom: 0.5rem;">name: <span id="store-name" style="color: #64ffda;">"Alice"</span></div>
                                    <div style="margin-bottom: 0.5rem;">theme: <span id="store-theme" style="color: #64ffda;">"light"</span></div>
                                </div>
                                
                                <div style="margin-top: 1rem; display: flex; flex-wrap: wrap; gap: 0.5rem;">
                                    <button onclick="updateStoreValue('count')" style="background: #667eea; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        ‚ûï Increment Count
                                    </button>
                                    <button onclick="updateStoreValue('name')" style="background: #764ba2; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        üîÑ Change Name
                                    </button>
                                    <button onclick="updateStoreValue('theme')" style="background: #f093fb; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                                        üé® Toggle Theme
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Components -->
                            <div style="background: #0d1b2a; border-radius: 8px; padding: 1rem;">
                                <h4 style="color: #667eea; margin: 0 0 1rem 0; font-size: 0.9rem;">‚öõÔ∏è Components</h4>
                                
                                <!-- Counter Component -->
                                <div id="comp-counter" style="background: #1a1a2e; border: 2px solid #2d3748; border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem; transition: all 0.3s ease;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: #b8c5d6; font-size: 0.85rem;">Counter</span>
                                        <code style="font-size: 0.7rem; color: #8892b0; background: #0d1b2a; padding: 0.2rem 0.5rem; border-radius: 3px;">state.count</code>
                                    </div>
                                    <div style="color: #64ffda; font-family: monospace; margin-top: 0.5rem;">Count: <span id="comp-counter-val">0</span></div>
                                </div>
                                
                                <!-- UserName Component -->
                                <div id="comp-username" style="background: #1a1a2e; border: 2px solid #2d3748; border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem; transition: all 0.3s ease;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: #b8c5d6; font-size: 0.85rem;">UserName</span>
                                        <code style="font-size: 0.7rem; color: #8892b0; background: #0d1b2a; padding: 0.2rem 0.5rem; border-radius: 3px;">state.name</code>
                                    </div>
                                    <div style="color: #f093fb; font-family: monospace; margin-top: 0.5rem;">Hello, <span id="comp-username-val">Alice</span>!</div>
                                </div>
                                
                                <!-- ThemeIndicator Component -->
                                <div id="comp-theme" style="background: #1a1a2e; border: 2px solid #2d3748; border-radius: 6px; padding: 0.75rem; margin-bottom: 0.75rem; transition: all 0.3s ease;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: #b8c5d6; font-size: 0.85rem;">ThemeIndicator</span>
                                        <code style="font-size: 0.7rem; color: #8892b0; background: #0d1b2a; padding: 0.2rem 0.5rem; border-radius: 3px;">state.theme</code>
                                    </div>
                                    <div style="color: #ffd93d; font-family: monospace; margin-top: 0.5rem;"><span id="comp-theme-val">‚òÄÔ∏è light</span></div>
                                </div>
                                
                                <!-- DebugPanel Component -->
                                <div id="comp-debug" style="background: #1a1a2e; border: 2px solid #ff6b6b; border-radius: 6px; padding: 0.75rem; transition: all 0.3s ease;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: #ff6b6b; font-size: 0.85rem;">‚ö†Ô∏è DebugPanel</span>
                                        <code style="font-size: 0.7rem; color: #ff6b6b; background: #0d1b2a; padding: 0.2rem 0.5rem; border-radius: 3px;">entire store</code>
                                    </div>
                                    <div style="color: #8892b0; font-family: monospace; margin-top: 0.5rem; font-size: 0.75rem;">{count, name, theme}</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Stats -->
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.75rem; margin-top: 1rem;">
                            <div style="background: #0d1b2a; border-radius: 6px; padding: 0.75rem; text-align: center;">
                                <div style="color: #64ffda; font-size: 1.5rem; font-weight: bold;" id="counter-renders">0</div>
                                <div style="color: #8892b0; font-size: 0.7rem;">Counter Renders</div>
                            </div>
                            <div style="background: #0d1b2a; border-radius: 6px; padding: 0.75rem; text-align: center;">
                                <div style="color: #f093fb; font-size: 1.5rem; font-weight: bold;" id="username-renders">0</div>
                                <div style="color: #8892b0; font-size: 0.7rem;">UserName Renders</div>
                            </div>
                            <div style="background: #0d1b2a; border-radius: 6px; padding: 0.75rem; text-align: center;">
                                <div style="color: #ffd93d; font-size: 1.5rem; font-weight: bold;" id="theme-renders">0</div>
                                <div style="color: #8892b0; font-size: 0.7rem;">Theme Renders</div>
                            </div>
                            <div style="background: #0d1b2a; border-radius: 6px; padding: 0.75rem; text-align: center;">
                                <div style="color: #ff6b6b; font-size: 1.5rem; font-weight: bold;" id="debug-renders">0</div>
                                <div style="color: #8892b0; font-size: 0.7rem;">Debug Renders</div>
                            </div>
                        </div>
                        
                        <div style="margin-top: 1rem; padding: 0.75rem; background: rgba(100, 255, 218, 0.1); border-radius: 6px; border-left: 3px solid #64ffda;">
                            <p style="color: #64ffda; margin: 0; font-size: 0.85rem;">
                                <strong>üí° Key Insight:</strong> Notice how DebugPanel (red border) re-renders on EVERY update because it selects the entire store, while other components only re-render when their specific data changes. This is why selective subscriptions are crucial!
                            </p>
                        </div>
                    </div>
                </div>
                
                <script>
                (function() {
                    // Demo store state
                    const store = {
                        count: 0,
                        name: 'Alice',
                        theme: 'light'
                    };
                    
                    const names = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve'];
                    let nameIndex = 0;
                    
                    // Render counts
                    const renders = {
                        counter: 0,
                        username: 0,
                        theme: 0,
                        debug: 0
                    };
                    
                    // Flash animation
                    function flashComponent(id) {
                        const el = document.getElementById(id);
                        if (el) {
                            el.style.borderColor = '#64ffda';
                            el.style.boxShadow = '0 0 15px rgba(100, 255, 218, 0.5)';
                            el.style.transform = 'scale(1.02)';
                            setTimeout(() => {
                                el.style.borderColor = id === 'comp-debug' ? '#ff6b6b' : '#2d3748';
                                el.style.boxShadow = 'none';
                                el.style.transform = 'scale(1)';
                            }, 300);
                        }
                    }
                    
                    // Update functions
                    window.updateStoreValue = function(key) {
                        if (key === 'count') {
                            store.count++;
                            document.getElementById('store-count').textContent = store.count;
                            document.getElementById('comp-counter-val').textContent = store.count;
                            
                            // Counter re-renders
                            renders.counter++;
                            document.getElementById('counter-renders').textContent = renders.counter;
                            flashComponent('comp-counter');
                        } else if (key === 'name') {
                            nameIndex = (nameIndex + 1) % names.length;
                            store.name = names[nameIndex];
                            document.getElementById('store-name').textContent = '"' + store.name + '"';
                            document.getElementById('comp-username-val').textContent = store.name;
                            
                            // UserName re-renders
                            renders.username++;
                            document.getElementById('username-renders').textContent = renders.username;
                            flashComponent('comp-username');
                        } else if (key === 'theme') {
                            store.theme = store.theme === 'light' ? 'dark' : 'light';
                            document.getElementById('store-theme').textContent = '"' + store.theme + '"';
                            document.getElementById('comp-theme-val').textContent = store.theme === 'light' ? '‚òÄÔ∏è light' : 'üåô dark';
                            
                            // ThemeIndicator re-renders
                            renders.theme++;
                            document.getElementById('theme-renders').textContent = renders.theme;
                            flashComponent('comp-theme');
                        }
                        
                        // DebugPanel ALWAYS re-renders (selects entire store)
                        renders.debug++;
                        document.getElementById('debug-renders').textContent = renders.debug;
                        flashComponent('comp-debug');
                    };
                })();
                </script>

                <pre><code class="language-typescript">// Example: Understanding re-renders
interface CounterStore {
  count: number;
  increment: () => void;
  reset: () => void;
}

const useCounterStore = create&lt;CounterStore&gt;()((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  reset: () => set({ count: 0 })
}));

// Component 1: Only re-renders when count changes
function Counter() {
  const count = useCounterStore((state) => state.count);
  console.log('Counter rendered');
  return &lt;div&gt;Count: {count}&lt;/div&gt;;
}

// Component 2: Never re-renders (increment function reference is stable)
function IncrementButton() {
  const increment = useCounterStore((state) => state.increment);
  console.log('IncrementButton rendered');
  return &lt;button onClick={increment}&gt;+1&lt;/button&gt;;
}

// Component 3: Re-renders on EVERY store change (gets entire store)
function DebugPanel() {
  const store = useCounterStore(); // ‚ö†Ô∏è Gets entire store
  console.log('DebugPanel rendered');
  return &lt;pre&gt;{JSON.stringify(store, null, 2)}&lt;/pre&gt;;
}</code></pre>

                <h3>Selector Best Practices</h3>

                <h4>1. Select Minimal Data</h4>

                <pre><code class="language-typescript">// ‚ùå Bad: Selects too much data
function UserProfile() {
  const { user, settings, preferences, notifications } = useAppStore();
  return &lt;div&gt;{user.name}&lt;/div&gt;; // Only needs user.name, but re-renders when anything changes
}

// ‚úÖ Good: Selects only what's needed
function UserProfile() {
  const userName = useAppStore((state) => state.user.name);
  return &lt;div&gt;{userName}&lt;/div&gt;; // Only re-renders when user.name changes
}</code></pre>

                <h4>2. Use Primitive Values When Possible</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Primitive value
const count = useCartStore((state) => state.items.length);

// ‚úÖ Good: Primitive value
const isLoggedIn = useAuthStore((state) => state.user !== null);

// ‚ö†Ô∏è Careful: Object (new reference each time)
const userInfo = useAuthStore((state) => ({
  name: state.user?.name,
  email: state.user?.email
})); // Creates new object on every render!</code></pre>

                <h4>3. Memoize Object Selectors</h4>

                <p>When you need to return objects from selectors, use Zustand's shallow equality helper:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { shallow } from 'zustand/shallow';

interface UserStore {
  firstName: string;
  lastName: string;
  email: string;
  setFirstName: (name: string) => void;
  setLastName: (name: string) => void;
}

const useUserStore = create&lt;UserStore&gt;()((set) => ({
  firstName: '',
  lastName: '',
  email: '',
  setFirstName: (firstName) => set({ firstName }),
  setLastName: (lastName) => set({ lastName })
}));

// ‚ùå Without shallow: Re-renders even when values haven't changed
function UserName() {
  const { firstName, lastName } = useUserStore((state) => ({
    firstName: state.firstName,
    lastName: state.lastName
  })); // New object every time!
  
  return &lt;div&gt;{firstName} {lastName}&lt;/div&gt;;
}

// ‚úÖ With shallow: Only re-renders when firstName or lastName actually change
function UserName() {
  const { firstName, lastName } = useUserStore(
    (state) => ({
      firstName: state.firstName,
      lastName: state.lastName
    }),
    shallow // Compare object properties, not object reference
  );
  
  return &lt;div&gt;{firstName} {lastName}&lt;/div&gt;;
}</code></pre>

                <h4>4. Create Custom Selector Hooks</h4>

                <p>Encapsulate commonly used selectors in custom hooks:</p>

                <pre><code class="language-typescript">// store.ts
interface TodoStore {
  todos: Todo[];
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  removeTodo: (id: string) => void;
}

export const useTodoStore = create&lt;TodoStore&gt;()(/* ... */);

// Custom selector hooks
export const useAllTodos = () => 
  useTodoStore((state) => state.todos);

export const useActiveTodos = () =>
  useTodoStore((state) => state.todos.filter(t => !t.completed));

export const useCompletedTodos = () =>
  useTodoStore((state) => state.todos.filter(t => t.completed));

export const useTodoCount = () =>
  useTodoStore((state) => ({
    total: state.todos.length,
    active: state.todos.filter(t => !t.completed).length,
    completed: state.todos.filter(t => t.completed).length
  }), shallow);

// Usage in components - clean and simple!
function TodoList() {
  const todos = useAllTodos(); // Clear, reusable
  return &lt;ul&gt;{todos.map(t => &lt;TodoItem key={t.id} todo={t} /&gt;)}&lt;/ul&gt;;
}

function TodoStats() {
  const { total, active, completed } = useTodoCount();
  return (
    &lt;div&gt;
      Total: {total} | Active: {active} | Completed: {completed}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Custom Selector Hooks</h4>
                    <ul>
                        <li><strong>Reusability:</strong> Use the same selector in multiple components</li>
                        <li><strong>Consistency:</strong> Same logic everywhere</li>
                        <li><strong>Maintainability:</strong> Change selector logic in one place</li>
                        <li><strong>Testability:</strong> Easy to test selectors independently</li>
                        <li><strong>Readability:</strong> Clear intent in component code</li>
                    </ul>
                </div>

                <h3>Computing Derived Values</h3>

                <p>Derived values should be computed in selectors, not in the store:</p>

                <pre><code class="language-typescript">interface ShoppingCartStore {
  items: CartItem[];
  discount: number; // percentage
  taxRate: number; // percentage
  
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
  updateQuantity: (id: string, quantity: number) => void;
}

const useCartStore = create&lt;ShoppingCartStore&gt;()(/* ... */);

// ‚úÖ Compute derived values in selectors
export const useCartTotals = () => 
  useCartStore((state) => {
    const subtotal = state.items.reduce(
      (sum, item) => sum + item.price * item.quantity, 
      0
    );
    const discountAmount = subtotal * (state.discount / 100);
    const afterDiscount = subtotal - discountAmount;
    const tax = afterDiscount * (state.taxRate / 100);
    const total = afterDiscount + tax;
    
    return { subtotal, discountAmount, tax, total };
  }, shallow);

// Usage
function CartSummary() {
  const { subtotal, discountAmount, tax, total } = useCartTotals();
  
  return (
    &lt;div&gt;
      &lt;p&gt;Subtotal: ${subtotal.toFixed(2)}&lt;/p&gt;
      &lt;p&gt;Discount: -${discountAmount.toFixed(2)}&lt;/p&gt;
      &lt;p&gt;Tax: ${tax.toFixed(2)}&lt;/p&gt;
      &lt;p&gt;&lt;strong&gt;Total: ${total.toFixed(2)}&lt;/strong&gt;&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Performance Warning</h4>
                    <p>Complex calculations in selectors run on every render. For expensive computations, consider:</p>
                    <ol>
                        <li><strong>Store computed values:</strong> Calculate once, store in state</li>
                        <li><strong>Use useMemo:</strong> Cache results in the component</li>
                        <li><strong>Debounce updates:</strong> Reduce calculation frequency</li>
                    </ol>
                    <pre><code class="language-typescript">// Example: Cache expensive computation
function ExpensiveComponent() {
  const data = useDataStore((state) => state.largeDataset);
  
  const processedData = useMemo(() => {
    // Expensive processing only when data changes
    return data.map(/* complex transformation */);
  }, [data]);
  
  return &lt;div&gt;{/* use processedData */}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Testing Selectors</h3>

                <p>Custom selector hooks make testing much easier:</p>

                <pre><code class="language-typescript">// __tests__/store.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCartStore, useCartTotals } from './store';

describe('Cart Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useCartStore.setState({ items: [], discount: 0, taxRate: 8 });
  });
  
  it('calculates totals correctly', () => {
    const { result } = renderHook(() => useCartTotals());
    
    // Initially empty
    expect(result.current.total).toBe(0);
    
    // Add items
    act(() => {
      useCartStore.getState().addItem({
        id: '1',
        name: 'Widget',
        price: 100,
        quantity: 2
      });
    });
    
    // Check calculations
    expect(result.current.subtotal).toBe(200);
    expect(result.current.tax).toBe(16); // 8% of 200
    expect(result.current.total).toBe(216);
  });
});</code></pre>
            </section>

            <!-- Section 7: Actions and State Updates -->
            <section id="section7" class="lesson-section">
                <h2>üé¨ Actions and State Updates</h2>
                
                <p>Actions are functions in your store that update state. Let's explore patterns for creating clean, maintainable actions.</p>

                <h3>Basic Actions</h3>

                <p>Actions use the <code>set</code> function to update state:</p>

                <pre><code class="language-typescript">interface CounterStore {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
  setCount: (count: number) => void;
}

const useCounterStore = create&lt;CounterStore&gt;()((set) => ({
  count: 0,
  
  // Simple state replacement
  increment: () => set((state) => ({ count: state.count + 1 })),
  
  decrement: () => set((state) => ({ count: state.count - 1 })),
  
  // Reset to initial value
  reset: () => set({ count: 0 }),
  
  // Set to specific value
  setCount: (count) => set({ count })
}));</code></pre>

                <h3>The <code>set</code> Function</h3>

                <p>Zustand's <code>set</code> function has two forms:</p>

                <pre><code class="language-typescript">// Form 1: Partial state object (merged with existing state)
set({ count: 5 });

// Form 2: Updater function (receives current state)
set((state) => ({ count: state.count + 1 }));

// With replace flag (replaces entire state, not just merge)
set({ count: 0 }, true); // ‚ö†Ô∏è Removes all other properties!</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Merge vs Replace</h4>
                    <p>By default, <code>set</code> merges the new state with the existing state. The second parameter (true) replaces the entire state:</p>
                    <pre><code class="language-typescript">// Merge (default)
set({ count: 5 }); // Keeps all other properties, updates only count

// Replace
set({ count: 5 }, true); // Removes all other properties! Usually not what you want</code></pre>
                </div>

                <h3>The <code>get</code> Function</h3>

                <p>The <code>get</code> function lets you read current state within actions:</p>

                <pre><code class="language-typescript">interface TodoStore {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
  
  addTodo: (text: string) => void;
  toggleAllTodos: () => void;
}

const useTodoStore = create&lt;TodoStore&gt;()((set, get) => ({
  todos: [],
  filter: 'all',
  
  addTodo: (text) => {
    const currentTodos = get().todos; // Read current state
    const newTodo: Todo = {
      id: Date.now().toString(),
      text,
      completed: false
    };
    set({ todos: [...currentTodos, newTodo] });
  },
  
  toggleAllTodos: () => {
    const currentTodos = get().todos;
    const allCompleted = currentTodos.every(t => t.completed);
    
    set({
      todos: currentTodos.map(todo => ({
        ...todo,
        completed: !allCompleted
      }))
    });
  }
}));</code></pre>

                <h3>Async Actions</h3>

                <p>Async actions work seamlessly in Zustand:</p>

                <pre><code class="language-typescript">interface UserStore {
  users: User[];
  isLoading: boolean;
  error: string | null;
  
  fetchUsers: () => Promise&lt;void&gt;;
  createUser: (userData: Omit&lt;User, 'id'&gt;) => Promise&lt;User&gt;;
  updateUser: (id: string, updates: Partial&lt;User&gt;) => Promise&lt;void&gt;;
  deleteUser: (id: string) => Promise&lt;void&gt;;
}

const useUserStore = create&lt;UserStore&gt;()((set, get) => ({
  users: [],
  isLoading: false,
  error: null,
  
  fetchUsers: async () => {
    set({ isLoading: true, error: null });
    
    try {
      const response = await fetch('/api/users');
      if (!response.ok) throw new Error('Failed to fetch users');
      
      const users = await response.json();
      set({ users, isLoading: false });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      });
    }
  },
  
  createUser: async (userData) => {
    set({ isLoading: true, error: null });
    
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      });
      
      if (!response.ok) throw new Error('Failed to create user');
      
      const newUser = await response.json();
      const currentUsers = get().users;
      
      set({ 
        users: [...currentUsers, newUser],
        isLoading: false 
      });
      
      return newUser;
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      });
      throw error;
    }
  },
  
  updateUser: async (id, updates) => {
    set({ isLoading: true, error: null });
    
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      });
      
      if (!response.ok) throw new Error('Failed to update user');
      
      const updatedUser = await response.json();
      const currentUsers = get().users;
      
      set({
        users: currentUsers.map(user => 
          user.id === id ? updatedUser : user
        ),
        isLoading: false
      });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      });
      throw error;
    }
  },
  
  deleteUser: async (id) => {
    set({ isLoading: true, error: null });
    
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE'
      });
      
      if (!response.ok) throw new Error('Failed to delete user');
      
      const currentUsers = get().users;
      set({
        users: currentUsers.filter(user => user.id !== id),
        isLoading: false
      });
    } catch (error) {
      set({ 
        error: error instanceof Error ? error.message : 'Unknown error',
        isLoading: false 
      });
      throw error;
    }
  }
}));</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Async Action Best Practices</h4>
                    <ol>
                        <li><strong>Set loading state:</strong> Before starting async operation</li>
                        <li><strong>Handle errors:</strong> Use try-catch and store errors in state</li>
                        <li><strong>Clear errors:</strong> Reset error state before new attempts</li>
                        <li><strong>Return values:</strong> Return data from actions when needed</li>
                        <li><strong>Throw on error:</strong> Let components handle errors if needed</li>
                    </ol>
                </div>

                <h3>Optimistic Updates</h3>

                <p>Update UI immediately, roll back if the server request fails:</p>

                <pre><code class="language-typescript">interface TodoStore {
  todos: Todo[];
  toggleTodo: (id: string) => Promise&lt;void&gt;;
}

const useTodoStore = create&lt;TodoStore&gt;()((set, get) => ({
  todos: [],
  
  toggleTodo: async (id) => {
    // Save current state for rollback
    const previousTodos = get().todos;
    
    // Optimistic update - update UI immediately
    set({
      todos: previousTodos.map(todo =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      )
    });
    
    try {
      // Send to server
      const response = await fetch(`/api/todos/${id}/toggle`, {
        method: 'PATCH'
      });
      
      if (!response.ok) throw new Error('Failed to toggle todo');
      
      // Server confirmed - we're good!
    } catch (error) {
      // Rollback on error
      set({ todos: previousTodos });
      
      // Show error to user
      console.error('Failed to toggle todo:', error);
      // Could also set an error state here
    }
  }
}));</code></pre>

                <h3>Batching Updates</h3>

                <p>Multiple <code>set</code> calls are automatically batched in React 18+:</p>

                <pre><code class="language-typescript">const useAppStore = create&lt;AppStore&gt;()((set) => ({
  // ...
  
  initialize: async () => {
    // These updates are batched - only one render
    set({ isLoading: true });
    set({ error: null });
    set({ initialized: false });
    
    try {
      const [users, settings, notifications] = await Promise.all([
        fetch('/api/users').then(r => r.json()),
        fetch('/api/settings').then(r => r.json()),
        fetch('/api/notifications').then(r => r.json())
      ]);
      
      // These are also batched
      set({ users });
      set({ settings });
      set({ notifications });
      set({ isLoading: false });
      set({ initialized: true });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  }
}));</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Manual Batching</h4>
                    <p>You can also combine updates into a single <code>set</code> call:</p>
                    <pre><code class="language-typescript">// Instead of multiple set calls:
set({ isLoading: true });
set({ error: null });
set({ data: newData });

// Combine into one:
set({ 
  isLoading: true, 
  error: null, 
  data: newData 
});</code></pre>
                </div>

                <h3>Immutable Updates with Immer</h3>

                <p>For deeply nested state, Immer middleware makes updates much cleaner:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface NestedStore {
  user: {
    profile: {
      name: string;
      email: string;
      settings: {
        theme: string;
        notifications: {
          email: boolean;
          push: boolean;
          sms: boolean;
        };
      };
    };
  };
  updateEmailNotifications: (enabled: boolean) => void;
}

// Without Immer - complex and error-prone
const useStoreWithoutImmer = create&lt;NestedStore&gt;()((set) => ({
  user: { /* ... */ },
  
  updateEmailNotifications: (enabled) => {
    set((state) => ({
      user: {
        ...state.user,
        profile: {
          ...state.user.profile,
          settings: {
            ...state.user.profile.settings,
            notifications: {
              ...state.user.profile.settings.notifications,
              email: enabled
            }
          }
        }
      }
    }));
  }
}));

// With Immer - simple and clear
const useStoreWithImmer = create&lt;NestedStore&gt;()(
  immer((set) => ({
    user: { /* ... */ },
    
    updateEmailNotifications: (enabled) => {
      set((state) => {
        // "Mutate" directly - Immer makes it immutable
        state.user.profile.settings.notifications.email = enabled;
      });
    }
  }))
);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Immer</h4>
                    <ul>
                        <li>Deeply nested state structures</li>
                        <li>Complex array manipulations</li>
                        <li>Frequent updates to nested objects</li>
                        <li>When readability is more important than the tiny performance cost</li>
                    </ul>
                    <p><strong>Note:</strong> Immer adds ~16KB to your bundle, so use it only when beneficial.</p>
                </div>
            </section>

            <!-- Section 8: Middleware (Beginning) -->
            <section id="section8" class="lesson-section">
                <h2>üîå Middleware</h2>
                
                <p>Middleware extends Zustand's functionality. Think of middleware as plugins that wrap your store to add features like persistence, logging, or Redux DevTools integration.</p>

                <div class="mermaid">
graph LR
    A[Component] --> B[Middleware Layer]
    B --> C[Store]
    C --> D[State]
    
    B --> E[Persist Middleware]
    B --> F[DevTools Middleware]
    B --> G[Immer Middleware]
    
    style A fill:#e3f2fd
    style B fill:#fff3cd
    style C fill:#c8e6c9
    style D fill:#f0f0f0
</div>

                <h3>Persist Middleware</h3>

                <p>The persist middleware saves your store to localStorage (or other storage) automatically:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface SettingsStore {
  theme: 'light' | 'dark';
  language: string;
  fontSize: number;
  
  setTheme: (theme: 'light' | 'dark') => void;
  setLanguage: (language: string) => void;
  setFontSize: (fontSize: number) => void;
}

export const useSettingsStore = create&lt;SettingsStore&gt;()(
  persist(
    (set) => ({
      // Initial state
      theme: 'light',
      language: 'en',
      fontSize: 16,
      
      // Actions
      setTheme: (theme) => set({ theme }),
      setLanguage: (language) => set({ language }),
      setFontSize: (fontSize) => set({ fontSize })
    }),
    {
      name: 'app-settings', // Storage key
      storage: createJSONStorage(() => localStorage), // Default
    }
  )
);</code></pre>

                <p>Now the settings automatically save to localStorage and restore on page reload!</p>

                <h4>Persist Configuration Options</h4>

                <pre><code class="language-typescript">persist(
  (set, get) => ({ /* store */ }),
  {
    name: 'my-store', // Required: localStorage key
    
    storage: createJSONStorage(() => localStorage), // Storage engine
    
    // Partial persistence - only save specific fields
    partialize: (state) => ({ 
      theme: state.theme, 
      language: state.language 
      // fontSize is NOT persisted
    }),
    
    // Version your storage for migrations
    version: 1,
    
    // Migrate data when version changes
    migrate: (persistedState: any, version: number) => {
      if (version === 0) {
        // Upgrade from version 0 to 1
        return {
          ...persistedState,
          newField: 'default value'
        };
      }
      return persistedState;
    },
    
    // Skip hydration on mount (useful for SSR)
    skipHydration: false,
    
    // Merge strategy
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    })
  }
)</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Alternative Storage Engines</h4>
                    <p>You can use different storage backends:</p>
                    <pre><code class="language-typescript">// SessionStorage
storage: createJSONStorage(() => sessionStorage)

// AsyncStorage (React Native)
import AsyncStorage from '@react-native-async-storage/async-storage';
storage: createJSONStorage(() => AsyncStorage)

// IndexedDB (using idb-keyval)
import { get, set, del } from 'idb-keyval';
storage: {
  getItem: async (name: string): Promise&lt;string | null&gt; => {
    return (await get(name)) || null;
  },
  setItem: async (name: string, value: string): Promise&lt;void&gt; => {
    await set(name, value);
  },
  removeItem: async (name: string): Promise&lt;void&gt; => {
    await del(name);
  },
}</code></pre>
                </div>

                <h4>Manual Hydration Control</h4>

                <p>Sometimes you need to control when the persisted state is loaded:</p>

                <pre><code class="language-typescript">export const useSettingsStore = create&lt;SettingsStore&gt;()(
  persist(
    (set) => ({ /* ... */ }),
    {
      name: 'app-settings',
      skipHydration: true, // Don't auto-load on creation
    }
  )
);

// Later, in your app initialization:
function App() {
  useEffect(() => {
    // Manually trigger hydration when ready
    useSettingsStore.persist.rehydrate();
  }, []);
  
  return &lt;div&gt;{/* app */}&lt;/div&gt;;
}</code></pre>

                <h3>DevTools Middleware</h3>

                <p>Integrate with Redux DevTools for debugging:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

interface CounterStore {
  count: number;
  increment: () => void;
  decrement: () => void;
}

export const useCounterStore = create&lt;CounterStore&gt;()(
  devtools(
    (set) => ({
      count: 0,
      
      // Action names will appear in DevTools
      increment: () => set(
        (state) => ({ count: state.count + 1 }),
        false,
        'counter/increment' // Action name for DevTools
      ),
      
      decrement: () => set(
        (state) => ({ count: state.count - 1 }),
        false,
        'counter/decrement'
      )
    }),
    { name: 'CounterStore' } // Store name in DevTools
  )
);</code></pre>

                <p>Install the Redux DevTools browser extension to see your Zustand state and actions!</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è DevTools in Production</h4>
                    <p>DevTools middleware should typically be disabled in production:</p>
                    <pre><code class="language-typescript">const middleware = process.env.NODE_ENV === 'development' 
  ? devtools 
  : (f: any) => f;

export const useStore = create&lt;Store&gt;()(
  middleware(
    (set) => ({ /* ... */ }),
    { name: 'MyStore' }
  )
);</code></pre>
                </div>
<h3>Immer Middleware</h3>

                <p>We've seen Immer in action already, but let's dive deeper into its capabilities:</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { immer } from 'zustand/middleware/immer';

interface ComplexStore {
  users: User[];
  posts: Post[];
  comments: { [postId: string]: Comment[] };
  
  addUser: (user: User) => void;
  updateUser: (id: string, updates: Partial&lt;User&gt;) => void;
  addPost: (post: Post) => void;
  addComment: (postId: string, comment: Comment) => void;
  likePost: (postId: string) => void;
}

export const useComplexStore = create&lt;ComplexStore&gt;()(
  immer((set) => ({
    users: [],
    posts: [],
    comments: {},
    
    addUser: (user) => {
      set((state) => {
        state.users.push(user);
      });
    },
    
    updateUser: (id, updates) => {
      set((state) => {
        const user = state.users.find(u => u.id === id);
        if (user) {
          Object.assign(user, updates);
        }
      });
    },
    
    addPost: (post) => {
      set((state) => {
        state.posts.push(post);
        state.comments[post.id] = []; // Initialize comments array
      });
    },
    
    addComment: (postId, comment) => {
      set((state) => {
        if (!state.comments[postId]) {
          state.comments[postId] = [];
        }
        state.comments[postId].push(comment);
      });
    },
    
    likePost: (postId) => {
      set((state) => {
        const post = state.posts.find(p => p.id === postId);
        if (post) {
          post.likes = (post.likes || 0) + 1;
        }
      });
    }
  }))
);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Immer Benefits</h4>
                    <ul>
                        <li><strong>Readability:</strong> Code looks like simple mutations</li>
                        <li><strong>Less Boilerplate:</strong> No spread operators everywhere</li>
                        <li><strong>Fewer Bugs:</strong> Easier to write correct updates</li>
                        <li><strong>Array Methods:</strong> Use push, splice, etc. directly</li>
                        <li><strong>Nested Updates:</strong> Update deep properties easily</li>
                    </ul>
                </div>

                <h3>Combining Multiple Middleware</h3>

                <p>You can compose multiple middleware together. Order matters!</p>

                <pre><code class="language-typescript">import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { devtools } from 'zustand/middleware';

interface TodoStore {
  todos: Todo[];
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  removeTodo: (id: string) => void;
}

// Middleware composition: immer -> devtools -> persist
// Order: innermost to outermost
export const useTodoStore = create&lt;TodoStore&gt;()(
  persist(
    devtools(
      immer((set) => ({
        todos: [],
        
        addTodo: (text) => {
          set((state) => {
            state.todos.push({
              id: Date.now().toString(),
              text,
              completed: false
            });
          });
        },
        
        toggleTodo: (id) => {
          set((state) => {
            const todo = state.todos.find(t => t.id === id);
            if (todo) {
              todo.completed = !todo.completed;
            }
          });
        },
        
        removeTodo: (id) => {
          set((state) => {
            state.todos = state.todos.filter(t => t.id !== id);
          });
        }
      })),
      { name: 'TodoStore' }
    ),
    { name: 'todos-storage' }
  )
);</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Middleware Order Guide</h4>
                    <p>Recommended order (innermost to outermost):</p>
                    <ol>
                        <li><strong>Immer:</strong> Closest to your store logic</li>
                        <li><strong>DevTools:</strong> Wraps Immer, sees "clean" actions</li>
                        <li><strong>Persist:</strong> Outermost, handles storage</li>
                    </ol>
                    <pre><code class="language-typescript">create(
  persist(      // 3. Outermost - saves to storage
    devtools(   // 2. Middle - logs to DevTools
      immer(    // 1. Innermost - simplifies updates
        (set) => ({ /* your store */ })
      )
    )
  )
)</code></pre>
                </div>

                <h3>Creating Custom Middleware</h3>

                <p>You can create your own middleware to extend Zustand:</p>

                <pre><code class="language-typescript">import { StateCreator, StoreMutatorIdentifier } from 'zustand';

// Example: Logger middleware that logs all state changes
type Logger = &lt;
  T,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = []
&gt;(
  f: StateCreator&lt;T, Mps, Mcs&gt;,
  name?: string
) => StateCreator&lt;T, Mps, Mcs&gt;;

const logger: Logger = (f, name) => (set, get, store) => {
  const loggedSet: typeof set = (...args) => {
    console.log(`[${name || 'store'}] Setting state:`, args[0]);
    set(...args);
    console.log(`[${name || 'store'}] New state:`, get());
  };
  
  return f(loggedSet, get, store);
};

// Usage
interface CounterStore {
  count: number;
  increment: () => void;
}

export const useCounterStore = create&lt;CounterStore&gt;()(
  logger(
    (set) => ({
      count: 0,
      increment: () => set((state) => ({ count: state.count + 1 }))
    }),
    'CounterStore'
  )
);</code></pre>

                <h4>Example: Reset Middleware</h4>

                <p>Middleware that adds a <code>reset</code> function to any store:</p>

                <pre><code class="language-typescript">import { StateCreator } from 'zustand';

// Middleware that adds reset functionality
const resetters: (() => void)[] = [];

export const resetAllStores = () => {
  resetters.forEach((resetter) => resetter());
};

type Resettable&lt;T&gt; = T & { reset: () => void };

export const resettable = &lt;T extends object&gt;(
  config: StateCreator&lt;T&gt;
): StateCreator&lt;Resettable&lt;T&gt;&gt; => {
  return (set, get, api) => {
    const initialState = config(set, get, api);
    
    resetters.push(() => {
      set(initialState, true); // Replace entire state
    });
    
    return {
      ...initialState,
      reset: () => {
        set(initialState, true);
      }
    };
  };
};

// Usage
interface UserStore {
  name: string;
  email: string;
  setName: (name: string) => void;
  setEmail: (email: string) => void;
}

export const useUserStore = create&lt;UserStore&gt;()(
  resettable((set) => ({
    name: '',
    email: '',
    setName: (name) => set({ name }),
    setEmail: (email) => set({ email })
  }))
);

// Now you can reset the store
function UserProfile() {
  const { name, email, reset } = useUserStore();
  
  return (
    &lt;div&gt;
      &lt;p&gt;{name} - {email}&lt;/p&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// Or reset all stores at once
resetAllStores();</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Middleware Complexity</h4>
                    <p>Creating custom middleware requires understanding Zustand's TypeScript types. Start with the built-in middleware and only create custom middleware when you have a clear, reusable pattern that appears across multiple stores.</p>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                
                <p>Let's consolidate everything we've learned into actionable best practices for using Zustand effectively.</p>

                <h3>Store Organization</h3>

                <h4>1. One Store Per Domain</h4>

                <p>Organize stores by feature/domain, not by data type:</p>

                <pre><code class="language-typescript">// ‚úÖ Good: Domain-based stores
// stores/auth.ts
export const useAuthStore = create&lt;AuthStore&gt;()(/* auth logic */);

// stores/cart.ts
export const useCartStore = create&lt;CartStore&gt;()(/* cart logic */);

// stores/products.ts
export const useProductStore = create&lt;ProductStore&gt;()(/* product logic */);

// ‚ùå Bad: Generic data stores
export const useDataStore = create&lt;DataStore&gt;()((set) => ({
  users: [],
  products: [],
  orders: [],
  // Everything mixed together
}));</code></pre>

                <h4>2. Colocate Related State</h4>

                <p>Keep related state together in the same store:</p>

                <pre><code class="language-typescript">// ‚úÖ Good: Related state together
interface TodoStore {
  todos: Todo[];
  filter: 'all' | 'active' | 'completed';
  searchQuery: string;
  
  // Actions that work with this related state
  addTodo: (text: string) => void;
  setFilter: (filter: 'all' | 'active' | 'completed') => void;
  setSearchQuery: (query: string) => void;
}

// ‚ùå Bad: Related state split across stores
const useTodoStore = create&lt;TodoState&gt;()(/* todos */);
const useFilterStore = create&lt;FilterState&gt;()(/* filter */);
const useSearchStore = create&lt;SearchState&gt;()(/* search */);</code></pre>

                <h4>3. File Structure</h4>

                <pre><code class="language-typescript">src/
  stores/
    auth.ts           // Auth store
    cart.ts           // Shopping cart store
    products.ts       // Product catalog store
    ui.ts             // UI state (modals, theme, etc.)
    types.ts          // Shared types
    index.ts          // Re-export all stores
  
  hooks/
    useAuthGuard.ts   // Custom hooks using stores
    useCartTotals.ts
  
  components/
    auth/
      LoginForm.tsx   // Uses useAuthStore
    cart/
      CartSummary.tsx // Uses useCartStore</code></pre>

                <h3>Performance Optimization</h3>

                <h4>1. Selector Patterns</h4>

                <pre><code class="language-typescript">// ‚úÖ Best: Primitive values
const count = useCartStore((state) => state.items.length);

// ‚úÖ Good: Multiple primitives with shallow
const { firstName, lastName } = useUserStore(
  (state) => ({ firstName: state.firstName, lastName: state.lastName }),
  shallow
);

// ‚ö†Ô∏è Careful: Derived objects (use useMemo in component)
const stats = useCartStore((state) => ({
  total: state.items.reduce((sum, item) => sum + item.price, 0),
  count: state.items.length
}), shallow);

// ‚ùå Bad: Entire store
const store = useCartStore(); // Re-renders on ANY change!</code></pre>

                <h4>2. Memoize Expensive Selectors</h4>

                <pre><code class="language-typescript">import { useMemo } from 'react';

function ProductList() {
  const products = useProductStore((state) => state.products);
  const filters = useProductStore((state) => state.filters);
  
  // Memoize expensive filtering
  const filteredProducts = useMemo(() => {
    return products.filter(product => {
      // Complex filtering logic
      return (
        product.category === filters.category &&
        product.price >= filters.minPrice &&
        product.price <= filters.maxPrice
      );
    }).sort((a, b) => {
      // Complex sorting logic
      return a.price - b.price;
    });
  }, [products, filters]);
  
  return &lt;div&gt;{/* render filteredProducts */}&lt;/div&gt;;
}</code></pre>

                <h4>3. Split Large Components</h4>

                <pre><code class="language-typescript">// ‚ùå Bad: One component subscribes to everything
function UserDashboard() {
  const { profile, settings, notifications, orders } = useUserStore();
  
  return (
    &lt;div&gt;
      &lt;ProfileSection profile={profile} /&gt;
      &lt;SettingsSection settings={settings} /&gt;
      &lt;NotificationsSection notifications={notifications} /&gt;
      &lt;OrdersSection orders={orders} /&gt;
    &lt;/div&gt;
  );
}

// ‚úÖ Good: Each component subscribes to what it needs
function UserDashboard() {
  return (
    &lt;div&gt;
      &lt;ProfileSection /&gt;
      &lt;SettingsSection /&gt;
      &lt;NotificationsSection /&gt;
      &lt;OrdersSection /&gt;
    &lt;/div&gt;
  );
}

function ProfileSection() {
  const profile = useUserStore((state) => state.profile);
  return &lt;div&gt;{/* profile UI */}&lt;/div&gt;;
}

function SettingsSection() {
  const settings = useUserStore((state) => state.settings);
  return &lt;div&gt;{/* settings UI */}&lt;/div&gt;;
}</code></pre>

                <h3>State Management Patterns</h3>

                <h4>1. Separate Actions from State</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Clear separation
interface TodoState {
  todos: Todo[];
  isLoading: boolean;
  error: string | null;
}

interface TodoActions {
  fetchTodos: () => Promise&lt;void&gt;;
  addTodo: (text: string) => void;
  toggleTodo: (id: string) => void;
  removeTodo: (id: string) => void;
}

type TodoStore = TodoState & TodoActions;</code></pre>

                <h4>2. Use Discriminated Unions for Complex State</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Impossible states are impossible
type DataState&lt;T&gt; =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: string };

// ‚ùå Bad: Can be in impossible state
interface DataState&lt;T&gt; {
  data: T | null;
  isLoading: boolean;
  error: string | null;
  // Could be: isLoading=true, data=something, error=something ü§î
}</code></pre>

                <h4>3. Normalize Nested Data</h4>

                <pre><code class="language-typescript">// ‚ùå Bad: Nested arrays are hard to update
interface AppStore {
  users: {
    id: string;
    name: string;
    posts: {
      id: string;
      title: string;
      comments: Comment[];
    }[];
  }[];
}

// ‚úÖ Good: Normalized structure
interface AppStore {
  users: { [id: string]: User };
  posts: { [id: string]: Post };
  comments: { [id: string]: Comment };
  
  userPosts: { [userId: string]: string[] }; // Post IDs
  postComments: { [postId: string]: string[] }; // Comment IDs
}</code></pre>

                <h3>Testing</h3>

                <pre><code class="language-typescript">// stores/__tests__/cart.test.ts
import { renderHook, act } from '@testing-library/react';
import { useCartStore } from '../cart';

describe('Cart Store', () => {
  beforeEach(() => {
    // Reset store before each test
    useCartStore.setState({
      items: [],
      discount: 0,
      taxRate: 8
    });
  });
  
  it('adds items to cart', () => {
    const { result } = renderHook(() => useCartStore());
    
    act(() => {
      result.current.addItem({
        id: '1',
        name: 'Test Product',
        price: 100,
        quantity: 1
      });
    });
    
    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].name).toBe('Test Product');
  });
  
  it('updates item quantity', () => {
    const { result } = renderHook(() => useCartStore());
    
    // Setup
    act(() => {
      result.current.addItem({
        id: '1',
        name: 'Test Product',
        price: 100,
        quantity: 1
      });
    });
    
    // Test
    act(() => {
      result.current.updateQuantity('1', 3);
    });
    
    expect(result.current.items[0].quantity).toBe(3);
  });
  
  it('calculates total correctly', () => {
    const { result } = renderHook(() => useCartStore());
    
    act(() => {
      result.current.addItem({
        id: '1',
        name: 'Product 1',
        price: 100,
        quantity: 2
      });
      result.current.addItem({
        id: '2',
        name: 'Product 2',
        price: 50,
        quantity: 1
      });
    });
    
    const total = result.current.items.reduce(
      (sum, item) => sum + item.price * item.quantity,
      0
    );
    
    expect(total).toBe(250);
  });
});</code></pre>

                <h3>Common Pitfalls to Avoid</h3>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistakes</h4>
                    <ol>
                        <li><strong>Mutating state directly:</strong> Always use <code>set()</code></li>
                        <li><strong>Over-selecting:</strong> Don't select more than you need</li>
                        <li><strong>Forgetting shallow:</strong> Use shallow for object selectors</li>
                        <li><strong>Not handling errors:</strong> Always handle async errors</li>
                        <li><strong>Global state for everything:</strong> Local state is fine!</li>
                        <li><strong>Too many stores:</strong> Don't split unnecessarily</li>
                        <li><strong>Not using TypeScript:</strong> Types prevent many bugs</li>
                    </ol>
                </div>

                <h3>When NOT to Use Zustand</h3>

                <p>Zustand isn't always the answer. Consider alternatives when:</p>

                <ul>
                    <li><strong>Component-local state:</strong> Use <code>useState</code> for state that doesn't need to be shared</li>
                    <li><strong>URL state:</strong> Use React Router for navigation state</li>
                    <li><strong>Form state:</strong> Consider React Hook Form or Formik</li>
                    <li><strong>Server cache:</strong> Use React Query or SWR for server data</li>
                    <li><strong>Simple prop drilling:</strong> 2-3 levels of props is fine</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Golden Rule</h4>
                    <p>Use Zustand when you need to share state across multiple components that aren't closely related in the component tree. For everything else, start with the simplest solution (local state, props) and only reach for Zustand when you feel the pain of prop drilling or complex state coordination.</p>
                </div>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" class="lesson-section">
                <h2>üìù Summary</h2>
                
                <p>Congratulations! You've mastered Zustand, one of the most elegant state management solutions in the React ecosystem. Let's recap what you've learned:</p>

                <h3>Key Takeaways</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ What You've Learned</h4>
                    <ul style="color: white;">
                        <li><strong>Zustand Fundamentals:</strong> Create and use stores with minimal boilerplate</li>
                        <li><strong>TypeScript Integration:</strong> Build fully type-safe stores with interfaces and generics</li>
                        <li><strong>Performance Optimization:</strong> Use selectors effectively to prevent unnecessary re-renders</li>
                        <li><strong>State Updates:</strong> Implement actions, handle async operations, and manage complex state</li>
                        <li><strong>Middleware:</strong> Extend functionality with persist, devtools, immer, and custom middleware</li>
                        <li><strong>Best Practices:</strong> Organize stores, optimize performance, and avoid common pitfalls</li>
                    </ul>
                </div>

                <h3>Zustand vs Other Solutions</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Zustand</th>
                            <th>Redux Toolkit</th>
                            <th>Context API</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Bundle Size</td>
                            <td>~1KB</td>
                            <td>~8KB</td>
                            <td>0 (built-in)</td>
                        </tr>
                        <tr>
                            <td>Boilerplate</td>
                            <td>Minimal</td>
                            <td>Moderate</td>
                            <td>Minimal</td>
                        </tr>
                        <tr>
                            <td>Learning Curve</td>
                            <td>Easy</td>
                            <td>Steep</td>
                            <td>Easy</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>Excellent</td>
                            <td>Excellent</td>
                            <td>Can cause re-renders</td>
                        </tr>
                        <tr>
                            <td>DevTools</td>
                            <td>Yes (via middleware)</td>
                            <td>Yes (built-in)</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>TypeScript</td>
                            <td>Excellent</td>
                            <td>Good</td>
                            <td>Good</td>
                        </tr>
                        <tr>
                            <td>Middleware</td>
                            <td>Yes</td>
                            <td>Yes</td>
                            <td>No</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Quick Reference</h3>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Creating a Store</summary>
                    <pre><code class="language-typescript">import { create } from 'zustand';

interface Store {
  count: number;
  increment: () => void;
}

export const useStore = create&lt;Store&gt;()((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));</code></pre>
                </details>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Using Selectors</summary>
                    <pre><code class="language-typescript">// Primitive value
const count = useStore((state) => state.count);

// Object with shallow
const { count, name } = useStore(
  (state) => ({ count: state.count, name: state.name }),
  shallow
);

// Action
const increment = useStore((state) => state.increment);</code></pre>
                </details>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Middleware Composition</summary>
                    <pre><code class="language-typescript">import { create } from 'zustand';
import { persist, devtools, immer } from 'zustand/middleware';

export const useStore = create&lt;Store&gt;()(
  persist(
    devtools(
      immer((set) => ({ /* store */ }))
    ),
    { name: 'storage-key' }
  )
);</code></pre>
                </details>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Async Actions</summary>
                    <pre><code class="language-typescript">fetchData: async () => {
  set({ isLoading: true, error: null });
  
  try {
    const response = await fetch('/api/data');
    const data = await response.json();
    set({ data, isLoading: false });
  } catch (error) {
    set({ 
      error: error.message, 
      isLoading: false 
    });
  }
}</code></pre>
                </details>

                <h3>Next Steps</h3>

                <p>Now that you've mastered Zustand, here's how to continue your journey:</p>

                <ol>
                    <li><strong>Practice:</strong> Build small projects using Zustand</li>
                    <li><strong>Explore:</strong> Try different middleware combinations</li>
                    <li><strong>Compare:</strong> In Lesson 8.3, we'll explore Redux Toolkit</li>
                    <li><strong>Integrate:</strong> Combine Zustand with React Query for server state</li>
                    <li><strong>Contribute:</strong> Check out Zustand's GitHub repo and community</li>
                </ol>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip: Start Simple</h4>
                    <p>Don't overthink your state management architecture. Start with a simple Zustand store and only add middleware or complexity as you actually need it. The beauty of Zustand is that it grows with your application.</p>
                </div>

                <h3>Resources</h3>

                <ul>
                    <li><a href="https://github.com/pmndrs/zustand" target="_blank" rel="noopener noreferrer">Zustand GitHub Repository</a></li>
                    <li><a href="https://docs.pmnd.rs/zustand" target="_blank" rel="noopener noreferrer">Official Zustand Documentation</a></li>
                    <li><a href="https://github.com/pmndrs/zustand/discussions" target="_blank" rel="noopener noreferrer">Community Discussions</a></li>
                    <li><a href="https://github.com/pmndrs/zustand/tree/main/examples" target="_blank" rel="noopener noreferrer">Example Applications</a></li>
                </ul>
            </section>

            <!-- Exercises Section -->
            <section class="lesson-section">
                <h2>üèãÔ∏è Practice Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: User Authentication Store</h3>
                    
                    <p><strong>Objective:</strong> Create a complete authentication store with TypeScript.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Store user data, loading state, and errors</li>
                        <li>Implement login, logout, and register actions</li>
                        <li>Use persist middleware to save auth state</li>
                        <li>Add TypeScript types for all state and actions</li>
                        <li>Handle async errors properly</li>
                    </ul>

                    <details>
                        <summary style="cursor: pointer; color: #2196F3; margin-top: 1rem;">üí° Hint</summary>
                        <div style="padding: 1rem; background: white; margin-top: 0.5rem;">
                            <p>Start with this structure:</p>
                            <pre><code class="language-typescript">interface User {
  id: string;
  email: string;
  name: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

interface AuthActions {
  login: (email: string, password: string) => Promise&lt;void&gt;;
  logout: () => void;
  register: (email: string, password: string, name: string) => Promise&lt;void&gt;;
}</code></pre>
                        </div>
                    </details>

                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">‚úÖ Solution</summary>
                        <div style="padding: 1rem; background: white; margin-top: 0.5rem;">
                            <pre><code class="language-typescript">import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

interface User {
  id: string;
  email: string;
  name: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

interface AuthActions {
  login: (email: string, password: string) => Promise&lt;void&gt;;
  logout: () => void;
  register: (email: string, password: string, name: string) => Promise&lt;void&gt;;
  clearError: () => void;
}

type AuthStore = AuthState & AuthActions;

export const useAuthStore = create&lt;AuthStore&gt;()(
  persist(
    (set) => ({
      user: null,
      isLoading: false,
      error: null,
      
      login: async (email, password) => {
        set({ isLoading: true, error: null });
        
        try {
          const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password })
          });
          
          if (!response.ok) {
            throw new Error('Invalid credentials');
          }
          
          const user = await response.json();
          set({ user, isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Login failed',
            isLoading: false
          });
        }
      },
      
      logout: () => {
        set({ user: null, error: null });
      },
      
      register: async (email, password, name) => {
        set({ isLoading: true, error: null });
        
        try {
          const response = await fetch('/api/auth/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email, password, name })
          });
          
          if (!response.ok) {
            throw new Error('Registration failed');
          }
          
          const user = await response.json();
          set({ user, isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'Registration failed',
            isLoading: false
          });
        }
      },
      
      clearError: () => {
        set({ error: null });
      }
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({ user: state.user }) // Only persist user
    }
  )
);</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Shopping Cart with Calculations</h3>
                    
                    <p><strong>Objective:</strong> Build a shopping cart with derived calculations using custom selector hooks.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Store cart items with quantity and price</li>
                        <li>Implement add, remove, and update quantity actions</li>
                        <li>Create custom selector hooks for totals</li>
                        <li>Use Immer middleware for easier updates</li>
                        <li>Calculate subtotal, discount, tax, and total</li>
                    </ul>

                    <details>
                        <summary style="cursor: pointer; color: #2196F3; margin-top: 1rem;">üí° Hint</summary>
                        <div style="padding: 1rem; background: white; margin-top: 0.5rem;">
                            <p>Create a custom hook for totals:</p>
                            <pre><code class="language-typescript">export const useCartTotals = () => 
  useCartStore((state) => {
    const subtotal = state.items.reduce(
      (sum, item) => sum + item.price * item.quantity,
      0
    );
    // Calculate discount, tax, total
    return { subtotal, discount, tax, total };
  }, shallow);</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Todo App with Filters</h3>
                    
                    <p><strong>Objective:</strong> Create a todo application with filtering and persistence.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Store todos with completed status</li>
                        <li>Implement filter state (all, active, completed)</li>
                        <li>Create custom selector hooks for filtered todos</li>
                        <li>Use persist middleware to save todos</li>
                        <li>Add DevTools middleware for debugging</li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section -->
            <section class="lesson-section">
                <h2>‚ùì Knowledge Check</h2>
                
                <div class="card">
                    <h3>Question 1: Selector Performance</h3>
                    <p>Which selector pattern is most performant?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="a"> 
                            A) <code>const store = useStore();</code>
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="b"> 
                            B) <code>const count = useStore((state) => state.count);</code>
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="c"> 
                            C) <code>const { count, name } = useStore((state) => ({ count: state.count, name: state.name }));</code>
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>Selecting a primitive value is most performant because it only re-renders when that specific value changes. Option A re-renders on any store change. Option C creates a new object reference each time, causing unnecessary re-renders unless you use <code>shallow</code>.</p>
                        </div>
                    </details>
                </div>

                <div class="card">
                    <h3>Question 2: Middleware Order</h3>
                    <p>What's the correct order for combining middleware?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="a"> 
                            A) persist ‚Üí immer ‚Üí devtools
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="b"> 
                            B) immer ‚Üí devtools ‚Üí persist
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="c"> 
                            C) devtools ‚Üí persist ‚Üí immer
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>Correct order (innermost to outermost): immer (simplifies updates) ‚Üí devtools (logs actions) ‚Üí persist (handles storage). This ensures Immer processes updates first, DevTools sees clean actions, and persist handles the final state.</p>
                        </div>
                    </details>
                </div>

                <div class="card">
                    <h3>Question 3: State Updates</h3>
                    <p>Which statement is true about Zustand's <code>set</code> function?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="a"> 
                            A) It always replaces the entire state
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="b"> 
                            B) It merges new state with existing state by default
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="c"> 
                            C) It requires Immer middleware to work
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>By default, <code>set</code> performs a shallow merge of the new state with the existing state. You can pass <code>true</code> as a second parameter to replace the entire state, but this is rarely needed. Immer is optional and just makes nested updates easier.</p>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_8_1_state_management_overview.html" class="prev-lesson">‚Üê Previous: State Management Overview</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_8_3_redux_toolkit.html" class="next-lesson">Next: Redux Toolkit ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build exceptional applications.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
