<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master integration and end-to-end testing in React applications. Learn to test component interactions, routing, state management, and complete user workflows with Playwright and Cypress.">
    <meta name="author" content="Ray">
    <title>Lesson 9.5: Integration and E2E Testing - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 9: Testing React Applications</a></li>
            <li aria-current="page">Lesson 9.5: Integration and E2E Testing</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üîó Lesson 9.5: Integration and E2E Testing</h1>
                <p class="lead">Take your testing skills to the next level. Learn to test how multiple components work together, test routing and navigation flows, verify state management across components, and write end-to-end tests that simulate real user journeys through your entire application.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the difference between unit, integration, and E2E tests</li>
                        <li>Write integration tests for multiple connected components</li>
                        <li>Test React Router navigation and routing logic</li>
                        <li>Test global state management (Context, Redux, Zustand)</li>
                        <li>Set up and write E2E tests with Playwright or Cypress</li>
                        <li>Test complete user workflows from start to finish</li>
                        <li>Implement CI/CD testing strategies</li>
                        <li>Choose the right test type for different scenarios</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 90-120 minutes</p>
                    <p><strong>Project:</strong> Add comprehensive integration and E2E tests to an e-commerce application</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Understanding Test Types</a></li>
                        <li><a href="#integration-basics" class="toc-link">Integration Testing Basics</a></li>
                        <li><a href="#testing-routing" class="toc-link">Testing Routing and Navigation</a></li>
                        <li><a href="#testing-state" class="toc-link">Testing State Management</a></li>
                        <li><a href="#component-integration" class="toc-link">Testing Component Integration</a></li>
                        <li><a href="#e2e-intro" class="toc-link">Introduction to E2E Testing</a></li>
                        <li><a href="#playwright-setup" class="toc-link">Playwright Setup and Basics</a></li>
                        <li><a href="#cypress-intro" class="toc-link">Cypress Introduction</a></li>
                        <li><a href="#e2e-patterns" class="toc-link">E2E Testing Patterns</a></li>
                        <li><a href="#ci-cd" class="toc-link">CI/CD Testing Strategies</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#best-practices" class="toc-link">Best Practices</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Test Types -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Understanding Test Types</h2>
                
                <p>You've already learned about unit tests (testing individual functions) and basic component tests. Now it's time to level up and understand the full spectrum of testing approaches available to you.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ The Testing Spectrum</h4>
                    <p style="color: white;">Testing exists on a spectrum from <strong>small, fast, isolated tests</strong> (unit tests) to <strong>large, slower, realistic tests</strong> (E2E tests). Each type serves a different purpose and provides different value.</p>
                </div>

                <h3>Visualizing the Test Types</h3>
                <div class="mermaid">
                    graph LR
                    A[Unit Tests] --> B[Integration Tests]
                    B --> C[E2E Tests]
                    
                    A --> D[Fast<br/>Many<br/>Isolated]
                    C --> E[Slow<br/>Few<br/>Realistic]
                    B --> F[Balanced<br/>Moderate<br/>Connected]
                    
                    style A fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style B fill:#339af0,stroke:#1971c2,stroke-width:2px,color:#fff
                    style C fill:#f59f00,stroke:#e67700,stroke-width:2px,color:#fff
                    style D fill:#e8f5e9
                    style E fill:#fff3e0
                    style F fill:#e3f2fd
                </div>

                <h3>Comparing Test Types</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Unit Tests</th>
                            <th>Integration Tests</th>
                            <th>E2E Tests</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Single function or component</td>
                            <td>Multiple components working together</td>
                            <td>Entire application from user perspective</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Very fast (milliseconds)</td>
                            <td>Fast to moderate (seconds)</td>
                            <td>Slow (seconds to minutes)</td>
                        </tr>
                        <tr>
                            <td><strong>Cost to maintain</strong></td>
                            <td>Low</td>
                            <td>Moderate</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td><strong>Confidence level</strong></td>
                            <td>Low to moderate</td>
                            <td>Moderate to high</td>
                            <td>Very high</td>
                        </tr>
                        <tr>
                            <td><strong>What to test</strong></td>
                            <td>Logic, calculations, edge cases</td>
                            <td>Component interactions, data flow</td>
                            <td>User workflows, critical paths</td>
                        </tr>
                        <tr>
                            <td><strong>How many?</strong></td>
                            <td>Many (70-80%)</td>
                            <td>Moderate (15-25%)</td>
                            <td>Few (5-10%)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>The Testing Pyramid</h3>
                <p>The testing pyramid is a classic model that helps you balance your testing strategy:</p>

                <pre><code class="language-text">
                     /\
                    /  \     E2E Tests (5-10%)
                   /____\    Few, slow, high confidence
                  /      \
                 /        \  Integration Tests (15-25%)
                /__________\ Moderate number, moderate speed
               /            \
              /              \
             /                \
            /                  \ Unit Tests (70-80%)
           /____________________\ Many, fast, focused
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why This Balance?</h4>
                    <p>The pyramid shape represents:</p>
                    <ul>
                        <li><strong>Base (Unit Tests):</strong> Quick feedback during development, catch bugs early</li>
                        <li><strong>Middle (Integration Tests):</strong> Verify components work together correctly</li>
                        <li><strong>Top (E2E Tests):</strong> Ensure critical user paths work end-to-end</li>
                    </ul>
                    <p>This balance gives you fast, reliable feedback while still maintaining confidence that your application works as a whole.</p>
                </div>

                <h3>When to Use Each Test Type</h3>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use Unit Tests For:</h4>
                    <ul>
                        <li>Pure functions and utility functions</li>
                        <li>Complex calculations and algorithms</li>
                        <li>Business logic</li>
                        <li>Edge cases and error handling</li>
                        <li>Custom hooks</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üîó Use Integration Tests For:</h4>
                    <ul>
                        <li>Parent and child component interactions</li>
                        <li>Form submissions with multiple fields</li>
                        <li>Routing and navigation flows</li>
                        <li>State management across components</li>
                        <li>API integration with multiple requests</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3e0; border-left: 4px solid #f59f00;">
                    <h4>üåê Use E2E Tests For:</h4>
                    <ul>
                        <li>Critical user workflows (login, checkout, signup)</li>
                        <li>Multi-page user journeys</li>
                        <li>Authentication flows</li>
                        <li>Payment processing</li>
                        <li>Happy path scenarios</li>
                    </ul>
                </div>

                <blockquote>
                    <strong>üí¨ Testing Philosophy:</strong> "Write tests that give you confidence without becoming a burden. The goal isn't 100% coverage‚Äîit's having the right tests that catch real bugs and allow you to move fast."
                </blockquote>
            </section>

            <!-- Section 2: Integration Testing Basics -->
            <section id="integration-basics" class="lesson-section">
                <h2>üîó Integration Testing Basics</h2>
                
                <p>Integration tests verify that multiple pieces of your application work together correctly. Unlike unit tests that isolate components, integration tests let components interact naturally.</p>

                <h3>What Makes a Test an Integration Test?</h3>
                <p>An integration test typically involves:</p>
                <ul>
                    <li><strong>Multiple components:</strong> Parent and child components rendering together</li>
                    <li><strong>Real interactions:</strong> User events triggering state changes across components</li>
                    <li><strong>Data flow:</strong> Props, callbacks, and context passing data between components</li>
                    <li><strong>Side effects:</strong> API calls, routing, or state management updates</li>
                </ul>

                <h3>Simple Integration Test Example</h3>
                <p>Let's test a parent component that manages state for its children:</p>

                <pre><code class="language-typescript">
// ProductList.tsx
interface Product {
  id: string;
  name: string;
  price: number;
}

function ProductList() {
  const [products, setProducts] = React.useState&lt;Product[]&gt;([
    { id: '1', name: 'Laptop', price: 999 },
    { id: '2', name: 'Mouse', price: 29 }
  ]);
  const [cart, setCart] = React.useState&lt;string[]&gt;([]);
  
  const addToCart = (productId: string) => {
    setCart([...cart, productId]);
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Products&lt;/h1&gt;
      {products.map(product => (
        &lt;ProductCard
          key={product.id}
          product={product}
          onAddToCart={addToCart}
        /&gt;
      ))}
      &lt;CartSummary cart={cart} products={products} /&gt;
    &lt;/div&gt;
  );
}

// ProductCard.tsx
function ProductCard({ product, onAddToCart }: {
  product: Product;
  onAddToCart: (id: string) => void;
}) {
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;${product.price}&lt;/p&gt;
      &lt;button onClick={() => onAddToCart(product.id)}&gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// CartSummary.tsx
function CartSummary({ cart, products }: {
  cart: string[];
  products: Product[];
}) {
  const total = cart.reduce((sum, id) => {
    const product = products.find(p => p.id === id);
    return sum + (product?.price || 0);
  }, 0);
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Cart ({cart.length} items)&lt;/h2&gt;
      &lt;p&gt;Total: ${total}&lt;/p&gt;
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>Integration Test for the Complete Flow</h3>
                <pre><code class="language-typescript">
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect } from 'vitest';
import { ProductList } from './ProductList';

describe('ProductList Integration', () => {
  it('adds products to cart and updates total', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    // Initial state
    expect(screen.getByText('Cart (0 items)')).toBeInTheDocument();
    expect(screen.getByText('Total: $0')).toBeInTheDocument();
    
    // Find and click "Add to Cart" for Laptop
    const laptopButtons = screen.getAllByText('Add to Cart');
    await user.click(laptopButtons[0]);
    
    // Cart updates
    expect(screen.getByText('Cart (1 items)')).toBeInTheDocument();
    expect(screen.getByText('Total: $999')).toBeInTheDocument();
    
    // Add mouse
    await user.click(laptopButtons[1]);
    
    // Cart updates again
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    expect(screen.getByText('Total: $1028')).toBeInTheDocument();
  });
  
  it('allows adding same product multiple times', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    const laptopButton = screen.getAllByText('Add to Cart')[0];
    
    // Add laptop twice
    await user.click(laptopButton);
    await user.click(laptopButton);
    
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    expect(screen.getByText('Total: $1998')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° What Makes This Integration Testing?</h4>
                    <p>Notice how we're testing:</p>
                    <ol>
                        <li><strong>Multiple components:</strong> ProductList, ProductCard, and CartSummary work together</li>
                        <li><strong>Data flow:</strong> Callback from child to parent updates state</li>
                        <li><strong>State propagation:</strong> State changes in parent affect multiple children</li>
                        <li><strong>Calculations:</strong> Cart total calculated from multiple pieces of data</li>
                        <li><strong>User workflow:</strong> Complete "add to cart" flow from button click to total update</li>
                    </ol>
                    <p>We're not testing components in isolation‚Äîwe're testing how they work together as a system.</p>
                </div>

                <h3>Testing Complex Parent-Child Interactions</h3>
                <pre><code class="language-typescript">
// SearchableList.tsx
function SearchableList() {
  const [items] = React.useState([
    'Apple', 'Banana', 'Cherry', 'Date', 'Elderberry'
  ]);
  const [searchTerm, setSearchTerm] = React.useState('');
  const [selectedItems, setSelectedItems] = React.useState&lt;string[]&gt;([]);
  
  const filteredItems = items.filter(item =>
    item.toLowerCase().includes(searchTerm.toLowerCase())
  );
  
  const toggleItem = (item: string) => {
    setSelectedItems(prev =>
      prev.includes(item)
        ? prev.filter(i => i !== item)
        : [...prev, item]
    );
  };
  
  return (
    &lt;div&gt;
      &lt;SearchInput value={searchTerm} onChange={setSearchTerm} /&gt;
      &lt;ItemList
        items={filteredItems}
        selectedItems={selectedItems}
        onToggle={toggleItem}
      /&gt;
      &lt;SelectionSummary selected={selectedItems} /&gt;
    &lt;/div&gt;
  );
}

// Integration test
describe('SearchableList Integration', () => {
  it('filters items and maintains selection', async () => {
    const user = userEvent.setup();
    
    render(&lt;SearchableList /&gt;);
    
    // Initially shows all items
    expect(screen.getByText('Apple')).toBeInTheDocument();
    expect(screen.getByText('Banana')).toBeInTheDocument();
    
    // Select Apple
    await user.click(screen.getByText('Apple'));
    expect(screen.getByText('Selected: 1')).toBeInTheDocument();
    
    // Filter for 'a'
    await user.type(screen.getByRole('textbox'), 'a');
    
    // Should show only items with 'a'
    expect(screen.getByText('Apple')).toBeInTheDocument();
    expect(screen.getByText('Banana')).toBeInTheDocument();
    expect(screen.queryByText('Cherry')).not.toBeInTheDocument();
    
    // Apple should still be selected after filtering
    expect(screen.getByText('Selected: 1')).toBeInTheDocument();
    
    // Select Banana
    await user.click(screen.getByText('Banana'));
    expect(screen.getByText('Selected: 2')).toBeInTheDocument();
    
    // Clear filter
    await user.clear(screen.getByRole('textbox'));
    
    // All items visible, both still selected
    expect(screen.getByText('Cherry')).toBeInTheDocument();
    expect(screen.getByText('Selected: 2')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Form Integration</h3>
                <pre><code class="language-typescript">
// RegistrationForm.tsx
function RegistrationForm() {
  const [formData, setFormData] = React.useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  const [errors, setErrors] = React.useState&lt;Record&lt;string, string&gt;&gt;({});
  const [submitted, setSubmitted] = React.useState(false);
  
  const validate = () => {
    const newErrors: Record&lt;string, string&gt; = {};
    
    if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }
    
    if (!formData.email.includes('@')) {
      newErrors.email = 'Invalid email';
    }
    
    if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords must match';
    }
    
    return newErrors;
  };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    const newErrors = validate();
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      setSubmitted(true);
    }
  };
  
  if (submitted) {
    return &lt;div&gt;Registration successful!&lt;/div&gt;;
  }
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;InputField
        label="Username"
        value={formData.username}
        onChange={value => setFormData({...formData, username: value})}
        error={errors.username}
      /&gt;
      &lt;InputField
        label="Email"
        type="email"
        value={formData.email}
        onChange={value => setFormData({...formData, email: value})}
        error={errors.email}
      /&gt;
      &lt;InputField
        label="Password"
        type="password"
        value={formData.password}
        onChange={value => setFormData({...formData, password: value})}
        error={errors.password}
      /&gt;
      &lt;InputField
        label="Confirm Password"
        type="password"
        value={formData.confirmPassword}
        onChange={value => setFormData({...formData, confirmPassword: value})}
        error={errors.confirmPassword}
      /&gt;
      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Integration test
describe('RegistrationForm Integration', () => {
  it('validates entire form and shows all errors', async () => {
    const user = userEvent.setup();
    
    render(&lt;RegistrationForm /&gt;);
    
    // Submit without filling anything
    await user.click(screen.getByText('Register'));
    
    // All validation errors appear
    expect(screen.getByText('Username must be at least 3 characters')).toBeInTheDocument();
    expect(screen.getByText('Invalid email')).toBeInTheDocument();
    expect(screen.getByText('Password must be at least 8 characters')).toBeInTheDocument();
    expect(screen.getByText('Passwords must match')).toBeInTheDocument();
  });
  
  it('clears errors as user fixes them', async () => {
    const user = userEvent.setup();
    
    render(&lt;RegistrationForm /&gt;);
    
    // Submit to trigger errors
    await user.click(screen.getByText('Register'));
    expect(screen.getByText('Username must be at least 3 characters')).toBeInTheDocument();
    
    // Fix username
    await user.type(screen.getByLabelText('Username'), 'john_doe');
    await user.click(screen.getByText('Register'));
    
    // Username error should be gone
    expect(screen.queryByText('Username must be at least 3 characters')).not.toBeInTheDocument();
    // But other errors remain
    expect(screen.getByText('Invalid email')).toBeInTheDocument();
  });
  
  it('successfully submits with valid data', async () => {
    const user = userEvent.setup();
    
    render(&lt;RegistrationForm /&gt;);
    
    // Fill form correctly
    await user.type(screen.getByLabelText('Username'), 'john_doe');
    await user.type(screen.getByLabelText('Email'), 'john@example.com');
    await user.type(screen.getByLabelText('Password'), 'SecurePass123');
    await user.type(screen.getByLabelText('Confirm Password'), 'SecurePass123');
    
    // Submit
    await user.click(screen.getByText('Register'));
    
    // Success message appears
    expect(screen.getByText('Registration successful!')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Integration Testing Best Practices</h4>
                    <ul>
                        <li><strong>Test user workflows:</strong> Follow the steps a real user would take</li>
                        <li><strong>Test state changes:</strong> Verify state updates propagate correctly</li>
                        <li><strong>Test error states:</strong> Ensure error handling works across components</li>
                        <li><strong>Use realistic data:</strong> Don't oversimplify test data</li>
                        <li><strong>Test happy and sad paths:</strong> Both success and failure scenarios</li>
                        <li><strong>Don't mock too much:</strong> Let components interact naturally</li>
                    </ul>
                </div>
            </section>

            <!-- Section 3: Testing Routing -->
            <section id="testing-routing" class="lesson-section">
                <h2>üõ£Ô∏è Testing Routing and Navigation</h2>
                
                <p>React Router is a critical part of most React applications. Integration tests should verify that routing works correctly and that navigation flows make sense.</p>

                <h3>Setting Up Router for Tests</h3>
                <pre><code class="language-typescript">
import { MemoryRouter, Route, Routes } from 'react-router-dom';
import { render, screen } from '@testing-library/react';

function renderWithRouter(
  ui: React.ReactElement,
  { initialEntries = ['/'] } = {}
) {
  return render(
    &lt;MemoryRouter initialEntries={initialEntries}&gt;
      {ui}
    &lt;/MemoryRouter&gt;
  );
}
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why MemoryRouter?</h4>
                    <p><strong>MemoryRouter</strong> keeps routing history in memory instead of in the browser's address bar. This is perfect for tests because:</p>
                    <ul>
                        <li>No interaction with actual browser history</li>
                        <li>Can set initial route with <code>initialEntries</code></li>
                        <li>Tests remain isolated and don't affect each other</li>
                        <li>Faster than using BrowserRouter</li>
                    </ul>
                </div>

                <h3>Testing Basic Navigation</h3>
                <pre><code class="language-typescript">
// App.tsx
function App() {
  return (
    &lt;div&gt;
      &lt;nav&gt;
        &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;Link to="/about"&gt;About&lt;/Link&gt;
        &lt;Link to="/contact"&gt;Contact&lt;/Link&gt;
      &lt;/nav&gt;
      
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;AboutPage /&gt;} /&gt;
        &lt;Route path="/contact" element={&lt;ContactPage /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/div&gt;
  );
}

// Test
describe('App Routing', () => {
  it('navigates between pages', async () => {
    const user = userEvent.setup();
    
    renderWithRouter(&lt;App /&gt;);
    
    // Starts on home page
    expect(screen.getByText('Welcome to Home')).toBeInTheDocument();
    
    // Navigate to About
    await user.click(screen.getByText('About'));
    expect(screen.getByText('About Us')).toBeInTheDocument();
    
    // Navigate to Contact
    await user.click(screen.getByText('Contact'));
    expect(screen.getByText('Contact Us')).toBeInTheDocument();
    
    // Navigate back to Home
    await user.click(screen.getByText('Home'));
    expect(screen.getByText('Welcome to Home')).toBeInTheDocument();
  });
  
  it('renders correct page based on initial route', () => {
    // Start directly on About page
    renderWithRouter(&lt;App /&gt;, { initialEntries: ['/about'] });
    
    expect(screen.getByText('About Us')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Dynamic Routes</h3>
                <pre><code class="language-typescript">
// BlogPost.tsx
function BlogPost() {
  const { id } = useParams&lt;{ id: string }&gt;();
  const [post, setPost] = React.useState&lt;Post | null&gt;(null);
  
  React.useEffect(() => {
    fetch(`/api/posts/${id}`)
      .then(res => res.json())
      .then(setPost);
  }, [id]);
  
  if (!post) return &lt;div&gt;Loading...&lt;/div&gt;;
  
  return (
    &lt;article&gt;
      &lt;h1&gt;{post.title}&lt;/h1&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
    &lt;/article&gt;
  );
}

// Test
describe('BlogPost Routing', () => {
  it('fetches and displays correct post based on route param', async () => {
    server.use(
      rest.get('/api/posts/:id', (req, res, ctx) => {
        const { id } = req.params;
        return res(
          ctx.json({
            id,
            title: `Post ${id}`,
            content: `Content for post ${id}`
          })
        );
      })
    );
    
    renderWithRouter(
      &lt;Routes&gt;
        &lt;Route path="/posts/:id" element={&lt;BlogPost /&gt;} /&gt;
      &lt;/Routes&gt;,
      { initialEntries: ['/posts/123'] }
    );
    
    expect(await screen.findByText('Post 123')).toBeInTheDocument();
    expect(screen.getByText('Content for post 123')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Programmatic Navigation</h3>
                <pre><code class="language-typescript">
// LoginForm.tsx
function LoginForm() {
  const navigate = useNavigate();
  const [credentials, setCredentials] = React.useState({
    username: '',
    password: ''
  });
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const response = await fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials)
    });
    
    if (response.ok) {
      navigate('/dashboard');
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        placeholder="Username"
        value={credentials.username}
        onChange={e => setCredentials({...credentials, username: e.target.value})}
      /&gt;
      &lt;input
        type="password"
        placeholder="Password"
        value={credentials.password}
        onChange={e => setCredentials({...credentials, password: e.target.value})}
      /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}

// Test
describe('LoginForm Navigation', () => {
  it('navigates to dashboard after successful login', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.post('/api/login', (req, res, ctx) => {
        return res(ctx.status(200));
      })
    );
    
    renderWithRouter(
      &lt;Routes&gt;
        &lt;Route path="/login" element={&lt;LoginForm /&gt;} /&gt;
        &lt;Route path="/dashboard" element={&lt;div&gt;Dashboard&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;,
      { initialEntries: ['/login'] }
    );
    
    // Fill and submit form
    await user.type(screen.getByPlaceholderText('Username'), 'john');
    await user.type(screen.getByPlaceholderText('Password'), 'password123');
    await user.click(screen.getByText('Login'));
    
    // Should navigate to dashboard
    expect(await screen.findByText('Dashboard')).toBeInTheDocument();
  });
  
  it('stays on login page after failed login', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.post('/api/login', (req, res, ctx) => {
        return res(ctx.status(401));
      })
    );
    
    renderWithRouter(
      &lt;Routes&gt;
        &lt;Route path="/login" element={&lt;LoginForm /&gt;} /&gt;
        &lt;Route path="/dashboard" element={&lt;div&gt;Dashboard&lt;/div&gt;} /&gt;
      &lt;/Routes&gt;,
      { initialEntries: ['/login'] }
    );
    
    await user.type(screen.getByPlaceholderText('Username'), 'john');
    await user.type(screen.getByPlaceholderText('Password'), 'wrong');
    await user.click(screen.getByText('Login'));
    
    // Should still be on login page
    await waitFor(() => {
      expect(screen.getByText('Login')).toBeInTheDocument();
      expect(screen.queryByText('Dashboard')).not.toBeInTheDocument();
    });
  });
});
                </code></pre>

                <h3>Testing Protected Routes</h3>
                <pre><code class="language-typescript">
// ProtectedRoute.tsx
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isAuthenticated } = useAuth();
  
  if (!isAuthenticated) {
    return &lt;Navigate to="/login" replace /&gt;;
  }
  
  return &lt;&gt;{children}&lt;/&gt;;
}

// Test
describe('ProtectedRoute', () => {
  it('redirects to login when not authenticated', () => {
    renderWithRouter(
      &lt;AuthProvider value={{ isAuthenticated: false }}&gt;
        &lt;Routes&gt;
          &lt;Route path="/login" element={&lt;div&gt;Login Page&lt;/div&gt;} /&gt;
          &lt;Route
            path="/dashboard"
            element={
              &lt;ProtectedRoute&gt;
                &lt;div&gt;Dashboard&lt;/div&gt;
              &lt;/ProtectedRoute&gt;
            }
          /&gt;
        &lt;/Routes&gt;
      &lt;/AuthProvider&gt;,
      { initialEntries: ['/dashboard'] }
    );
    
    // Should redirect to login
    expect(screen.getByText('Login Page')).toBeInTheDocument();
    expect(screen.queryByText('Dashboard')).not.toBeInTheDocument();
  });
  
  it('renders protected content when authenticated', () => {
    renderWithRouter(
      &lt;AuthProvider value={{ isAuthenticated: true }}&gt;
        &lt;Routes&gt;
          &lt;Route path="/login" element={&lt;div&gt;Login Page&lt;/div&gt;} /&gt;
          &lt;Route
            path="/dashboard"
            element={
              &lt;ProtectedRoute&gt;
                &lt;div&gt;Dashboard&lt;/div&gt;
              &lt;/ProtectedRoute&gt;
            }
          /&gt;
        &lt;/Routes&gt;
      &lt;/AuthProvider&gt;,
      { initialEntries: ['/dashboard'] }
    );
    
    // Should show dashboard
    expect(screen.getByText('Dashboard')).toBeInTheDocument();
    expect(screen.queryByText('Login Page')).not.toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Search Parameters</h3>
                <pre><code class="language-typescript">
// ProductSearch.tsx
function ProductSearch() {
  const [searchParams, setSearchParams] = useSearchParams();
  const query = searchParams.get('q') || '';
  const category = searchParams.get('category') || 'all';
  
  return (
    &lt;div&gt;
      &lt;input
        value={query}
        onChange={e => setSearchParams({ q: e.target.value, category })}
        placeholder="Search..."
      /&gt;
      &lt;select
        value={category}
        onChange={e => setSearchParams({ q: query, category: e.target.value })}
      &gt;
        &lt;option value="all"&gt;All Categories&lt;/option&gt;
        &lt;option value="electronics"&gt;Electronics&lt;/option&gt;
        &lt;option value="books"&gt;Books&lt;/option&gt;
      &lt;/select&gt;
      &lt;div&gt;Query: {query}&lt;/div&gt;
      &lt;div&gt;Category: {category}&lt;/div&gt;
    &lt;/div&gt;
  );
}

// Test
describe('ProductSearch URL Parameters', () => {
  it('reads initial search params from URL', () => {
    renderWithRouter(
      &lt;Routes&gt;
        &lt;Route path="/search" element={&lt;ProductSearch /&gt;} /&gt;
      &lt;/Routes&gt;,
      { initialEntries: ['/search?q=laptop&category=electronics'] }
    );
    
    expect(screen.getByDisplayValue('laptop')).toBeInTheDocument();
    expect(screen.getByDisplayValue('electronics')).toBeInTheDocument();
    expect(screen.getByText('Query: laptop')).toBeInTheDocument();
    expect(screen.getByText('Category: electronics')).toBeInTheDocument();
  });
  
  it('updates URL when search changes', async () => {
    const user = userEvent.setup();
    
    renderWithRouter(
      &lt;Routes&gt;
        &lt;Route path="/search" element={&lt;ProductSearch /&gt;} /&gt;
      &lt;/Routes&gt;,
      { initialEntries: ['/search'] }
    );
    
    // Type in search
    await user.type(screen.getByPlaceholderText('Search...'), 'phone');
    
    expect(screen.getByText('Query: phone')).toBeInTheDocument();
    
    // Change category
    await user.selectOptions(screen.getByRole('combobox'), 'books');
    
    expect(screen.getByText('Category: books')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Routing Testing Tips</h4>
                    <ul>
                        <li><strong>Use MemoryRouter:</strong> Keeps tests isolated and fast</li>
                        <li><strong>Set initialEntries:</strong> Start tests on specific routes</li>
                        <li><strong>Test navigation:</strong> Verify users can move between pages</li>
                        <li><strong>Test params:</strong> Check dynamic routes load correct data</li>
                        <li><strong>Test redirects:</strong> Ensure protected routes redirect properly</li>
                        <li><strong>Test search params:</strong> Verify URL state management works</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Testing State Management -->
            <section id="testing-state" class="lesson-section">
                <h2>üóÑÔ∏è Testing State Management</h2>
                
                <p>Global state management is a crucial part of modern React apps. Whether you're using Context, Redux, or Zustand, you need to test that state updates correctly across components.</p>

                <h3>Testing Context-Based State</h3>
                <pre><code class="language-typescript">
// CartContext.tsx
interface CartItem {
  id: string;
  name: string;
  quantity: number;
}

interface CartContextType {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (id: string) => void;
  clearCart: () => void;
}

const CartContext = React.createContext&lt;CartContextType | null&gt;(null);

export function CartProvider({ children }: { children: React.ReactNode }) {
  const [items, setItems] = React.useState&lt;CartItem[]&gt;([]);
  
  const addItem = (item: CartItem) => {
    setItems(prev => {
      const existing = prev.find(i => i.id === item.id);
      if (existing) {
        return prev.map(i =>
          i.id === item.id
            ? { ...i, quantity: i.quantity + item.quantity }
            : i
        );
      }
      return [...prev, item];
    });
  };
  
  const removeItem = (id: string) => {
    setItems(prev => prev.filter(i => i.id !== id));
  };
  
  const clearCart = () => {
    setItems([]);
  };
  
  return (
    &lt;CartContext.Provider value={{ items, addItem, removeItem, clearCart }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

export const useCart = () => {
  const context = React.useContext(CartContext);
  if (!context) throw new Error('useCart must be used within CartProvider');
  return context;
};

// Components using the context
function AddToCartButton({ product }: { product: { id: string; name: string } }) {
  const { addItem } = useCart();
  
  return (
    &lt;button onClick={() => addItem({ ...product, quantity: 1 })}&gt;
      Add {product.name} to Cart
    &lt;/button&gt;
  );
}

function CartDisplay() {
  const { items, removeItem, clearCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Cart ({items.length} items)&lt;/h2&gt;
      {items.map(item => (
        &lt;div key={item.id}&gt;
          {item.name} (x{item.quantity})
          &lt;button onClick={() => removeItem(item.id)}&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
      ))}
      {items.length > 0 && (
        &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>Integration Test for Context State</h3>
                <pre><code class="language-typescript">
describe('Cart Context Integration', () => {
  function renderWithCart(ui: React.ReactElement) {
    return render(
      &lt;CartProvider&gt;
        {ui}
      &lt;/CartProvider&gt;
    );
  }
  
  it('adds items to cart from multiple components', async () => {
    const user = userEvent.setup();
    
    renderWithCart(
      &lt;&gt;
        &lt;AddToCartButton product={{ id: '1', name: 'Laptop' }} /&gt;
        &lt;AddToCartButton product={{ id: '2', name: 'Mouse' }} /&gt;
        &lt;CartDisplay /&gt;
      &lt;/&gt;
    );
    
    // Initially empty
    expect(screen.getByText('Cart (0 items)')).toBeInTheDocument();
    
    // Add laptop
    await user.click(screen.getByText('Add Laptop to Cart'));
    expect(screen.getByText('Cart (1 items)')).toBeInTheDocument();
    expect(screen.getByText('Laptop (x1)')).toBeInTheDocument();
    
    // Add mouse
    await user.click(screen.getByText('Add Mouse to Cart'));
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    expect(screen.getByText('Mouse (x1)')).toBeInTheDocument();
    
    // Add laptop again (should increase quantity)
    await user.click(screen.getByText('Add Laptop to Cart'));
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    expect(screen.getByText('Laptop (x2)')).toBeInTheDocument();
  });
  
  it('removes items from cart', async () => {
    const user = userEvent.setup();
    
    renderWithCart(
      &lt;&gt;
        &lt;AddToCartButton product={{ id: '1', name: 'Laptop' }} /&gt;
        &lt;AddToCartButton product={{ id: '2', name: 'Mouse' }} /&gt;
        &lt;CartDisplay /&gt;
      &lt;/&gt;
    );
    
    // Add items
    await user.click(screen.getByText('Add Laptop to Cart'));
    await user.click(screen.getByText('Add Mouse to Cart'));
    
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    
    // Remove laptop
    const removeButtons = screen.getAllByText('Remove');
    await user.click(removeButtons[0]);
    
    expect(screen.getByText('Cart (1 items)')).toBeInTheDocument();
    expect(screen.queryByText('Laptop (x1)')).not.toBeInTheDocument();
    expect(screen.getByText('Mouse (x1)')).toBeInTheDocument();
  });
  
  it('clears entire cart', async () => {
    const user = userEvent.setup();
    
    renderWithCart(
      &lt;&gt;
        &lt;AddToCartButton product={{ id: '1', name: 'Laptop' }} /&gt;
        &lt;AddToCartButton product={{ id: '2', name: 'Mouse' }} /&gt;
        &lt;CartDisplay /&gt;
      &lt;/&gt;
    );
    
    // Add items
    await user.click(screen.getByText('Add Laptop to Cart'));
    await user.click(screen.getByText('Add Mouse to Cart'));
    
    expect(screen.getByText('Cart (2 items)')).toBeInTheDocument();
    
    // Clear cart
    await user.click(screen.getByText('Clear Cart'));
    
    expect(screen.getByText('Cart (0 items)')).toBeInTheDocument();
    expect(screen.queryByText('Laptop (x1)')).not.toBeInTheDocument();
    expect(screen.queryByText('Mouse (x1)')).not.toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Redux/Redux Toolkit</h3>
                <pre><code class="language-typescript">
// store.ts
import { configureStore, createSlice } from '@reduxjs/toolkit';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

const todosSlice = createSlice({
  name: 'todos',
  initialState: [] as Todo[],
  reducers: {
    addTodo: (state, action) => {
      state.push({
        id: Date.now().toString(),
        text: action.payload,
        completed: false
      });
    },
    toggleTodo: (state, action) => {
      const todo = state.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    deleteTodo: (state, action) => {
      return state.filter(t => t.id !== action.payload);
    }
  }
});

export const { addTodo, toggleTodo, deleteTodo } = todosSlice.actions;

export function createTestStore() {
  return configureStore({
    reducer: {
      todos: todosSlice.reducer
    }
  });
}

// Test helper
import { Provider } from 'react-redux';

function renderWithRedux(
  ui: React.ReactElement,
  { store = createTestStore() } = {}
) {
  return {
    ...render(&lt;Provider store={store}&gt;{ui}&lt;/Provider&gt;),
    store
  };
}

// TodoList component
function TodoList() {
  const dispatch = useDispatch();
  const todos = useSelector((state: RootState) => state.todos);
  const [input, setInput] = React.useState('');
  
  const handleAdd = () => {
    if (input.trim()) {
      dispatch(addTodo(input));
      setInput('');
    }
  };
  
  return (
    &lt;div&gt;
      &lt;input
        value={input}
        onChange={e => setInput(e.target.value)}
        placeholder="Add todo..."
      /&gt;
      &lt;button onClick={handleAdd}&gt;Add&lt;/button&gt;
      
      &lt;ul&gt;
        {todos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            /&gt;
            &lt;span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => dispatch(deleteTodo(todo.id))}&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

// Test
describe('Redux TodoList Integration', () => {
  it('adds and manages todos', async () => {
    const user = userEvent.setup();
    
    renderWithRedux(&lt;TodoList /&gt;);
    
    // Add first todo
    await user.type(screen.getByPlaceholderText('Add todo...'), 'Buy milk');
    await user.click(screen.getByText('Add'));
    
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
    
    // Add second todo
    await user.type(screen.getByPlaceholderText('Add todo...'), 'Walk dog');
    await user.click(screen.getByText('Add'));
    
    expect(screen.getByText('Walk dog')).toBeInTheDocument();
    
    // Toggle first todo
    const checkboxes = screen.getAllByRole('checkbox');
    await user.click(checkboxes[0]);
    
    const buyMilkText = screen.getByText('Buy milk');
    expect(buyMilkText).toHaveStyle({ textDecoration: 'line-through' });
    
    // Delete second todo
    const deleteButtons = screen.getAllByText('Delete');
    await user.click(deleteButtons[1]);
    
    expect(screen.queryByText('Walk dog')).not.toBeInTheDocument();
    expect(screen.getByText('Buy milk')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Zustand Store</h3>
                <pre><code class="language-typescript">
// store.ts
import { create } from 'zustand';

interface CounterStore {
  count: number;
  increment: () => void;
  decrement: () => void;
  reset: () => void;
}

export const useCounterStore = create&lt;CounterStore&gt;((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
  reset: () => set({ count: 0 })
}));

// Counter component
function Counter() {
  const { count, increment, decrement, reset } = useCounterStore();
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Count: {count}&lt;/h1&gt;
      &lt;button onClick={increment}&gt;+&lt;/button&gt;
      &lt;button onClick={decrement}&gt;-&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}

// DisplayCount component (separate component using same store)
function DisplayCount() {
  const count = useCounterStore(state => state.count);
  
  return &lt;div&gt;Display: {count}&lt;/div&gt;;
}

// Test
describe('Zustand Counter Integration', () => {
  beforeEach(() => {
    // Reset store before each test
    useCounterStore.setState({ count: 0 });
  });
  
  it('updates count across multiple components', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;Counter /&gt;
        &lt;DisplayCount /&gt;
      &lt;/&gt;
    );
    
    // Initial state
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
    expect(screen.getByText('Display: 0')).toBeInTheDocument();
    
    // Increment
    await user.click(screen.getByText('+'));
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
    expect(screen.getByText('Display: 1')).toBeInTheDocument();
    
    // Increment again
    await user.click(screen.getByText('+'));
    expect(screen.getByText('Count: 2')).toBeInTheDocument();
    expect(screen.getByText('Display: 2')).toBeInTheDocument();
    
    // Decrement
    await user.click(screen.getByText('-'));
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
    expect(screen.getByText('Display: 1')).toBeInTheDocument();
    
    // Reset
    await user.click(screen.getByText('Reset'));
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
    expect(screen.getByText('Display: 0')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° State Management Testing Tips</h4>
                    <ul>
                        <li><strong>Test state updates:</strong> Verify state changes propagate to all consumers</li>
                        <li><strong>Test multiple components:</strong> Ensure different components see same state</li>
                        <li><strong>Reset state:</strong> Clean slate for each test (especially Zustand)</li>
                        <li><strong>Test actions/reducers:</strong> Verify state logic works correctly</li>
                        <li><strong>Use test stores:</strong> Create fresh stores for Redux tests</li>
                        <li><strong>Test selectors:</strong> Ensure derived state computes correctly</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Testing Component Integration -->
            <section id="component-integration" class="lesson-section">
                <h2>üß© Testing Component Integration</h2>
                
                <p>Real applications have complex component hierarchies with data flowing in multiple directions. Integration tests should verify these interactions work correctly.</p>

                <h3>Testing Parent-Multiple Children Flow</h3>
                <pre><code class="language-typescript">
// Dashboard.tsx
function Dashboard() {
  const [user, setUser] = React.useState&lt;User | null&gt;(null);
  const [notifications, setNotifications] = React.useState&lt;Notification[]&gt;([]);
  const [loading, setLoading] = React.useState(true);
  
  React.useEffect(() => {
    Promise.all([
      fetch('/api/user').then(r => r.json()),
      fetch('/api/notifications').then(r => r.json())
    ])
      .then(([userData, notificationData]) => {
        setUser(userData);
        setNotifications(notificationData);
        setLoading(false);
      });
  }, []);
  
  const markAsRead = (id: string) => {
    fetch(`/api/notifications/${id}/read`, { method: 'POST' })
      .then(() => {
        setNotifications(prev =>
          prev.map(n => n.id === id ? { ...n, read: true } : n)
        );
      });
  };
  
  if (loading) return &lt;div&gt;Loading dashboard...&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;UserProfile user={user} /&gt;
      &lt;NotificationList
        notifications={notifications}
        onMarkAsRead={markAsRead}
      /&gt;
      &lt;ActivityFeed userId={user?.id} /&gt;
    &lt;/div&gt;
  );
}

// Test
describe('Dashboard Integration', () => {
  it('loads and displays all dashboard components', async () => {
    server.use(
      rest.get('/api/user', (req, res, ctx) => {
        return res(
          ctx.json({
            id: '123',
            name: 'John Doe',
            email: 'john@example.com'
          })
        );
      }),
      rest.get('/api/notifications', (req, res, ctx) => {
        return res(
          ctx.json([
            { id: '1', message: 'New message', read: false },
            { id: '2', message: 'Update available', read: true }
          ])
        );
      }),
      rest.get('/api/users/123/activity', (req, res, ctx) => {
        return res(
          ctx.json([
            { id: '1', action: 'Posted comment' }
          ])
        );
      })
    );
    
    render(&lt;Dashboard /&gt;);
    
    // Shows loading
    expect(screen.getByText('Loading dashboard...')).toBeInTheDocument();
    
    // All components load
    expect(await screen.findByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
    expect(screen.getByText('New message')).toBeInTheDocument();
    expect(screen.getByText('Update available')).toBeInTheDocument();
    expect(screen.getByText('Posted comment')).toBeInTheDocument();
  });
  
  it('marks notification as read and updates UI', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.get('/api/user', (req, res, ctx) => {
        return res(ctx.json({ id: '123', name: 'John' }));
      }),
      rest.get('/api/notifications', (req, res, ctx) => {
        return res(
          ctx.json([
            { id: '1', message: 'New message', read: false }
          ])
        );
      }),
      rest.post('/api/notifications/:id/read', (req, res, ctx) => {
        return res(ctx.status(200));
      })
    );
    
    render(&lt;Dashboard /&gt;);
    
    // Wait for notification to appear
    const notification = await screen.findByText('New message');
    expect(notification).toHaveClass('unread'); // Assuming this class exists
    
    // Mark as read
    await user.click(screen.getByText('Mark as Read'));
    
    // UI updates
    await waitFor(() => {
      expect(notification).toHaveClass('read');
    });
  });
});
                </code></pre>

                <h3>Testing Complex Data Flow</h3>
                <pre><code class="language-typescript">
// FilterableProductList.tsx
function FilterableProductList() {
  const [products, setProducts] = React.useState&lt;Product[]&gt;([]);
  const [filters, setFilters] = React.useState({
    category: 'all',
    minPrice: 0,
    maxPrice: 1000,
    inStock: false
  });
  const [sortBy, setSortBy] = React.useState('name');
  
  React.useEffect(() => {
    fetch('/api/products')
      .then(r => r.json())
      .then(setProducts);
  }, []);
  
  const filteredProducts = products
    .filter(p => {
      if (filters.category !== 'all' && p.category !== filters.category) {
        return false;
      }
      if (p.price < filters.minPrice || p.price > filters.maxPrice) {
        return false;
      }
      if (filters.inStock && !p.inStock) {
        return false;
      }
      return true;
    })
    .sort((a, b) => {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return 0;
    });
  
  return (
    &lt;div&gt;
      &lt;FilterPanel filters={filters} onFiltersChange={setFilters} /&gt;
      &lt;SortControls sortBy={sortBy} onSortChange={setSortBy} /&gt;
      &lt;ProductGrid products={filteredProducts} /&gt;
      &lt;ResultCount count={filteredProducts.length} total={products.length} /&gt;
    &lt;/div&gt;
  );
}

// Test
describe('FilterableProductList Integration', () => {
  it('filters and sorts products correctly', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.get('/api/products', (req, res, ctx) => {
        return res(
          ctx.json([
            { id: '1', name: 'Laptop', price: 999, category: 'electronics', inStock: true },
            { id: '2', name: 'Book', price: 20, category: 'books', inStock: true },
            { id: '3', name: 'Phone', price: 699, category: 'electronics', inStock: false },
            { id: '4', name: 'Desk', price: 300, category: 'furniture', inStock: true }
          ])
        );
      })
    );
    
    render(&lt;FilterableProductList /&gt;);
    
    // Wait for products to load
    await screen.findByText('Laptop');
    expect(screen.getByText('Showing 4 of 4 products')).toBeInTheDocument();
    
    // Filter by category
    await user.selectOptions(screen.getByLabelText('Category'), 'electronics');
    expect(screen.getByText('Showing 2 of 4 products')).toBeInTheDocument();
    expect(screen.getByText('Laptop')).toBeInTheDocument();
    expect(screen.getByText('Phone')).toBeInTheDocument();
    expect(screen.queryByText('Book')).not.toBeInTheDocument();
    
    // Filter by in stock
    await user.click(screen.getByLabelText('In Stock Only'));
    expect(screen.getByText('Showing 1 of 4 products')).toBeInTheDocument();
    expect(screen.getByText('Laptop')).toBeInTheDocument();
    expect(screen.queryByText('Phone')).not.toBeInTheDocument();
    
    // Change sort
    await user.selectOptions(screen.getByLabelText('Sort by'), 'price');
    
    // Products should be sorted (verify order if needed)
    const products = screen.getAllByRole('article');
    expect(products[0]).toHaveTextContent('Laptop');
  });
  
  it('clears filters and shows all products', async () => {
    const user = userEvent.setup();
    
    // ... setup
    
    render(&lt;FilterableProductList /&gt;);
    
    await screen.findByText('Laptop');
    
    // Apply filters
    await user.selectOptions(screen.getByLabelText('Category'), 'electronics');
    expect(screen.getByText('Showing 2 of 4 products')).toBeInTheDocument();
    
    // Clear filters
    await user.click(screen.getByText('Clear Filters'));
    
    expect(screen.getByText('Showing 4 of 4 products')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Modal and Dialog Interactions</h3>
                <pre><code class="language-typescript">
// UserSettings.tsx
function UserSettings() {
  const [user, setUser] = React.useState({ name: 'John', email: 'john@example.com' });
  const [isEditing, setIsEditing] = React.useState(false);
  const [showDeleteModal, setShowDeleteModal] = React.useState(false);
  
  const handleSave = (newData: typeof user) => {
    fetch('/api/user', {
      method: 'PUT',
      body: JSON.stringify(newData)
    })
      .then(r => r.json())
      .then(data => {
        setUser(data);
        setIsEditing(false);
      });
  };
  
  const handleDelete = () => {
    fetch('/api/user', { method: 'DELETE' })
      .then(() => {
        // Redirect or show success
      });
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;User Settings&lt;/h1&gt;
      
      {!isEditing ? (
        &lt;div&gt;
          &lt;p&gt;Name: {user.name}&lt;/p&gt;
          &lt;p&gt;Email: {user.email}&lt;/p&gt;
          &lt;button onClick={() => setIsEditing(true)}&gt;Edit&lt;/button&gt;
          &lt;button onClick={() => setShowDeleteModal(true)}&gt;Delete Account&lt;/button&gt;
        &lt;/div&gt;
      ) : (
        &lt;EditForm
          user={user}
          onSave={handleSave}
          onCancel={() => setIsEditing(false)}
        /&gt;
      )}
      
      {showDeleteModal && (
        &lt;ConfirmDialog
          title="Delete Account"
          message="Are you sure? This cannot be undone."
          onConfirm={handleDelete}
          onCancel={() => setShowDeleteModal(false)}
        /&gt;
      )}
    &lt;/div&gt;
  );
}

// Test
describe('UserSettings Integration', () => {
  it('edits user information', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.put('/api/user', async (req, res, ctx) => {
        const body = await req.json();
        return res(ctx.json(body));
      })
    );
    
    render(&lt;UserSettings /&gt;);
    
    // Initial view
    expect(screen.getByText('Name: John')).toBeInTheDocument();
    
    // Enter edit mode
    await user.click(screen.getByText('Edit'));
    
    // Form appears
    expect(screen.getByLabelText('Name')).toBeInTheDocument();
    
    // Change name
    const nameInput = screen.getByLabelText('Name');
    await user.clear(nameInput);
    await user.type(nameInput, 'Jane Doe');
    
    // Save
    await user.click(screen.getByText('Save'));
    
    // Returns to view mode with updated data
    expect(await screen.findByText('Name: Jane Doe')).toBeInTheDocument();
    expect(screen.queryByLabelText('Name')).not.toBeInTheDocument();
  });
  
  it('shows confirmation before deleting account', async () => {
    const user = userEvent.setup();
    
    server.use(
      rest.delete('/api/user', (req, res, ctx) => {
        return res(ctx.status(200));
      })
    );
    
    render(&lt;UserSettings /&gt;);
    
    // Click delete
    await user.click(screen.getByText('Delete Account'));
    
    // Modal appears
    expect(screen.getByText('Are you sure? This cannot be undone.')).toBeInTheDocument();
    
    // Cancel
    await user.click(screen.getByText('Cancel'));
    
    // Modal closes, still on settings
    expect(screen.queryByText('Are you sure?')).not.toBeInTheDocument();
    expect(screen.getByText('Name: John')).toBeInTheDocument();
    
    // Try again and confirm
    await user.click(screen.getByText('Delete Account'));
    await user.click(screen.getByText('Confirm'));
    
    // Account deleted (verify redirect or message)
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Component Integration Testing Tips</h4>
                    <ul>
                        <li><strong>Test complete flows:</strong> From user action to final UI update</li>
                        <li><strong>Test data propagation:</strong> Verify data flows through component tree</li>
                        <li><strong>Test conditional rendering:</strong> Different UI states based on data</li>
                        <li><strong>Test error boundaries:</strong> Error handling across components</li>
                        <li><strong>Test loading states:</strong> Multiple components loading simultaneously</li>
                        <li><strong>Test user workflows:</strong> Multi-step processes across components</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Introduction to E2E Testing -->
            <section id="e2e-intro" class="lesson-section">
                <h2>üåê Introduction to E2E Testing</h2>
                
                <p>End-to-End (E2E) testing is the highest level of testing. Unlike unit and integration tests that run in Node.js, E2E tests run in a real browser and test your entire application from the user's perspective.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What is E2E Testing?</h4>
                    <p style="color: white;"><strong>End-to-End testing</strong> simulates real user scenarios by automating browser interactions. Tests click buttons, fill forms, navigate pages, and verify the application behaves correctly‚Äîjust like a real user would.</p>
                </div>

                <h3>Why E2E Tests Matter</h3>
                <p>E2E tests provide the highest confidence that your application works because they test:</p>
                <ul>
                    <li><strong>Real browser environment:</strong> Actual rendering, JavaScript execution, CSS layout</li>
                    <li><strong>Complete workflows:</strong> Multi-page journeys from start to finish</li>
                    <li><strong>Network interactions:</strong> Real API calls (or realistic mocks)</li>
                    <li><strong>Browser APIs:</strong> localStorage, cookies, navigation, history</li>
                    <li><strong>User experience:</strong> Visual layout, responsive design, animations</li>
                </ul>

                <h3>E2E vs Integration Tests</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Integration Tests</th>
                            <th>E2E Tests</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Environment</strong></td>
                            <td>jsdom (simulated browser)</td>
                            <td>Real browser (Chrome, Firefox, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>Network</strong></td>
                            <td>Mocked with MSW</td>
                            <td>Real or mocked at network level</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>MemoryRouter</td>
                            <td>Real browser routing</td>
                        </tr>
                        <tr>
                            <td><strong>CSS/Layout</strong></td>
                            <td>Not tested</td>
                            <td>Fully tested</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Fast (1-2 seconds)</td>
                            <td>Slower (5-30 seconds)</td>
                        </tr>
                        <tr>
                            <td><strong>Use case</strong></td>
                            <td>Feature-level testing</td>
                            <td>Critical user workflows</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Popular E2E Testing Tools</h3>
                <div class="mermaid">
                    graph TB
                    A[E2E Testing Tools]
                    A --> B[Playwright]
                    A --> C[Cypress]
                    A --> D[Selenium]
                    
                    B --> E[Modern, Fast<br/>Multiple Browsers<br/>TypeScript First]
                    C --> F[Developer Friendly<br/>Great DX<br/>Time Travel Debug]
                    D --> G[Industry Standard<br/>Wide Support<br/>Older Tech]
                    
                    style B fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style C fill:#339af0,stroke:#1971c2,stroke-width:2px,color:#fff
                    style D fill:#868e96,stroke:#495057,stroke-width:2px,color:#fff
                </div>

                <h3>Choosing Between Playwright and Cypress</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Playwright</th>
                            <th>Cypress</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Browser Support</strong></td>
                            <td>Chrome, Firefox, Safari, Edge</td>
                            <td>Chrome, Firefox, Edge (Safari experimental)</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Very fast, parallel execution</td>
                            <td>Fast, but slower than Playwright</td>
                        </tr>
                        <tr>
                            <td><strong>TypeScript</strong></td>
                            <td>Excellent, built-in</td>
                            <td>Good, needs setup</td>
                        </tr>
                        <tr>
                            <td><strong>API Testing</strong></td>
                            <td>Native support</td>
                            <td>Via plugins</td>
                        </tr>
                        <tr>
                            <td><strong>Learning Curve</strong></td>
                            <td>Moderate</td>
                            <td>Easy</td>
                        </tr>
                        <tr>
                            <td><strong>Debugging</strong></td>
                            <td>Good (trace viewer)</td>
                            <td>Excellent (time travel)</td>
                        </tr>
                        <tr>
                            <td><strong>Mobile Testing</strong></td>
                            <td>Device emulation</td>
                            <td>Viewport only</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Which Should You Choose?</h4>
                    <p><strong>Choose Playwright if:</strong></p>
                    <ul>
                        <li>You need to test across multiple browsers</li>
                        <li>You want the fastest test execution</li>
                        <li>You need mobile device testing</li>
                        <li>You're starting a new project</li>
                    </ul>
                    <p><strong>Choose Cypress if:</strong></p>
                    <ul>
                        <li>You value developer experience and debugging tools</li>
                        <li>You want the easiest learning curve</li>
                        <li>You're already using Cypress</li>
                        <li>Chrome/Firefox support is sufficient</li>
                    </ul>
                </div>

                <h3>What to Test with E2E</h3>
                <p>E2E tests are expensive, so focus on:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Critical User Paths</h4>
                    <ul>
                        <li><strong>Authentication:</strong> Login, signup, logout, password reset</li>
                        <li><strong>Core features:</strong> The main value proposition of your app</li>
                        <li><strong>Payment flows:</strong> Checkout, subscriptions, billing</li>
                        <li><strong>Data creation:</strong> Creating posts, products, profiles</li>
                        <li><strong>Happy paths:</strong> The most common user journeys</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Test with E2E</h4>
                    <ul>
                        <li>Edge cases (use unit tests)</li>
                        <li>Error handling (use integration tests)</li>
                        <li>Complex calculations (use unit tests)</li>
                        <li>Every possible path (too expensive)</li>
                        <li>UI variations (use visual regression tests)</li>
                    </ul>
                </div>

                <blockquote>
                    <strong>üí¨ E2E Testing Philosophy:</strong> "Test the critical paths that, if broken, would prevent users from getting value from your application. Everything else should be covered by faster, cheaper tests."
                </blockquote>
            </section>

            <!-- Section 7: Playwright Setup and Basics -->
            <section id="playwright-setup" class="lesson-section">
                <h2>üé≠ Playwright Setup and Basics</h2>
                
                <p>Playwright is a modern E2E testing framework created by Microsoft. It's fast, reliable, and has excellent TypeScript support out of the box.</p>

                <h3>Installing Playwright</h3>
                <pre><code class="language-bash">
# Install Playwright
npm init playwright@latest

# Or with existing project
npm install -D @playwright/test

# Install browsers
npx playwright install
                </code></pre>

                <h3>Project Structure</h3>
                <pre><code class="language-text">
my-app/
‚îú‚îÄ‚îÄ e2e/
‚îÇ   ‚îú‚îÄ‚îÄ auth.spec.ts
‚îÇ   ‚îú‚îÄ‚îÄ shopping.spec.ts
‚îÇ   ‚îî‚îÄ‚îÄ profile.spec.ts
‚îú‚îÄ‚îÄ playwright.config.ts
‚îî‚îÄ‚îÄ package.json
                </code></pre>

                <h3>Basic Playwright Configuration</h3>
                <pre><code class="language-typescript">
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  
  // Run tests in parallel
  fullyParallel: true,
  
  // Fail the build on CI if you accidentally left test.only
  forbidOnly: !!process.env.CI,
  
  // Retry on CI only
  retries: process.env.CI ? 2 : 0,
  
  // Reporter
  reporter: 'html',
  
  use: {
    // Base URL for your app
    baseURL: 'http://localhost:5173',
    
    // Collect trace on failure
    trace: 'on-first-retry',
    
    // Screenshot on failure
    screenshot: 'only-on-failure',
  },
  
  // Configure projects for different browsers
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
  ],
  
  // Start dev server before tests
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});
                </code></pre>

                <h3>Your First Playwright Test</h3>
                <pre><code class="language-typescript">
// e2e/example.spec.ts
import { test, expect } from '@playwright/test';

test('homepage has title and heading', async ({ page }) => {
  // Navigate to the page
  await page.goto('/');
  
  // Check page title
  await expect(page).toHaveTitle(/My App/);
  
  // Check for heading
  await expect(page.getByRole('heading', { name: 'Welcome' })).toBeVisible();
});
                </code></pre>

                <h3>Basic Playwright Actions</h3>
                <pre><code class="language-typescript">
test('user can interact with the page', async ({ page }) => {
  await page.goto('/');
  
  // Click a button
  await page.getByRole('button', { name: 'Click me' }).click();
  
  // Fill an input
  await page.getByLabel('Email').fill('user@example.com');
  
  // Select from dropdown
  await page.getByLabel('Country').selectOption('US');
  
  // Check a checkbox
  await page.getByLabel('I agree').check();
  
  // Wait for element to appear
  await page.getByText('Success!').waitFor();
  
  // Check element is visible
  await expect(page.getByText('Welcome!')).toBeVisible();
  
  // Check input value
  await expect(page.getByLabel('Email')).toHaveValue('user@example.com');
});
                </code></pre>

                <h3>Playwright Locators</h3>
                <p>Playwright has powerful locator strategies that prioritize accessibility:</p>

                <pre><code class="language-typescript">
// By role (BEST - most accessible)
page.getByRole('button', { name: 'Submit' })
page.getByRole('textbox', { name: 'Username' })
page.getByRole('link', { name: 'Contact Us' })

// By label (GOOD - accessible)
page.getByLabel('Email address')

// By placeholder
page.getByPlaceholder('Enter your email')

// By text
page.getByText('Welcome back')

// By test ID (use when others don't work)
page.getByTestId('submit-button')

// By CSS selector (AVOID - brittle)
page.locator('.submit-btn')
                </code></pre>

                <h3>Testing a Login Flow</h3>
                <pre><code class="language-typescript">
// e2e/auth.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Authentication', () => {
  test('user can login successfully', async ({ page }) => {
    // Navigate to login page
    await page.goto('/login');
    
    // Fill in credentials
    await page.getByLabel('Email').fill('user@example.com');
    await page.getByLabel('Password').fill('SecurePass123');
    
    // Submit form
    await page.getByRole('button', { name: 'Login' }).click();
    
    // Wait for navigation to dashboard
    await page.waitForURL('/dashboard');
    
    // Verify we're logged in
    await expect(page.getByText('Welcome back, User!')).toBeVisible();
    await expect(page.getByRole('button', { name: 'Logout' })).toBeVisible();
  });
  
  test('shows error with invalid credentials', async ({ page }) => {
    await page.goto('/login');
    
    await page.getByLabel('Email').fill('wrong@example.com');
    await page.getByLabel('Password').fill('wrongpass');
    await page.getByRole('button', { name: 'Login' }).click();
    
    // Should stay on login page
    await expect(page).toHaveURL('/login');
    
    // Should show error message
    await expect(page.getByText('Invalid email or password')).toBeVisible();
  });
  
  test('validates required fields', async ({ page }) => {
    await page.goto('/login');
    
    // Try to submit without filling fields
    await page.getByRole('button', { name: 'Login' }).click();
    
    // Should show validation errors
    await expect(page.getByText('Email is required')).toBeVisible();
    await expect(page.getByText('Password is required')).toBeVisible();
  });
});
                </code></pre>

                <h3>Testing Multi-Step Forms</h3>
                <pre><code class="language-typescript">
test('completes multi-step registration', async ({ page }) => {
  await page.goto('/register');
  
  // Step 1: Personal info
  await page.getByLabel('First Name').fill('John');
  await page.getByLabel('Last Name').fill('Doe');
  await page.getByLabel('Email').fill('john@example.com');
  await page.getByRole('button', { name: 'Next' }).click();
  
  // Wait for step 2
  await expect(page.getByText('Step 2: Account Details')).toBeVisible();
  
  // Step 2: Account details
  await page.getByLabel('Username').fill('johndoe');
  await page.getByLabel('Password').fill('SecurePass123');
  await page.getByLabel('Confirm Password').fill('SecurePass123');
  await page.getByRole('button', { name: 'Next' }).click();
  
  // Wait for step 3
  await expect(page.getByText('Step 3: Preferences')).toBeVisible();
  
  // Step 3: Preferences
  await page.getByLabel('Newsletter').check();
  await page.getByLabel('Language').selectOption('en');
  await page.getByRole('button', { name: 'Complete Registration' }).click();
  
  // Success!
  await page.waitForURL('/dashboard');
  await expect(page.getByText('Registration successful!')).toBeVisible();
});
                </code></pre>

                <h3>Testing Navigation</h3>
                <pre><code class="language-typescript">
test('navigates through the app', async ({ page }) => {
  await page.goto('/');
  
  // Check we're on home page
  await expect(page).toHaveURL('/');
  await expect(page.getByRole('heading', { name: 'Home' })).toBeVisible();
  
  // Navigate to products
  await page.getByRole('link', { name: 'Products' }).click();
  await expect(page).toHaveURL('/products');
  await expect(page.getByRole('heading', { name: 'Our Products' })).toBeVisible();
  
  // Navigate to specific product
  await page.getByRole('link', { name: 'Laptop' }).click();
  await expect(page).toHaveURL(/\/products\/\d+/);
  await expect(page.getByRole('heading', { name: 'Laptop' })).toBeVisible();
  
  // Use browser back button
  await page.goBack();
  await expect(page).toHaveURL('/products');
  
  // Use browser forward button
  await page.goForward();
  await expect(page).toHaveURL(/\/products\/\d+/);
});
                </code></pre>

                <h3>Working with API Requests</h3>
                <pre><code class="language-typescript">
test('mocks API responses', async ({ page }) => {
  // Mock the API call
  await page.route('/api/products', async (route) => {
    await route.fulfill({
      status: 200,
      contentType: 'application/json',
      body: JSON.stringify([
        { id: 1, name: 'Laptop', price: 999 },
        { id: 2, name: 'Mouse', price: 29 }
      ])
    });
  });
  
  await page.goto('/products');
  
  // Products should be displayed from mock data
  await expect(page.getByText('Laptop')).toBeVisible();
  await expect(page.getByText('$999')).toBeVisible();
});

test('waits for API response', async ({ page }) => {
  await page.goto('/products');
  
  // Wait for API call to complete
  const response = await page.waitForResponse('/api/products');
  expect(response.status()).toBe(200);
  
  // Products should be loaded
  await expect(page.getByRole('article').first()).toBeVisible();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Playwright Best Practices</h4>
                    <ul>
                        <li><strong>Use role-based selectors:</strong> More accessible and stable</li>
                        <li><strong>Wait automatically:</strong> Playwright auto-waits, don't add manual waits</li>
                        <li><strong>Use page.goto() carefully:</strong> Only navigate when needed</li>
                        <li><strong>Mock external APIs:</strong> Make tests deterministic</li>
                        <li><strong>Use test.describe():</strong> Group related tests</li>
                        <li><strong>Take screenshots:</strong> On failure for debugging</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Cypress Introduction -->
            <section id="cypress-intro" class="lesson-section">
                <h2>üå≤ Cypress Introduction</h2>
                
                <p>Cypress is another popular E2E testing framework known for its excellent developer experience and powerful debugging capabilities.</p>

                <h3>Installing Cypress</h3>
                <pre><code class="language-bash">
# Install Cypress
npm install -D cypress

# Open Cypress for first time
npx cypress open
                </code></pre>

                <h3>Project Structure</h3>
                <pre><code class="language-text">
my-app/
‚îú‚îÄ‚îÄ cypress/
‚îÇ   ‚îú‚îÄ‚îÄ e2e/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.cy.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shopping.cy.ts
‚îÇ   ‚îú‚îÄ‚îÄ fixtures/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.json
‚îÇ   ‚îú‚îÄ‚îÄ support/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ e2e.ts
‚îú‚îÄ‚îÄ cypress.config.ts
‚îî‚îÄ‚îÄ package.json
                </code></pre>

                <h3>Basic Cypress Configuration</h3>
                <pre><code class="language-typescript">
// cypress.config.ts
import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:5173',
    viewportWidth: 1280,
    viewportHeight: 720,
    
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
});
                </code></pre>

                <h3>Your First Cypress Test</h3>
                <pre><code class="language-typescript">
// cypress/e2e/example.cy.ts
describe('Homepage', () => {
  it('displays welcome message', () => {
    cy.visit('/');
    cy.contains('h1', 'Welcome').should('be.visible');
  });
});
                </code></pre>

                <h3>Basic Cypress Commands</h3>
                <pre><code class="language-typescript">
describe('User interactions', () => {
  it('can interact with elements', () => {
    cy.visit('/');
    
    // Click a button
    cy.contains('button', 'Click me').click();
    
    // Fill an input
    cy.get('input[name="email"]').type('user@example.com');
    
    // Select from dropdown
    cy.get('select[name="country"]').select('US');
    
    // Check a checkbox
    cy.get('input[type="checkbox"]').check();
    
    // Assert element is visible
    cy.contains('Success!').should('be.visible');
    
    // Assert input value
    cy.get('input[name="email"]').should('have.value', 'user@example.com');
  });
});
                </code></pre>

                <h3>Cypress Selectors</h3>
                <pre><code class="language-typescript">
// By text content
cy.contains('Login')
cy.contains('button', 'Submit')

// By CSS selector
cy.get('.submit-button')
cy.get('#email-input')

// By attribute
cy.get('[data-cy="submit"]')
cy.get('[type="email"]')

// By multiple criteria
cy.get('button').contains('Submit')
                </code></pre>

                <h3>Testing a Login Flow with Cypress</h3>
                <pre><code class="language-typescript">
// cypress/e2e/auth.cy.ts
describe('Authentication', () => {
  beforeEach(() => {
    cy.visit('/login');
  });
  
  it('logs in successfully', () => {
    cy.get('[data-cy="email"]').type('user@example.com');
    cy.get('[data-cy="password"]').type('SecurePass123');
    cy.contains('button', 'Login').click();
    
    // Should redirect to dashboard
    cy.url().should('include', '/dashboard');
    cy.contains('Welcome back').should('be.visible');
  });
  
  it('shows error with invalid credentials', () => {
    cy.get('[data-cy="email"]').type('wrong@example.com');
    cy.get('[data-cy="password"]').type('wrongpass');
    cy.contains('button', 'Login').click();
    
    // Should stay on login
    cy.url().should('include', '/login');
    cy.contains('Invalid credentials').should('be.visible');
  });
});
                </code></pre>

                <h3>Custom Cypress Commands</h3>
                <pre><code class="language-typescript">
// cypress/support/commands.ts
declare global {
  namespace Cypress {
    interface Chainable {
      login(email: string, password: string): Chainable&lt;void&gt;
      logout(): Chainable&lt;void&gt;
    }
  }
}

Cypress.Commands.add('login', (email: string, password: string) => {
  cy.visit('/login');
  cy.get('[data-cy="email"]').type(email);
  cy.get('[data-cy="password"]').type(password);
  cy.contains('button', 'Login').click();
  cy.url().should('include', '/dashboard');
});

Cypress.Commands.add('logout', () => {
  cy.contains('button', 'Logout').click();
  cy.url().should('include', '/login');
});

// Use in tests
describe('Protected pages', () => {
  it('requires authentication', () => {
    cy.login('user@example.com', 'SecurePass123');
    
    // Now logged in, can access protected page
    cy.visit('/profile');
    cy.contains('My Profile').should('be.visible');
    
    cy.logout();
  });
});
                </code></pre>

                <h3>Working with API in Cypress</h3>
                <pre><code class="language-typescript">
describe('Products', () => {
  it('loads products from API', () => {
    // Intercept API call
    cy.intercept('GET', '/api/products', {
      statusCode: 200,
      body: [
        { id: 1, name: 'Laptop', price: 999 },
        { id: 2, name: 'Mouse', price: 29 }
      ]
    }).as('getProducts');
    
    cy.visit('/products');
    
    // Wait for API call
    cy.wait('@getProducts');
    
    // Products should be displayed
    cy.contains('Laptop').should('be.visible');
    cy.contains('$999').should('be.visible');
  });
  
  it('adds product to cart', () => {
    cy.intercept('POST', '/api/cart', {
      statusCode: 201,
      body: { success: true }
    }).as('addToCart');
    
    cy.visit('/products/1');
    cy.contains('button', 'Add to Cart').click();
    
    cy.wait('@addToCart');
    cy.contains('Added to cart').should('be.visible');
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Playwright vs Cypress: Quick Comparison</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Feature</th>
                                <th>Playwright</th>
                                <th>Cypress</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Syntax</strong></td>
                                <td><code>await page.click()</code></td>
                                <td><code>cy.get().click()</code></td>
                            </tr>
                            <tr>
                                <td><strong>Auto-wait</strong></td>
                                <td>Built-in</td>
                                <td>Built-in</td>
                            </tr>
                            <tr>
                                <td><strong>Debugging</strong></td>
                                <td>Trace viewer</td>
                                <td>Time travel, better DX</td>
                            </tr>
                            <tr>
                                <td><strong>Speed</strong></td>
                                <td>Faster</td>
                                <td>Slower</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Section 9: E2E Testing Patterns -->
            <section id="e2e-patterns" class="lesson-section">
                <h2>üéØ E2E Testing Patterns</h2>
                
                <p>Let's explore common patterns and best practices for writing maintainable E2E tests.</p>

                <h3>Page Object Model (POM)</h3>
                <p>The Page Object Model organizes selectors and actions into reusable classes:</p>

                <pre><code class="language-typescript">
// pages/LoginPage.ts
import { Page } from '@playwright/test';

export class LoginPage {
  constructor(private page: Page) {}
  
  // Selectors
  get emailInput() {
    return this.page.getByLabel('Email');
  }
  
  get passwordInput() {
    return this.page.getByLabel('Password');
  }
  
  get submitButton() {
    return this.page.getByRole('button', { name: 'Login' });
  }
  
  get errorMessage() {
    return this.page.getByRole('alert');
  }
  
  // Actions
  async goto() {
    await this.page.goto('/login');
  }
  
  async login(email: string, password: string) {
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.submitButton.click();
  }
  
  async getErrorText() {
    return await this.errorMessage.textContent();
  }
}

// Use in test
import { test, expect } from '@playwright/test';
import { LoginPage } from './pages/LoginPage';

test('user can login', async ({ page }) => {
  const loginPage = new LoginPage(page);
  
  await loginPage.goto();
  await loginPage.login('user@example.com', 'SecurePass123');
  
  await expect(page).toHaveURL('/dashboard');
});
                </code></pre>

                <h3>Test Fixtures for Setup</h3>
                <pre><code class="language-typescript">
// fixtures/auth.fixture.ts
import { test as base } from '@playwright/test';
import { LoginPage } from '../pages/LoginPage';

type AuthFixtures = {
  authenticatedPage: Page;
};

export const test = base.extend&lt;AuthFixtures&gt;({
  authenticatedPage: async ({ page }, use) => {
    const loginPage = new LoginPage(page);
    await loginPage.goto();
    await loginPage.login('user@example.com', 'SecurePass123');
    
    await use(page);
  },
});

// Use in test
test('authenticated user can access profile', async ({ authenticatedPage }) => {
  await authenticatedPage.goto('/profile');
  await expect(authenticatedPage.getByText('My Profile')).toBeVisible();
});
                </code></pre>

                <h3>Testing Complete User Journeys</h3>
                <pre><code class="language-typescript">
test('complete shopping journey', async ({ page }) => {
  // 1. Browse products
  await page.goto('/products');
  await expect(page.getByRole('heading', { name: 'Products' })).toBeVisible();
  
  // 2. Search for product
  await page.getByPlaceholder('Search products').fill('laptop');
  await page.getByRole('button', { name: 'Search' }).click();
  await expect(page.getByText('Gaming Laptop')).toBeVisible();
  
  // 3. View product details
  await page.getByText('Gaming Laptop').click();
  await expect(page).toHaveURL(/\/products\/\d+/);
  await expect(page.getByRole('heading', { name: 'Gaming Laptop' })).toBeVisible();
  
  // 4. Add to cart
  await page.getByRole('button', { name: 'Add to Cart' }).click();
  await expect(page.getByText('Added to cart')).toBeVisible();
  
  // 5. Go to cart
  await page.getByRole('link', { name: 'Cart' }).click();
  await expect(page).toHaveURL('/cart');
  await expect(page.getByText('Gaming Laptop')).toBeVisible();
  
  // 6. Proceed to checkout
  await page.getByRole('button', { name: 'Checkout' }).click();
  await expect(page).toHaveURL('/checkout');
  
  // 7. Fill shipping info
  await page.getByLabel('Full Name').fill('John Doe');
  await page.getByLabel('Address').fill('123 Main St');
  await page.getByLabel('City').fill('New York');
  await page.getByLabel('Zip Code').fill('10001');
  
  // 8. Fill payment info
  await page.getByLabel('Card Number').fill('4111111111111111');
  await page.getByLabel('Expiry').fill('12/25');
  await page.getByLabel('CVV').fill('123');
  
  // 9. Complete order
  await page.getByRole('button', { name: 'Place Order' }).click();
  
  // 10. Verify success
  await expect(page).toHaveURL(/\/orders\/\d+/);
  await expect(page.getByText('Order confirmed!')).toBeVisible();
  await expect(page.getByText('Order #')).toBeVisible();
});
                </code></pre>

                <h3>Testing Responsive Design</h3>
                <pre><code class="language-typescript">
test.describe('Responsive navigation', () => {
  test('shows desktop menu on large screen', async ({ page }) => {
    await page.setViewportSize({ width: 1920, height: 1080 });
    await page.goto('/');
    
    // Desktop menu visible
    await expect(page.getByRole('navigation')).toBeVisible();
    await expect(page.getByRole('link', { name: 'Products' })).toBeVisible();
    
    // Mobile menu not visible
    await expect(page.getByRole('button', { name: 'Menu' })).not.toBeVisible();
  });
  
  test('shows mobile menu on small screen', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    // Mobile menu button visible
    await expect(page.getByRole('button', { name: 'Menu' })).toBeVisible();
    
    // Menu items hidden initially
    await expect(page.getByRole('link', { name: 'Products' })).not.toBeVisible();
    
    // Open mobile menu
    await page.getByRole('button', { name: 'Menu' }).click();
    
    // Menu items now visible
    await expect(page.getByRole('link', { name: 'Products' })).toBeVisible();
  });
});
                </code></pre>

                <h3>Testing File Uploads</h3>
                <pre><code class="language-typescript">
test('uploads profile picture', async ({ page }) => {
  await page.goto('/profile');
  
  // Prepare file to upload
  const filePath = path.join(__dirname, 'fixtures', 'avatar.png');
  
  // Upload file
  await page.getByLabel('Profile Picture').setInputFiles(filePath);
  
  // Submit
  await page.getByRole('button', { name: 'Save' }).click();
  
  // Verify upload
  await expect(page.getByText('Profile updated')).toBeVisible();
  
  // Check image is displayed
  const img = page.getByRole('img', { name: 'Profile picture' });
  await expect(img).toBeVisible();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ E2E Testing Patterns Best Practices</h4>
                    <ul>
                        <li><strong>Use Page Object Model:</strong> Encapsulate page logic</li>
                        <li><strong>Create reusable fixtures:</strong> DRY principle for setup</li>
                        <li><strong>Test complete journeys:</strong> End-to-end user flows</li>
                        <li><strong>Test responsive behavior:</strong> Multiple viewport sizes</li>
                        <li><strong>Use test data factories:</strong> Generate realistic test data</li>
                        <li><strong>Clean up after tests:</strong> Delete created data</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: CI/CD Testing Strategies -->
            <section id="ci-cd" class="lesson-section">
                <h2>üîÑ CI/CD Testing Strategies</h2>
                
                <p>Running tests in Continuous Integration ensures your application stays healthy as the codebase grows.</p>

                <h3>GitHub Actions Example</h3>
                <pre><code class="language-yaml">
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  unit-and-integration:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test:unit
      
      - name: Run integration tests
        run: npm run test:integration
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
  
  e2e:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright
        run: npx playwright install --with-deps
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
                </code></pre>

                <h3>Test Pyramid in CI/CD</h3>
                <div class="mermaid">
                    graph TB
                    A[Git Push] --> B[CI Pipeline Starts]
                    B --> C[Unit Tests: 2-3 min]
                    C --> D{Pass?}
                    D -->|No| E[‚ùå Pipeline Fails]
                    D -->|Yes| F[Integration Tests: 5-10 min]
                    F --> G{Pass?}
                    G -->|No| E
                    G -->|Yes| H[E2E Tests: 10-20 min]
                    H --> I{Pass?}
                    I -->|No| E
                    I -->|Yes| J[‚úÖ Deploy]
                    
                    style C fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style F fill:#339af0,stroke:#1971c2,stroke-width:2px,color:#fff
                    style H fill:#f59f00,stroke:#e67700,stroke-width:2px,color:#fff
                    style E fill:#ff6b6b,stroke:#c92a2a,stroke-width:2px,color:#fff
                    style J fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                </div>

                <h3>Parallel Test Execution</h3>
                <pre><code class="language-typescript">
// playwright.config.ts
export default defineConfig({
  // Run tests in parallel
  workers: process.env.CI ? 2 : undefined,
  
  // Shard tests across machines in CI
  shard: process.env.CI
    ? { current: 1, total: 4 }
    : undefined,
    
  // Retry failed tests
  retries: process.env.CI ? 2 : 0,
});
                </code></pre>

                <h3>Test Reporting</h3>
                <pre><code class="language-typescript">
// playwright.config.ts
export default defineConfig({
  reporter: [
    ['html'],
    ['json', { outputFile: 'test-results.json' }],
    ['junit', { outputFile: 'test-results.xml' }],
    process.env.CI ? ['github'] : ['list']
  ],
});
                </code></pre>

                <h3>Managing Test Data in CI</h3>
                <pre><code class="language-typescript">
// Use environment-specific test data
test.beforeEach(async ({ page }) => {
  // Seed database with test data
  if (process.env.CI) {
    await fetch(`${process.env.API_URL}/test/seed`, {
      method: 'POST',
      headers: { 'X-Test-Token': process.env.TEST_TOKEN }
    });
  }
});

test.afterEach(async () => {
  // Clean up test data
  if (process.env.CI) {
    await fetch(`${process.env.API_URL}/test/cleanup`, {
      method: 'POST',
      headers: { 'X-Test-Token': process.env.TEST_TOKEN }
    });
  }
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° CI/CD Testing Best Practices</h4>
                    <ul>
                        <li><strong>Fast feedback:</strong> Run unit tests first, E2E last</li>
                        <li><strong>Parallel execution:</strong> Speed up test runs</li>
                        <li><strong>Retry flaky tests:</strong> Auto-retry up to 2 times</li>
                        <li><strong>Cache dependencies:</strong> Faster pipeline runs</li>
                        <li><strong>Record artifacts:</strong> Screenshots, videos, traces</li>
                        <li><strong>Monitor test health:</strong> Track flaky tests</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Hands-on Exercises -->
            <section id="exercises" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Exercises</h2>
                
                <p>Practice your integration and E2E testing skills with these comprehensive exercises.</p>

                <!-- Exercise 1 -->
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Test a Shopping Cart Feature</h3>
                    
                    <p><strong>Task:</strong> Write integration tests for a shopping cart that spans multiple components.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Test adding products to cart from product list</li>
                        <li>Test updating quantities in cart</li>
                        <li>Test removing items from cart</li>
                        <li>Test cart total calculation</li>
                        <li>Test cart persistence (Context or Redux)</li>
                        <li>Test empty cart state</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create a test helper that renders your components within the cart provider. Test the complete flow from product list ‚Üí add to cart ‚Üí cart summary ‚Üí remove items. Verify state updates across all components.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <pre><code class="language-typescript">
describe('Shopping Cart Integration', () => {
  function renderWithCart(ui: React.ReactElement) {
    return render(
      &lt;CartProvider&gt;
        {ui}
      &lt;/CartProvider&gt;
    );
  }
  
  it('adds products and updates cart across components', async () => {
    const user = userEvent.setup();
    
    renderWithCart(
      &lt;&gt;
        &lt;ProductList /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Add product
    await user.click(screen.getAllByText('Add to Cart')[0]);
    
    // Verify cart updates
    expect(screen.getByText('1 items')).toBeInTheDocument();
    
    // Update quantity
    await user.click(screen.getByLabelText('Increase quantity'));
    expect(screen.getByText('2 items')).toBeInTheDocument();
    
    // Remove item
    await user.click(screen.getByText('Remove'));
    expect(screen.getByText('0 items')).toBeInTheDocument();
    expect(screen.getByText('Your cart is empty')).toBeInTheDocument();
  });
});
                        </code></pre>
                    </details>
                </div>

                <!-- Exercise 2 -->
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Test Multi-Page User Journey with E2E</h3>
                    
                    <p><strong>Task:</strong> Write a Playwright test for a complete user registration and profile setup flow.</p>
                    
                    <p><strong>User Journey:</strong></p>
                    <ol>
                        <li>User visits homepage</li>
                        <li>Clicks "Sign Up"</li>
                        <li>Fills registration form</li>
                        <li>Confirms email (mock)</li>
                        <li>Completes profile setup</li>
                        <li>Uploads profile picture</li>
                        <li>Views completed profile</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use Page Object Model to organize each page's actions. Mock the email confirmation endpoint. Test each step of the journey, verifying navigation and data persistence between pages.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <pre><code class="language-typescript">
test('complete user registration journey', async ({ page }) => {
  // 1. Homepage
  await page.goto('/');
  await page.getByRole('link', { name: 'Sign Up' }).click();
  
  // 2. Registration
  await expect(page).toHaveURL('/register');
  await page.getByLabel('Email').fill('newuser@example.com');
  await page.getByLabel('Password').fill('SecurePass123');
  await page.getByLabel('Confirm Password').fill('SecurePass123');
  await page.getByRole('button', { name: 'Create Account' }).click();
  
  // 3. Email confirmation (mock)
  await page.route('/api/auth/verify', route => {
    route.fulfill({ status: 200, body: JSON.stringify({ verified: true }) });
  });
  await expect(page).toHaveURL('/verify-email');
  
  // 4. Profile setup
  await expect(page).toHaveURL('/profile/setup');
  await page.getByLabel('Display Name').fill('John Doe');
  await page.getByLabel('Bio').fill('Software developer');
  
  // 5. Upload picture
  await page.getByLabel('Profile Picture').setInputFiles('fixtures/avatar.png');
  await page.getByRole('button', { name: 'Complete Setup' }).click();
  
  // 6. View profile
  await expect(page).toHaveURL('/profile');
  await expect(page.getByText('John Doe')).toBeVisible();
  await expect(page.getByText('Software developer')).toBeVisible();
});
                        </code></pre>
                    </details>
                </div>

                <!-- Exercise 3 -->
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Test Authentication Flow with Protected Routes</h3>
                    
                    <p><strong>Task:</strong> Write integration tests for authentication with route protection.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Test login redirects to dashboard</li>
                        <li>Test logout redirects to login</li>
                        <li>Test protected routes redirect unauthenticated users</li>
                        <li>Test authenticated users can access protected routes</li>
                        <li>Test auth state persists across page navigation</li>
                        <li>Test session expiration</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use MemoryRouter with AuthProvider. Test both successful and failed login attempts. Verify that navigation to protected routes triggers appropriate redirects based on auth state.</p>
                    </details>
                </div>

                <!-- Exercise 4 -->
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 4: Test Real-Time Features</h3>
                    
                    <p><strong>Task:</strong> Write tests for a chat application with real-time messages.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Test sending messages</li>
                        <li>Test receiving messages (mock WebSocket)</li>
                        <li>Test message list updates</li>
                        <li>Test typing indicators</li>
                        <li>Test online/offline status</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Mock WebSocket connection. Use fake timers for typing indicators. Test that messages appear in the correct order and that UI updates reflect connection status.</p>
                    </details>
                </div>
            </section>

            <!-- Section 12: Best Practices -->
            <section id="best-practices" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                
                <p>Follow these guidelines to write maintainable, reliable integration and E2E tests.</p>

                <h3>1. Follow the Testing Pyramid</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do This</h4>
                    <ul>
                        <li>70-80% unit tests (fast, focused)</li>
                        <li>15-25% integration tests (component interactions)</li>
                        <li>5-10% E2E tests (critical user paths)</li>
                    </ul>
                </div>

                <h3>2. Test User Behavior, Not Implementation</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do This</h4>
                    <pre><code class="language-typescript">
// Test what the user sees and does
test('user can submit form', async () => {
  await user.type(screen.getByLabelText('Email'), 'test@example.com');
  await user.click(screen.getByRole('button', { name: 'Submit' }));
  expect(screen.getByText('Success!')).toBeVisible();
});
                    </code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don't Do This</h4>
                    <pre><code class="language-typescript">
// Don't test implementation details
test('form submission calls handleSubmit', () => {
  const handleSubmit = vi.fn();
  render(&lt;Form onSubmit={handleSubmit} /&gt;);
  // Testing internal function calls
});
                    </code></pre>
                </div>

                <h3>3. Use Realistic Test Data</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - realistic data
const testUser = {
  name: 'John Doe',
  email: 'john.doe@example.com',
  age: 32,
  address: {
    street: '123 Main St',
    city: 'New York',
    zip: '10001'
  }
};

// ‚ùå Bad - oversimplified
const testUser = {
  name: 'test',
  email: 'test@test.com'
};
                </code></pre>

                <h3>4. Keep Tests Independent</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - each test sets up its own state
describe('Todo List', () => {
  test('adds todo', async () => {
    render(&lt;TodoList /&gt;);
    // Fresh state, independent test
  });
  
  test('deletes todo', async () => {
    render(&lt;TodoList /&gt;);
    // Fresh state, independent test
  });
});

// ‚ùå Bad - tests depend on each other
describe('Todo List', () => {
  let todoId: string;
  
  test('adds todo', async () => {
    // Sets todoId for next test
  });
  
  test('deletes todo', async () => {
    // Depends on previous test
  });
});
                </code></pre>

                <h3>5. Use Page Object Model for E2E</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - encapsulated page logic
class LoginPage {
  constructor(private page: Page) {}
  
  async login(email: string, password: string) {
    await this.page.getByLabel('Email').fill(email);
    await this.page.getByLabel('Password').fill(password);
    await this.page.getByRole('button', { name: 'Login' }).click();
  }
}

test('user can login', async ({ page }) => {
  const loginPage = new LoginPage(page);
  await loginPage.login('user@example.com', 'pass123');
});

// ‚ùå Bad - repeated selectors
test('user can login', async ({ page }) => {
  await page.getByLabel('Email').fill('user@example.com');
  await page.getByLabel('Password').fill('pass123');
  await page.getByRole('button', { name: 'Login' }).click();
});
                </code></pre>

                <h3>6. Mock External Dependencies</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - mock external APIs
test('loads user data', async () => {
  server.use(
    rest.get('/api/user', (req, res, ctx) => {
      return res(ctx.json({ name: 'John' }));
    })
  );
  
  render(&lt;UserProfile /&gt;);
  expect(await screen.findByText('John')).toBeVisible();
});
                </code></pre>

                <h3>7. Use Descriptive Test Names</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - clear what's being tested
test('displays validation error when email is invalid', () => {});
test('redirects to dashboard after successful login', () => {});
test('shows loading spinner while fetching products', () => {});

// ‚ùå Bad - vague test names
test('works', () => {});
test('test login', () => {});
test('should render', () => {});
                </code></pre>

                <h3>8. Clean Up After Tests</h3>
                <pre><code class="language-typescript">
describe('Database tests', () => {
  beforeEach(async () => {
    await seedDatabase();
  });
  
  afterEach(async () => {
    await cleanDatabase();
  });
  
  test('creates user', async () => {
    // Test runs with clean database
  });
});
                </code></pre>

                <h3>9. Handle Async Operations Properly</h3>
                <pre><code class="language-typescript">
// ‚úÖ Good - wait for async operations
test('loads data', async () => {
  render(&lt;DataComponent /&gt;);
  expect(await screen.findByText('Loaded')).toBeVisible();
});

// ‚ùå Bad - no async handling
test('loads data', () => {
  render(&lt;DataComponent /&gt;);
  expect(screen.getByText('Loaded')).toBeVisible(); // Will fail!
});
                </code></pre>

                <h3>10. Test Accessibility</h3>
                <pre><code class="language-typescript">
test('form is accessible', async () => {
  render(&lt;ContactForm /&gt;);
  
  // Can use labels to find inputs
  expect(screen.getByLabelText('Email')).toBeInTheDocument();
  expect(screen.getByLabelText('Message')).toBeInTheDocument();
  
  // Can use button role
  expect(screen.getByRole('button', { name: 'Submit' })).toBeInTheDocument();
  
  // Test keyboard navigation
  await user.tab();
  expect(screen.getByLabelText('Email')).toHaveFocus();
});
                </code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìã Testing Checklist</h4>
                    <ul style="color: white;">
                        <li>‚úÖ Tests are independent and can run in any order</li>
                        <li>‚úÖ Test names clearly describe what's being tested</li>
                        <li>‚úÖ Using realistic test data</li>
                        <li>‚úÖ Mocking external dependencies (APIs, time, randomness)</li>
                        <li>‚úÖ Testing user behavior, not implementation</li>
                        <li>‚úÖ Proper async handling with await</li>
                        <li>‚úÖ Cleaning up after each test</li>
                        <li>‚úÖ Tests run quickly (< 30 seconds for integration, < 5 min for E2E)</li>
                        <li>‚úÖ Following the testing pyramid</li>
                        <li>‚úÖ Tests are maintainable and easy to update</li>
                    </ul>
                </div>
            </section>

            <!-- Section 13: Summary -->
            <section id="summary" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <p>Congratulations! You've mastered integration and end-to-end testing for React applications. You now understand how to test components working together and complete user workflows.</p>

                <h3>Key Takeaways</h3>
                
                <div class="card">
                    <h4>üéØ Core Concepts</h4>
                    <ol>
                        <li><strong>Test Types Hierarchy</strong>
                            <ul>
                                <li>Unit tests: Fast, focused, many</li>
                                <li>Integration tests: Moderate speed, component interactions</li>
                                <li>E2E tests: Slow, realistic, critical paths only</li>
                            </ul>
                        </li>
                        
                        <li><strong>Integration Testing</strong>
                            <ul>
                                <li>Test multiple components working together</li>
                                <li>Test data flow through component trees</li>
                                <li>Test routing and navigation</li>
                                <li>Test state management (Context, Redux, Zustand)</li>
                            </ul>
                        </li>
                        
                        <li><strong>E2E Testing</strong>
                            <ul>
                                <li>Test in real browsers with Playwright or Cypress</li>
                                <li>Test complete user journeys from start to finish</li>
                                <li>Test critical workflows (auth, checkout, core features)</li>
                                <li>Use Page Object Model for maintainable tests</li>
                            </ul>
                        </li>
                        
                        <li><strong>Tools and Frameworks</strong>
                            <ul>
                                <li>Playwright: Fast, modern, multi-browser support</li>
                                <li>Cypress: Great DX, time travel debugging</li>
                                <li>MSW: Network mocking for both integration and E2E</li>
                                <li>Testing Library: User-centric testing utilities</li>
                            </ul>
                        </li>
                        
                        <li><strong>CI/CD Integration</strong>
                            <ul>
                                <li>Run tests in pipeline (unit ‚Üí integration ‚Üí E2E)</li>
                                <li>Parallel test execution for speed</li>
                                <li>Retry flaky tests automatically</li>
                                <li>Generate test reports and artifacts</li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <h3>The Testing Pyramid Recap</h3>
                <div class="mermaid">
                    graph TB
                    A[Testing Strategy]
                    A --> B[Unit Tests<br/>70-80%<br/>Fast, Many]
                    A --> C[Integration Tests<br/>15-25%<br/>Moderate, Some]
                    A --> D[E2E Tests<br/>5-10%<br/>Slow, Few]
                    
                    B --> E[Functions<br/>Hooks<br/>Utils]
                    C --> F[Components<br/>Routes<br/>State]
                    D --> G[User Flows<br/>Critical Paths<br/>Auth]
                    
                    style B fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style C fill:#339af0,stroke:#1971c2,stroke-width:2px,color:#fff
                    style D fill:#f59f00,stroke:#e67700,stroke-width:2px,color:#fff
                </div>

                <h3>Integration vs E2E: Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>When to Use</th>
                            <th>Integration Tests</th>
                            <th>E2E Tests</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Component interactions</strong></td>
                            <td>‚úÖ Perfect</td>
                            <td>‚ùå Overkill</td>
                        </tr>
                        <tr>
                            <td><strong>Routing flows</strong></td>
                            <td>‚úÖ Good</td>
                            <td>‚úÖ Good</td>
                        </tr>
                        <tr>
                            <td><strong>State management</strong></td>
                            <td>‚úÖ Perfect</td>
                            <td>‚ùå Too slow</td>
                        </tr>
                        <tr>
                            <td><strong>Form validation</strong></td>
                            <td>‚úÖ Perfect</td>
                            <td>‚ùå Too slow</td>
                        </tr>
                        <tr>
                            <td><strong>Critical user journeys</strong></td>
                            <td>‚ùå Not realistic enough</td>
                            <td>‚úÖ Perfect</td>
                        </tr>
                        <tr>
                            <td><strong>Authentication flows</strong></td>
                            <td>‚úÖ Good for logic</td>
                            <td>‚úÖ Good for full flow</td>
                        </tr>
                        <tr>
                            <td><strong>Payment processing</strong></td>
                            <td>‚ùå Not realistic</td>
                            <td>‚úÖ Perfect</td>
                        </tr>
                        <tr>
                            <td><strong>Responsive design</strong></td>
                            <td>‚ùå Can't test</td>
                            <td>‚úÖ Perfect</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Pitfalls to Avoid</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Pitfall</th>
                            <th>Problem</th>
                            <th>Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Too many E2E tests</td>
                            <td>Slow test suite, high maintenance</td>
                            <td>Follow testing pyramid, focus on critical paths</td>
                        </tr>
                        <tr>
                            <td>Testing implementation</td>
                            <td>Brittle tests that break on refactoring</td>
                            <td>Test user behavior and outcomes</td>
                        </tr>
                        <tr>
                            <td>Dependent tests</td>
                            <td>Tests fail in isolation or random order</td>
                            <td>Make each test independent with own setup</td>
                        </tr>
                        <tr>
                            <td>Not mocking external APIs</td>
                            <td>Flaky tests, slow execution</td>
                            <td>Mock with MSW or route handlers</td>
                        </tr>
                        <tr>
                            <td>Poor selectors in E2E</td>
                            <td>Tests break with styling changes</td>
                            <td>Use role-based and accessible selectors</td>
                        </tr>
                        <tr>
                            <td>No CI/CD integration</td>
                            <td>Tests not run regularly</td>
                            <td>Set up automated testing pipeline</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Tools Summary</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üõ†Ô∏è Your Testing Toolkit</h4>
                    <ul>
                        <li><strong>Vitest:</strong> Fast unit test runner</li>
                        <li><strong>React Testing Library:</strong> User-centric component testing</li>
                        <li><strong>MSW:</strong> Network request mocking</li>
                        <li><strong>Playwright:</strong> Modern E2E testing framework</li>
                        <li><strong>Cypress:</strong> Developer-friendly E2E alternative</li>
                        <li><strong>GitHub Actions:</strong> CI/CD automation</li>
                    </ul>
                </div>

                <h3>Next Steps</h3>
                <p>Now that you've mastered testing, you're ready to:</p>
                <ul>
                    <li>Add comprehensive test coverage to your projects</li>
                    <li>Set up CI/CD pipelines with automated testing</li>
                    <li>Write tests that give you confidence to refactor</li>
                    <li>Choose the right test type for each scenario</li>
                    <li>Build reliable, maintainable applications</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéâ Congratulations!</h4>
                    <p>You've completed Lesson 9.5: Integration and E2E Testing! You now have the skills to:</p>
                    <ul>
                        <li>‚úÖ Understand the difference between test types</li>
                        <li>‚úÖ Write integration tests for component interactions</li>
                        <li>‚úÖ Test routing and navigation flows</li>
                        <li>‚úÖ Test state management across components</li>
                        <li>‚úÖ Write E2E tests with Playwright or Cypress</li>
                        <li>‚úÖ Test complete user workflows</li>
                        <li>‚úÖ Set up CI/CD testing pipelines</li>
                        <li>‚úÖ Choose the right test type for each scenario</li>
                    </ul>
                </div>

                <blockquote>
                    <strong>üí° Remember:</strong> "The goal of testing isn't 100% coverage‚Äîit's having confidence that your application works correctly. Focus on testing the things that matter most to your users."
                </blockquote>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üöÄ Module 9 Complete!</h4>
                    <p style="color: white;">You've finished the Testing React Applications module! You've learned:</p>
                    <ul style="color: white;">
                        <li>Testing fundamentals and why testing matters</li>
                        <li>React Testing Library and component testing</li>
                        <li>Testing user interactions and forms</li>
                        <li>Testing asynchronous code and API calls</li>
                        <li>Integration testing and E2E testing</li>
                    </ul>
                    <p style="color: white;"><strong>Next up:</strong> Module 10 - Advanced Topics and Deployment</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav aria-label="Lesson Navigation">
                <div class="lesson-nav">
                    <a href="lesson_9_4_testing_async_code.html" class="nav-button prev-lesson">
                        ‚Üê Previous: Testing Async Code
                    </a>
                    <a href="index.html" class="nav-button home">
                        ‚åÇ Home
                    </a>
                    <a href="module_project_9_testing_ecommerce.html" class="nav-button next-lesson">
                        Next: Module 9 Project ‚Üí
                    </a>
                </div>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="#">Terms of Use</a> |
                <a href="#">Privacy Policy</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
