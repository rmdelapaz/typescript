<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master JSX and TSX syntax - Learn how to write HTML-like code in JavaScript/TypeScript, embed expressions, render conditionally, work with lists, and understand JSX transformations.">
    <meta name="author" content="PracticalAce">
    <title>JSX and TSX - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module2">Module 2: React Basics</a></li>
            <li aria-current="page">Lesson 2.2: JSX and TSX</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üé® JSX and TSX</h1>
                <p class="lead">Welcome to one of React's most distinctive features - JSX! At first glance, mixing HTML with JavaScript might seem strange (remember when we were told to keep them separate?), but JSX is actually one of the things that makes React so powerful and intuitive. It lets you describe your UI structure right alongside the logic that controls it. Once you get comfortable with JSX, you'll wonder how you ever lived without it! Let's explore this game-changing syntax. üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what JSX and TSX are and how they differ</li>
                        <li>Write valid JSX/TSX syntax and understand the rules</li>
                        <li>Embed JavaScript expressions in JSX using curly braces</li>
                        <li>Use conditional rendering techniques (if/else, ternary, logical AND)</li>
                        <li>Render lists of data and understand the importance of keys</li>
                        <li>Handle common JSX gotchas and edge cases</li>
                        <li>Apply JSX best practices for clean, maintainable code</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a dynamic product catalog with conditional rendering and list mapping</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What is JSX/TSX?</a></li>
                        <li><a href="#section2" class="toc-link">JSX Syntax Rules</a></li>
                        <li><a href="#section3" class="toc-link">Embedding Expressions</a></li>
                        <li><a href="#section4" class="toc-link">JSX Attributes</a></li>
                        <li><a href="#section5" class="toc-link">Conditional Rendering</a></li>
                        <li><a href="#section6" class="toc-link">Rendering Lists</a></li>
                        <li><a href="#section7" class="toc-link">Fragments</a></li>
                        <li><a href="#section8" class="toc-link">JSX Gotchas</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What is JSX/TSX? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What is JSX/TSX?</h2>
                <p>JSX stands for JavaScript XML. It's a syntax extension to JavaScript that lets you write HTML-like code directly in your JavaScript files. When you use TypeScript with React, it's called TSX (TypeScript XML).</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>JSX/TSX:</strong> A syntax extension that allows you to write HTML-like markup inside JavaScript/TypeScript. It's not a string, not HTML, but a syntax that gets transformed into regular JavaScript function calls.</p>
                </div>

                <h3>JSX vs TSX</h3>
                <p>The difference is simple:</p>
                <ul>
                    <li><strong>JSX</strong> - Used in <code>.jsx</code> files (JavaScript + JSX)</li>
                    <li><strong>TSX</strong> - Used in <code>.tsx</code> files (TypeScript + JSX)</li>
                </ul>

                <p>Since we're using TypeScript throughout this course, we'll write TSX. The syntax is identical - the only difference is you get TypeScript's type checking! üí™</p>

                <h3>Why JSX Exists</h3>
                <p>Before JSX, creating React elements looked like this:</p>

                <pre><code class="language-typescript">// Without JSX - using React.createElement
const element = React.createElement(
    'h1',
    { className: 'greeting' },
    'Hello, ',
    React.createElement('span', null, 'World'),
    '!'
);</code></pre>

                <p>With JSX, you can write the same thing much more intuitively:</p>

                <pre><code class="language-typescript">// With JSX - much more readable!
const element = (
    &lt;h1 className="greeting"&gt;
        Hello, &lt;span&gt;World&lt;/span&gt;!
    &lt;/h1&gt;
);</code></pre>

                <p>JSX makes your code look like the UI it creates. This makes it easier to visualize, understand, and maintain your components!</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° JSX is Optional</h4>
                    <p>You don't <em>have</em> to use JSX with React - you can use <code>React.createElement</code> directly. But 99.9% of React developers use JSX because it's so much better! Think of JSX as syntactic sugar that makes your life easier.</p>
                </div>

                <h3>How JSX Works</h3>
                <p>JSX is not valid JavaScript on its own. Your code goes through a transformation process:</p>

                <div class="mermaid">
                    graph LR
                    A[Write JSX/TSX] --> B[Babel/Compiler]
                    B --> C[Transform to React.createElement calls]
                    C --> D[Create React Elements]
                    D --> E[Virtual DOM]
                    E --> F[Real DOM]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style F fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <!-- Interactive JSX Transformation Visualizer -->
                <div class="card" style="margin-top: 2rem;">
                    <h4>üé® Interactive: JSX Transformation Visualizer</h4>
                    <p>Watch JSX transform into JavaScript! Click different JSX examples to see how they compile:</p>
                    
                    <svg id="jsx-transform-svg" viewBox="0 0 600 320" style="width: 100%; max-width: 600px; display: block; margin: 1rem auto;" role="img" aria-label="JSX transformation visualization">
                        <!-- Background -->
                        <rect x="0" y="0" width="600" height="320" fill="#f8f9fa" rx="8"/>
                        
                        <!-- Title -->
                        <text x="300" y="22" text-anchor="middle" fill="#667eea" font-weight="bold" font-size="13">JSX ‚Üí JavaScript Transformation</text>
                        
                        <!-- JSX Code Box -->
                        <rect x="20" y="35" width="270" height="120" fill="#e3f2fd" rx="6" stroke="#2196F3" stroke-width="2"/>
                        <text x="155" y="52" text-anchor="middle" fill="#2196F3" font-weight="bold" font-size="11">JSX (What you write)</text>
                        <text id="jsx-line1" x="30" y="75" fill="#333" font-family="monospace" font-size="10">&lt;button onClick={handleClick}&gt;</text>
                        <text id="jsx-line2" x="30" y="92" fill="#333" font-family="monospace" font-size="10">  Click me!</text>
                        <text id="jsx-line3" x="30" y="109" fill="#333" font-family="monospace" font-size="10">&lt;/button&gt;</text>
                        <text id="jsx-line4" x="30" y="126" fill="#333" font-family="monospace" font-size="10"></text>
                        <text id="jsx-line5" x="30" y="143" fill="#333" font-family="monospace" font-size="10"></text>
                        
                        <!-- Arrow -->
                        <path d="M 295 95 L 305 95" stroke="#667eea" stroke-width="3" fill="none"/>
                        <polygon points="305,90 315,95 305,100" fill="#667eea"/>
                        <text x="305" y="85" fill="#667eea" font-size="9" font-weight="bold">Babel</text>
                        
                        <!-- JavaScript Code Box -->
                        <rect x="320" y="35" width="260" height="120" fill="#e8f5e9" rx="6" stroke="#4CAF50" stroke-width="2"/>
                        <text x="450" y="52" text-anchor="middle" fill="#4CAF50" font-weight="bold" font-size="11">JavaScript (What runs)</text>
                        <text id="js-line1" x="330" y="75" fill="#333" font-family="monospace" font-size="9">React.createElement(</text>
                        <text id="js-line2" x="330" y="90" fill="#333" font-family="monospace" font-size="9">  'button',</text>
                        <text id="js-line3" x="330" y="105" fill="#333" font-family="monospace" font-size="9">  { onClick: handleClick },</text>
                        <text id="js-line4" x="330" y="120" fill="#333" font-family="monospace" font-size="9">  'Click me!'</text>
                        <text id="js-line5" x="330" y="135" fill="#333" font-family="monospace" font-size="9">)</text>
                        <text id="js-line6" x="330" y="150" fill="#333" font-family="monospace" font-size="9"></text>
                        
                        <!-- React Element Box -->
                        <rect x="150" y="170" width="300" height="90" fill="#fff8e1" rx="6" stroke="#FF9800" stroke-width="2"/>
                        <text x="300" y="187" text-anchor="middle" fill="#FF9800" font-weight="bold" font-size="11">React Element Object (Result)</text>
                        <text id="elem-line1" x="160" y="207" fill="#333" font-family="monospace" font-size="9">{ type: 'button',</text>
                        <text id="elem-line2" x="160" y="222" fill="#333" font-family="monospace" font-size="9">  props: { onClick: fn, children: 'Click me!' } }</text>
                        <text id="elem-line3" x="160" y="237" fill="#333" font-family="monospace" font-size="9"></text>
                        <text id="elem-line4" x="160" y="252" fill="#333" font-family="monospace" font-size="9"></text>
                        
                        <!-- Info Box -->
                        <rect x="20" y="275" width="560" height="35" fill="white" rx="4" stroke="#667eea"/>
                        <text id="jsx-transform-info" x="300" y="297" text-anchor="middle" fill="#333" font-size="11">Click an example below to see how different JSX transforms!</text>
                    </svg>
                    
                    <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem;">
                        <button onclick="showJsxTransform('button')" style="padding: 0.4rem 0.8rem; border: none; background: #2196F3; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">&lt;button&gt;</button>
                        <button onclick="showJsxTransform('div')" style="padding: 0.4rem 0.8rem; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">&lt;div&gt; nested</button>
                        <button onclick="showJsxTransform('input')" style="padding: 0.4rem 0.8rem; border: none; background: #FF9800; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">&lt;input /&gt;</button>
                        <button onclick="showJsxTransform('component')" style="padding: 0.4rem 0.8rem; border: none; background: #9C27B0; color: white; border-radius: 4px; cursor: pointer; font-size: 11px;">&lt;MyComponent /&gt;</button>
                    </div>
                </div>
                
                <script>
                (function() {
                    const transforms = {
                        button: {
                            jsx: [
                                '<button onClick={handleClick}>',
                                '  Click me!',
                                '</button>',
                                '', ''
                            ],
                            js: [
                                'React.createElement(',
                                "  'button',",
                                '  { onClick: handleClick },',
                                "  'Click me!'",
                                ')', ''
                            ],
                            elem: [
                                "{ type: 'button',",
                                "  props: { onClick: fn, children: 'Click me!' } }",
                                '', ''
                            ],
                            info: 'Simple button: tag name becomes string, props become object, text becomes children'
                        },
                        div: {
                            jsx: [
                                '<div className="card">',
                                '  <h1>Title</h1>',
                                '  <p>Content</p>',
                                '</div>', ''
                            ],
                            js: [
                                'React.createElement("div",',
                                '  { className: "card" },',
                                '  React.createElement("h1", null, "Title"),',
                                '  React.createElement("p", null, "Content")',
                                ')', ''
                            ],
                            elem: [
                                "{ type: 'div', props: { className: 'card',",
                                '    children: [',
                                "      { type: 'h1', props: {children: 'Title'} },",
                                "      { type: 'p', props: {children: 'Content'} } ] } }"
                            ],
                            info: 'Nested elements: each child becomes a nested createElement call'
                        },
                        input: {
                            jsx: [
                                '<input',
                                '  type="text"',
                                '  value={name}',
                                '  onChange={handleChange}',
                                '/>'
                            ],
                            js: [
                                'React.createElement(',
                                "  'input',",
                                '  { type: "text",',
                                '    value: name,',
                                '    onChange: handleChange }', ')'
                            ],
                            elem: [
                                "{ type: 'input',",
                                '  props: { type: "text", value: name,',
                                '    onChange: handleChange } }', ''
                            ],
                            info: 'Self-closing tag: no children, all attributes become props'
                        },
                        component: {
                            jsx: [
                                '<UserCard',
                                '  name="Alice"',
                                '  age={30}',
                                '  isActive',
                                '/>'
                            ],
                            js: [
                                'React.createElement(',
                                '  UserCard,  // Note: NOT a string!',
                                '  { name: "Alice",',
                                '    age: 30,',
                                '    isActive: true }', ')'
                            ],
                            elem: [
                                '{ type: UserCard,  // Function reference!',
                                '  props: { name: "Alice", age: 30,',
                                '    isActive: true } }', ''
                            ],
                            info: 'Components: type is function reference (not string), boolean props default to true'
                        }
                    };
                    
                    window.showJsxTransform = function(type) {
                        const t = transforms[type];
                        
                        // Update JSX lines
                        for (let i = 0; i < 5; i++) {
                            document.getElementById('jsx-line' + (i+1)).textContent = t.jsx[i] || '';
                        }
                        
                        // Update JS lines
                        for (let i = 0; i < 6; i++) {
                            document.getElementById('js-line' + (i+1)).textContent = t.js[i] || '';
                        }
                        
                        // Update element lines
                        for (let i = 0; i < 4; i++) {
                            document.getElementById('elem-line' + (i+1)).textContent = t.elem[i] || '';
                        }
                        
                        document.getElementById('jsx-transform-info').textContent = t.info;
                    };
                })();
                </script>

                <p>Let's see this transformation in action:</p>

                <pre><code class="language-typescript">// You write this JSX:
const button = (
    &lt;button onClick={handleClick} className="btn"&gt;
        Click me
    &lt;/button&gt;
);

// It gets transformed to this JavaScript:
const button = React.createElement(
    'button',
    { 
        onClick: handleClick,
        className: 'btn'
    },
    'Click me'
);

// Which creates this React element object:
const button = {
    type: 'button',
    props: {
        onClick: handleClick,
        className: 'btn',
        children: 'Click me'
    }
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Build Process Handles It</h4>
                    <p>When you use tools like Vite, Create React App, or Next.js, the JSX transformation happens automatically during the build process. You just write JSX and everything works! The tool chain includes Babel or the TypeScript compiler to handle the transformation.</p>
                </div>

                <h3>TSX Type Safety</h3>
                <p>Using TSX with TypeScript gives you amazing type safety:</p>

                <pre><code class="language-typescript">interface ButtonProps {
    text: string;
    onClick: () => void;
    disabled?: boolean;
}

function MyButton({ text, onClick, disabled }: ButtonProps) {
    return (
        &lt;button onClick={onClick} disabled={disabled}&gt;
            {text}
        &lt;/button&gt;
    );
}

// TypeScript catches errors:
&lt;MyButton text="Click" onClick={() => {}} /&gt;  // ‚úÖ Correct
&lt;MyButton text={123} onClick={() => {}} /&gt;     // ‚ùå Error: text should be string
&lt;MyButton onClick={() => {}} /&gt;                // ‚ùå Error: text is required</code></pre>
            </section>

            <!-- Section 2: JSX Syntax Rules -->
            <section id="section2" class="lesson-section">
                <h2>üìè JSX Syntax Rules</h2>
                <p>JSX looks like HTML, but it has some important differences. Let's learn the rules so you can write valid JSX!</p>

                <h3>Rule 1: Return a Single Root Element</h3>
                <p>Every JSX expression must have exactly one root element. You can't return multiple elements at the same level.</p>

                <pre><code class="language-typescript">// ‚ùå WRONG - Multiple root elements
function BadComponent() {
    return (
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Paragraph&lt;/p&gt;
    );
}

// ‚úÖ CORRECT - Single root element wrapping everything
function GoodComponent() {
    return (
        &lt;div&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Paragraph&lt;/p&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ ALSO CORRECT - Using a Fragment (we'll cover this later)
function AlsoGoodComponent() {
    return (
        &lt;&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Paragraph&lt;/p&gt;
        &lt;/&gt;
    );
}</code></pre>

                <h3>Rule 2: Close All Tags</h3>
                <p>In HTML, some tags can be left unclosed. In JSX, every tag must be closed!</p>

                <pre><code class="language-typescript">// ‚ùå WRONG in JSX (even though valid in HTML)
&lt;img src="photo.jpg"&gt;
&lt;br&gt;
&lt;input type="text"&gt;

// ‚úÖ CORRECT - Self-closing tags
&lt;img src="photo.jpg" /&gt;
&lt;br /&gt;
&lt;input type="text" /&gt;</code></pre>

                <h3>Rule 3: Use camelCase for Attributes</h3>
                <p>JSX uses camelCase for most attributes instead of HTML's kebab-case.</p>

                <pre><code class="language-typescript">// HTML attributes
&lt;div class="container" tabindex="0" onclick="handleClick()"&gt;

// JSX attributes (camelCase)
&lt;div className="container" tabIndex={0} onClick={handleClick}&gt;</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>HTML</th>
                            <th>JSX/TSX</th>
                            <th>Reason</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>class</code></td>
                            <td><code>className</code></td>
                            <td>class is a reserved word in JavaScript</td>
                        </tr>
                        <tr>
                            <td><code>for</code></td>
                            <td><code>htmlFor</code></td>
                            <td>for is a reserved word in JavaScript</td>
                        </tr>
                        <tr>
                            <td><code>tabindex</code></td>
                            <td><code>tabIndex</code></td>
                            <td>Follows JavaScript naming convention</td>
                        </tr>
                        <tr>
                            <td><code>onclick</code></td>
                            <td><code>onClick</code></td>
                            <td>Follows JavaScript naming convention</td>
                        </tr>
                        <tr>
                            <td><code>maxlength</code></td>
                            <td><code>maxLength</code></td>
                            <td>Follows JavaScript naming convention</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Rule 4: Use Curly Braces for JavaScript</h3>
                <p>To embed JavaScript expressions in JSX, wrap them in curly braces <code>{}</code>:</p>

                <pre><code class="language-typescript">const name = "Alice";
const age = 30;

// Use curly braces to embed JavaScript
const element = (
    &lt;div&gt;
        &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
        &lt;p&gt;You are {age} years old.&lt;/p&gt;
        &lt;p&gt;Next year you'll be {age + 1}!&lt;/p&gt;
    &lt;/div&gt;
);</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è JSX Expressions Must Have a Value</h4>
                    <p>You can only use <em>expressions</em> in curly braces, not statements. Expressions evaluate to a value, statements don't.</p>
                    <pre><code class="language-typescript">// ‚úÖ Expressions (return a value)
{name}
{2 + 2}
{user.firstName}
{isLoggedIn ? 'Logout' : 'Login'}
{numbers.map(n => n * 2)}

// ‚ùå Statements (don't return a value)
{if (x > 5) { ... }}        // Use ternary instead
{for (let i = 0; ...) {}}   // Use map instead
{const x = 5}               // Define variables outside JSX</code></pre>
                </div>

                <h3>Rule 5: Comments in JSX</h3>
                <p>Comments in JSX need to be wrapped in curly braces:</p>

                <pre><code class="language-typescript">function MyComponent() {
    return (
        &lt;div&gt;
            {/* This is a comment in JSX */}
            &lt;h1&gt;Title&lt;/h1&gt;
            
            {/* 
                Multi-line comment
                in JSX
            */}
            &lt;p&gt;Content&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Rule 6: Boolean Attributes</h3>
                <p>For boolean attributes, you can omit the value if it's <code>true</code>:</p>

                <pre><code class="language-typescript">// These are equivalent
&lt;input type="text" disabled={true} /&gt;
&lt;input type="text" disabled /&gt;

// Explicitly set to false
&lt;input type="text" disabled={false} /&gt;

// Conditional
&lt;button disabled={isLoading}&gt;Submit&lt;/button&gt;</code></pre>

                <div class="mermaid">
                    graph TD
                    A[Write JSX] --> B{Valid Syntax?}
                    B -->|Single root| C{All tags closed?}
                    B -->|Multiple roots| X[‚ùå Error]
                    C -->|Yes| D{camelCase attributes?}
                    C -->|No| X
                    D -->|Yes| E[‚úÖ Valid JSX]
                    D -->|No| X
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style X fill:#f44336,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 3: Embedding Expressions -->
            <section id="section3" class="lesson-section">
                <h2>üîß Embedding Expressions</h2>
                <p>One of JSX's superpowers is the ability to embed JavaScript expressions directly in your markup. Let's explore all the ways you can do this!</p>

                <h3>Basic Expression Embedding</h3>
                <p>Wrap any JavaScript expression in curly braces:</p>

                <pre><code class="language-typescript">function UserGreeting() {
    const user = {
        firstName: "Alice",
        lastName: "Johnson",
        age: 30
    };
    
    const currentYear = new Date().getFullYear();
    
    return (
        &lt;div&gt;
            {/* Simple variables */}
            &lt;h1&gt;{user.firstName} {user.lastName}&lt;/h1&gt;
            
            {/* Object properties */}
            &lt;p&gt;Age: {user.age}&lt;/p&gt;
            
            {/* Expressions and calculations */}
            &lt;p&gt;Birth year: {currentYear - user.age}&lt;/p&gt;
            
            {/* Function calls */}
            &lt;p&gt;Uppercase name: {user.firstName.toUpperCase()}&lt;/p&gt;
            
            {/* Template literals */}
            &lt;p&gt;{`Hello, ${user.firstName}!`}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Expressions in Attributes</h3>
                <p>You can use expressions in attributes too:</p>

                <pre><code class="language-typescript">function ImageGallery() {
    const imageUrl = "https://example.com/photo.jpg";
    const altText = "Beautiful landscape";
    const imageWidth = 500;
    const isLarge = true;
    
    return (
        &lt;img 
            src={imageUrl}
            alt={altText}
            width={imageWidth}
            className={isLarge ? "large-image" : "small-image"}
            style={{
                border: '2px solid #ccc',
                borderRadius: '8px'
            }}
        /&gt;
    );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Style Objects</h4>
                    <p>Notice the double curly braces in <code>style={{}}</code>? The outer braces mean "JavaScript expression", and the inner braces are a JavaScript object. Styles use camelCase: <code>backgroundColor</code> not <code>background-color</code>.</p>
                </div>

                <h3>Complex Expressions</h3>
                <p>You can use more complex JavaScript expressions:</p>

                <pre><code class="language-typescript">function ProductCard() {
    const product = {
        name: "Laptop",
        price: 999,
        inStock: true,
        rating: 4.5,
        reviews: 128
    };
    
    return (
        &lt;div className="product-card"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            
            {/* Mathematical operations */}
            &lt;p&gt;Price: ${product.price.toFixed(2)}&lt;/p&gt;
            &lt;p&gt;With tax: ${(product.price * 1.08).toFixed(2)}&lt;/p&gt;
            
            {/* String methods */}
            &lt;p&gt;{product.name.toLowerCase().replace(/\s+/g, '-')}.jpg&lt;/p&gt;
            
            {/* Array methods */}
            &lt;p&gt;Rating: {'‚≠ê'.repeat(Math.floor(product.rating))}&lt;/p&gt;
            
            {/* Logical expressions */}
            &lt;p&gt;{product.inStock && `${product.reviews} reviews`}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Function Calls</h3>
                <p>You can call functions in JSX expressions:</p>

                <pre><code class="language-typescript">function formatDate(date: Date): string {
    return date.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
    });
}

function formatPrice(price: number): string {
    return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD'
    }).format(price);
}

function OrderSummary() {
    const order = {
        date: new Date(),
        total: 1234.56,
        items: 5
    };
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Order Summary&lt;/h2&gt;
            &lt;p&gt;Date: {formatDate(order.date)}&lt;/p&gt;
            &lt;p&gt;Total: {formatPrice(order.total)}&lt;/p&gt;
            &lt;p&gt;Items: {order.items}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Extract Complex Logic</h4>
                    <p>When expressions get complex, extract them into functions or variables. This makes your JSX cleaner and easier to test. Keep your JSX focused on structure, not complex logic!</p>
                </div>

                <!-- Interactive Expression Types Reference -->
                <div class="card" style="margin-top: 2rem;">
                    <h4>üé® Interactive: What Can Go Inside { }?</h4>
                    <p>Click each expression type to see examples and understand what works in JSX curly braces:</p>
                    
                    <svg id="expr-types-svg" viewBox="0 0 580 280" style="width: 100%; max-width: 580px; display: block; margin: 1rem auto;" role="img" aria-label="JSX expression types">
                        <!-- Background -->
                        <rect x="0" y="0" width="580" height="280" fill="#f8f9fa" rx="8"/>
                        
                        <!-- Title -->
                        <text x="290" y="20" text-anchor="middle" fill="#667eea" font-weight="bold" font-size="13">What Can Go Inside { } in JSX?</text>
                        
                        <!-- Valid expressions grid -->
                        <text x="150" y="42" text-anchor="middle" fill="#4CAF50" font-weight="bold" font-size="11">‚úÖ VALID Expressions</text>
                        
                        <!-- Expression type boxes -->
                        <g id="expr-var" style="cursor: pointer;" onclick="showExprType('var')">
                            <rect x="15" y="50" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="57" y="72" text-anchor="middle" fill="#333" font-size="10">Variables</text>
                        </g>
                        
                        <g id="expr-math" style="cursor: pointer;" onclick="showExprType('math')">
                            <rect x="105" y="50" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="147" y="72" text-anchor="middle" fill="#333" font-size="10">Math</text>
                        </g>
                        
                        <g id="expr-ternary" style="cursor: pointer;" onclick="showExprType('ternary')">
                            <rect x="195" y="50" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="237" y="72" text-anchor="middle" fill="#333" font-size="10">Ternary</text>
                        </g>
                        
                        <g id="expr-func" style="cursor: pointer;" onclick="showExprType('func')">
                            <rect x="15" y="90" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="57" y="112" text-anchor="middle" fill="#333" font-size="10">Functions</text>
                        </g>
                        
                        <g id="expr-map" style="cursor: pointer;" onclick="showExprType('map')">
                            <rect x="105" y="90" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="147" y="112" text-anchor="middle" fill="#333" font-size="10">Array.map()</text>
                        </g>
                        
                        <g id="expr-template" style="cursor: pointer;" onclick="showExprType('template')">
                            <rect x="195" y="90" width="85" height="35" fill="#e8f5e9" rx="4" stroke="#4CAF50" stroke-width="1.5"/>
                            <text x="237" y="112" text-anchor="middle" fill="#333" font-size="10">Template Lit</text>
                        </g>
                        
                        <!-- Invalid expressions -->
                        <text x="435" y="42" text-anchor="middle" fill="#f44336" font-weight="bold" font-size="11">‚ùå INVALID Statements</text>
                        
                        <g id="expr-if" style="cursor: pointer;" onclick="showExprType('if')">
                            <rect x="300" y="50" width="85" height="35" fill="#ffebee" rx="4" stroke="#f44336" stroke-width="1.5"/>
                            <text x="342" y="72" text-anchor="middle" fill="#333" font-size="10">if/else</text>
                        </g>
                        
                        <g id="expr-for" style="cursor: pointer;" onclick="showExprType('for')">
                            <rect x="390" y="50" width="85" height="35" fill="#ffebee" rx="4" stroke="#f44336" stroke-width="1.5"/>
                            <text x="432" y="72" text-anchor="middle" fill="#333" font-size="10">for loops</text>
                        </g>
                        
                        <g id="expr-const" style="cursor: pointer;" onclick="showExprType('const')">
                            <rect x="480" y="50" width="85" height="35" fill="#ffebee" rx="4" stroke="#f44336" stroke-width="1.5"/>
                            <text x="522" y="72" text-anchor="middle" fill="#333" font-size="10">const/let</text>
                        </g>
                        
                        <g id="expr-obj" style="cursor: pointer;" onclick="showExprType('obj')">
                            <rect x="345" y="90" width="85" height="35" fill="#ffebee" rx="4" stroke="#f44336" stroke-width="1.5"/>
                            <text x="387" y="112" text-anchor="middle" fill="#333" font-size="10">Objects</text>
                        </g>
                        
                        <g id="expr-foreach" style="cursor: pointer;" onclick="showExprType('foreach')">
                            <rect x="435" y="90" width="85" height="35" fill="#ffebee" rx="4" stroke="#f44336" stroke-width="1.5"/>
                            <text x="477" y="112" text-anchor="middle" fill="#333" font-size="10">forEach()</text>
                        </g>
                        
                        <!-- Example display area -->
                        <rect x="15" y="135" width="550" height="135" fill="white" rx="6" stroke="#667eea" stroke-width="2"/>
                        <text id="expr-title" x="290" y="155" text-anchor="middle" fill="#667eea" font-weight="bold" font-size="12">Click an expression type above</text>
                        <text id="expr-code1" x="25" y="180" fill="#333" font-family="monospace" font-size="11"></text>
                        <text id="expr-code2" x="25" y="198" fill="#333" font-family="monospace" font-size="11"></text>
                        <text id="expr-code3" x="25" y="216" fill="#333" font-family="monospace" font-size="11"></text>
                        <text id="expr-result" x="25" y="240" fill="#666" font-size="11"></text>
                        <text id="expr-tip" x="25" y="260" fill="#2196F3" font-size="10"></text>
                    </svg>
                </div>
                
                <script>
                (function() {
                    const exprTypes = {
                        var: {
                            title: '‚úÖ Variables & Properties',
                            code: ['{name}', '{user.firstName}', '{items.length}'],
                            result: 'Result: Displays the value directly',
                            tip: 'Tip: Any variable in scope can be used!'
                        },
                        math: {
                            title: '‚úÖ Math & Calculations',
                            code: ['{2 + 2}', '{price * 1.08}', '{Math.round(4.7)}'],
                            result: 'Result: Evaluates and displays the number',
                            tip: 'Tip: Great for displaying computed values!'
                        },
                        ternary: {
                            title: '‚úÖ Ternary Operator',
                            code: ['{isLoggedIn ? "Welcome" : "Login"}', '{count > 0 ? count : "None"}', '{active && <Badge />}'],
                            result: 'Result: Conditional expression that returns a value',
                            tip: 'Tip: Use for simple if/else in JSX!'
                        },
                        func: {
                            title: '‚úÖ Function Calls',
                            code: ['{formatDate(date)}', '{user.getName()}', '{items.join(", ")}'],
                            result: 'Result: Displays the return value',
                            tip: 'Tip: Extract complex logic to functions!'
                        },
                        map: {
                            title: '‚úÖ Array.map()',
                            code: ['{items.map(item => (', '  <li key={item.id}>{item.name}</li>', '))}'],
                            result: 'Result: Returns array of JSX elements',
                            tip: 'Tip: Always include a key prop!'
                        },
                        template: {
                            title: '‚úÖ Template Literals',
                            code: ['{`Hello, ${name}!`}', '{`Total: ${price.toFixed(2)}`}', '{`${firstName} ${lastName}`}'],
                            result: 'Result: Displays interpolated string',
                            tip: 'Tip: Great for complex string formatting!'
                        },
                        if: {
                            title: '‚ùå if/else Statements',
                            code: ['// WRONG:', '{if (x > 5) { return <p>Big</p> }}', '// Use ternary instead: {x > 5 ? <p>Big</p> : null}'],
                            result: 'Error: Statements don\'t return values',
                            tip: 'Fix: Use ternary operator or move if/else outside JSX'
                        },
                        for: {
                            title: '‚ùå for Loops',
                            code: ['// WRONG:', '{for (let i=0; i<5; i++) { ... }}', '// Use map instead: {[1,2,3,4,5].map(n => ...)}'],
                            result: 'Error: for is a statement, not an expression',
                            tip: 'Fix: Use .map(), .filter(), or create array before JSX'
                        },
                        const: {
                            title: '‚ùå Variable Declarations',
                            code: ['// WRONG:', '{const x = 5}', '// Declare BEFORE the return statement'],
                            result: 'Error: Declarations are statements',
                            tip: 'Fix: Declare variables before the JSX return'
                        },
                        obj: {
                            title: '‚ùå Plain Objects',
                            code: ['// WRONG:', '{user}  // if user is an object', '// Use: {user.name} or {JSON.stringify(user)}'],
                            result: 'Error: Objects are not valid React children',
                            tip: 'Fix: Access specific properties or convert to string'
                        },
                        foreach: {
                            title: '‚ùå forEach()',
                            code: ['// WRONG:', '{items.forEach(item => <li>{item}</li>)}', '// forEach returns undefined, use map()!'],
                            result: 'Error: forEach returns undefined, not an array',
                            tip: 'Fix: Use .map() instead - it returns a new array'
                        }
                    };
                    
                    window.showExprType = function(type) {
                        const e = exprTypes[type];
                        document.getElementById('expr-title').textContent = e.title;
                        document.getElementById('expr-code1').textContent = e.code[0] || '';
                        document.getElementById('expr-code2').textContent = e.code[1] || '';
                        document.getElementById('expr-code3').textContent = e.code[2] || '';
                        document.getElementById('expr-result').textContent = e.result;
                        document.getElementById('expr-tip').textContent = e.tip;
                        
                        // Highlight selected box
                        document.querySelectorAll('[id^="expr-"]').forEach(g => {
                            if (g.tagName === 'g') {
                                const rect = g.querySelector('rect');
                                if (rect) {
                                    const isSelected = g.id === 'expr-' + type;
                                    rect.setAttribute('stroke-width', isSelected ? '3' : '1.5');
                                }
                            }
                        });
                    };
                })();
                </script>

                <h3>What You Can't Do</h3>
                <p>Some things don't work in JSX expressions:</p>

                <pre><code class="language-typescript">function WrongExamples() {
    return (
        &lt;div&gt;
            {/* ‚ùå Can't use if statements */}
            {if (user.isAdmin) { return &lt;p&gt;Admin&lt;/p&gt; }}
            
            {/* ‚ùå Can't use for loops */}
            {for (let i = 0; i &lt; 5; i++) { ... }}
            
            {/* ‚ùå Can't declare variables */}
            {const message = "Hello"}
            
            {/* ‚ùå Can't use multiple statements */}
            {
                const x = 5;
                return x * 2;
            }
        &lt;/div&gt;
    );
}

function CorrectExamples() {
    // ‚úÖ Declare variables outside JSX
    const message = "Hello";
    const items = [1, 2, 3, 4, 5];
    
    return (
        &lt;div&gt;
            {/* ‚úÖ Use ternary for conditions */}
            {user.isAdmin ? &lt;p&gt;Admin&lt;/p&gt; : &lt;p&gt;User&lt;/p&gt;}
            
            {/* ‚úÖ Use map for loops */}
            {items.map(item => &lt;p key={item}&gt;{item}&lt;/p&gt;)}
            
            {/* ‚úÖ Use variables */}
            &lt;p&gt;{message}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
            </section>

            <!-- Section 4: JSX Attributes -->
            <section id="section4" class="lesson-section">
                <h2>üè∑Ô∏è JSX Attributes</h2>
                <p>Attributes in JSX work similarly to HTML, but with some important differences. Let's explore how to work with them effectively!</p>

                <h3>String Attributes</h3>
                <p>String values can be wrapped in quotes or curly braces:</p>

                <pre><code class="language-typescript">// Both work the same
&lt;img src="photo.jpg" alt="A photo" /&gt;
&lt;img src={"photo.jpg"} alt={"A photo"} /&gt;

// Use quotes for static strings
&lt;input type="text" placeholder="Enter your name" /&gt;

// Use curly braces for dynamic strings
const placeholder = "Enter your name";
&lt;input type="text" placeholder={placeholder} /&gt;</code></pre>

                <h3>Number Attributes</h3>
                <p>Numbers must be in curly braces (no quotes!):</p>

                <pre><code class="language-typescript">// ‚úÖ Correct
&lt;input type="number" max={100} min={0} step={5} /&gt;
&lt;img width={300} height={200} /&gt;
&lt;div style={{ fontSize: 16, padding: 20 }} /&gt;

// ‚ùå Wrong - these become strings!
&lt;input type="number" max="100" min="0" /&gt;  // Strings, not numbers!</code></pre>

                <h3>Boolean Attributes</h3>
                <p>Boolean attributes have special shorthand:</p>

                <pre><code class="language-typescript">// All three are equivalent for true
&lt;input type="checkbox" checked={true} /&gt;
&lt;input type="checkbox" checked /&gt;
&lt;button disabled /&gt;

// For false, must be explicit
&lt;input type="checkbox" checked={false} /&gt;
&lt;button disabled={false} /&gt;

// Dynamic based on state
const [isChecked, setIsChecked] = useState(false);
&lt;input type="checkbox" checked={isChecked} /&gt;</code></pre>

                <h3>The className Attribute</h3>
                <p>Use <code>className</code> instead of <code>class</code>:</p>

                <pre><code class="language-typescript">// ‚ùå Wrong
&lt;div class="container"&gt;&lt;/div&gt;

// ‚úÖ Correct
&lt;div className="container"&gt;&lt;/div&gt;

// Dynamic className
const isActive = true;
&lt;button className={isActive ? "btn-active" : "btn-inactive"}&gt;
    Click
&lt;/button&gt;

// Multiple classes
const classes = ["btn", "btn-primary", "btn-lg"].join(" ");
&lt;button className={classes}&gt;Click&lt;/button&gt;

// Template literal for multiple classes
&lt;div className={`container ${isActive ? 'active' : ''}`}&gt;
    Content
&lt;/div&gt;</code></pre>

                <h3>The style Attribute</h3>
                <p>The <code>style</code> attribute takes a JavaScript object, not a string:</p>

                <pre><code class="language-typescript">// ‚ùå Wrong - style is not a string in React
&lt;div style="color: red; font-size: 20px;"&gt;Text&lt;/div&gt;

// ‚úÖ Correct - style is an object with camelCase properties
&lt;div style={{ color: 'red', fontSize: '20px' }}&gt;Text&lt;/div&gt;

// Style object extracted for clarity
const cardStyle = {
    backgroundColor: '#f0f0f0',
    padding: '1rem',
    borderRadius: '8px',
    boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
};

&lt;div style={cardStyle}&gt;Card content&lt;/div&gt;

// Dynamic styles
const isError = true;
&lt;p style={{
    color: isError ? 'red' : 'green',
    fontWeight: isError ? 'bold' : 'normal'
}}&gt;
    Message
&lt;/p&gt;</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Style Performance Note</h4>
                    <p>Inline styles are fine for dynamic values, but for static styles, use CSS classes. CSS classes are more performant and easier to maintain. Use inline styles when you need to compute styles based on props or state.</p>
                </div>

                <h3>Event Handler Attributes</h3>
                <p>Event handlers are camelCase and take functions:</p>

                <pre><code class="language-typescript">function EventExample() {
    const handleClick = () => {
        console.log('Clicked!');
    };
    
    const handleInputChange = (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        console.log('Input value:', event.target.value);
    };
    
    return (
        &lt;div&gt;
            {/* Function reference - no parentheses! */}
            &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;
            
            {/* Inline arrow function */}
            &lt;button onClick={() => console.log('Inline click')}&gt;
                Click me too
            &lt;/button&gt;
            
            {/* With parameters */}
            &lt;button onClick={() => handleClick()}&gt;
                Click with params
            &lt;/button&gt;
            
            {/* Input events */}
            &lt;input 
                type="text"
                onChange={handleInputChange}
                onFocus={() => console.log('Focused')}
                onBlur={() => console.log('Blurred')}
            /&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Data Attributes</h3>
                <p>Custom data attributes work just like HTML:</p>

                <pre><code class="language-typescript">// Data attributes for storing custom data
&lt;div data-user-id="123" data-role="admin"&gt;
    User info
&lt;/div&gt;

// Accessing in event handlers
const handleClick = (event: React.MouseEvent&lt;HTMLDivElement&gt;) => {
    const userId = event.currentTarget.dataset.userId;
    const role = event.currentTarget.dataset.role;
    console.log(userId, role);
};

&lt;div 
    data-user-id="123" 
    data-role="admin"
    onClick={handleClick}
&gt;
    Click me
&lt;/div&gt;</code></pre>

                <h3>Spreading Attributes</h3>
                <p>You can spread an object of attributes:</p>

                <pre><code class="language-typescript">function Input() {
    const inputProps = {
        type: 'text',
        placeholder: 'Enter text',
        maxLength: 50,
        required: true
    };
    
    // Spread all properties onto the input
    return &lt;input {...inputProps} /&gt;;
}

// Useful for forwarding props
interface ButtonProps {
    text: string;
    [key: string]: any; // Allow any other props
}

function CustomButton({ text, ...rest }: ButtonProps) {
    return (
        &lt;button {...rest}&gt;
            {text}
        &lt;/button&gt;
    );
}

// Use it
&lt;CustomButton 
    text="Click me"
    onClick={() => {}}
    disabled={false}
    className="btn-primary"
/&gt;</code></pre>
            </section>

            <!-- Section 5: Conditional Rendering -->
            <section id="section5" class="lesson-section">
                <h2>üîÄ Conditional Rendering</h2>
                <p>One of the most common patterns in React is rendering different content based on conditions. Let's explore all the techniques for conditional rendering!</p>

                <h3>Method 1: Ternary Operator (Most Common)</h3>
                <p>The ternary operator is perfect for choosing between two options:</p>

                <pre><code class="language-typescript">function WelcomeMessage({ isLoggedIn }: { isLoggedIn: boolean }) {
    return (
        &lt;div&gt;
            {isLoggedIn ? (
                &lt;h1&gt;Welcome back!&lt;/h1&gt;
            ) : (
                &lt;h1&gt;Please log in.&lt;/h1&gt;
            )}
        &lt;/div&gt;
    );
}

// Inline content
function UserGreeting({ user }: { user: any }) {
    return (
        &lt;p&gt;
            {user ? `Hello, ${user.name}!` : 'Hello, Guest!'}
        &lt;/p&gt;
    );
}</code></pre>

                <h3>Method 2: Logical AND (&&)</h3>
                <p>Use <code>&&</code> when you want to render something or nothing:</p>

                <pre><code class="language-typescript">function Notifications({ count }: { count: number }) {
    return (
        &lt;div&gt;
            &lt;h2&gt;Notifications&lt;/h2&gt;
            {/* Only show if count > 0 */}
            {count > 0 && (
                &lt;p&gt;You have {count} new notifications!&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

// Multiple conditions
function UserProfile({ user, isAdmin }: any) {
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            {user.email && &lt;p&gt;Email: {user.email}&lt;/p&gt;}
            {user.phone && &lt;p&gt;Phone: {user.phone}&lt;/p&gt;}
            {isAdmin && &lt;span className="badge"&gt;Admin&lt;/span&gt;}
        &lt;/div&gt;
    );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Falsy Values</h4>
                    <p>Be careful with <code>&&</code>! React renders <code>0</code> and <code>""</code> (empty string). If the left side is <code>0</code>, it will show <code>0</code> in your UI!</p>
                    <pre><code class="language-typescript">// ‚ùå Will display "0" if count is 0
{count && &lt;p&gt;{count} items&lt;/p&gt;}

// ‚úÖ Correctly shows nothing if count is 0
{count > 0 && &lt;p&gt;{count} items&lt;/p&gt;}

// ‚úÖ Alternative: use boolean conversion
{!!count && &lt;p&gt;{count} items&lt;/p&gt;}</code></pre>
                </div>

                <h3>Method 3: If-Else with Variables</h3>
                <p>For complex conditions, use if-else outside JSX:</p>

                <pre><code class="language-typescript">function StatusMessage({ status }: { status: string }) {
    let message;
    let icon;
    let className;
    
    if (status === 'success') {
        message = 'Operation completed successfully!';
        icon = '‚úÖ';
        className = 'success';
    } else if (status === 'error') {
        message = 'An error occurred.';
        icon = '‚ùå';
        className = 'error';
    } else if (status === 'loading') {
        message = 'Loading...';
        icon = '‚è≥';
        className = 'loading';
    } else {
        message = 'Ready';
        icon = '‚ö™';
        className = 'default';
    }
    
    return (
        &lt;div className={className}&gt;
            &lt;span&gt;{icon}&lt;/span&gt;
            &lt;p&gt;{message}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Method 4: Switch Statement with Function</h3>
                <p>Extract complex conditionals into a function:</p>

                <pre><code class="language-typescript">type AlertType = 'info' | 'success' | 'warning' | 'error';

function Alert({ type, message }: { type: AlertType; message: string }) {
    const renderIcon = () => {
        switch (type) {
            case 'info':
                return '‚ÑπÔ∏è';
            case 'success':
                return '‚úÖ';
            case 'warning':
                return '‚ö†Ô∏è';
            case 'error':
                return '‚ùå';
            default:
                return 'üì¢';
        }
    };
    
    const getClassName = () => {
        return `alert alert-${type}`;
    };
    
    return (
        &lt;div className={getClassName()}&gt;
            &lt;span className="icon"&gt;{renderIcon()}&lt;/span&gt;
            &lt;p&gt;{message}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Method 5: Early Return</h3>
                <p>Return early for simple cases:</p>

                <pre><code class="language-typescript">function UserDashboard({ user }: { user: any }) {
    // Early return for loading state
    if (!user) {
        return &lt;p&gt;Loading...&lt;/p&gt;;
    }
    
    // Early return for error state
    if (user.error) {
        return &lt;p&gt;Error: {user.error}&lt;/p&gt;;
    }
    
    // Main content
    return (
        &lt;div&gt;
            &lt;h1&gt;Welcome, {user.name}!&lt;/h1&gt;
            &lt;p&gt;Email: {user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Nested Conditionals</h3>
                <p>You can nest conditions, but try to keep them simple:</p>

                <pre><code class="language-typescript">function ProductCard({ product, user }: any) {
    return (
        &lt;div className="product"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
            
            {product.inStock ? (
                &lt;div&gt;
                    {user ? (
                        user.isPremium ? (
                            &lt;button&gt;Buy Now - 10% Off!&lt;/button&gt;
                        ) : (
                            &lt;button&gt;Buy Now&lt;/button&gt;
                        )
                    ) : (
                        &lt;button&gt;Login to Purchase&lt;/button&gt;
                    )}
                &lt;/div&gt;
            ) : (
                &lt;p&gt;Out of Stock&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

// Better: Extract to a function
function ProductCard({ product, user }: any) {
    const renderButton = () => {
        if (!product.inStock) return &lt;p&gt;Out of Stock&lt;/p&gt;;
        if (!user) return &lt;button&gt;Login to Purchase&lt;/button&gt;;
        if (user.isPremium) return &lt;button&gt;Buy Now - 10% Off!&lt;/button&gt;;
        return &lt;button&gt;Buy Now&lt;/button&gt;;
    };
    
    return (
        &lt;div className="product"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
            {renderButton()}
        &lt;/div&gt;
    );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practices for Conditionals</h4>
                    <ul>
                        <li><strong>Simple conditions:</strong> Use ternary or <code>&&</code> directly in JSX</li>
                        <li><strong>Complex conditions:</strong> Extract to variables or functions</li>
                        <li><strong>Multiple states:</strong> Use if-else or switch statements</li>
                        <li><strong>Deep nesting:</strong> Break into separate components or functions</li>
                        <li><strong>Early returns:</strong> Handle edge cases first, then main content</li>
                    </ul>
                </div>

                <div class="mermaid">
                    graph TD
                    A[Conditional Rendering] --> B{How many options?}
                    B -->|2 options| C[Use Ternary ?:]
                    B -->|Show or hide| D[Use && operator]
                    B -->|3+ options| E[Use if/else or switch]
                    B -->|Complex logic| F[Extract to function]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style C fill:#4CAF50,stroke:#333,stroke-width:2px
                    style D fill:#4CAF50,stroke:#333,stroke-width:2px
                    style E fill:#ffc107,stroke:#333,stroke-width:2px
                    style F fill:#2196F3,stroke:#333,stroke-width:2px
                </div>

                <!-- Interactive Conditional Rendering Simulator -->
                <div class="card" style="margin-top: 2rem;">
                    <h4>üé® Interactive: Conditional Rendering Simulator</h4>
                    <p>Toggle the conditions to see how different rendering methods work:</p>
                    
                    <canvas id="cond-render-canvas" width="580" height="340" style="width: 100%; max-width: 580px; display: block; margin: 1rem auto; border-radius: 8px;" role="img" aria-label="Conditional rendering visualization"></canvas>
                    
                    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem; align-items: center;">
                        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                            <input type="checkbox" id="cond-isLoggedIn" onchange="updateCondRender()" checked>
                            <span style="font-size: 13px;">isLoggedIn</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                            <input type="checkbox" id="cond-hasNotifications" onchange="updateCondRender()">
                            <span style="font-size: 13px;">hasNotifications</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.3rem; cursor: pointer;">
                            <input type="range" id="cond-count" min="0" max="5" value="0" onchange="updateCondRender()" style="width: 80px;">
                            <span id="cond-count-label" style="font-size: 13px;">count: 0</span>
                        </label>
                    </div>
                </div>
                
                <script>
                (function() {
                    const condCanvas = document.getElementById('cond-render-canvas');
                    const condCtx = condCanvas.getContext('2d');
                    
                    // Polyfill for roundRect
                    if (!condCtx.roundRect) {
                        condCtx.roundRect = function(x, y, w, h, r) {
                            this.beginPath();
                            this.moveTo(x + r, y);
                            this.lineTo(x + w - r, y);
                            this.quadraticCurveTo(x + w, y, x + w, y + r);
                            this.lineTo(x + w, y + h - r);
                            this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                            this.lineTo(x + r, y + h);
                            this.quadraticCurveTo(x, y + h, x, y + h - r);
                            this.lineTo(x, y + r);
                            this.quadraticCurveTo(x, y, x + r, y);
                            this.closePath();
                        };
                    }
                    
                    function drawCondRender() {
                        const isLoggedIn = document.getElementById('cond-isLoggedIn').checked;
                        const hasNotifications = document.getElementById('cond-hasNotifications').checked;
                        const count = parseInt(document.getElementById('cond-count').value);
                        document.getElementById('cond-count-label').textContent = 'count: ' + count;
                        
                        condCtx.clearRect(0, 0, 580, 340);
                        
                        // Background
                        condCtx.fillStyle = '#f8f9fa';
                        condCtx.fillRect(0, 0, 580, 340);
                        
                        // Title
                        condCtx.fillStyle = '#667eea';
                        condCtx.font = 'bold 13px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Conditional Rendering Methods', 290, 20);
                        
                        // Method 1: Ternary
                        drawMethodBox(15, 35, 175, 140, '#2196F3', 'Ternary ( ? : )');
                        condCtx.font = '10px monospace';
                        condCtx.fillStyle = '#333';
                        condCtx.textAlign = 'left';
                        condCtx.fillText('{isLoggedIn ?', 25, 70);
                        condCtx.fillText('  <p>Welcome!</p> :', 25, 85);
                        condCtx.fillText('  <p>Please login</p>', 25, 100);
                        condCtx.fillText('}', 25, 115);
                        
                        // Result box
                        condCtx.fillStyle = isLoggedIn ? '#e8f5e9' : '#ffebee';
                        condCtx.beginPath();
                        condCtx.roundRect(25, 125, 155, 40, 4);
                        condCtx.fill();
                        condCtx.fillStyle = '#333';
                        condCtx.font = '11px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Result: ' + (isLoggedIn ? '"Welcome!"' : '"Please login"'), 102, 150);
                        
                        // Method 2: Logical AND
                        drawMethodBox(200, 35, 175, 140, '#4CAF50', 'Logical AND (&&)');
                        condCtx.font = '10px monospace';
                        condCtx.fillStyle = '#333';
                        condCtx.textAlign = 'left';
                        condCtx.fillText('{hasNotifications &&', 210, 70);
                        condCtx.fillText('  <span>üîî</span>', 210, 85);
                        condCtx.fillText('}', 210, 100);
                        
                        // Result box
                        condCtx.fillStyle = hasNotifications ? '#e8f5e9' : '#f5f5f5';
                        condCtx.beginPath();
                        condCtx.roundRect(210, 125, 155, 40, 4);
                        condCtx.fill();
                        condCtx.fillStyle = '#333';
                        condCtx.font = '11px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Result: ' + (hasNotifications ? '"üîî"' : '(nothing)'), 287, 150);
                        
                        // Method 3: && with falsy gotcha
                        drawMethodBox(385, 35, 180, 140, '#FF9800', '‚ö†Ô∏è Falsy Gotcha');
                        condCtx.font = '10px monospace';
                        condCtx.fillStyle = '#333';
                        condCtx.textAlign = 'left';
                        condCtx.fillText('{count &&', 395, 70);
                        condCtx.fillText('  <p>{count} items</p>', 395, 85);
                        condCtx.fillText('}', 395, 100);
                        
                        // Result box - showing the gotcha
                        const showsZero = count === 0;
                        condCtx.fillStyle = showsZero ? '#ffebee' : '#e8f5e9';
                        condCtx.beginPath();
                        condCtx.roundRect(395, 125, 160, 40, 4);
                        condCtx.fill();
                        condCtx.fillStyle = showsZero ? '#f44336' : '#333';
                        condCtx.font = '11px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Result: ' + (showsZero ? '"0" ‚ùå BUG!' : '"' + count + ' items"'), 475, 150);
                        
                        // Method 4: Fixed version
                        drawMethodBox(15, 185, 175, 140, '#9C27B0', '‚úÖ Fixed Version');
                        condCtx.font = '10px monospace';
                        condCtx.fillStyle = '#333';
                        condCtx.textAlign = 'left';
                        condCtx.fillText('{count > 0 &&', 25, 220);
                        condCtx.fillText('  <p>{count} items</p>', 25, 235);
                        condCtx.fillText('}', 25, 250);
                        
                        // Result box
                        condCtx.fillStyle = count > 0 ? '#e8f5e9' : '#f5f5f5';
                        condCtx.beginPath();
                        condCtx.roundRect(25, 275, 155, 40, 4);
                        condCtx.fill();
                        condCtx.fillStyle = '#333';
                        condCtx.font = '11px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Result: ' + (count > 0 ? '"' + count + ' items"' : '(nothing) ‚úÖ'), 102, 300);
                        
                        // Summary box
                        condCtx.fillStyle = '#e3f2fd';
                        condCtx.beginPath();
                        condCtx.roundRect(200, 185, 365, 140, 6);
                        condCtx.fill();
                        condCtx.strokeStyle = '#2196F3';
                        condCtx.lineWidth = 2;
                        condCtx.stroke();
                        
                        condCtx.fillStyle = '#2196F3';
                        condCtx.font = 'bold 12px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText('Summary', 382, 205);
                        
                        condCtx.font = '11px Arial';
                        condCtx.fillStyle = '#333';
                        condCtx.textAlign = 'left';
                        condCtx.fillText('‚Ä¢ Use ternary when you have two options', 215, 225);
                        condCtx.fillText('‚Ä¢ Use && when you show something or nothing', 215, 245);
                        condCtx.fillText('‚Ä¢ Watch out for 0 - it renders as "0"!', 215, 265);
                        condCtx.fillText('‚Ä¢ Use count > 0 instead of just count', 215, 285);
                        condCtx.fillText('‚Ä¢ Complex conditions? Use if/else before JSX', 215, 305);
                    }
                    
                    function drawMethodBox(x, y, w, h, color, title) {
                        condCtx.fillStyle = 'white';
                        condCtx.beginPath();
                        condCtx.roundRect(x, y, w, h, 6);
                        condCtx.fill();
                        condCtx.strokeStyle = color;
                        condCtx.lineWidth = 2;
                        condCtx.stroke();
                        
                        condCtx.fillStyle = color;
                        condCtx.font = 'bold 11px Arial';
                        condCtx.textAlign = 'center';
                        condCtx.fillText(title, x + w/2, y + 18);
                    }
                    
                    window.updateCondRender = drawCondRender;
                    drawCondRender();
                })();
                </script>
            </section>

            <!-- Section 6: Rendering Lists -->
            <section id="section6" class="lesson-section">
                <h2>üìã Rendering Lists</h2>
                <p>Displaying lists of data is one of the most common tasks in React. Let's learn how to render arrays efficiently and correctly!</p>

                <h3>Basic List Rendering with map()</h3>
                <p>Use the <code>map()</code> method to transform an array into JSX elements:</p>

                <pre><code class="language-typescript">function ShoppingList() {
    const items = ['Apples', 'Bananas', 'Oranges', 'Grapes'];
    
    return (
        &lt;ul&gt;
            {items.map(item => (
                &lt;li&gt;{item}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}</code></pre>

                <h3>The Importance of Keys</h3>
                <p>React needs a <code>key</code> prop to identify which items have changed, been added, or removed. Keys must be unique among siblings!</p>

                <pre><code class="language-typescript">// ‚ùå No key - React will warn you
function BadList() {
    const items = ['Apples', 'Bananas', 'Oranges'];
    return (
        &lt;ul&gt;
            {items.map(item => &lt;li&gt;{item}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
}

// ‚úÖ With key
function GoodList() {
    const items = ['Apples', 'Bananas', 'Oranges'];
    return (
        &lt;ul&gt;
            {items.map((item, index) => (
                &lt;li key={index}&gt;{item}&lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}

// ‚úÖ Even better - use stable IDs
interface Product {
    id: number;
    name: string;
    price: number;
}

function ProductList({ products }: { products: Product[] }) {
    return (
        &lt;ul&gt;
            {products.map(product => (
                &lt;li key={product.id}&gt;
                    {product.name} - ${product.price}
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Why Not Use Index as Key?</h4>
                    <p>Using array indexes as keys can cause bugs when the list changes (items added, removed, or reordered). React uses keys to match elements between renders, and indexes can point to different items after changes!</p>
                    <pre><code class="language-typescript">// ‚ùå Don't use index if list can change
{items.map((item, index) => &lt;li key={index}&gt;{item}&lt;/li&gt;)}

// ‚úÖ Use stable unique IDs
{items.map(item => &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;)}

// ‚úÖ If no ID, create one when data loads
const itemsWithIds = rawItems.map((item, i) => ({
    ...item,
    id: `${item.name}-${i}` // Create stable ID
}));</code></pre>
                </div>

                <h3>Rendering Complex List Items</h3>
                <p>List items can contain complex JSX:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    avatar: string;
    isActive: boolean;
}

function UserList({ users }: { users: User[] }) {
    return (
        &lt;div className="user-list"&gt;
            {users.map(user => (
                &lt;div key={user.id} className="user-card"&gt;
                    &lt;img src={user.avatar} alt={user.name} /&gt;
                    &lt;div className="user-info"&gt;
                        &lt;h3&gt;{user.name}&lt;/h3&gt;
                        &lt;p&gt;{user.email}&lt;/p&gt;
                        {user.isActive && (
                            &lt;span className="badge"&gt;Active&lt;/span&gt;
                        )}
                    &lt;/div&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Extracting List Item Components</h3>
                <p>For better organization, extract list items into separate components:</p>

                <pre><code class="language-typescript">// Child component for list item
interface TodoItemProps {
    todo: {
        id: number;
        text: string;
        completed: boolean;
    };
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

function TodoItem({ todo, onToggle, onDelete }: TodoItemProps) {
    return (
        &lt;li className={todo.completed ? 'completed' : ''}&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/li&gt;
    );
}

// Parent component rendering list
function TodoList({ todos, onToggle, onDelete }: any) {
    return (
        &lt;ul&gt;
            {todos.map(todo => (
                &lt;TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={onToggle}
                    onDelete={onDelete}
                /&gt;
            ))}
        &lt;/ul&gt;
    );
}</code></pre>

                <h3>Filtering and Sorting Lists</h3>
                <p>You can filter and sort before rendering:</p>

                <pre><code class="language-typescript">function ProductCatalog({ products }: { products: Product[] }) {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState&lt;'name' | 'price'&gt;('name');
    
    // Filter products
    const filteredProducts = products.filter(product =>
        product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    // Sort products
    const sortedProducts = [...filteredProducts].sort((a, b) => {
        if (sortBy === 'name') {
            return a.name.localeCompare(b.name);
        } else {
            return a.price - b.price;
        }
    });
    
    return (
        &lt;div&gt;
            &lt;input
                type="text"
                placeholder="Search products..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
            /&gt;
            
            &lt;select value={sortBy} onChange={(e) => setSortBy(e.target.value as any)}&gt;
                &lt;option value="name"&gt;Sort by Name&lt;/option&gt;
                &lt;option value="price"&gt;Sort by Price&lt;/option&gt;
            &lt;/select&gt;
            
            &lt;div className="products"&gt;
                {sortedProducts.map(product => (
                    &lt;div key={product.id} className="product-card"&gt;
                        &lt;h3&gt;{product.name}&lt;/h3&gt;
                        &lt;p&gt;${product.price}&lt;/p&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Handling Empty Lists</h3>
                <p>Always handle the case when lists are empty:</p>

                <pre><code class="language-typescript">function CommentList({ comments }: { comments: any[] }) {
    if (comments.length === 0) {
        return &lt;p&gt;No comments yet. Be the first to comment!&lt;/p&gt;;
    }
    
    return (
        &lt;div&gt;
            {comments.map(comment => (
                &lt;div key={comment.id}&gt;
                    &lt;p&gt;{comment.text}&lt;/p&gt;
                    &lt;small&gt;By {comment.author}&lt;/small&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}

// Alternative: inline conditional
function MessageList({ messages }: { messages: any[] }) {
    return (
        &lt;div&gt;
            {messages.length > 0 ? (
                messages.map(msg => (
                    &lt;div key={msg.id}&gt;{msg.text}&lt;/div&gt;
                ))
            ) : (
                &lt;p&gt;No messages to display&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Nested Lists</h3>
                <p>You can render lists within lists:</p>

                <pre><code class="language-typescript">interface Category {
    id: number;
    name: string;
    items: { id: number; name: string }[];
}

function CategoryList({ categories }: { categories: Category[] }) {
    return (
        &lt;div&gt;
            {categories.map(category => (
                &lt;div key={category.id} className="category"&gt;
                    &lt;h2&gt;{category.name}&lt;/h2&gt;
                    &lt;ul&gt;
                        {category.items.map(item => (
                            &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
                        ))}
                    &lt;/ul&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ List Rendering Best Practices</h4>
                    <ul>
                        <li><strong>Always use keys</strong> - React needs them for efficient updates</li>
                        <li><strong>Use stable IDs</strong> - Avoid using array indexes when possible</li>
                        <li><strong>Extract components</strong> - Keep list items in separate components</li>
                        <li><strong>Handle empty states</strong> - Show meaningful messages for empty lists</li>
                        <li><strong>Filter/sort wisely</strong> - Do data transformations before rendering</li>
                        <li><strong>Keep keys unique</strong> - Only among siblings, not globally</li>
                    </ul>
                </div>

                <!-- Interactive List Keys Demo -->
                <div class="card" style="margin-top: 2rem;">
                    <h4>üé® Interactive: Why Keys Matter</h4>
                    <p>See how React uses keys to track list items. Watch what happens when items are added or removed:</p>
                    
                    <svg id="list-keys-svg" viewBox="0 0 580 300" style="width: 100%; max-width: 580px; display: block; margin: 1rem auto;" role="img" aria-label="List keys visualization">
                        <!-- Background -->
                        <rect x="0" y="0" width="580" height="300" fill="#f8f9fa" rx="8"/>
                        
                        <!-- Title -->
                        <text x="290" y="22" text-anchor="middle" fill="#667eea" font-weight="bold" font-size="13">React List Keys Demo</text>
                        
                        <!-- Without Keys Side -->
                        <rect x="15" y="35" width="265" height="210" fill="white" rx="6" stroke="#f44336" stroke-width="2"/>
                        <text x="147" y="55" text-anchor="middle" fill="#f44336" font-weight="bold" font-size="11">‚ùå Without Stable Keys (index)</text>
                        
                        <!-- List items without keys -->
                        <g id="no-keys-items">
                        </g>
                        
                        <!-- With Keys Side -->
                        <rect x="300" y="35" width="265" height="210" fill="white" rx="6" stroke="#4CAF50" stroke-width="2"/>
                        <text x="432" y="55" text-anchor="middle" fill="#4CAF50" font-weight="bold" font-size="11">‚úÖ With Stable Keys (id)</text>
                        
                        <!-- List items with keys -->
                        <g id="with-keys-items">
                        </g>
                        
                        <!-- Info box -->
                        <rect x="15" y="255" width="550" height="35" fill="#e3f2fd" rx="4" stroke="#2196F3"/>
                        <text id="list-keys-info" x="290" y="277" text-anchor="middle" fill="#333" font-size="11">Click buttons to add/remove items and see how React tracks them</text>
                    </svg>
                    
                    <div style="display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap; margin-top: 1rem;">
                        <button onclick="listKeysAdd()" style="padding: 0.4rem 0.8rem; border: none; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">‚ûï Add Item</button>
                        <button onclick="listKeysRemoveFirst()" style="padding: 0.4rem 0.8rem; border: none; background: #FF9800; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">üóëÔ∏è Remove First</button>
                        <button onclick="listKeysShuffle()" style="padding: 0.4rem 0.8rem; border: none; background: #9C27B0; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">üîÄ Shuffle</button>
                        <button onclick="listKeysReset()" style="padding: 0.4rem 0.8rem; border: none; background: #666; color: white; border-radius: 4px; cursor: pointer; font-size: 12px;">Reset</button>
                    </div>
                </div>
                
                <script>
                (function() {
                    let listItems = [
                        { id: 1, name: 'Apple', color: '#FF6B6B' },
                        { id: 2, name: 'Banana', color: '#FFE66D' },
                        { id: 3, name: 'Cherry', color: '#C44569' }
                    ];
                    let nextId = 4;
                    const newItems = ['Date', 'Elderberry', 'Fig', 'Grape', 'Honeydew'];
                    let newItemIndex = 0;
                    const newColors = ['#95E1D3', '#F38181', '#AA96DA', '#FCBAD3', '#A8D8EA'];
                    
                    function drawListKeys() {
                        const noKeysGroup = document.getElementById('no-keys-items');
                        const withKeysGroup = document.getElementById('with-keys-items');
                        
                        // Clear groups
                        noKeysGroup.innerHTML = '';
                        withKeysGroup.innerHTML = '';
                        
                        // Draw items
                        listItems.forEach((item, index) => {
                            // Without keys (using index)
                            const y1 = 70 + index * 45;
                            noKeysGroup.innerHTML += `
                                <rect x="25" y="${y1}" width="245" height="38" fill="${item.color}20" rx="4" stroke="${item.color}" stroke-width="1.5"/>
                                <text x="35" y="${y1 + 24}" fill="#333" font-size="11" font-family="monospace">key={${index}} ‚Üí ${item.name}</text>
                                <text x="220" y="${y1 + 24}" fill="#666" font-size="9">(id: ${item.id})</text>
                            `;
                            
                            // With keys (using id)
                            const y2 = 70 + index * 45;
                            withKeysGroup.innerHTML += `
                                <rect x="310" y="${y2}" width="245" height="38" fill="${item.color}20" rx="4" stroke="${item.color}" stroke-width="1.5"/>
                                <text x="320" y="${y2 + 24}" fill="#333" font-size="11" font-family="monospace">key={${item.id}} ‚Üí ${item.name}</text>
                                <circle cx="540" cy="${y2 + 19}" r="8" fill="${item.color}"/>
                            `;
                        });
                    }
                    
                    window.listKeysAdd = function() {
                        if (listItems.length >= 4) {
                            document.getElementById('list-keys-info').textContent = 'Max 4 items for this demo';
                            return;
                        }
                        const newName = newItems[newItemIndex % newItems.length];
                        const newColor = newColors[newItemIndex % newColors.length];
                        listItems.unshift({ id: nextId++, name: newName, color: newColor });
                        newItemIndex++;
                        drawListKeys();
                        document.getElementById('list-keys-info').textContent = 
                            '‚ö†Ô∏è Left: indexes shifted! key={0} now points to different item. Right: keys stable!';
                    };
                    
                    window.listKeysRemoveFirst = function() {
                        if (listItems.length <= 1) {
                            document.getElementById('list-keys-info').textContent = 'Need at least 1 item';
                            return;
                        }
                        listItems.shift();
                        drawListKeys();
                        document.getElementById('list-keys-info').textContent = 
                            '‚ö†Ô∏è Left: all indexes changed! React may re-render wrong items. Right: only removed item affected.';
                    };
                    
                    window.listKeysShuffle = function() {
                        for (let i = listItems.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [listItems[i], listItems[j]] = [listItems[j], listItems[i]];
                        }
                        drawListKeys();
                        document.getElementById('list-keys-info').textContent = 
                            '‚ö†Ô∏è Left: indexes point to different items now! Right: each item keeps its key.';
                    };
                    
                    window.listKeysReset = function() {
                        listItems = [
                            { id: 1, name: 'Apple', color: '#FF6B6B' },
                            { id: 2, name: 'Banana', color: '#FFE66D' },
                            { id: 3, name: 'Cherry', color: '#C44569' }
                        ];
                        nextId = 4;
                        newItemIndex = 0;
                        drawListKeys();
                        document.getElementById('list-keys-info').textContent = 
                            'Click buttons to add/remove items and see how React tracks them';
                    };
                    
                    drawListKeys();
                })();
                </script>
            </section>

            <!-- Section 7: Fragments -->
            <section id="section7" class="lesson-section">
                <h2>üß© Fragments</h2>
                <p>Remember the rule about returning a single root element? Fragments let you group elements without adding extra DOM nodes!</p>

                <h3>The Problem</h3>
                <p>Sometimes wrapping in a <code>div</code> causes issues:</p>

                <pre><code class="language-typescript">// This adds an extra div to the DOM
function Columns() {
    return (
        &lt;div&gt;
            &lt;td&gt;Column 1&lt;/td&gt;
            &lt;td&gt;Column 2&lt;/td&gt;
        &lt;/div&gt;
    );
}

// Usage - creates invalid HTML!
&lt;table&gt;
    &lt;tr&gt;
        &lt;Columns /&gt;  {/* Results in: tr > div > td (invalid!) */}
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>

                <h3>The Solution: Fragments</h3>
                <p>Fragments let you group elements without adding a DOM node:</p>

                <pre><code class="language-typescript">// Method 1: React.Fragment (verbose)
function Columns() {
    return (
        &lt;React.Fragment&gt;
            &lt;td&gt;Column 1&lt;/td&gt;
            &lt;td&gt;Column 2&lt;/td&gt;
        &lt;/React.Fragment&gt;
    );
}

// Method 2: Short syntax (preferred)
function Columns() {
    return (
        &lt;&gt;
            &lt;td&gt;Column 1&lt;/td&gt;
            &lt;td&gt;Column 2&lt;/td&gt;
        &lt;/&gt;
    );
}

// Now the table is valid HTML!
&lt;table&gt;
    &lt;tr&gt;
        &lt;Columns /&gt;  {/* Results in: tr > td (valid!) */}
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>

                <h3>When to Use Fragments</h3>
                <p>Fragments are useful in several scenarios:</p>

                <pre><code class="language-typescript">// 1. Returning multiple elements
function Header() {
    return (
        &lt;&gt;
            &lt;h1&gt;My Site&lt;/h1&gt;
            &lt;nav&gt;Navigation&lt;/nav&gt;
        &lt;/&gt;
    );
}

// 2. Avoiding wrapper divs in layouts
function Layout() {
    return (
        &lt;&gt;
            &lt;Header /&gt;
            &lt;Main /&gt;
            &lt;Footer /&gt;
        &lt;/&gt;
    );
}

// 3. In conditional rendering
function ConditionalContent({ show }: { show: boolean }) {
    return (
        &lt;div&gt;
            {show && (
                &lt;&gt;
                    &lt;h2&gt;Title&lt;/h2&gt;
                    &lt;p&gt;Content&lt;/p&gt;
                    &lt;button&gt;Action&lt;/button&gt;
                &lt;/&gt;
            )}
        &lt;/div&gt;
    );
}

// 4. In lists (but you need the key prop!)
function List({ items }: { items: any[] }) {
    return (
        &lt;ul&gt;
            {items.map(item => (
                &lt;React.Fragment key={item.id}&gt;
                    &lt;li&gt;{item.name}&lt;/li&gt;
                    &lt;li&gt;{item.description}&lt;/li&gt;
                &lt;/React.Fragment&gt;
            ))}
        &lt;/ul&gt;
    );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Fragment vs Div</h4>
                    <p><strong>Use Fragment when:</strong></p>
                    <ul>
                        <li>You don't need the extra DOM node</li>
                        <li>The extra div would break CSS (flexbox, grid)</li>
                        <li>The extra div would create invalid HTML (tables, lists)</li>
                    </ul>
                    <p><strong>Use Div when:</strong></p>
                    <ul>
                        <li>You need to apply styles or CSS classes</li>
                        <li>You need to attach event handlers to the container</li>
                        <li>You need a ref to the container element</li>
                    </ul>
                </div>

                <h3>Fragments with Keys</h3>
                <p>When you need a <code>key</code> prop, use the full syntax:</p>

                <pre><code class="language-typescript">// ‚ùå Short syntax doesn't accept props
{items.map(item => (
    &lt;&gt;  {/* Can't add key here! */}
        &lt;dt&gt;{item.term}&lt;/dt&gt;
        &lt;dd&gt;{item.definition}&lt;/dd&gt;
    &lt;/&gt;
))}

// ‚úÖ Use React.Fragment for keys
{items.map(item => (
    &lt;React.Fragment key={item.id}&gt;
        &lt;dt&gt;{item.term}&lt;/dt&gt;
        &lt;dd&gt;{item.definition}&lt;/dd&gt;
    &lt;/React.Fragment&gt;
))}</code></pre>
            </section>

            <!-- Section 8: JSX Gotchas -->
            <section id="section8" class="lesson-section">
                <h2>‚ö†Ô∏è JSX Gotchas and Common Mistakes</h2>
                <p>JSX has some quirks that can trip up beginners (and even experienced developers!). Let's learn about the common pitfalls and how to avoid them.</p>

                <h3>1. Rendering null, undefined, boolean</h3>
                <p>React handles these values specially:</p>

                <pre><code class="language-typescript">function RenderingExamples() {
    return (
        &lt;div&gt;
            {null}        {/* Renders nothing */}
            {undefined}   {/* Renders nothing */}
            {true}        {/* Renders nothing */}
            {false}       {/* Renders nothing */}
            {0}           {/* Renders "0" - watch out! */}
            {""}          {/* Renders nothing */}
            {" "}         {/* Renders a space */}
        &lt;/div&gt;
    );
}

// The zero gotcha!
function ItemCount({ count }: { count: number }) {
    return (
        &lt;div&gt;
            {/* ‚ùå Will show "0" if count is 0 */}
            {count && &lt;p&gt;{count} items&lt;/p&gt;}
            
            {/* ‚úÖ Won't show anything if count is 0 */}
            {count > 0 && &lt;p&gt;{count} items&lt;/p&gt;}
        &lt;/div&gt;
    );
}</code></pre>

                <h3>2. Objects Can't Be Rendered</h3>
                <p>You can't render plain objects directly:</p>

                <pre><code class="language-typescript">function ObjectExample() {
    const user = { name: "Alice", age: 30 };
    
    return (
        &lt;div&gt;
            {/* ‚ùå ERROR: Objects are not valid as a React child */}
            &lt;p&gt;{user}&lt;/p&gt;
            
            {/* ‚úÖ Render specific properties */}
            &lt;p&gt;{user.name}&lt;/p&gt;
            
            {/* ‚úÖ Or convert to string */}
            &lt;p&gt;{JSON.stringify(user)}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>3. Reserved Words</h3>
                <p>Some HTML attributes are JavaScript reserved words:</p>

                <pre><code class="language-typescript">// ‚ùå class and for are reserved in JavaScript
&lt;div class="container"&gt;
    &lt;label for="email"&gt;Email&lt;/label&gt;
&lt;/div&gt;

// ‚úÖ Use className and htmlFor
&lt;div className="container"&gt;
    &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
&lt;/div&gt;</code></pre>

                <h3>4. Event Handlers Need Functions</h3>
                <p>Don't call the function immediately:</p>

                <pre><code class="language-typescript">function ButtonExample() {
    const handleClick = () => {
        console.log('Clicked!');
    };
    
    return (
        &lt;div&gt;
            {/* ‚ùå Calls immediately, doesn't work as expected */}
            &lt;button onClick={handleClick()}&gt;Bad&lt;/button&gt;
            
            {/* ‚úÖ Passes function reference */}
            &lt;button onClick={handleClick}&gt;Good&lt;/button&gt;
            
            {/* ‚úÖ Inline arrow function */}
            &lt;button onClick={() => handleClick()}&gt;Also Good&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>5. Self-Closing Tags</h3>
                <p>All tags must be properly closed:</p>

                <pre><code class="language-typescript">// ‚ùå HTML style - won't work in JSX
&lt;img src="photo.jpg"&gt;
&lt;input type="text"&gt;
&lt;br&gt;

// ‚úÖ JSX requires self-closing tags
&lt;img src="photo.jpg" /&gt;
&lt;input type="text" /&gt;
&lt;br /&gt;</code></pre>

                <h3>6. Adjacent JSX Elements</h3>
                <p>Must have a single parent:</p>

                <pre><code class="language-typescript">// ‚ùå Adjacent elements - error!
return (
    &lt;h1&gt;Title&lt;/h1&gt;
    &lt;p&gt;Content&lt;/p&gt;
);

// ‚úÖ Wrap in container or fragment
return (
    &lt;&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Content&lt;/p&gt;
    &lt;/&gt;
);</code></pre>

                <h3>7. Array Methods That Don't Return</h3>
                <p>Some array methods don't work in JSX:</p>

                <pre><code class="language-typescript">function ListExample({ items }: { items: string[] }) {
    return (
        &lt;ul&gt;
            {/* ‚ùå forEach doesn't return anything */}
            {items.forEach(item => &lt;li&gt;{item}&lt;/li&gt;)}
            
            {/* ‚úÖ map returns a new array */}
            {items.map(item => &lt;li key={item}&gt;{item}&lt;/li&gt;)}
        &lt;/ul&gt;
    );
}</code></pre>

                <h3>8. Whitespace Handling</h3>
                <p>JSX handles whitespace differently than HTML:</p>

                <pre><code class="language-typescript">// These produce different output:
&lt;p&gt;Hello World&lt;/p&gt;                    // "Hello World"

&lt;p&gt;
    Hello World
&lt;/p&gt;                                   // "Hello World"

&lt;p&gt;Hello {' '} World&lt;/p&gt;             // "Hello  World"

&lt;p&gt;Hello&lt;/p&gt;&lt;p&gt;World&lt;/p&gt;            // No space between

&lt;p&gt;Hello&lt;/p&gt;{' '}&lt;p&gt;World&lt;/p&gt;      // Space between</code></pre>

                <h3>9. Inline Styles Must Be Objects</h3>
                <p>And use camelCase properties:</p>

                <pre><code class="language-typescript">// ‚ùå String styles don't work
&lt;div style="color: red; font-size: 20px"&gt;&lt;/div&gt;

// ‚úÖ Object with camelCase properties
&lt;div style={{ color: 'red', fontSize: '20px' }}&gt;&lt;/div&gt;

// ‚ùå kebab-case properties don't work
&lt;div style={{ 'background-color': 'blue' }}&gt;&lt;/div&gt;

// ‚úÖ camelCase
&lt;div style={{ backgroundColor: 'blue' }}&gt;&lt;/div&gt;</code></pre>

                <h3>10. The Semicolon Trap</h3>
                <p>Be careful with automatic semicolon insertion:</p>

                <pre><code class="language-typescript">// ‚ùå Returns undefined!
function BadComponent() {
    return
        &lt;div&gt;Hello&lt;/div&gt;;
}

// ‚úÖ Wrap in parentheses
function GoodComponent() {
    return (
        &lt;div&gt;Hello&lt;/div&gt;
    );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Quick Reference: Common Gotchas</h4>
                    <ul>
                        <li><code>0</code> renders as "0" - use <code>{'{count > 0 && ...}'}</code></li>
                        <li>Objects can't render - access properties instead</li>
                        <li>Use <code>className</code> not <code>class</code></li>
                        <li>Use <code>htmlFor</code> not <code>for</code></li>
                        <li>Event handlers get functions, not calls</li>
                        <li>Close all tags - even <code>&lt;br /&gt;</code></li>
                        <li>Single root element required - use Fragment <code>&lt;&gt;&lt;/&gt;</code></li>
                        <li>Use <code>map()</code> not <code>forEach()</code></li>
                        <li>Styles are objects with camelCase properties</li>
                        <li>Wrap return value in parentheses</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Build a Product Catalog</h3>
                    <p><strong>Objective:</strong> Create a product catalog with filtering, sorting, and conditional rendering.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Display a list of products with name, price, and stock status</li>
                        <li>Add a search filter to find products by name</li>
                        <li>Show "In Stock" badge for available products</li>
                        <li>Show "Out of Stock" message for unavailable products</li>
                        <li>Handle empty search results</li>
                    </ol>
                    
                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">import { useState } from 'react';

interface Product {
    id: number;
    name: string;
    price: number;
    inStock: boolean;
}

const products: Product[] = [
    { id: 1, name: "Laptop", price: 999, inStock: true },
    { id: 2, name: "Mouse", price: 29, inStock: true },
    { id: 3, name: "Keyboard", price: 79, inStock: false },
    { id: 4, name: "Monitor", price: 299, inStock: true },
    { id: 5, name: "Webcam", price: 89, inStock: false }
];

function ProductCatalog() {
    const [searchTerm, setSearchTerm] = useState('');
    
    // TODO: Filter products based on search term
    // TODO: Render filtered products
    // TODO: Handle empty results
    
    return (
        &lt;div&gt;
            &lt;h1&gt;Product Catalog&lt;/h1&gt;
            {/* TODO: Add search input */}
            {/* TODO: Render product list */}
        &lt;/div&gt;
    );
}</code></pre>
                    
                    <details>
                        <summary>üí° Hint 1</summary>
                        <p>Use the <code>filter()</code> method to filter products: <code>products.filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()))</code></p>
                    </details>
                    
                    <details>
                        <summary>üí° Hint 2</summary>
                        <p>Use conditional rendering to show "In Stock" or "Out of Stock": <code>{product.inStock ? "In Stock" : "Out of Stock"}</code></p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useState } from 'react';
import './ProductCatalog.css';

interface Product {
    id: number;
    name: string;
    price: number;
    inStock: boolean;
}

const products: Product[] = [
    { id: 1, name: "Laptop", price: 999, inStock: true },
    { id: 2, name: "Mouse", price: 29, inStock: true },
    { id: 3, name: "Keyboard", price: 79, inStock: false },
    { id: 4, name: "Monitor", price: 299, inStock: true },
    { id: 5, name: "Webcam", price: 89, inStock: false }
];

function ProductCatalog() {
    const [searchTerm, setSearchTerm] = useState('');
    
    // Filter products
    const filteredProducts = products.filter(product =>
        product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    return (
        &lt;div className="catalog"&gt;
            &lt;h1&gt;Product Catalog&lt;/h1&gt;
            
            &lt;input
                type="text"
                placeholder="Search products..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="search-input"
            /&gt;
            
            {filteredProducts.length > 0 ? (
                &lt;div className="product-grid"&gt;
                    {filteredProducts.map(product => (
                        &lt;div key={product.id} className="product-card"&gt;
                            &lt;h3&gt;{product.name}&lt;/h3&gt;
                            &lt;p className="price"&gt;${product.price}&lt;/p&gt;
                            
                            {product.inStock ? (
                                &lt;span className="badge in-stock"&gt;In Stock&lt;/span&gt;
                            ) : (
                                &lt;span className="badge out-of-stock"&gt;Out of Stock&lt;/span&gt;
                            )}
                            
                            &lt;button disabled={!product.inStock}&gt;
                                {product.inStock ? 'Add to Cart' : 'Unavailable'}
                            &lt;/button&gt;
                        &lt;/div&gt;
                    ))}
                &lt;/div&gt;
            ) : (
                &lt;p className="no-results"&gt;
                    No products found matching "{searchTerm}"
                &lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}

export default ProductCatalog;</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Build a Comment Section</h3>
                    <p><strong>Objective:</strong> Create a comment section that renders a list of comments with conditional content.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Display a list of comments with author, text, and timestamp</li>
                        <li>Show "Edited" badge if comment was edited</li>
                        <li>Show "No comments yet" if the list is empty</li>
                        <li>Format the timestamp nicely</li>
                    </ol>
                    
                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">interface Comment {
    id: number;
    author: string;
    text: string;
    timestamp: Date;
    edited: boolean;
}

const comments: Comment[] = [
    {
        id: 1,
        author: "Alice",
        text: "Great article!",
        timestamp: new Date('2024-01-15T10:30:00'),
        edited: false
    },
    {
        id: 2,
        author: "Bob",
        text: "Thanks for sharing this.",
        timestamp: new Date('2024-01-15T11:45:00'),
        edited: true
    }
];

function CommentSection() {
    // TODO: Implement comment rendering
    return &lt;div&gt;&lt;/div&gt;;
}</code></pre>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">interface Comment {
    id: number;
    author: string;
    text: string;
    timestamp: Date;
    edited: boolean;
}

function CommentSection({ comments }: { comments: Comment[] }) {
    const formatTime = (date: Date) => {
        return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    };
    
    if (comments.length === 0) {
        return (
            &lt;div className="comments"&gt;
                &lt;h3&gt;Comments&lt;/h3&gt;
                &lt;p className="no-comments"&gt;
                    No comments yet. Be the first to comment!
                &lt;/p&gt;
            &lt;/div&gt;
        );
    }
    
    return (
        &lt;div className="comments"&gt;
            &lt;h3&gt;Comments ({comments.length})&lt;/h3&gt;
            
            {comments.map(comment => (
                &lt;div key={comment.id} className="comment"&gt;
                    &lt;div className="comment-header"&gt;
                        &lt;strong&gt;{comment.author}&lt;/strong&gt;
                        &lt;span className="timestamp"&gt;
                            {formatTime(comment.timestamp)}
                        &lt;/span&gt;
                        {comment.edited && (
                            &lt;span className="badge"&gt;Edited&lt;/span&gt;
                        )}
                    &lt;/div&gt;
                    
                    &lt;p className="comment-text"&gt;{comment.text}&lt;/p&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}

export default CommentSection;</code></pre>
                    </details>
                </div>

                <div class="card quiz-container">
                    <h3>üéØ Quick Quiz</h3>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> Which is the correct way to render a list in JSX?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="forEach doesn't return a value">
                                A) {'{items.forEach(item => <li>{item}</li>)}'}
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! map() transforms the array into JSX elements.">
                                B) {'{items.map(item => <li key={item.id}>{item}</li>)}'}
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Can't use for loops in JSX">
                                C) {'{for(let item of items) <li>{item}</li>}'}
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> What's wrong with this code: <code>&lt;div class="container"&gt;</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="There is something wrong">
                                A) Nothing, it's correct
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly! In JSX, use className instead of class.">
                                B) Should use className instead of class
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="The attribute name is the issue">
                                C) Should use quotes around container
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> Why do list items need a key prop?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="It's more than just styling">
                                A) For CSS styling purposes
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Keys help React identify which items changed, were added, or removed.">
                                B) To help React identify and track elements efficiently
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Keys have a real purpose">
                                C) They're optional and only for debugging
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>üèÜ Best Practices</h2>
                
                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Use className, not class</strong> - Always use <code>className</code> for CSS classes in JSX</li>
                    <li><strong>Always provide keys for lists</strong> - Use stable, unique IDs when rendering lists</li>
                    <li><strong>Close all tags</strong> - Self-closing tags need the <code>/</code> at the end</li>
                    <li><strong>Use camelCase for attributes</strong> - <code>onClick</code>, not <code>onclick</code></li>
                    <li><strong>Keep JSX expressions simple</strong> - Extract complex logic into functions or variables</li>
                    <li><strong>Use fragments to avoid extra divs</strong> - <code>&lt;&gt;&lt;/&gt;</code> when you don't need a wrapper</li>
                    <li><strong>Format your JSX</strong> - Use Prettier or similar tools for consistent formatting</li>
                    <li><strong>Use descriptive keys</strong> - Prefer IDs over array indexes when possible</li>
                </ul>
                
                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't use array index as key</strong> - Can cause bugs when list changes</li>
                    <li><strong>Don't call functions in event handlers</strong> - Use <code>onClick={handleClick}</code> not <code>onClick={handleClick()}</code></li>
                    <li><strong>Don't use if statements in JSX</strong> - Use ternary operators or logical AND instead</li>
                    <li><strong>Don't render objects directly</strong> - Access specific properties or convert to string</li>
                    <li><strong>Don't forget parentheses around multiline JSX</strong> - Avoid semicolon insertion issues</li>
                    <li><strong>Don't use <code>0</code> in <code>&&</code> conditionals</strong> - Use <code>count > 0</code> instead</li>
                    <li><strong>Don't nest too deeply</strong> - Extract nested components into separate functions</li>
                </ul>
                
                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Use VS Code extensions</strong> - ES7+ React/Redux/React-Native snippets speeds up JSX writing</li>
                    <li><strong>Learn the Emmet shortcuts</strong> - Works in JSX files for rapid HTML-like typing</li>
                    <li><strong>Use TypeScript</strong> - Catches JSX errors at compile time</li>
                    <li><strong>Destructure props early</strong> - <code>const { name, age } = props</code> makes JSX cleaner</li>
                    <li><strong>Extract render functions</strong> - For complex conditionals, create separate functions</li>
                    <li><strong>Use optional chaining</strong> - <code>{user?.name}</code> safely accesses nested properties</li>
                    <li><strong>Group related code</strong> - Keep data transformations near where they're used</li>
                </ul>

                <h3>Code Organization</h3>
                <p>Keep your JSX readable by following these patterns:</p>

                <pre><code class="language-typescript">function WellOrganizedComponent({ data }: { data: any }) {
    // 1. Early returns for edge cases
    if (!data) {
        return &lt;p&gt;Loading...&lt;/p&gt;;
    }
    
    // 2. Data transformations
    const filteredData = data.filter(item => item.active);
    const sortedData = [...filteredData].sort((a, b) => a.name.localeCompare(b.name));
    
    // 3. Helper render functions
    const renderHeader = () => (
        &lt;header&gt;
            &lt;h1&gt;{data.title}&lt;/h1&gt;
        &lt;/header&gt;
    );
    
    const renderItem = (item: any) => (
        &lt;div key={item.id}&gt;
            &lt;h3&gt;{item.name}&lt;/h3&gt;
            &lt;p&gt;{item.description}&lt;/p&gt;
        &lt;/div&gt;
    );
    
    // 4. Main render - clean and readable
    return (
        &lt;div&gt;
            {renderHeader()}
            
            &lt;main&gt;
                {sortedData.length > 0 ? (
                    sortedData.map(renderItem)
                ) : (
                    &lt;p&gt;No items to display&lt;/p&gt;
                )}
            &lt;/main&gt;
        &lt;/div&gt;
    );
}</code></pre>

                <h3>Performance Tips</h3>
                <ul>
                    <li><strong>Avoid inline functions when possible</strong> - Extract event handlers to avoid recreating them</li>
                    <li><strong>Use CSS classes over inline styles</strong> - Better performance and maintainability</li>
                    <li><strong>Memoize expensive computations</strong> - Use useMemo for heavy data transformations (we'll learn this later)</li>
                    <li><strong>Keep keys stable</strong> - Don't generate random keys on every render</li>
                </ul>
            </section>

            <!-- Section 11: Summary -->
            <section id="section11" class="lesson-section">
                <h2>üìù Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Congratulations!</h3>
                    <p>You've mastered JSX and TSX! Here's what you now know:</p>
                    <ul>
                        <li><strong>JSX/TSX fundamentals</strong> - HTML-like syntax in JavaScript/TypeScript</li>
                        <li><strong>Syntax rules</strong> - Single root, closed tags, camelCase attributes</li>
                        <li><strong>Embedding expressions</strong> - Using <code>{}</code> to include JavaScript</li>
                        <li><strong>Attributes</strong> - className, style objects, event handlers</li>
                        <li><strong>Conditional rendering</strong> - Ternary, &&, if/else patterns</li>
                        <li><strong>List rendering</strong> - Using map() with proper keys</li>
                        <li><strong>Fragments</strong> - Grouping without extra DOM nodes</li>
                        <li><strong>Common gotchas</strong> - And how to avoid them!</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li>JSX makes React components intuitive by mixing markup with logic</li>
                        <li>TypeScript + JSX = TSX with full type safety</li>
                        <li>Use <code>className</code>, not <code>class</code></li>
                        <li>Expressions in <code>{}</code>, not statements</li>
                        <li>Map arrays to JSX, always with keys</li>
                        <li>Ternary and && for conditional rendering</li>
                        <li>Fragments avoid unnecessary DOM nodes</li>
                        <li>Keep JSX simple, extract complex logic</li>
                    </ul>
                </div>

                <h3>Quick Reference: JSX Cheat Sheet</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Syntax</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Expression</td>
                            <td><code>{'{expression}'}</code></td>
                            <td><code>{'{name}'}</code></td>
                        </tr>
                        <tr>
                            <td>Attribute</td>
                            <td><code>attr={'{value}'}</code></td>
                            <td><code>className="btn"</code></td>
                        </tr>
                        <tr>
                            <td>Conditional</td>
                            <td><code>{'{cond ? a : b}'}</code></td>
                            <td><code>{'{isActive ? "Yes" : "No"}'}</code></td>
                        </tr>
                        <tr>
                            <td>Show/Hide</td>
                            <td><code>{'{cond && element}'}</code></td>
                            <td><code>{'{count > 0 && <p>{count}</p>}'}</code></td>
                        </tr>
                        <tr>
                            <td>List</td>
                            <td><code>{'{arr.map(...)}'}</code></td>
                            <td><code>{'{items.map(i => <li key={i.id}>{i.name}</li>)}'}</code></td>
                        </tr>
                        <tr>
                            <td>Fragment</td>
                            <td><code>&lt;&gt;&lt;/&gt;</code></td>
                            <td><code>&lt;&gt;&lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Text&lt;/p&gt;&lt;/&gt;</code></td>
                        </tr>
                        <tr>
                            <td>Comment</td>
                            <td><code>{'{/* ... */}'}</code></td>
                            <td><code>{'{/* This is a comment */}'}</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://react.dev/learn/writing-markup-with-jsx" target="_blank">React Docs: Writing Markup with JSX</a></li>
                    <li><a href="https://react.dev/learn/javascript-in-jsx-with-curly-braces" target="_blank">React Docs: JavaScript in JSX with Curly Braces</a></li>
                    <li><a href="https://react.dev/learn/conditional-rendering" target="_blank">React Docs: Conditional Rendering</a></li>
                    <li><a href="https://react.dev/learn/rendering-lists" target="_blank">React Docs: Rendering Lists</a></li>
                    <li><a href="https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/basic_type_example" target="_blank">React TypeScript Cheatsheet</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll dive into <strong>Components and Props</strong>. You'll learn:</p>
                <ul>
                    <li>How to create reusable component hierarchies</li>
                    <li>Passing data with props and prop validation</li>
                    <li>Component composition patterns</li>
                    <li>Children props and component flexibility</li>
                    <li>Best practices for component design</li>
                </ul>

                <p>You've got the syntax down - now let's build some real components! üí™</p>

                <div class="mermaid">
                    graph LR
                    A[Lesson 2.1: Intro] --> B[Lesson 2.2: JSX/TSX]
                    B --> C[Lesson 2.3: Components & Props]
                    C --> D[Lesson 2.4: Styling]
                    D --> E[Lesson 2.5: Events]
                    E --> F[Module Project]
                    style B fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style C fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ JSX Master Unlocked!</h3>
                    <p style="color: white; font-size: 1.1rem;">You can now write JSX with confidence! From simple expressions to complex conditionals and lists, you've got all the tools you need to describe your UI declaratively.</p>
                    <p style="color: white; font-size: 1.1rem; margin: 0;">Ready to build amazing components! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_2_1_intro_to_react.html" class="prev-lesson">‚Üê Previous: Introduction to React</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_2_3_components_and_props.html" class="next-lesson">Next: Components and Props ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce - React TypeScript Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build better applications with TypeScript and React.</p>
        <p style="margin-top: 1rem; font-size: 0.9rem;">
            <a href="index.html" style="color: white; text-decoration: underline;">Course Home</a> | 
            <a href="index.html#modules" style="color: white; text-decoration: underline;">All Modules</a> | 
            <a href="#main-content" style="color: white; text-decoration: underline;">Back to Top ‚Üë</a>
        </p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
