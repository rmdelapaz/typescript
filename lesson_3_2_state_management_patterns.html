<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn essential state management patterns in React - Master lifting state up, understand prop drilling, state colocation, and derived state for building scalable applications.">
    <meta name="author" content="PracticalAce">
    <title>State Management Patterns - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module3">Module 3: State and Interactivity</a></li>
            <li aria-current="page">Lesson 3.2: State Management Patterns</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üéØ State Management Patterns</h1>
                <p class="lead">You've learned how to use useState in individual components - awesome! But real applications have multiple components that need to share and communicate data. How do you decide where to put state? When should components share state? How do you pass data between components efficiently? These are the questions that separate beginners from confident React developers. In this lesson, we'll explore the essential patterns for organizing state in your applications. Let's level up your state management skills! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand when and how to lift state up to parent components</li>
                        <li>Recognize and solve prop drilling problems</li>
                        <li>Apply state colocation for better component organization</li>
                        <li>Identify and calculate derived state instead of storing it</li>
                        <li>Choose appropriate state initialization strategies</li>
                        <li>Design component hierarchies with proper state placement</li>
                        <li>Refactor components to improve state management</li>
                        <li>Build scalable React applications with clean state architecture</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a todo list where multiple components share and manage state</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">State Placement Principles</a></li>
                        <li><a href="#section2" class="toc-link">Lifting State Up</a></li>
                        <li><a href="#section3" class="toc-link">Prop Drilling Problem</a></li>
                        <li><a href="#section4" class="toc-link">State Colocation</a></li>
                        <li><a href="#section5" class="toc-link">Derived State</a></li>
                        <li><a href="#section6" class="toc-link">State Initialization</a></li>
                        <li><a href="#section7" class="toc-link">Component Communication Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section9" class="toc-link">Refactoring Exercise</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: State Placement Principles -->
            <section id="section1" class="lesson-section">
                <h2>üìç State Placement Principles</h2>
                <p>The most important question in state management is: <strong>"Where should I put this state?"</strong> Let's learn the principles that guide this decision.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ The Golden Rule</h4>
                    <p style="color: white;"><strong>State should live at the lowest common ancestor of all components that need it.</strong></p>
                    <p style="color: white;">In other words: Keep state as close as possible to where it's used, but high enough that all components that need it can access it.</p>
                </div>

                <h3>The State Placement Decision Tree</h3>
                <pre class="mermaid">
graph TD
    A[Need to add state] --> B{Used by one component?}
    B -->|Yes| C[Keep it local in that component]
    B -->|No| D{Used by sibling components?}
    D -->|Yes| E[Lift to parent]
    D -->|No| F{Used by distant relatives?}
    F -->|Yes| G[Lift to common ancestor]
    
    style C fill:#4CAF50,color:#fff
    style E fill:#2196F3,color:#fff
    style G fill:#FF9800,color:#fff
</pre>

                <h3>Three Key Questions</h3>
                <div class="card">
                    <h4>Before Adding State, Ask:</h4>
                    <ol>
                        <li><strong>Can this be calculated from existing state or props?</strong><br>
                        ‚Üí If yes, don't store it - derive it instead!</li>
                        
                        <li><strong>Which components need to read or update this state?</strong><br>
                        ‚Üí State should live in their common parent</li>
                        
                        <li><strong>Is this state truly shared, or just passed through?</strong><br>
                        ‚Üí If just passed through, consider restructuring</li>
                    </ol>
                </div>

                <h3>State Ownership Models</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>When to Use</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Local State</strong></td>
                            <td>Only one component needs it</td>
                            <td>Toggle button's open/closed state</td>
                        </tr>
                        <tr>
                            <td><strong>Lifted State</strong></td>
                            <td>Siblings need to share data</td>
                            <td>Filter and list both need search term</td>
                        </tr>
                        <tr>
                            <td><strong>Global State</strong></td>
                            <td>Many distant components need it</td>
                            <td>User authentication, theme</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Mental Model: The State Tree</h4>
                    <p>Think of your component tree as an actual tree:</p>
                    <ul>
                        <li><strong>Leaves (components at bottom):</strong> Local state that affects only them</li>
                        <li><strong>Branches (parent components):</strong> State shared by their children</li>
                        <li><strong>Trunk (top-level components):</strong> State needed throughout the app</li>
                    </ul>
                    <p>Water (state) flows down from trunk to branches to leaves, but never sideways!</p>
                </div>
            </section>

            <!-- Section 2: Lifting State Up -->
            <section id="section2" class="lesson-section">
                <h2>‚¨ÜÔ∏è Lifting State Up</h2>
                <p>Lifting state up is one of the most fundamental patterns in React. It's how sibling components share data.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Lifting State Up:</strong> Moving state from a child component to a parent component so that multiple children can share and synchronize that state.</p>
                </div>

                <h3>The Problem: Siblings Can't Talk Directly</h3>
                <div class="card">
                    <h4>Scenario: Temperature Converter</h4>
                    <p>Imagine two input fields - one for Celsius, one for Fahrenheit. When you type in either, the other should update. But they're sibling components!</p>
                    
                    <pre class="mermaid">
graph TD
    A[App] --> B[CelsiusInput]
    A --> C[FahrenheitInput]
    
    B -.Can't talk directly!.-> C
    
    style B fill:#f44336,color:#fff
    style C fill:#f44336,color:#fff
</pre>
                </div>

                <h3>The Solution: Lift State to Parent</h3>
                <div class="card">
                    <h4>Before: State in Children (Doesn't Work)</h4>
                    <pre><code class="language-typescript">// ‚ùå Problem: Each has its own independent state
const CelsiusInput: React.FC = () => {
    const [temperature, setTemperature] = useState('');
    
    return (
        &lt;input 
            value={temperature}
            onChange={(e) => setTemperature(e.target.value)}
        /&gt;
    );
};

const FahrenheitInput: React.FC = () => {
    const [temperature, setTemperature] = useState('');
    
    return (
        &lt;input 
            value={temperature}
            onChange={(e) => setTemperature(e.target.value)}
        /&gt;
    );
};</code></pre>
                    <p style="color: #f44336;">‚ùå They can't synchronize - each has separate state!</p>
                </div>

                <div class="card">
                    <h4>After: State in Parent (Works!)</h4>
                    <pre><code class="language-typescript">// ‚úÖ Solution: Lift state to parent
interface TemperatureInputProps {
    temperature: string;
    onTemperatureChange: (temp: string) => void;
    scale: 'c' | 'f';
}

const TemperatureInput: React.FC&lt;TemperatureInputProps&gt; = ({
    temperature,
    onTemperatureChange,
    scale
}) => {
    const scaleName = scale === 'c' ? 'Celsius' : 'Fahrenheit';
    
    return (
        &lt;div&gt;
            &lt;label&gt;{scaleName}:&lt;/label&gt;
            &lt;input 
                value={temperature}
                onChange={(e) => onTemperatureChange(e.target.value)}
            /&gt;
        &lt;/div&gt;
    );
};

// Parent component manages the shared state
const TemperatureConverter: React.FC = () => {
    const [temperature, setTemperature] = useState('');
    const [scale, setScale] = useState&lt;'c' | 'f'&gt;('c');
    
    const handleCelsiusChange = (temp: string) => {
        setScale('c');
        setTemperature(temp);
    };
    
    const handleFahrenheitChange = (temp: string) => {
        setScale('f');
        setTemperature(temp);
    };
    
    // Convert temperatures
    const celsius = scale === 'f' 
        ? ((parseFloat(temperature) - 32) * 5/9).toFixed(1)
        : temperature;
    const fahrenheit = scale === 'c'
        ? ((parseFloat(temperature) * 9/5) + 32).toFixed(1)
        : temperature;
    
    return (
        &lt;div&gt;
            &lt;TemperatureInput
                temperature={celsius}
                onTemperatureChange={handleCelsiusChange}
                scale="c"
            /&gt;
            &lt;TemperatureInput
                temperature={fahrenheit}
                onTemperatureChange={handleFahrenheitChange}
                scale="f"
            /&gt;
        &lt;/div&gt;
    );
};</code></pre>
                    <p style="color: #4CAF50;">‚úÖ Now they stay synchronized through the parent!</p>
                </div>

                <h3>How Lifting State Works</h3>
                <pre class="mermaid">
sequenceDiagram
    participant User
    participant Child1
    participant Parent
    participant Child2
    
    User->>Child1: Type "25" in Celsius

                <h3>üéÆ Interactive Demo: Lifting State in Action</h3>
                <p>Watch how sibling components communicate through their parent:</p>
                
                <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <canvas id="liftingStateCanvas" width="750" height="380" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; border: 1px solid #ddd; border-radius: 8px; background: white;"></canvas>
                    <div style="display: flex; justify-content: center; gap: 1rem; margin-top: 1rem;">
                        <button id="celsiusUpBtn" style="padding: 0.4rem 1rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Celsius +5¬∞</button>
                        <button id="celsiusDownBtn" style="padding: 0.4rem 1rem; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">Celsius -5¬∞</button>
                        <button id="fahrenheitUpBtn" style="padding: 0.4rem 1rem; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Fahrenheit +9¬∞</button>
                        <button id="fahrenheitDownBtn" style="padding: 0.4rem 1rem; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">Fahrenheit -9¬∞</button>
                    </div>
                    <p style="text-align: center; color: #666; margin-top: 0.5rem; font-size: 0.9rem;">Both inputs stay synchronized through lifted state!</p>
                </div>
                
                <script>
                (function() {
                    const canvas = document.getElementById('liftingStateCanvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    let celsius = 20;
                    let animationPhase = 0;
                    let animationProgress = 0;
                    let lastSource = null;
                    
                    function celsiusToFahrenheit(c) { return (c * 9/5) + 32; }
                    
                    function drawRoundedRect(x, y, w, h, r, fill, stroke, strokeWidth = 2) {
                        ctx.beginPath();
                        ctx.roundRect(x, y, w, h, r);
                        if (fill) { ctx.fillStyle = fill; ctx.fill(); }
                        if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = strokeWidth; ctx.stroke(); }
                    }
                    
                    function drawArrow(fromX, fromY, toX, toY, color, dashed = false) {
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 3;
                        if (dashed) ctx.setLineDash([6, 4]);
                        else ctx.setLineDash([]);
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        const angle = Math.atan2(toY - fromY, toX - fromX);
                        ctx.beginPath();
                        ctx.moveTo(toX, toY);
                        ctx.lineTo(toX - 12 * Math.cos(angle - 0.4), toY - 12 * Math.sin(angle - 0.4));
                        ctx.lineTo(toX - 12 * Math.cos(angle + 0.4), toY - 12 * Math.sin(angle + 0.4));
                        ctx.closePath();
                        ctx.fillStyle = color;
                        ctx.fill();
                    }
                    
                    function draw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        const fahrenheit = celsiusToFahrenheit(celsius);
                        
                        ctx.font = 'bold 16px system-ui';
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.fillText('Lifting State Up: Temperature Converter', canvas.width / 2, 25);
                        
                        // Parent component (owns state)
                        const parentHighlight = animationPhase >= 2 && animationPhase <= 3;
                        drawRoundedRect(200, 50, 350, 100, 10, parentHighlight ? '#E8F5E9' : '#f8f4ff', parentHighlight ? '#4CAF50' : '#667eea');
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#667eea';
                        ctx.fillText('üì¶ TemperatureConverter (Parent)', 375, 75);
                        
                        drawRoundedRect(220, 95, 310, 45, 6, 'white', '#ddd', 1);
                        ctx.font = '12px monospace';
                        ctx.fillStyle = '#666';
                        ctx.fillText('const [temperature, setTemperature] = useState(' + celsius + ')', 375, 115);
                        ctx.font = 'bold 11px system-ui';
                        ctx.fillStyle = parentHighlight ? '#4CAF50' : '#667eea';
                        ctx.fillText('Source of Truth', 375, 132);
                        
                        // Celsius child
                        const celsiusHighlight = lastSource === 'celsius' && animationPhase === 1;
                        drawRoundedRect(50, 220, 200, 130, 10, celsiusHighlight ? '#E3F2FD' : '#f5f5f5', celsiusHighlight ? '#2196F3' : '#ddd');
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#2196F3';
                        ctx.fillText('üå°Ô∏è CelsiusInput', 150, 245);
                        
                        drawRoundedRect(70, 260, 160, 70, 6, 'white', '#2196F3', 2);
                        ctx.font = 'bold 28px system-ui';
                        ctx.fillStyle = '#2196F3';
                        ctx.fillText(celsius.toFixed(0) + '¬∞C', 150, 305);
                        
                        // Fahrenheit child
                        const fahrenheitHighlight = lastSource === 'fahrenheit' && animationPhase === 1;
                        drawRoundedRect(500, 220, 200, 130, 10, fahrenheitHighlight ? '#FFF3E0' : '#f5f5f5', fahrenheitHighlight ? '#FF9800' : '#ddd');
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#FF9800';
                        ctx.fillText('üå°Ô∏è FahrenheitInput', 600, 245);
                        
                        drawRoundedRect(520, 260, 160, 70, 6, 'white', '#FF9800', 2);
                        ctx.font = 'bold 28px system-ui';
                        ctx.fillStyle = '#FF9800';
                        ctx.fillText(fahrenheit.toFixed(0) + '¬∞F', 600, 305);
                        
                        // Arrows - props down
                        drawArrow(300, 150, 150, 215, '#4CAF50');
                        ctx.font = '10px system-ui';
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText('temp prop', 200, 175);
                        
                        drawArrow(450, 150, 600, 215, '#4CAF50');
                        ctx.fillText('temp prop', 550, 175);
                        
                        // Arrows - callbacks up (show during animation)
                        if (animationPhase >= 1 && lastSource === 'celsius') {
                            drawArrow(150, 215, 320, 150, '#2196F3', true);
                            ctx.fillStyle = '#2196F3';
                            ctx.fillText('onChange', 210, 195);
                        }
                        if (animationPhase >= 1 && lastSource === 'fahrenheit') {
                            drawArrow(600, 215, 430, 150, '#FF9800', true);
                            ctx.fillStyle = '#FF9800';
                            ctx.fillText('onChange', 540, 195);
                        }
                        
                        // Legend
                        ctx.font = '11px system-ui';
                        ctx.fillStyle = '#666';
                        ctx.textAlign = 'left';
                        ctx.fillText('‚Üí Props flow down', 50, 375);
                        ctx.fillText('‚§¥ Callbacks flow up', 200, 375);
                        ctx.fillText('State in parent = synchronized inputs!', 400, 375);
                        
                        if (animationPhase > 0 && animationPhase < 4) {
                            animationProgress += 0.04;
                            if (animationProgress >= 1) {
                                animationPhase++;
                                animationProgress = 0;
                                if (animationPhase >= 4) {
                                    animationPhase = 0;
                                    lastSource = null;
                                }
                            }
                            requestAnimationFrame(draw);
                        }
                    }
                    
                    function updateTemp(source, delta) {
                        celsius += delta;
                        lastSource = source;
                        animationPhase = 1;
                        animationProgress = 0;
                        draw();
                    }
                    
                    document.getElementById('celsiusUpBtn').addEventListener('click', () => updateTemp('celsius', 5));
                    document.getElementById('celsiusDownBtn').addEventListener('click', () => updateTemp('celsius', -5));
                    document.getElementById('fahrenheitUpBtn').addEventListener('click', () => updateTemp('fahrenheit', 5));
                    document.getElementById('fahrenheitDownBtn').addEventListener('click', () => updateTemp('fahrenheit', -5));
                    
                    draw();
                })();
                </script>
    Child1->>Parent: onTemperatureChange("25")
    Parent->>Parent: Update state, calculate Fahrenheit
    Parent->>Child1: Re-render with temp="25"
    Parent->>Child2: Re-render with temp="77"
    Child2->>User: Display "77" Fahrenheit
    
    Note over Parent: Parent is "source of truth"
</pre>

                <h3>Key Steps to Lift State</h3>
                <div class="card">
                    <h4>The Lifting State Up Recipe</h4>
                    <ol>
                        <li><strong>Remove state from children</strong> - Delete their useState calls</li>
                        <li><strong>Add state to parent</strong> - Parent now owns the data</li>
                        <li><strong>Pass data down as props</strong> - Children receive the current value</li>
                        <li><strong>Pass callbacks down</strong> - Children can request updates</li>
                        <li><strong>Make children controlled</strong> - They no longer manage their own state</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Lifting State</h4>
                    <ul>
                        <li><strong>Single source of truth</strong> - One place owns the data</li>
                        <li><strong>Synchronized updates</strong> - All components see the same data</li>
                        <li><strong>Easier debugging</strong> - State logic is in one place</li>
                        <li><strong>Better testability</strong> - Test parent, children are simple</li>
                    </ul>
                </div>
            </section>

            <!-- Section 3: Prop Drilling Problem -->
            <section id="section3" class="lesson-section">
                <h2>üï≥Ô∏è Prop Drilling Problem</h2>
                <p>As your component tree grows, you might find yourself passing props through many layers of components that don't actually use them. This is called "prop drilling" - and it's a code smell!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Prop Drilling:</strong> Passing props through multiple component layers, where intermediate components don't use the props - they just pass them down to deeper children.</p>
                </div>

                <h3>The Problem Illustrated</h3>
                <pre class="mermaid">
graph TD
    A[App - has user state] --> B[Header]
    A --> C[Main]
    C --> D[Sidebar]
    C --> E[Content]
    E --> F[Article]
    F --> G[Author - needs user]
    
    A -.props drilling.-> B
    A -.props drilling.-> C
    C -.props drilling.-> E
    E -.props drilling.-> F
    F -.user prop.-> G
    
    style A fill:#667eea,color:#fff
    style B fill:#f44336,color:#fff
    style C fill:#f44336,color:#fff
    style E fill:#f44336,color:#fff
    style F fill:#f44336,color:#fff
    style G fill:#4CAF50,color:#fff
</pre>

                <div class="card">
                    <h4>Example: Prop Drilling Code</h4>
                    <pre><code class="language-typescript">// ‚ùå Prop drilling - passing user through many layers
interface User {
    name: string;
    avatar: string;
}

const App: React.FC = () => {
    const [user, setUser] = useState&lt;User&gt;({ name: 'Alice', avatar: 'üë§' });
    
    return &lt;Main user={user} /&gt;;
};

// Main doesn't use user, just passes it down
const Main: React.FC&lt;{ user: User }&gt; = ({ user }) => {
    return &lt;Content user={user} /&gt;;
};

// Content doesn't use user, just passes it down
const Content: React.FC&lt;{ user: User }&gt; = ({ user }) => {
    return &lt;Article user={user} /&gt;;
};

// Article doesn't use user, just passes it down
const Article: React.FC&lt;{ user: User }&gt; = ({ user }) => {
    return &lt;Author user={user} /&gt;;
};

// Finally! Author actually uses it
const Author: React.FC&lt;{ user: User }&gt; = ({ user }) => {
    return &lt;div&gt;{user.avatar} {user.name}&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>Why Prop Drilling is Bad</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Problem</th>
                            <th>Impact</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Verbose code</td>

                <h3>üé® Visualizing Prop Drilling</h3>
                <svg viewBox="0 0 800 420" style="width: 100%; max-width: 800px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <defs>
                        <linearGradient id="propDrillGrad" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea"/>
                            <stop offset="100%" style="stop-color:#764ba2"/>
                        </linearGradient>
                        <marker id="propArrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#f44336"/>
                        </marker>
                        <marker id="needArrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <path d="M0,0 L0,6 L9,3 z" fill="#4CAF50"/>
                        </marker>
                    </defs>
                    
                    <text x="400" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="16">Prop Drilling: User Data Through 5 Levels</text>
                    
                    <!-- App (owns state) -->
                    <rect x="300" y="45" width="200" height="50" rx="8" fill="url(#propDrillGrad)"/>
                    <text x="400" y="75" text-anchor="middle" fill="white" font-weight="bold" font-size="13">App (owns user state)</text>
                    
                    <!-- Level 1 -->
                    <rect x="300" y="115" width="200" height="40" rx="6" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                    <text x="400" y="140" text-anchor="middle" fill="#c62828" font-size="12">Layout</text>
                    <text x="520" y="140" fill="#f44336" font-size="10">passes user ‚Üì</text>
                    
                    <!-- Level 2 -->
                    <rect x="300" y="175" width="200" height="40" rx="6" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                    <text x="400" y="200" text-anchor="middle" fill="#c62828" font-size="12">Main</text>
                    <text x="520" y="200" fill="#f44336" font-size="10">passes user ‚Üì</text>
                    
                    <!-- Level 3 -->
                    <rect x="300" y="235" width="200" height="40" rx="6" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                    <text x="400" y="260" text-anchor="middle" fill="#c62828" font-size="12">Content</text>
                    <text x="520" y="260" fill="#f44336" font-size="10">passes user ‚Üì</text>
                    
                    <!-- Level 4 -->
                    <rect x="300" y="295" width="200" height="40" rx="6" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                    <text x="400" y="320" text-anchor="middle" fill="#c62828" font-size="12">Article</text>
                    <text x="520" y="320" fill="#f44336" font-size="10">passes user ‚Üì</text>
                    
                    <!-- Level 5 (actually uses it) -->
                    <rect x="300" y="355" width="200" height="50" rx="8" fill="#E8F5E9" stroke="#4CAF50" stroke-width="3"/>
                    <text x="400" y="380" text-anchor="middle" fill="#2E7D32" font-weight="bold" font-size="13">Author (uses user!)</text>
                    <text x="400" y="395" text-anchor="middle" fill="#4CAF50" font-size="10">Finally needs the data ‚úì</text>
                    
                    <!-- Connecting lines -->
                    <line x1="400" y1="95" x2="400" y2="115" stroke="#f44336" stroke-width="2" stroke-dasharray="4"/>
                    <line x1="400" y1="155" x2="400" y2="175" stroke="#f44336" stroke-width="2" stroke-dasharray="4"/>
                    <line x1="400" y1="215" x2="400" y2="235" stroke="#f44336" stroke-width="2" stroke-dasharray="4"/>
                    <line x1="400" y1="275" x2="400" y2="295" stroke="#f44336" stroke-width="2" stroke-dasharray="4"/>
                    <line x1="400" y1="335" x2="400" y2="355" stroke="#4CAF50" stroke-width="3"/>
                    
                    <!-- Problem indicators -->
                    <rect x="50" y="120" width="180" height="200" rx="8" fill="#FFF3E0" stroke="#FF9800"/>
                    <text x="140" y="145" text-anchor="middle" fill="#E65100" font-weight="bold" font-size="12">‚ö†Ô∏è Problems</text>
                    <text x="60" y="170" fill="#333" font-size="10">‚Ä¢ 4 components just pass data</text>
                    <text x="60" y="190" fill="#333" font-size="10">‚Ä¢ All need user in their props</text>
                    <text x="60" y="210" fill="#333" font-size="10">‚Ä¢ Hard to refactor</text>
                    <text x="60" y="230" fill="#333" font-size="10">‚Ä¢ Tight coupling</text>
                    <text x="60" y="250" fill="#333" font-size="10">‚Ä¢ Can't reuse components</text>
                    <text x="60" y="270" fill="#333" font-size="10">‚Ä¢ Props interfaces bloated</text>
                    <text x="60" y="295" fill="#f44336" font-size="10" font-weight="bold">These don't even USE user!</text>
                    
                    <!-- Solution hint -->
                    <rect x="570" y="120" width="180" height="200" rx="8" fill="#E8F5E9" stroke="#4CAF50"/>
                    <text x="660" y="145" text-anchor="middle" fill="#2E7D32" font-weight="bold" font-size="12">‚úÖ Solutions</text>
                    <text x="580" y="170" fill="#333" font-size="10">1. Composition</text>
                    <text x="590" y="188" fill="#666" font-size="9">   Pass Author as child</text>
                    <text x="580" y="210" fill="#333" font-size="10">2. Context API</text>
                    <text x="590" y="228" fill="#666" font-size="9">   Skip intermediate layers</text>
                    <text x="580" y="250" fill="#333" font-size="10">3. Restructure</text>
                    <text x="590" y="268" fill="#666" font-size="9">   Move Author closer to App</text>
                    <text x="580" y="295" fill="#4CAF50" font-size="10" font-weight="bold">Remove the middlemen!</text>
                </svg>
                            <td>Every intermediate component needs prop definitions</td>
                        </tr>
                        <tr>
                            <td>Hard to refactor</td>
                            <td>Adding/removing props affects many files</td>
                        </tr>
                        <tr>
                            <td>Tight coupling</td>
                            <td>Intermediate components know about data they don't use</td>
                        </tr>
                        <tr>
                            <td>Poor reusability</td>
                            <td>Components can't be reused without the drilled props</td>
                        </tr>
                        <tr>
                            <td>Confusing</td>
                            <td>Hard to track where data comes from and goes to</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Solutions to Prop Drilling</h3>
                <div class="card">
                    <h4>1. Component Composition (Recommended)</h4>
                    <p>Instead of passing props down, pass components as children:</p>
                    <pre><code class="language-typescript">// ‚úÖ Better: Use composition
const App: React.FC = () => {
    const [user, setUser] = useState&lt;User&gt;({ name: 'Alice', avatar: 'üë§' });
    
    return (
        &lt;Main&gt;
            &lt;Content&gt;
                &lt;Article&gt;
                    &lt;Author user={user} /&gt;
                &lt;/Article&gt;
            &lt;/Content&gt;
        &lt;/Main&gt;
    );
};

// Now these components don't need to know about user!
const Main: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {
    return &lt;main&gt;{children}&lt;/main&gt;;
};

const Content: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {
    return &lt;div className="content"&gt;{children}&lt;/div&gt;;
};</code></pre>
                </div>

                <div class="card">
                    <h4>2. Context API (For Truly Global Data)</h4>
                    <p>We'll cover this in detail in Module 5, but here's a preview:</p>
                    <pre><code class="language-typescript">// Create context (we'll learn this later!)
const UserContext = React.createContext&lt;User | null&gt;(null);

// Provider at top
const App: React.FC = () => {
    const [user, setUser] = useState&lt;User&gt;({ name: 'Alice', avatar: 'üë§' });
    
    return (
        &lt;UserContext.Provider value={user}&gt;
            &lt;Main /&gt;
        &lt;/UserContext.Provider&gt;
    );
};

// Consumer deep in tree - no prop drilling!
const Author: React.FC = () => {
    const user = useContext(UserContext);
    return &lt;div&gt;{user?.avatar} {user?.name}&lt;/div&gt;;
};</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When is Prop Drilling Okay?</h4>
                    <p>Prop drilling isn't always bad! It's fine when:</p>
                    <ul>
                        <li>Only 1-2 levels deep</li>
                        <li>The data flow is clear and obvious</li>
                        <li>Components are tightly related</li>
                        <li>Alternative solutions would be more complex</li>
                    </ul>
                    <p>Don't prematurely optimize! If it's not causing problems, it's fine.</p>
                </div>
            </section>

            <!-- Section 4: State Colocation -->
            <section id="section4" class="lesson-section">
                <h2>üìç State Colocation</h2>
                <p>While we've talked about lifting state up, sometimes the opposite is true - you should push state down! This is called state colocation.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>State Colocation:</strong> Keeping state as close as possible to where it's used. If only one component (or a small component subtree) needs the state, keep it there instead of unnecessarily lifting it up.</p>
                </div>

                <h3>The Colocation Principle</h3>
                <div class="card">
                    <h4>Kent C. Dodds' Rule</h4>
                    <blockquote style="border-left: 4px solid #667eea; padding-left: 1rem; margin: 1rem 0; font-style: italic;">
                        "Place code as close to where it's relevant as possible"
                    </blockquote>
                    <p>Don't lift state higher than necessary. Each component should own the minimal amount of state it needs.</p>
                </div>

                <h3>Problem: State Too High in the Tree</h3>
                <div class="card">
                    <h4>Example: Accordion Component</h4>
                    <pre><code class="language-typescript">// ‚ùå Bad: App manages accordion state it doesn't need
const App: React.FC = () => {
    const [openPanel, setOpenPanel] = useState&lt;number | null&gt;(null);
    
    return (
        &lt;div&gt;
            &lt;Header /&gt;
            &lt;Sidebar /&gt;
            &lt;Accordion openPanel={openPanel} setOpenPanel={setOpenPanel} /&gt;
            &lt;Footer /&gt;
        &lt;/div&gt;
    );
};

// Why does App need to know about accordion state?
// Header, Sidebar, and Footer don't care!</code></pre>
                </div>

                <div class="card">
                    <h4>Better: State Lives Where It's Used</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Accordion manages its own state
const App: React.FC = () => {
    return (
        &lt;div&gt;
            &lt;Header /&gt;
            &lt;Sidebar /&gt;
            &lt;Accordion /&gt;  {/* Self-contained! */}
            &lt;Footer /&gt;
        &lt;/div&gt;
    );
};

const Accordion: React.FC = () => {
    // State lives here - only this component needs it
    const [openPanel, setOpenPanel] = useState&lt;number | null&gt;(null);
    
    return (
        &lt;div&gt;
            &lt;AccordionPanel
                id={0}
                isOpen={openPanel === 0}
                onToggle={() => setOpenPanel(openPanel === 0 ? null : 0)}
            &gt;
                Panel 1 Content
            &lt;/AccordionPanel&gt;
            &lt;AccordionPanel
                id={1}
                isOpen={openPanel === 1}
                onToggle={() => setOpenPanel(openPanel === 1 ? null : 1)}
            &gt;
                Panel 2 Content
            &lt;/AccordionPanel&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Benefits of State Colocation</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Benefit</th>
                            <th>Why It Matters</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Better Performance</strong></td>
                            <td>Only relevant components re-render when state changes</td>
                        </tr>
                        <tr>
                            <td><strong>Easier to Understand</strong></td>
                            <td>State logic is near where it's used</td>
                        </tr>
                        <tr>
                            <td><strong>More Maintainable</strong></td>
                            <td>Changes are localized, not spread across files</td>
                        </tr>
                        <tr>
                            <td><strong>Better Reusability</strong></td>
                            <td>Components are self-contained and portable</td>
                        </tr>
                        <tr>
                            <td><strong>Cleaner Parent Components</strong></td>
                            <td>Parents don't manage irrelevant state</td>
                        </tr>

                <h3>üé® State Colocation: Before vs After</h3>
                <svg viewBox="0 0 800 380" style="width: 100%; max-width: 800px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <text x="400" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="16">State Colocation: Keep State Close to Where It's Used</text>
                    
                    <!-- BAD: State too high -->
                    <g transform="translate(20, 50)">
                        <rect x="0" y="0" width="360" height="310" rx="10" fill="#FFEBEE" stroke="#f44336" stroke-width="2"/>
                        <rect x="0" y="0" width="360" height="35" rx="10" fill="#f44336"/>
                        <text x="180" y="24" text-anchor="middle" fill="white" font-weight="bold" font-size="13">‚ùå State Too High</text>
                        
                        <!-- App with unnecessary state -->
                        <rect x="80" y="50" width="200" height="55" rx="6" fill="#fff" stroke="#f44336" stroke-width="2"/>
                        <text x="180" y="70" text-anchor="middle" fill="#333" font-size="11" font-weight="bold">App</text>
                        <text x="180" y="85" text-anchor="middle" fill="#c62828" font-size="9">[openPanel, setOpenPanel]</text>
                        <text x="180" y="98" text-anchor="middle" fill="#999" font-size="8">Why does App care? ü§î</text>
                        
                        <!-- Children that don't need it -->
                        <rect x="20" y="125" width="70" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="55" y="147" text-anchor="middle" fill="#999" font-size="9">Header</text>
                        
                        <rect x="100" y="125" width="70" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="135" y="147" text-anchor="middle" fill="#999" font-size="9">Sidebar</text>
                        
                        <rect x="180" y="125" width="90" height="35" rx="4" fill="#fff" stroke="#f44336" stroke-width="2"/>
                        <text x="225" y="147" text-anchor="middle" fill="#c62828" font-size="9">Accordion</text>
                        
                        <rect x="280" y="125" width="60" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="310" y="147" text-anchor="middle" fill="#999" font-size="9">Footer</text>
                        
                        <!-- Problem indicators -->
                        <text x="20" y="185" fill="#c62828" font-size="10">Problems:</text>
                        <text x="20" y="205" fill="#666" font-size="9">‚Ä¢ App re-renders when panel changes</text>
                        <text x="20" y="220" fill="#666" font-size="9">‚Ä¢ All siblings re-render too</text>
                        <text x="20" y="235" fill="#666" font-size="9">‚Ä¢ Props drilling to Accordion</text>
                        <text x="20" y="250" fill="#666" font-size="9">‚Ä¢ App bloated with unrelated state</text>
                        
                        <!-- Re-render indicator -->
                        <rect x="20" y="265" width="320" height="30" rx="4" fill="#ffcdd2"/>
                        <text x="180" y="285" text-anchor="middle" fill="#c62828" font-size="10" font-weight="bold">üîÑ 5 components re-render on panel change!</text>
                    </g>
                    
                    <!-- GOOD: State colocated -->
                    <g transform="translate(420, 50)">
                        <rect x="0" y="0" width="360" height="310" rx="10" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <rect x="0" y="0" width="360" height="35" rx="10" fill="#4CAF50"/>
                        <text x="180" y="24" text-anchor="middle" fill="white" font-weight="bold" font-size="13">‚úÖ State Colocated</text>
                        
                        <!-- App without unnecessary state -->
                        <rect x="80" y="50" width="200" height="45" rx="6" fill="#fff" stroke="#ddd"/>
                        <text x="180" y="70" text-anchor="middle" fill="#333" font-size="11" font-weight="bold">App</text>
                        <text x="180" y="88" text-anchor="middle" fill="#999" font-size="9">No panel state here!</text>
                        
                        <!-- Children -->
                        <rect x="20" y="115" width="70" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="55" y="137" text-anchor="middle" fill="#999" font-size="9">Header</text>
                        
                        <rect x="100" y="115" width="70" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="135" y="137" text-anchor="middle" fill="#999" font-size="9">Sidebar</text>
                        
                        <rect x="180" y="115" width="90" height="45" rx="4" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                        <text x="225" y="132" text-anchor="middle" fill="#2E7D32" font-size="9" font-weight="bold">Accordion</text>
                        <text x="225" y="148" text-anchor="middle" fill="#4CAF50" font-size="8">[openPanel] ‚úì</text>
                        
                        <rect x="280" y="115" width="60" height="35" rx="4" fill="#fff" stroke="#ddd"/>
                        <text x="310" y="137" text-anchor="middle" fill="#999" font-size="9">Footer</text>
                        
                        <!-- Benefits */
                        <text x="20" y="185" fill="#2E7D32" font-size="10">Benefits:</text>
                        <text x="20" y="205" fill="#666" font-size="9">‚Ä¢ Only Accordion manages its state</text>
                        <text x="20" y="220" fill="#666" font-size="9">‚Ä¢ Other components unaffected</text>
                        <text x="20" y="235" fill="#666" font-size="9">‚Ä¢ No props drilling needed</text>
                        <text x="20" y="250" fill="#666" font-size="9">‚Ä¢ Accordion is self-contained</text>
                        
                        <!-- Re-render indicator -->
                        <rect x="20" y="265" width="320" height="30" rx="4" fill="#c8e6c9"/>
                        <text x="180" y="285" text-anchor="middle" fill="#2E7D32" font-size="10" font-weight="bold">üéØ Only 1 component re-renders!</text>
                    </g>
                </svg>
                    </tbody>
                </table>

                <h3>Real-World Example: Modal Dialog</h3>
                <div class="card">
                    <h4>Modal That Manages Its Own State</h4>
                    <pre><code class="language-typescript">// ‚úÖ Modal is self-contained
interface ModalProps {
    trigger: React.ReactNode;
    children: React.ReactNode;
}

const Modal: React.FC&lt;ModalProps&gt; = ({ trigger, children }) => {
    // State is colocated with the component that uses it
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        &lt;&gt;
            &lt;div onClick={() => setIsOpen(true)}&gt;
                {trigger}
            &lt;/div&gt;
            
            {isOpen && (
                &lt;div className="modal-overlay" onClick={() => setIsOpen(false)}&gt;
                    &lt;div className="modal-content" onClick={(e) => e.stopPropagation()}&gt;
                        {children}
                        &lt;button onClick={() => setIsOpen(false)}&gt;Close&lt;/button&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            )}
        &lt;/&gt;
    );
};

// Easy to use anywhere!
const App: React.FC = () => {
    return (
        &lt;div&gt;
            &lt;Modal trigger={&lt;button&gt;Open Settings&lt;/button&gt;}&gt;
                &lt;SettingsForm /&gt;
            &lt;/Modal&gt;
            
            &lt;Modal trigger={&lt;button&gt;Open Profile&lt;/button&gt;}&gt;
                &lt;ProfileEditor /&gt;
            &lt;/Modal&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Colocate State</h4>
                    <ul>
                        <li>UI state (open/closed, hover, focus)</li>
                        <li>Form input values (if form is self-contained)</li>
                        <li>Component-specific filters or settings</li>
                        <li>Animation or transition state</li>
                        <li>Temporary or transient data</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Colocate</h4>
                    <ul>
                        <li>Multiple components need to read the state</li>
                        <li>Multiple components need to update the state</li>
                        <li>State needs to persist across unmounting</li>
                        <li>State affects URL or needs to be bookmarkable</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Derived State -->
            <section id="section5" class="lesson-section">
                <h2>üîÑ Derived State</h2>
                <p>One of the most common mistakes in React is storing data that can be calculated from existing state or props. This creates unnecessary complexity and potential bugs!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Derived State:</strong> Data that can be calculated from existing state or props. Instead of storing it in state, compute it during render.</p>
                </div>

                <h3>The Problem: Redundant State</h3>
                <div class="card">
                    <h4>Example: Shopping Cart</h4>
                    <pre><code class="language-typescript">// ‚ùå Bad: Storing derived values
interface CartItem {
    id: number;
    name: string;
    price: number;
    quantity: number;
}

const ShoppingCart: React.FC = () => {
    const [items, setItems] = useState&lt;CartItem[]&gt;([]);
    const [itemCount, setItemCount] = useState(0);      // Redundant!
    const [totalPrice, setTotalPrice] = useState(0);    // Redundant!
    
    const addItem = (item: CartItem) => {
        setItems([...items, item]);
        setItemCount(itemCount + 1);                     // Extra work!
        setTotalPrice(totalPrice + item.price);          // Extra work!
    };
    
    // What if we remove an item? Update all three states!
    // What if quantity changes? Update all three states!
    // Easy to get out of sync! üò±
};</code></pre>
                </div>

                <div class="card">
                    <h4>Better: Calculate Derived Values</h4>
                    <pre><code class="language-typescript">// ‚úÖ Good: Derive values from source of truth
interface CartItem {
    id: number;
    name: string;
    price: number;
    quantity: number;
}

const ShoppingCart: React.FC = () => {
    // Only store the source of truth
    const [items, setItems] = useState&lt;CartItem[]&gt;([]);
    
    // Derive everything else
    const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
    const totalPrice = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    
    const addItem = (item: CartItem) => {
        setItems([...items, item]);
        // That's it! Counts update automatically
    };
    
    return (
        &lt;div&gt;
            &lt;p&gt;Items: {itemCount}&lt;/p&gt;
            &lt;p&gt;Total: ${totalPrice.toFixed(2)}&lt;/p&gt;
            {/* ... */}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Common Derived State Patterns</h3>
                <table>
                    <thead>
                        <tr>
                            <th>What You Want</th>
                            <th>Don't Store</th>
                            <th>Derive Instead</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Full name</td>
                            <td><code>const [fullName, ...]</code></td>
                            <td><code>const fullName = `${first} ${last}`</code></td>
                        </tr>
                        <tr>
                            <td>Array length</td>
                            <td><code>const [count, ...]</code></td>
                            <td><code>const count = items.length</code></td>
                        </tr>
                        <tr>
                            <td>Filtered list</td>
                            <td><code>const [filtered, ...]</code></td>
                            <td><code>const filtered = items.filter(...)</code></td>
                        </tr>
                        <tr>
                            <td>Sorted list</td>
                            <td><code>const [sorted, ...]</code></td>
                            <td><code>const sorted = [...items].sort(...)</code></td>
                        </tr>
                        <tr>
                            <td>Computed total</td>
                            <td><code>const [total, ...]</code></td>
                            <td><code>const total = items.reduce(...)</code></td>
                        </tr>

                <h3>üéÆ Interactive Demo: Derived State in Action</h3>
                <p>Add items to the cart and watch how totals are calculated automatically - never stored!</p>
                
                <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; margin: 1.5rem 0;">
                    <canvas id="derivedStateCanvas" width="750" height="340" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; border: 1px solid #ddd; border-radius: 8px; background: white;"></canvas>
                    <div style="display: flex; justify-content: center; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap;">
                        <button id="addAppleBtn" style="padding: 0.4rem 0.8rem; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">üçé Add Apple ($2)</button>
                        <button id="addBananaBtn" style="padding: 0.4rem 0.8rem; background: #FFEB3B; color: #333; border: none; border-radius: 4px; cursor: pointer;">üçå Add Banana ($1)</button>
                        <button id="addOrangeBtn" style="padding: 0.4rem 0.8rem; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">üçä Add Orange ($3)</button>
                        <button id="clearCartBtn" style="padding: 0.4rem 0.8rem; background: #9e9e9e; color: white; border: none; border-radius: 4px; cursor: pointer;">Clear Cart</button>
                    </div>
                </div>
                
                <script>
                (function() {
                    const canvas = document.getElementById('derivedStateCanvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');
                    
                    let items = [];
                    let nextId = 1;
                    
                    function draw() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Derive values (not stored!)
                        const itemCount = items.length;
                        const totalPrice = items.reduce((sum, item) => sum + item.price, 0);
                        const uniqueItems = [...new Set(items.map(i => i.name))].length;
                        
                        ctx.font = 'bold 16px system-ui';
                        ctx.fillStyle = '#333';
                        ctx.textAlign = 'center';
                        ctx.fillText('Derived State: Shopping Cart Demo', canvas.width / 2, 25);
                        
                        // Source of truth box
                        ctx.beginPath();
                        ctx.roundRect(30, 50, 320, 260, 8);
                        ctx.fillStyle = '#f8f4ff';
                        ctx.fill();
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#667eea';
                        ctx.textAlign = 'left';
                        ctx.fillText('üóÑÔ∏è Source of Truth (stored)', 45, 75);
                        ctx.font = '11px monospace';
                        ctx.fillStyle = '#666';
                        ctx.fillText('const [items, setItems] = useState([])', 45, 95);
                        
                        // Show items
                        ctx.font = '11px system-ui';
                        if (items.length === 0) {
                            ctx.fillStyle = '#999';
                            ctx.fillText('Cart is empty', 45, 125);
                        } else {
                            items.slice(0, 6).forEach((item, i) => {
                                ctx.fillStyle = '#333';
                                ctx.fillText(item.emoji + ' ' + item.name + ' - $' + item.price, 45, 125 + i * 22);
                            });
                            if (items.length > 6) {
                                ctx.fillStyle = '#999';
                                ctx.fillText('... and ' + (items.length - 6) + ' more items', 45, 125 + 6 * 22);
                            }
                        }
                        
                        // Derived values box
                        ctx.beginPath();
                        ctx.roundRect(400, 50, 320, 260, 8);
                        ctx.fillStyle = '#E8F5E9';
                        ctx.fill();
                        ctx.strokeStyle = '#4CAF50';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        ctx.font = 'bold 12px system-ui';
                        ctx.fillStyle = '#2E7D32';
                        ctx.textAlign = 'left';
                        ctx.fillText('üîÑ Derived Values (calculated)', 415, 75);
                        
                        ctx.font = '11px monospace';
                        ctx.fillStyle = '#666';
                        ctx.fillText('// Not stored! Calculated each render:', 415, 100);
                        
                        ctx.fillText('const itemCount = items.length;', 415, 125);
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText('‚Üí ' + itemCount, 640, 125);
                        
                        ctx.font = '11px monospace';
                        ctx.fillStyle = '#666';
                        ctx.fillText('const total = items.reduce(...);', 415, 160);
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText('‚Üí $' + totalPrice.toFixed(2), 640, 160);
                        
                        ctx.font = '11px monospace';
                        ctx.fillStyle = '#666';
                        ctx.fillText('const unique = new Set(...).size;', 415, 195);
                        ctx.font = 'bold 14px system-ui';
                        ctx.fillStyle = '#4CAF50';
                        ctx.fillText('‚Üí ' + uniqueItems, 640, 195);
                        
                        // Benefits
                        ctx.font = '10px system-ui';
                        ctx.fillStyle = '#2E7D32';
                        ctx.fillText('‚úì Always in sync with items', 415, 230);
                        ctx.fillText('‚úì No extra setState calls', 415, 248);
                        ctx.fillText('‚úì Cannot get out of sync!', 415, 266);
                        ctx.fillText('‚úì Single source of truth', 415, 284);
                        
                        // Arrow between boxes
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 3]);
                        ctx.beginPath();
                        ctx.moveTo(350, 180);
                        ctx.lineTo(400, 180);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        ctx.beginPath();
                        ctx.moveTo(400, 180);
                        ctx.lineTo(390, 175);
                        ctx.lineTo(390, 185);
                        ctx.closePath();
                        ctx.fillStyle = '#667eea';
                        ctx.fill();
                        
                        ctx.font = '9px system-ui';
                        ctx.fillStyle = '#667eea';
                        ctx.textAlign = 'center';
                        ctx.fillText('derives', 375, 170);
                    }
                    
                    function addItem(name, price, emoji) {
                        items.push({ id: nextId++, name, price, emoji });
                        draw();
                    }
                    
                    document.getElementById('addAppleBtn').addEventListener('click', () => addItem('Apple', 2, 'üçé'));
                    document.getElementById('addBananaBtn').addEventListener('click', () => addItem('Banana', 1, 'üçå'));
                    document.getElementById('addOrangeBtn').addEventListener('click', () => addItem('Orange', 3, 'üçä'));
                    document.getElementById('clearCartBtn').addEventListener('click', () => { items = []; draw(); });
                    
                    draw();
                })();
                </script>
                        <tr>
                            <td>Boolean check</td>
                            <td><code>const [isEmpty, ...]</code></td>
                            <td><code>const isEmpty = items.length === 0</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Real Example: Todo List with Filters</h3>
                <div class="card">
                    <h4>Deriving Filtered Lists</h4>
                    <pre><code class="language-typescript">interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

type Filter = 'all' | 'active' | 'completed';

const TodoList: React.FC = () => {
    // Store only the essential state
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [filter, setFilter] = useState&lt;Filter&gt;('all');
    
    // Derive filtered list (recalculated every render)
    const filteredTodos = todos.filter(todo => {
        if (filter === 'active') return !todo.completed;
        if (filter === 'completed') return todo.completed;
        return true; // 'all'
    });
    
    // Derive statistics
    const totalCount = todos.length;
    const activeCount = todos.filter(t => !t.completed).length;
    const completedCount = todos.filter(t => t.completed).length;
    
    return (
        &lt;div&gt;
            &lt;div&gt;
                &lt;button onClick={() => setFilter('all')}&gt;
                    All ({totalCount})
                &lt;/button&gt;
                &lt;button onClick={() => setFilter('active')}&gt;
                    Active ({activeCount})
                &lt;/button&gt;
                &lt;button onClick={() => setFilter('completed')}&gt;
                    Completed ({completedCount})
                &lt;/button&gt;
            &lt;/div&gt;
            
            &lt;ul&gt;
                {filteredTodos.map(todo => (
                    &lt;li key={todo.id}&gt;{todo.text}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Performance Note</h4>
                    <p>You might worry: "Doesn't recalculating every render hurt performance?"</p>
                    <p><strong>Usually, no!</strong> JavaScript is fast at simple operations. Only optimize if you have actual performance problems. For expensive calculations, you can use <code>useMemo</code> (we'll learn that in Module 5).</p>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Derived State</h4>
                    <ul>
                        <li><strong>Single source of truth</strong> - No risk of state getting out of sync</li>
                        <li><strong>Less code</strong> - No need to update multiple states</li>
                        <li><strong>Fewer bugs</strong> - Can't forget to update derived values</li>
                        <li><strong>Easier to reason about</strong> - Clear what the source data is</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: State Initialization -->
            <section id="section6" class="lesson-section">
                <h2>üé¨ State Initialization</h2>
                <p>How you initialize state matters! Let's explore different initialization strategies and when to use each.</p>

                <h3>Basic Initialization</h3>
                <div class="card">
                    <h4>Direct Value</h4>
                    <pre><code class="language-typescript">// Simple - pass the initial value directly
const [count, setCount] = useState(0);
const [name, setName] = useState('');
const [items, setItems] = useState&lt;string[]&gt;([]);</code></pre>
                </div>

                <h3>Lazy Initialization</h3>
                <div class="card">
                    <h4>Function Initializer</h4>
                    <p>If calculating the initial state is expensive, pass a function instead:</p>
                    <pre><code class="language-typescript">// ‚ùå Bad: Runs expensive function on every render
const [todos, setTodos] = useState(loadTodosFromLocalStorage());
// loadTodosFromLocalStorage() runs every time, but only first value is used!

// ‚úÖ Good: Lazy initialization - runs only once
const [todos, setTodos] = useState(() => loadTodosFromLocalStorage());
// Function only called on first render

// Another example
const [bigArray, setBigArray] = useState(() => {
    console.log('Computing initial state...');
    return Array.from({ length: 10000 }, (_, i) => i);
});
// Expensive computation only happens once!</code></pre>
                </div>

                <h3>Initialization from Props</h3>
                <div class="card">
                    <h4>Using Props for Initial State</h4>
                    <pre><code class="language-typescript">// Common pattern: Initialize from props
interface CounterProps {
    initialCount: number;
}

const Counter: React.FC&lt;CounterProps&gt; = ({ initialCount }) => {
    const [count, setCount] = useState(initialCount);
    
    // Note: This only uses initialCount on first render
    // Later prop changes won't update state!
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important: Props Don't Re-Initialize State</h4>
                    <pre><code class="language-typescript">// Parent changes initialCount
&lt;Counter initialCount={10} /&gt;  // First render: count = 10
&lt;Counter initialCount={20} /&gt;  // Re-render: count still 10!

// State is initialized once and then managed by the component
// Prop changes don't reset it!</code></pre>
                </div>

                <h3>Resetting State with Key</h3>
                <div class="card">
                    <h4>Using Key to Force Re-initialization</h4>
                    <p>If you need state to reset when a prop changes, use the <code>key</code> prop:</p>
                    <pre><code class="language-typescript">// Force component to remount (and re-initialize state) when userId changes
&lt;UserProfile key={userId} userId={userId} /&gt;

// Each unique key creates a new instance
&lt;Counter key="counter1" initialCount={0} /&gt;
&lt;Counter key="counter2" initialCount={10} /&gt;
// These are separate components with separate state!</code></pre>
                </div>

                <h3>Initialization Strategies</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Strategy</th>
                            <th>When to Use</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Direct Value</strong></td>
                            <td>Simple, cheap computation</td>
                            <td><code>useState(0)</code></td>
                        </tr>
                        <tr>
                            <td><strong>Lazy Function</strong></td>
                            <td>Expensive computation</td>
                            <td><code>useState(() => calculate())</code></td>
                        </tr>
                        <tr>
                            <td><strong>From Props</strong></td>
                            <td>Initial value from parent</td>
                            <td><code>useState(props.initial)</code></td>
                        </tr>
                        <tr>
                            <td><strong>From Local Storage</strong></td>
                            <td>Persist across sessions</td>
                            <td><code>useState(() => localStorage.get())</code></td>
                        </tr>
                        <tr>
                            <td><strong>With Key Reset</strong></td>
                            <td>Reset when prop changes</td>
                            <td><code>&lt;Comp key={id} /&gt;</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Local Storage Pattern</h3>
                <div class="card">
                    <h4>Persisting State Across Page Loads</h4>
                    <pre><code class="language-typescript">const useLocalStorage = &lt;T,&gt;(key: string, initialValue: T) => {
    // Lazy initialization from localStorage
    const [value, setValue] = useState&lt;T&gt;(() => {
        try {
            const item = window.localStorage.getItem(key);
            return item ? JSON.parse(item) : initialValue;
        } catch (error) {
            console.error(error);
            return initialValue;
        }
    });
    
    // Update localStorage when state changes
    const setStoredValue = (newValue: T) => {
        try {
            setValue(newValue);
            window.localStorage.setItem(key, JSON.stringify(newValue));
        } catch (error) {
            console.error(error);
        }
    };
    
    return [value, setStoredValue] as const;
};

// Usage
const [name, setName] = useLocalStorage('userName', '');
// State persists across page refreshes!</code></pre>
                </div>
            </section>

            <!-- Section 7: Component Communication Patterns -->
            <section id="section7" class="lesson-section">
                <h2>üí¨ Component Communication Patterns</h2>
                <p>Components need to communicate! Let's explore the different ways components can share information.</p>

                <h3>Communication Flow Directions</h3>
                <pre class="mermaid">
graph TD
    A[Parent] -->|Props down| B[Child]
    B -->|Callbacks up| A
    C[Sibling 1] -.Can't talk directly.-> D[Sibling 2]
    E[Parent] -->|Props| C
    E -->|Props| D
    C -->|Callback| E
    E -->|Re-render| D
    
    style A fill:#667eea,color:#fff
    style E fill:#667eea,color:#fff
</pre>

                <h3>Pattern 1: Parent to Child (Props)</h3>
                <div class="card">
                    <h4>Passing Data Down</h4>
                    <pre><code class="language-typescript">// Parent passes data to child via props
const Parent: React.FC = () => {
    const [message, setMessage] = useState('Hello!');
    
    return &lt;Child message={message} /&gt;;
};

const Child: React.FC&lt;{ message: string }&gt; = ({ message }) => {
    return &lt;p&gt;{message}&lt;/p&gt;;
};</code></pre>
                </div>

                <h3>Pattern 2: Child to Parent (Callbacks)</h3>
                <div class="card">
                    <h4>Passing Data Up</h4>
                    <pre><code class="language-typescript">// Child calls parent's function to send data up
const Parent: React.FC = () => {
    const [value, setValue] = useState('');
    
    const handleChange = (newValue: string) => {
        setValue(newValue);
        console.log('Child sent:', newValue);
    };
    
    return (

                <h3>üé® Data Flow Patterns Visualized</h3>
                <svg viewBox="0 0 800 400" style="width: 100%; max-width: 800px; height: auto; margin: 2rem auto; display: block; font-family: system-ui, sans-serif;">
                    <defs>
                        <marker id="downArrow" markerWidth="10" markerHeight="10" refX="5" refY="10" orient="auto">
                            <path d="M0,0 L5,10 L10,0" fill="#4CAF50"/>
                        </marker>
                        <marker id="upArrow" markerWidth="10" markerHeight="10" refX="5" refY="0" orient="auto">
                            <path d="M0,10 L5,0 L10,10" fill="#2196F3"/>
                        </marker>
                    </defs>
                    
                    <text x="400" y="25" text-anchor="middle" fill="#333" font-weight="bold" font-size="16">Component Communication: Unidirectional Data Flow</text>
                    
                    <!-- Parent -->
                    <rect x="280" y="50" width="240" height="70" rx="10" fill="#f8f4ff" stroke="#667eea" stroke-width="2"/>
                    <text x="400" y="75" text-anchor="middle" fill="#667eea" font-weight="bold" font-size="14">Parent Component</text>
                    <text x="400" y="95" text-anchor="middle" fill="#666" font-size="10">[state, setState] = useState(...)</text>
                    <text x="400" y="110" text-anchor="middle" fill="#999" font-size="9">Source of truth</text>
                    
                    <!-- Left Child -->
                    <rect x="100" y="200" width="200" height="80" rx="8" fill="#E8F5E9" stroke="#4CAF50" stroke-width="2"/>
                    <text x="200" y="225" text-anchor="middle" fill="#2E7D32" font-weight="bold" font-size="12">Child A (Input)</text>
                    <text x="200" y="245" text-anchor="middle" fill="#666" font-size="10">Receives: value prop</text>
                    <text x="200" y="265" text-anchor="middle" fill="#666" font-size="10">Sends: onChange callback</text>
                    
                    <!-- Right Child -->
                    <rect x="500" y="200" width="200" height="80" rx="8" fill="#E3F2FD" stroke="#2196F3" stroke-width="2"/>
                    <text x="600" y="225" text-anchor="middle" fill="#1565C0" font-weight="bold" font-size="12">Child B (Display)</text>
                    <text x="600" y="245" text-anchor="middle" fill="#666" font-size="10">Receives: value prop</text>
                    <text x="600" y="265" text-anchor="middle" fill="#666" font-size="10">Read-only display</text>
                    
                    <!-- Props down arrows -->
                    <line x1="330" y1="120" x2="200" y2="195" stroke="#4CAF50" stroke-width="3"/>
                    <polygon points="200,195 210,180 195,182" fill="#4CAF50"/>
                    <text x="240" y="155" fill="#4CAF50" font-size="10" font-weight="bold">Props ‚Üì</text>
                    
                    <line x1="470" y1="120" x2="600" y2="195" stroke="#4CAF50" stroke-width="3"/>
                    <polygon points="600,195 590,180 605,182" fill="#4CAF50"/>
                    <text x="560" y="155" fill="#4CAF50" font-size="10" font-weight="bold">Props ‚Üì</text>
                    
                    <!-- Callback up arrow -->
                    <line x1="200" y1="195" x2="350" y2="125" stroke="#2196F3" stroke-width="3" stroke-dasharray="6,3"/>
                    <polygon points="350,125 335,130 340,140" fill="#2196F3"/>
                    <text x="250" y="175" fill="#2196F3" font-size="10" font-weight="bold">Callback ‚Üë</text>
                    
                    <!-- Re-render arrow to Child B -->
                    <path d="M 470 90 Q 550 90 600 195" stroke="#FF9800" stroke-width="2" fill="none" stroke-dasharray="4,2"/>
                    <polygon points="600,195 595,180 607,185" fill="#FF9800"/>
                    <text x="560" y="100" fill="#FF9800" font-size="9">Re-render with new props</text>
                    
                    <!-- Flow description boxes -->
                    <rect x="50" y="310" width="200" height="80" rx="6" fill="#E8F5E9"/>
                    <text x="150" y="335" text-anchor="middle" fill="#2E7D32" font-weight="bold" font-size="11">Props Down</text>
                    <text x="150" y="355" text-anchor="middle" fill="#666" font-size="9">Data flows from parent to children</text>
                    <text x="150" y="370" text-anchor="middle" fill="#666" font-size="9">Read-only in children</text>
                    
                    <rect x="300" y="310" width="200" height="80" rx="6" fill="#E3F2FD"/>
                    <text x="400" y="335" text-anchor="middle" fill="#1565C0" font-weight="bold" font-size="11">Callbacks Up</text>
                    <text x="400" y="355" text-anchor="middle" fill="#666" font-size="9">Children request state changes</text>
                    <text x="400" y="370" text-anchor="middle" fill="#666" font-size="9">Parent decides what to update</text>
                    
                    <rect x="550" y="310" width="200" height="80" rx="6" fill="#FFF3E0"/>
                    <text x="650" y="335" text-anchor="middle" fill="#E65100" font-weight="bold" font-size="11">Siblings via Parent</text>
                    <text x="650" y="355" text-anchor="middle" fill="#666" font-size="9">No direct sibling communication</text>
                    <text x="650" y="370" text-anchor="middle" fill="#666" font-size="9">Parent coordinates all updates</text>
                </svg>
        &lt;div&gt;
            &lt;Child onValueChange={handleChange} /&gt;
            &lt;p&gt;Parent received: {value}&lt;/p&gt;
        &lt;/div&gt;
    );
};

const Child: React.FC&lt;{ onValueChange: (value: string) => void }&gt; = ({ onValueChange }) => {
    return (
        &lt;input 
            onChange={(e) => onValueChange(e.target.value)}
            placeholder="Type something..."
        /&gt;
    );
};</code></pre>
                </div>

                <h3>Pattern 3: Sibling to Sibling (via Parent)</h3>
                <div class="card">
                    <h4>Sharing Data Between Siblings</h4>
                    <pre><code class="language-typescript">// Siblings communicate through shared parent state
const Parent: React.FC = () => {
    const [sharedValue, setSharedValue] = useState('');
    
    return (
        &lt;div&gt;
            &lt;InputChild onValueChange={setSharedValue} /&gt;
            &lt;DisplayChild value={sharedValue} /&gt;
        &lt;/div&gt;
    );
};

const InputChild: React.FC&lt;{ onValueChange: (v: string) => void }&gt; = ({ onValueChange }) => {
    return &lt;input onChange={(e) => onValueChange(e.target.value)} /&gt;;
};

const DisplayChild: React.FC&lt;{ value: string }&gt; = ({ value }) => {
    return &lt;p&gt;Sibling says: {value}&lt;/p&gt;;
};</code></pre>
                </div>

                <h3>Pattern 4: Render Props</h3>
                <div class="card">
                    <h4>Sharing Logic with Render Props</h4>
                    <pre><code class="language-typescript">// Component provides functionality, parent controls rendering
interface MousePosition {
    x: number;
    y: number;
}

interface MouseTrackerProps {
    children: (position: MousePosition) => React.ReactNode;
}

const MouseTracker: React.FC&lt;MouseTrackerProps&gt; = ({ children }) => {
    const [position, setPosition] = useState({ x: 0, y: 0 });
    
    const handleMouseMove = (e: React.MouseEvent) => {
        setPosition({ x: e.clientX, y: e.clientY });
    };
    
    return (
        &lt;div onMouseMove={handleMouseMove} style={{ height: '100vh' }}&gt;
            {children(position)}
        &lt;/div&gt;
    );
};

// Usage - consumer controls what to render
&lt;MouseTracker&gt;
    {({ x, y }) => (
        &lt;p&gt;Mouse position: {x}, {y}&lt;/p&gt;
    )}
&lt;/MouseTracker&gt;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Communication Best Practices</h4>
                    <ul>
                        <li><strong>Prefer props and callbacks</strong> - Simple and explicit</li>
                        <li><strong>Keep data flow unidirectional</strong> - Down via props, up via callbacks</li>
                        <li><strong>Name callbacks clearly</strong> - Use "on" prefix: <code>onValueChange</code>, <code>onSubmit</code></li>
                        <li><strong>Lift state only when necessary</strong> - Don't prematurely optimize</li>
                        <li><strong>Consider composition</strong> - Sometimes better than prop drilling</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Hands-on Practice -->
            <section id="section8" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to apply these patterns! Let's build components that demonstrate proper state management.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Filter and List</h3>
                    <p><strong>Goal:</strong> Build a searchable list where search input and list are siblings.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Parent component manages the search term</li>
                        <li>SearchInput component (controlled input)</li>
                        <li>FilteredList component (displays filtered items)</li>
                        <li>Search term passed down, updates passed up</li>
                        <li>Items list should be hardcoded in parent</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Structure your components like this:</p>
                        <pre><code class="language-typescript">const App = () => {
    const [searchTerm, setSearchTerm] = useState('');
    const items = ['Apple', 'Banana', 'Cherry', ...];
    const filtered = items.filter(item => 
        item.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    return (
        &lt;div&gt;
            &lt;SearchInput value={searchTerm} onChange={setSearchTerm} /&gt;
            &lt;FilteredList items={filtered} /&gt;
        &lt;/div&gt;
    );
};</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import React, { useState } from 'react';

interface SearchInputProps {
    value: string;
    onChange: (value: string) => void;
}

const SearchInput: React.FC&lt;SearchInputProps&gt; = ({ value, onChange }) => {
    return (
        &lt;input
            type="text"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder="Search..."
            style={{ padding: '0.5rem', width: '100%', marginBottom: '1rem' }}
        /&gt;
    );
};

interface FilteredListProps {
    items: string[];
}

const FilteredList: React.FC&lt;FilteredListProps&gt; = ({ items }) => {
    return (
        &lt;ul style={{ listStyle: 'none', padding: 0 }}&gt;
            {items.length === 0 ? (
                &lt;li style={{ color: '#999' }}&gt;No items found&lt;/li&gt;
            ) : (
                items.map((item, index) => (
                    &lt;li key={index} style={{ padding: '0.5rem', borderBottom: '1px solid #eee' }}&gt;
                        {item}
                    &lt;/li&gt;
                ))
            )}
        &lt;/ul&gt;
    );
};

const SearchableList: React.FC = () => {
    const [searchTerm, setSearchTerm] = useState('');
    
    const items = [
        'Apple', 'Apricot', 'Banana', 'Blueberry', 'Cherry',
        'Cranberry', 'Date', 'Fig', 'Grape', 'Kiwi',
        'Lemon', 'Lime', 'Mango', 'Orange', 'Papaya',
        'Peach', 'Pear', 'Pineapple', 'Plum', 'Strawberry'
    ];
    
    // Derive filtered list - don't store it!
    const filteredItems = items.filter(item =>
        item.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    return (
        &lt;div style={{ maxWidth: '400px', margin: '0 auto', padding: '2rem' }}&gt;
            &lt;h2&gt;Fruit Search&lt;/h2&gt;
            &lt;SearchInput value={searchTerm} onChange={setSearchTerm} /&gt;
            &lt;p&gt;Showing {filteredItems.length} of {items.length} items&lt;/p&gt;
            &lt;FilteredList items={filteredItems} /&gt;
        &lt;/div&gt;
    );
};

export default SearchableList;</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Tabs Component</h3>
                    <p><strong>Goal:</strong> Build a tabs component that manages its own active tab state.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Tabs component manages active tab internally (state colocation)</li>
                        <li>Tab buttons to switch between tabs</li>
                        <li>Content area that shows active tab content</li>
                        <li>Highlight active tab</li>
                        <li>Parent shouldn't need to manage tab state</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <pre><code class="language-typescript">interface Tab {
    id: string;
    label: string;
    content: React.ReactNode;
}

const Tabs: React.FC&lt;{ tabs: Tab[] }&gt; = ({ tabs }) => {
    const [activeTab, setActiveTab] = useState(tabs[0].id);
    // Render tabs and content...
};</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import React, { useState } from 'react';

interface Tab {
    id: string;
    label: string;
    content: React.ReactNode;
}

interface TabsProps {
    tabs: Tab[];
}

const Tabs: React.FC&lt;TabsProps&gt; = ({ tabs }) => {
    // State is colocated - only Tabs needs to know which tab is active
    const [activeTab, setActiveTab] = useState(tabs[0]?.id || '');
    
    const activeContent = tabs.find(tab => tab.id === activeTab)?.content;
    
    return (
        &lt;div style={{ border: '1px solid #ddd', borderRadius: '8px', overflow: 'hidden' }}&gt;
            {/* Tab buttons */}
            &lt;div style={{ display: 'flex', borderBottom: '2px solid #ddd' }}&gt;
                {tabs.map(tab => (
                    &lt;button
                        key={tab.id}
                        onClick={() => setActiveTab(tab.id)}
                        style={{
                            flex: 1,
                            padding: '1rem',
                            border: 'none',
                            background: activeTab === tab.id ? '#667eea' : '#f5f5f5',
                            color: activeTab === tab.id ? 'white' : '#333',
                            cursor: 'pointer',
                            fontWeight: activeTab === tab.id ? 'bold' : 'normal',
                            transition: 'all 0.2s'
                        }}
                    &gt;
                        {tab.label}
                    &lt;/button&gt;
                ))}
            &lt;/div&gt;
            
            {/* Tab content */}
            &lt;div style={{ padding: '2rem' }}&gt;
                {activeContent}
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

// Usage - parent doesn't need to manage tab state!
const App: React.FC = () => {
    const tabs = [
        {
            id: 'profile',
            label: 'Profile',
            content: &lt;div&gt;Profile information goes here&lt;/div&gt;
        },
        {
            id: 'settings',
            label: 'Settings',
            content: &lt;div&gt;Settings options go here&lt;/div&gt;
        },
        {
            id: 'notifications',
            label: 'Notifications',
            content: &lt;div&gt;Notification preferences go here&lt;/div&gt;
        }
    ];
    
    return (
        &lt;div style={{ maxWidth: '600px', margin: '2rem auto' }}&gt;
            &lt;h1&gt;User Dashboard&lt;/h1&gt;
            &lt;Tabs tabs={tabs} /&gt;
        &lt;/div&gt;
    );
};

export default App;</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Parent-Child Sync</h3>
                    <p><strong>Goal:</strong> Build a color picker where RGB inputs sync with a color preview.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Three sliders for Red, Green, Blue (0-255)</li>
                        <li>Color preview box showing current color</li>
                        <li>Display hex code of current color</li>
                        <li>Parent manages RGB state, children are controlled</li>
                        <li>Derive hex color - don't store it!</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <pre><code class="language-typescript">const [rgb, setRgb] = useState({ r: 0, g: 0, b: 0 });

const hexColor = `#${rgb.r.toString(16).padStart(2, '0')}${rgb.g.toString(16).padStart(2, '0')}${rgb.b.toString(16).padStart(2, '0')}`;</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import React, { useState } from 'react';

interface RGB {
    r: number;
    g: number;
    b: number;
}

interface ColorSliderProps {
    label: string;
    value: number;
    onChange: (value: number) => void;
    color: string;
}

const ColorSlider: React.FC&lt;ColorSliderProps&gt; = ({ label, value, onChange, color }) => {
    return (
        &lt;div style={{ marginBottom: '1rem' }}&gt;
            &lt;label style={{ display: 'block', marginBottom: '0.5rem', fontWeight: 'bold' }}&gt;
                {label}: {value}
            &lt;/label&gt;
            &lt;input
                type="range"
                min="0"
                max="255"
                value={value}
                onChange={(e) => onChange(parseInt(e.target.value))}
                style={{ width: '100%', accentColor: color }}
            /&gt;
        &lt;/div&gt;
    );
};

const ColorPicker: React.FC = () => {
    const [rgb, setRgb] = useState&lt;RGB&gt;({ r: 100, g: 150, b: 200 });
    
    // Derive hex color - don't store it!
    const toHex = (n: number) => n.toString(16).padStart(2, '0');
    const hexColor = `#${toHex(rgb.r)}${toHex(rgb.g)}${toHex(rgb.b)}`;
    
    return (
        &lt;div style={{ maxWidth: '400px', margin: '2rem auto', padding: '2rem' }}&gt;
            &lt;h2&gt;RGB Color Picker&lt;/h2&gt;
            
            {/* Color Preview */}
            &lt;div
                style={{
                    width: '100%',
                    height: '150px',
                    backgroundColor: hexColor,
                    borderRadius: '8px',
                    marginBottom: '1.5rem',
                    border: '2px solid #ddd',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: rgb.r + rgb.g + rgb.b > 382 ? '#000' : '#fff',
                    fontSize: '1.5rem',
                    fontWeight: 'bold'
                }}
            &gt;
                {hexColor.toUpperCase()}
            &lt;/div&gt;
            
            {/* Sliders */}
            &lt;ColorSlider
                label="Red"
                value={rgb.r}
                onChange={(r) => setRgb({ ...rgb, r })}
                color="#ff0000"
            /&gt;
            
            &lt;ColorSlider
                label="Green"
                value={rgb.g}
                onChange={(g) => setRgb({ ...rgb, g })}
                color="#00ff00"
            /&gt;
            
            &lt;ColorSlider
                label="Blue"
                value={rgb.b}
                onChange={(b) => setRgb({ ...rgb, b })}
                color="#0000ff"
            /&gt;
            
            {/* RGB Values */}
            &lt;div style={{ marginTop: '1.5rem', padding: '1rem', background: '#f5f5f5', borderRadius: '4px' }}&gt;
                &lt;p style={{ margin: '0.25rem 0' }}&gt;&lt;strong&gt;RGB:&lt;/strong&gt; ({rgb.r}, {rgb.g}, {rgb.b})&lt;/p&gt;
                &lt;p style={{ margin: '0.25rem 0' }}&gt;&lt;strong&gt;Hex:&lt;/strong&gt; {hexColor.toUpperCase()}&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
};

export default ColorPicker;</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 9: Refactoring Exercise -->
            <section id="section9" class="lesson-section">
                <h2>üîß Refactoring Exercise</h2>
                <p>Let's take poorly organized state and refactor it to follow best practices!</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h3>‚ùå Bad Code: Multiple Issues</h3>
                    <p>This code has several state management problems. Can you spot them?</p>
                    <pre><code class="language-typescript">// üö® PROBLEMS IN THIS CODE!
const BadTodoApp: React.FC = () => {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [completedCount, setCompletedCount] = useState(0);  // Problem 1
    const [activeCount, setActiveCount] = useState(0);        // Problem 1
    const [filteredTodos, setFilteredTodos] = useState&lt;Todo[]&gt;([]);  // Problem 1
    const [filter, setFilter] = useState('all');
    
    const addTodo = (text: string) => {
        const newTodo = { id: Date.now(), text, completed: false };
        setTodos([...todos, newTodo]);
        setActiveCount(activeCount + 1);  // Problem 2: Easy to forget
        setFilteredTodos([...filteredTodos, newTodo]);  // Problem 2
    };
    
    const toggleTodo = (id: number) => {
        const updated = todos.map(t => 
            t.id === id ? { ...t, completed: !t.completed } : t
        );
        setTodos(updated);
        // Problem 3: Forgot to update counts! üò±
    };
    
    return &lt;div&gt;{/* JSX */}&lt;/div&gt;;
};</code></pre>
                    
                    <p><strong>Problems:</strong></p>
                    <ol>
                        <li>Storing derived state (counts and filtered list can be calculated)</li>
                        <li>Have to remember to update multiple states</li>
                        <li>Easy to forget updates, causing bugs (toggle forgot to update counts!)</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>‚úÖ Good Code: Refactored</h3>
                    <pre><code class="language-typescript">// ‚ú® FIXED VERSION
interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

type Filter = 'all' | 'active' | 'completed';

const GoodTodoApp: React.FC = () => {
    // Store only essential state
    const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
    const [filter, setFilter] = useState&lt;Filter&gt;('all');
    
    // Derive everything else
    const completedCount = todos.filter(t => t.completed).length;
    const activeCount = todos.filter(t => !t.completed).length;
    const filteredTodos = todos.filter(t => {
        if (filter === 'active') return !t.completed;
        if (filter === 'completed') return t.completed;
        return true;
    });
    
    const addTodo = (text: string) => {
        if (!text.trim()) return;
        const newTodo: Todo = {
            id: Date.now(),
            text: text.trim(),
            completed: false
        };
        setTodos([...todos, newTodo]);
        // That's it! Counts update automatically ‚ú®
    };
    
    const toggleTodo = (id: number) => {
        setTodos(todos.map(t =>
            t.id === id ? { ...t, completed: !t.completed } : t
        ));
        // Counts update automatically here too! ‚ú®
    };
    
    const deleteTodo = (id: number) => {
        setTodos(todos.filter(t => t.id !== id));
    };
    
    return (
        &lt;div style={{ maxWidth: '600px', margin: '2rem auto', padding: '2rem' }}&gt;
            &lt;h1&gt;Todo List&lt;/h1&gt;
            
            {/* Add Todo Form */}
            &lt;TodoInput onAddTodo={addTodo} /&gt;
            
            {/* Filter Buttons */}
            &lt;div style={{ margin: '1rem 0', display: 'flex', gap: '0.5rem' }}&gt;
                &lt;button onClick={() => setFilter('all')}&gt;
                    All ({todos.length})
                &lt;/button&gt;
                &lt;button onClick={() => setFilter('active')}&gt;
                    Active ({activeCount})
                &lt;/button&gt;
                &lt;button onClick={() => setFilter('completed')}&gt;
                    Completed ({completedCount})
                &lt;/button&gt;
            &lt;/div&gt;
            
            {/* Todo List */}
            &lt;TodoList
                todos={filteredTodos}
                onToggle={toggleTodo}
                onDelete={deleteTodo}
            /&gt;
        &lt;/div&gt;
    );
};

// Separate components for better organization
interface TodoInputProps {
    onAddTodo: (text: string) => void;
}

const TodoInput: React.FC&lt;TodoInputProps&gt; = ({ onAddTodo }) => {
    const [text, setText] = useState('');
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        onAddTodo(text);
        setText('');
    };
    
    return (
        &lt;form onSubmit={handleSubmit} style={{ display: 'flex', gap: '0.5rem', marginBottom: '1rem' }}&gt;
            &lt;input
                value={text}
                onChange={(e) => setText(e.target.value)}
                placeholder="Add a todo..."
                style={{ flex: 1, padding: '0.5rem' }}
            /&gt;
            &lt;button type="submit" style={{ padding: '0.5rem 1rem' }}&gt;Add&lt;/button&gt;
        &lt;/form&gt;
    );
};

interface TodoListProps {
    todos: Todo[];
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

const TodoList: React.FC&lt;TodoListProps&gt; = ({ todos, onToggle, onDelete }) => {
    if (todos.length === 0) {
        return &lt;p style={{ textAlign: 'center', color: '#999' }}&gt;No todos yet!&lt;/p&gt;;
    }
    
    return (
        &lt;ul style={{ listStyle: 'none', padding: 0 }}&gt;
            {todos.map(todo => (
                &lt;li
                    key={todo.id}
                    style={{
                        display: 'flex',
                        alignItems: 'center',
                        padding: '0.75rem',
                        marginBottom: '0.5rem',
                        background: '#f5f5f5',
                        borderRadius: '4px'
                    }}
                &gt;
                    &lt;input
                        type="checkbox"
                        checked={todo.completed}
                        onChange={() => onToggle(todo.id)}
                        style={{ marginRight: '0.75rem' }}
                    /&gt;
                    &lt;span
                        style={{
                            flex: 1,
                            textDecoration: todo.completed ? 'line-through' : 'none',
                            color: todo.completed ? '#999' : '#333'
                        }}
                    &gt;
                        {todo.text}
                    &lt;/span&gt;
                    &lt;button
                        onClick={() => onDelete(todo.id)}
                        style={{
                            background: '#f44336',
                            color: 'white',
                            border: 'none',
                            padding: '0.25rem 0.5rem',
                            borderRadius: '4px',
                            cursor: 'pointer'
                        }}
                    &gt;
                        Delete
                    &lt;/button&gt;
                &lt;/li&gt;
            ))}
        &lt;/ul&gt;
    );
};</code></pre>
                    
                    <p><strong>Improvements:</strong></p>
                    <ul>
                        <li>‚úÖ Only stores essential state (todos, filter)</li>
                        <li>‚úÖ Derives counts and filtered list</li>
                        <li>‚úÖ No risk of state getting out of sync</li>
                        <li>‚úÖ Cleaner update functions</li>
                        <li>‚úÖ Components properly separated</li>
                        <li>‚úÖ State lifted to appropriate level</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>‚ú® Best Practices</h2>
                <p>Let's consolidate everything you've learned into actionable best practices.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 1. Single Source of Truth</h4>
                    <p>Each piece of data should have exactly one source of truth:</p>
                    <ul>
                        <li>Don't duplicate state between components</li>
                        <li>Don't store derived values in state</li>
                        <li>Lift state to the lowest common ancestor</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 2. Minimize State</h4>
                    <p>Before adding state, ask: "Can I calculate this?"</p>
                    <pre><code class="language-typescript">// ‚ùå Don't store what you can calculate
const [items, setItems] = useState([]);
const [count, setCount] = useState(0);

// ‚úÖ Derive instead
const [items, setItems] = useState([]);
const count = items.length;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 3. Colocate State</h4>
                    <p>Keep state as local as possible:</p>
                    <ul>
                        <li>Only lift state when multiple components need it</li>
                        <li>UI state (hover, focus) usually stays local</li>
                        <li>Self-contained components are easier to maintain</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 4. Use Composition Over Prop Drilling</h4>
                    <p>When passing props through multiple layers, consider composition:</p>
                    <pre><code class="language-typescript">// ‚ùå Prop drilling
&lt;Layout user={user}&gt;
    &lt;Sidebar user={user}&gt;
        &lt;UserMenu user={user} /&gt;
    &lt;/Sidebar&gt;
&lt;/Layout&gt;

// ‚úÖ Composition
&lt;Layout&gt;
    &lt;Sidebar&gt;
        &lt;UserMenu user={user} /&gt;
    &lt;/Sidebar&gt;
&lt;/Layout&gt;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ 5. Name Callbacks Clearly</h4>
                    <p>Use consistent naming for callbacks:</p>
                    <pre><code class="language-typescript">// ‚úÖ Good naming
onValueChange, onSubmit, onUserSelect, onModalClose

// ‚ùå Unclear naming
change, submit, click, close</code></pre>
                </div>

                <h3>State Management Decision Tree</h3>
                <pre class="mermaid">
graph TD
    A[Need to add data] --> B{Can it be calculated?}
    B -->|Yes| C[Don't store it!<br/>Derive it instead]
    B -->|No| D{How many components<br/>need it?}
    D -->|One| E[Local state in<br/>that component]
    D -->|Siblings| F[Lift to parent]
    D -->|Many/distant| G[Consider Context<br/>or global state]
    
    style C fill:#4CAF50,color:#fff
    style E fill:#4CAF50,color:#fff
    style F fill:#2196F3,color:#fff
    style G fill:#FF9800,color:#fff
</pre>

                <h3>Checklist for Good State Management</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Question</th>
                            <th>Good Answer</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Can this be calculated from other state/props?</td>
                            <td>If yes, derive it - don't store it</td>
                        </tr>
                        <tr>
                            <td>Which components need this state?</td>
                            <td>Put it in their lowest common ancestor</td>
                        </tr>
                        <tr>
                            <td>Is this state truly global?</td>
                            <td>Most state isn't - keep it local when possible</td>
                        </tr>
                        <tr>
                            <td>Are we passing props through many layers?</td>
                            <td>Consider composition or Context</td>
                        </tr>
                        <tr>
                            <td>Could this state live lower in the tree?</td>
                            <td>Push it down for better performance</td>
                        </tr>
                        <tr>
                            <td>Is our state synchronized correctly?</td>
                            <td>Single source of truth prevents sync issues</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 11: Summary -->
            <section id="section11" class="lesson-section">
                <h2>üìö Summary</h2>
                <p>Congratulations! You've mastered the essential patterns for managing state in React applications. These patterns are the foundation of building scalable React apps.</p>

                <div class="card">
                    <h3>What You Learned</h3>
                    
                    <p><strong>üìç State Placement</strong></p>
                    <ul>
                        <li>The golden rule: lowest common ancestor</li>
                        <li>Three key questions before adding state</li>
                        <li>Local vs lifted vs global state</li>
                    </ul>

                    <p><strong>‚¨ÜÔ∏è Lifting State Up</strong></p>
                    <ul>
                        <li>How to share state between sibling components</li>
                        <li>Moving state to parent components</li>
                        <li>Props down, callbacks up pattern</li>
                        <li>Creating controlled components</li>
                    </ul>

                    <p><strong>üï≥Ô∏è Prop Drilling</strong></p>
                    <ul>
                        <li>Recognizing prop drilling problems</li>
                        <li>Solutions: composition and Context</li>
                        <li>When prop drilling is acceptable</li>
                    </ul>

                    <p><strong>üìç State Colocation</strong></p>
                    <ul>
                        <li>Keeping state close to where it's used</li>
                        <li>Benefits of localized state</li>
                        <li>Self-contained components</li>
                    </ul>

                    <p><strong>üîÑ Derived State</strong></p>
                    <ul>
                        <li>Calculating values instead of storing them</li>
                        <li>Avoiding redundant state</li>
                        <li>Single source of truth</li>
                    </ul>

                    <p><strong>üé¨ State Initialization</strong></p>
                    <ul>
                        <li>Direct vs lazy initialization</li>
                        <li>Initializing from props</li>
                        <li>Using key prop to reset state</li>
                        <li>Local storage pattern</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Minimize state</strong> - Don't store what you can calculate</li>
                        <li><strong>Single source of truth</strong> - Each piece of data has one owner</li>
                        <li><strong>Lift judiciously</strong> - Only lift when necessary</li>
                        <li><strong>Colocate when possible</strong> - Keep state local for better performance</li>
                        <li><strong>Derive, don't duplicate</strong> - Calculate derived values on the fly</li>
                        <li><strong>Use composition</strong> - Often better than prop drilling</li>
                    </ul>
                </div>

                <h3>üöÄ Next Steps</h3>
                <p>With these patterns mastered, you're ready for more advanced topics:</p>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üìñ Coming Up Next</h4>
                    <p><strong>Lesson 3.3: Forms in React</strong></p>
                    <ul>
                        <li>Controlled vs uncontrolled components</li>
                        <li>Handling multiple form inputs</li>
                        <li>Form validation patterns</li>
                        <li>Type-safe form handling</li>
                    </ul>
                    <p>You'll use the state management patterns you just learned to build complex forms!</p>
                </div>

                <h3>üí™ Practice Suggestions</h3>
                <p>To master these patterns, try building:</p>
                <ul>
                    <li><strong>Dashboard with Widgets</strong> - Multiple components sharing filter state</li>
                    <li><strong>Multi-page Form</strong> - Step navigation with state persisting across steps</li>
                    <li><strong>Shopping Cart</strong> - Product list, cart, and checkout sharing state</li>
                    <li><strong>Social Feed</strong> - Posts, comments, likes with proper state organization</li>
                    <li><strong>Kanban Board</strong> - Drag and drop with columns sharing task state</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚ú® Remember</h4>
                    <p>Good state management is about making deliberate decisions. Before adding state, think: Where should it live? Can it be derived? Who needs access? These patterns will guide you to cleaner, more maintainable React applications!</p>
                </div>

                <div class="card">
                    <h3>üìö Additional Resources</h3>
                    <ul>
                        <li><a href="https://react.dev/learn/sharing-state-between-components" target="_blank" rel="noopener noreferrer">React Docs: Sharing State Between Components</a></li>
                        <li><a href="https://react.dev/learn/choosing-the-state-structure" target="_blank" rel="noopener noreferrer">React Docs: Choosing the State Structure</a></li>
                        <li><a href="https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster" target="_blank" rel="noopener noreferrer">Kent C. Dodds: State Colocation</a></li>
                        <li><a href="https://react.dev/learn/passing-data-deeply-with-context" target="_blank" rel="noopener noreferrer">React Docs: Passing Data Deeply with Context</a></li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've completed Lesson 3.2 and learned professional state management patterns! You now know how to organize state in scalable React applications. These patterns will serve you throughout your React career. Excellent work! üöÄ</p>
                </div>
            </section>

        </div>
    </main>

    <!-- Lesson Navigation -->
    <div class="lesson-nav">
        <a href="lesson_3_1_usestate_hook_a.html" class="lesson-nav-btn lesson-nav-prev">
            <span>‚Üê Previous</span>
            <small>Lesson 3.1: useState Hook</small>
        </a>
        <a href="index.html" class="lesson-nav-btn lesson-nav-home">
            <span>‚åÇ</span>
            <small>Home</small>
        </a>
        <a href="lesson_3_3_forms_in_react.html" class="lesson-nav-btn lesson-nav-next">
            <span>Next ‚Üí</span>
            <small>Lesson 3.3: Forms in React</small>
        </a>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">Modules</a> |
                <a href="https://github.com/practicalace" target="_blank" rel="noopener noreferrer">GitHub</a>
            </p>
        </div>
    </footer>

    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
