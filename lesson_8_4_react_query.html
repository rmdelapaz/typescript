<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React Query (TanStack Query) for powerful data fetching and caching in React applications. Learn queries, mutations, cache management, optimistic updates, and TypeScript integration for seamless server state management.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.4: React Query (TanStack Query) - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.4: React Query (TanStack Query)</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üîÑ Lesson 8.4: React Query (TanStack Query)</h1>
                <p class="lead">Welcome to the data fetching revolution! React Query (now TanStack Query) has fundamentally changed how we think about server state in React applications. If you've ever struggled with loading states, caching, background refetching, or synchronizing server data, React Query is the solution you've been looking for. In this comprehensive lesson, you'll learn how to use React Query to build applications with seamless data fetching, automatic caching, and incredible developer experience.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the difference between server state and client state</li>
                        <li>Install and configure React Query in a TypeScript project</li>
                        <li>Use queries to fetch and cache data automatically</li>
                        <li>Implement mutations for creating, updating, and deleting data</li>
                        <li>Handle loading, error, and success states elegantly</li>
                        <li>Configure automatic refetching and cache invalidation</li>
                        <li>Implement optimistic updates for instant UI feedback</li>
                        <li>Type queries and mutations properly with TypeScript</li>
                        <li>Use React Query DevTools for debugging</li>
                        <li>Apply React Query best practices and patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 70-85 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 8.1-8.3 (State Management, Zustand, Redux Toolkit), Modules 1-4</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding Server State vs Client State</a></li>
                        <li><a href="#section2" class="toc-link">Installation and Setup</a></li>
                        <li><a href="#section3" class="toc-link">Queries: Fetching Data</a></li>
                        <li><a href="#section4" class="toc-link">Query Keys and Caching</a></li>
                        <li><a href="#section5" class="toc-link">Mutations: Updating Data</a></li>
                        <li><a href="#section6" class="toc-link">Cache Invalidation and Refetching</a></li>
                        <li><a href="#section7" class="toc-link">Optimistic Updates</a></li>
                        <li><a href="#section8" class="toc-link">Best Practices</a></li>
                        <li><a href="#section9" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Server State vs Client State -->
            <section id="section1" class="lesson-section">
                <h2>ü§î Understanding Server State vs Client State</h2>
                
                <p>React Query solves a fundamental problem: managing server state is fundamentally different from managing client state, yet we often treat them the same way.</p>

                <h3>What is Server State?</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Server state</strong> is data that lives on a remote server and is fetched over the network. It's data you don't own - it can change without your knowledge, be updated by other users, and requires synchronization between the server and your UI. <strong>React Query</strong> (now TanStack Query) is a powerful data fetching library that manages server state automatically with caching, background updates, and optimistic updates.</p>
                </div>

                <h3>Server State vs Client State</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Server State</th>
                            <th>Client State</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fetched from API/server</td>
                            <td>Created and managed locally</td>
                        </tr>
                        <tr>
                            <td>Shared across users</td>
                            <td>Unique to one user/session</td>
                        </tr>
                        <tr>
                            <td>Can become stale</td>
                            <td>Always current</td>
                        </tr>
                        <tr>
                            <td>Needs caching strategy</td>
                            <td>Direct state management</td>
                        </tr>
                        <tr>
                            <td>Requires synchronization</td>
                            <td>No synchronization needed</td>
                        </tr>
                        <tr>
                            <td>Examples: User data, posts, products</td>
                            <td>Examples: Modal open, theme, form inputs</td>
                        </tr>
                    </tbody>
                </table>

                <h3>The Problem with Traditional Approaches</h3>

                <p>Before React Query, managing server state typically looked like this:</p>

                <pre><code class="language-typescript">// ‚ùå The old way - so much boilerplate!
function UserList() {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() => {
    setIsLoading(true);
    setError(null);
    
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setIsLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setIsLoading(false);
      });
  }, []); // When should we refetch?
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with Manual Fetching</h4>
                    <ul>
                        <li><strong>Boilerplate:</strong> Loading states, error states, success states</li>
                        <li><strong>No Caching:</strong> Same data fetched multiple times</li>
                        <li><strong>No Background Updates:</strong> Data goes stale</li>
                        <li><strong>Race Conditions:</strong> Multiple requests can conflict</li>
                        <li><strong>No Deduplication:</strong> Multiple components = multiple requests</li>
                        <li><strong>Manual Refetching:</strong> When should we refetch? On focus? On interval?</li>
                        <li><strong>Memory Leaks:</strong> Updating state after unmount</li>
                    </ul>
                </div>

                <h3>How React Query Solves These Problems</h3>

                <p>With React Query, the same component becomes:</p>

                <pre><code class="language-typescript">// ‚úÖ The React Query way - simple and powerful!
import { useQuery } from '@tanstack/react-query';

function UserList() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ React Query Benefits</h4>
                    <p>Out of the box, React Query provides:</p>
                    <ul>
                        <li><strong>Automatic Caching:</strong> Data is cached and shared across components</li>
                        <li><strong>Background Refetching:</strong> Keeps data fresh automatically</li>
                        <li><strong>Window Focus Refetching:</strong> Updates when user returns to tab</li>
                        <li><strong>Request Deduplication:</strong> Multiple requests = one network call</li>
                        <li><strong>Automatic Retries:</strong> Failed requests retry automatically</li>
                        <li><strong>Garbage Collection:</strong> Old data is cleaned up automatically</li>
                        <li><strong>Optimistic Updates:</strong> Update UI before server responds</li>
                        <li><strong>Pagination & Infinite Scroll:</strong> Built-in support</li>
                        <li><strong>DevTools:</strong> Visualize queries and cache</li>
                    </ul>
                </div>

                <h3>When to Use React Query</h3>

                <div class="mermaid">
graph TB
    A[Need Data?] --> B{Where's it from?}
    B -->|Server/API| C[Use React Query]
    B -->|Local/Browser| D[Use useState/Context/Zustand]
    
    C --> E[Automatic caching]
    C --> F[Background updates]
    C --> G[Loading states]
    
    D --> H[Direct state control]
    D --> I[No network overhead]
    
    style C fill:#c8e6c9
    style D fill:#e3f2fd
    style A fill:#f0f0f0
</div>

                <p>Use React Query for:</p>
                <ul>
                    <li>‚úÖ Fetching data from REST APIs</li>
                    <li>‚úÖ GraphQL queries (with plugins)</li>
                    <li>‚úÖ Data that can become stale</li>
                    <li>‚úÖ Data shared across components</li>
                    <li>‚úÖ CRUD operations</li>
                    <li>‚úÖ Pagination and infinite scroll</li>
                </ul>

                <p>Don't use React Query for:</p>
                <ul>
                    <li>‚ùå Local UI state (modals, themes, forms)</li>
                    <li>‚ùå One-time configuration fetches</li>
                    <li>‚ùå Data you don't need to cache</li>
                    <li>‚ùå Simple, infrequent API calls</li>
                </ul>
            </section>

            <!-- Section 2: Installation and Setup -->
            <section id="section2" class="lesson-section">
                <h2>‚öôÔ∏è Installation and Setup</h2>
                
                <p>Let's get React Query set up in your React TypeScript project.</p>

                <h3>Installing React Query</h3>

                <pre><code class="language-bash"># Install React Query v5 (TanStack Query)
npm install @tanstack/react-query

# Optional: Install DevTools for debugging
npm install @tanstack/react-query-devtools</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Version Note</h4>
                    <p>React Query was rebranded as <strong>TanStack Query</strong> starting with v4. The package is now <code>@tanstack/react-query</code>. All functionality works the same, just with a new namespace. We'll use the latest v5 in this lesson.</p>
                </div>

                <h3>Setting Up QueryClient</h3>

                <p>Create and configure a QueryClient with default options:</p>

                <pre><code class="language-typescript">// src/lib/queryClient.ts

import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 10, // 10 minutes
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      retry: 1,
    },
  },
});

// Explanation:
// - staleTime: How long until data is considered stale
// - cacheTime: How long to keep unused data in cache
// - refetchOnWindowFocus: Refetch when user returns to window
// - refetchOnReconnect: Refetch when internet reconnects
// - retry: Number of retry attempts on failure</code></pre>

                <h3>Wrapping Your App</h3>

                <p>Provide the QueryClient to your entire application:</p>

                <pre><code class="language-typescript">// src/main.tsx (or App.tsx)

import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import App from './App';

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;App /&gt;
      
      {/* DevTools - only appears in development */}
      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
    &lt;/QueryClientProvider&gt;
  &lt;/React.StrictMode&gt;
);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ React Query DevTools</h4>
                    <p>The DevTools provide an amazing debugging experience:</p>
                    <ul>
                        <li>See all queries and their current state</li>
                        <li>Visualize query cache</li>
                        <li>Manually trigger refetches</li>
                        <li>Inspect query data and errors</li>
                        <li>View query timelines</li>
                        <li>Automatically tree-shaken from production builds</li>
                    </ul>
                </div>

                <h3>Project Structure</h3>

                <p>Organize your React Query code:</p>

                <pre><code class="language-typescript">src/
  lib/
    queryClient.ts          // QueryClient configuration
    
  api/
    users.ts               // User-related API functions
    posts.ts               // Post-related API functions
    
  hooks/
    queries/
      useUsers.ts          // User query hooks
      usePosts.ts          // Post query hooks
    mutations/
      useCreateUser.ts     // User mutation hooks
      useUpdatePost.ts     // Post mutation hooks
      
  components/
    users/
      UserList.tsx         // Uses user queries
      CreateUserForm.tsx   // Uses user mutations</code></pre>

                <h3>Creating API Functions</h3>

                <p>Separate your API logic from components:</p>

                <pre><code class="language-typescript">// src/api/users.ts

export interface User {
  id: string;
  name: string;
  email: string;
}

// GET all users
export async function getUsers(): Promise&lt;User[]&gt; {
  const response = await fetch('https://api.example.com/users');
  
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  
  return response.json();
}

// GET single user
export async function getUser(id: string): Promise&lt;User&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  
  return response.json();
}

// POST create user
export async function createUser(userData: Omit&lt;User, 'id'&gt;): Promise&lt;User&gt; {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData),
  });
  
  if (!response.ok) {
    throw new Error('Failed to create user');
  }
  
  return response.json();
}

// PATCH update user
export async function updateUser(
  id: string, 
  updates: Partial&lt;User&gt;
): Promise&lt;User&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(updates),
  });
  
  if (!response.ok) {
    throw new Error('Failed to update user');
  }
  
  return response.json();
}

// DELETE user
export async function deleteUser(id: string): Promise&lt;void&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'DELETE',
  });
  
  if (!response.ok) {
    throw new Error('Failed to delete user');
  }
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Error Handling</h4>
                    <p>Always check <code>response.ok</code> and throw errors for failed requests. React Query will catch these errors and expose them through the <code>error</code> property in your hooks.</p>
                </div>
            </section>

            <!-- Section 3: Queries - Fetching Data -->
            <section id="section3" class="lesson-section">
                <h2>üì• Queries: Fetching Data</h2>
                
                <p>Queries are the core of React Query. They fetch data, cache it, and keep it synchronized with the server.</p>

                <h3>Basic useQuery</h3>

                <pre><code class="language-typescript">// src/components/UserList.tsx

import { useQuery } from '@tanstack/react-query';
import { getUsers } from '../api/users';

function UserList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: getUsers
  });
  
  if (isLoading) {
    return &lt;div&gt;Loading users...&lt;/div&gt;;
  }
  
  if (error) {
    return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  }
  
  return (
    &lt;ul&gt;
      {data?.map(user => (
        &lt;li key={user.id}&gt;
          {user.name} - {user.email}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>Understanding Query States</h3>

                <p>React Query provides detailed state information:</p>

                <pre><code class="language-typescript">function UserList() {
  const { 
    data,              // The data returned from queryFn
    error,             // Error object if query failed
    isLoading,         // true on first load (no cached data)
    isFetching,        // true whenever fetching (even if cached data exists)
    isError,           // true if query errored
    isSuccess,         // true if query succeeded
    status,            // 'pending' | 'error' | 'success'
    fetchStatus,       // 'fetching' | 'paused' | 'idle'
    refetch,           // Function to manually refetch
  } = useQuery({
    queryKey: ['users'],
    queryFn: getUsers
  });
  
  // Different ways to check loading
  if (isLoading) {
    return &lt;div&gt;Loading for the first time...&lt;/div&gt;;
  }
  
  return (
    &lt;div&gt;
      {isFetching && &lt;div&gt;Updating...&lt;/div&gt;}
      {/* Render data */}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="mermaid">
stateDiagram-v2
    [*] --> Pending: Query starts
    Pending --> Success: Data received
    Pending --> Error: Request failed
    Success --> Fetching: Refetching
    Error --> Fetching: Retrying
    Fetching --> Success: Data received
    Fetching --> Error: Request failed
    
    Success --> [*]
    Error --> [*]
</div>

                <h3>Query with Parameters</h3>

                <pre><code class="language-typescript">// src/components/UserProfile.tsx

import { useQuery } from '@tanstack/react-query';
import { getUser } from '../api/users';

function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId], // Include params in key!
    queryFn: () => getUser(userId),
    enabled: !!userId, // Only run if userId exists
  });
  
  if (isLoading) return &lt;div&gt;Loading user...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The enabled Option</h4>
                    <p>Use <code>enabled</code> to conditionally execute queries:</p>
                    <ul>
                        <li>Wait for required data before fetching</li>
                        <li>Disable queries based on user permissions</li>
                        <li>Implement dependent queries</li>
                        <li>Prevent unnecessary requests</li>
                    </ul>
                    <pre><code class="language-typescript">const { data: user } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId),
  enabled: !!userId && hasPermission
});</code></pre>
                </div>

                <h3>TypeScript Integration</h3>

                <pre><code class="language-typescript">// Strongly typed query
const { data } = useQuery&lt;User[], Error&gt;({
  queryKey: ['users'],
  queryFn: getUsers
});
// data is typed as User[] | undefined
// error is typed as Error | null

// With type inference (recommended)
const { data, error } = useQuery({
  queryKey: ['users'],
  queryFn: getUsers // Return type inferred as User[]
});
// TypeScript infers types from getUsers function</code></pre>

                <h3>Query Options</h3>

                <pre><code class="language-typescript">const { data } = useQuery({
  queryKey: ['users'],
  queryFn: getUsers,
  
  // Caching
  staleTime: 1000 * 60 * 5,        // 5 minutes until stale
  cacheTime: 1000 * 60 * 10,       // 10 minutes in cache (deprecated in v5, use gcTime)
  gcTime: 1000 * 60 * 10,          // Garbage collection time (v5+)
  
  // Refetching
  refetchOnMount: true,             // Refetch on component mount if stale
  refetchOnWindowFocus: true,       // Refetch when window regains focus
  refetchOnReconnect: true,         // Refetch when internet reconnects
  refetchInterval: false,           // Refetch every X ms (or false to disable)
  refetchIntervalInBackground: false, // Refetch even when window not focused
  
  // Retry
  retry: 3,                         // Retry failed requests 3 times
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  
  // Other
  enabled: true,                    // Enable/disable query
  placeholderData: [],              // Show while loading (doesn't go to cache)
  initialData: [],                  // Initial data (goes to cache)
  
  // Callbacks
  onSuccess: (data) => {
    console.log('Query succeeded:', data);
  },
  onError: (error) => {
    console.error('Query failed:', error);
  },
  onSettled: (data, error) => {
    console.log('Query completed');
  }
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Query Best Practices</h4>
                    <ul>
                        <li>Always include all dependencies in <code>queryKey</code></li>
                        <li>Keep query functions pure and predictable</li>
                        <li>Use <code>enabled</code> for conditional fetching</li>
                        <li>Set appropriate <code>staleTime</code> based on data volatility</li>
                        <li>Extract query logic into custom hooks for reusability</li>
                        <li>Let TypeScript infer types from your API functions</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Query Keys and Caching -->
            <section id="section4" class="lesson-section">
                <h2>üîë Query Keys and Caching</h2>
                
                <p>Query keys are the backbone of React Query's caching system. Understanding them is crucial for effective data management.</p>

                <h3>How Query Keys Work</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Query Keys</h4>
                    <p style="color: white;">Query keys uniquely identify queries in the cache. They can be strings or arrays, and React Query compares them deeply. If two queries have the same key, they share the same cached data.</p>
                </div>

                <pre><code class="language-typescript">// Simple string key
useQuery({
  queryKey: ['users'],
  queryFn: getUsers
});

// Array with parameters
useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId)
});

// Complex keys with multiple parameters
useQuery({
  queryKey: ['users', { status: 'active', page: 1 }],
  queryFn: () => getUsers({ status: 'active', page: 1 })
});

// Keys are compared deeply
['users', { page: 1, status: 'active' }] 
  === 
['users', { status: 'active', page: 1 }]  // true!
</code></pre>

                <h3>Query Key Patterns</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Hierarchical structure
['users']                          // All users
['users', userId]                  // Specific user
['users', userId, 'posts']         // User's posts
['users', userId, 'posts', postId] // Specific post

// ‚úÖ Good: With filters/params
['users', { status: 'active' }]
['posts', { page: 1, limit: 10 }]
['products', { category: 'electronics', sort: 'price' }]

// ‚ùå Bad: Inconsistent structure
['users']
['userById', userId]  // Should be ['users', userId]
['getUserPosts', userId]  // Should be ['users', userId, 'posts']</code></pre>

                <h3>Query Key Factory</h3>

                <p>Create a centralized key factory for consistency:</p>

                <pre><code class="language-typescript">// src/lib/queryKeys.ts

export const queryKeys = {
  // Users
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: (filters: string) => 
      [...queryKeys.users.lists(), { filters }] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: string) => 
      [...queryKeys.users.details(), id] as const,
  },
  
  // Posts
  posts: {
    all: ['posts'] as const,
    lists: () => [...queryKeys.posts.all, 'list'] as const,
    list: (filters: string) => 
      [...queryKeys.posts.lists(), { filters }] as const,
    details: () => [...queryKeys.posts.all, 'detail'] as const,
    detail: (id: string) => 
      [...queryKeys.posts.details(), id] as const,
  },
};

// Usage
useQuery({
  queryKey: queryKeys.users.detail(userId),
  queryFn: () => getUser(userId)
});

useQuery({
  queryKey: queryKeys.posts.list('published'),
  queryFn: () => getPosts({ status: 'published' })
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Query Key Factory</h4>
                    <ul>
                        <li><strong>Consistency:</strong> Same structure everywhere</li>
                        <li><strong>Type Safety:</strong> TypeScript autocomplete</li>
                        <li><strong>Maintainability:</strong> Change keys in one place</li>
                        <li><strong>Invalidation:</strong> Easy to target specific queries</li>
                        <li><strong>Documentation:</strong> Self-documenting API</li>
                    </ul>
                </div>

                <h3>Understanding the Cache</h3>

                <div class="mermaid">
graph TB
    A[Component 1 requests 'users'] --> B{In cache?}
    B -->|No| C[Fetch from server]
    B -->|Yes - Fresh| D[Return cached data]
    B -->|Yes - Stale| E[Return cached + refetch]
    
    C --> F[Store in cache]
    E --> F
    F --> G[Update components]
    
    H[Component 2 requests 'users'] --> B
    
    style D fill:#c8e6c9
    style E fill:#fff3cd
    style C fill:#e3f2fd
</div>

                <h3>Stale Time vs Cache Time</h3>

                <pre><code class="language-typescript">useQuery({
  queryKey: ['users'],
  queryFn: getUsers,
  staleTime: 1000 * 60 * 5,  // 5 minutes
  gcTime: 1000 * 60 * 10      // 10 minutes (was cacheTime in v4)
});

// Timeline:
// t=0:  Fetch data, cache it as "fresh"
// t=5m: Data becomes "stale" but still in cache
//       - On mount, return stale data + refetch in background
// t=10m: Data removed from cache (garbage collected)
//       - On mount, show loading + fetch fresh data</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>staleTime</th>
                            <th>gcTime (cacheTime)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>How long data is considered "fresh"</td>
                            <td>How long inactive data stays in cache</td>
                        </tr>
                        <tr>
                            <td>Fresh data won't refetch</td>
                            <td>After gcTime, data is removed</td>
                        </tr>
                        <tr>
                            <td>Default: 0 (immediately stale)</td>
                            <td>Default: 5 minutes</td>
                        </tr>
                        <tr>
                            <td>Use for data that changes slowly</td>
                            <td>Use to control memory usage</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Choosing staleTime</h4>
                    <p>Set <code>staleTime</code> based on how often your data changes:</p>
                    <ul>
                        <li><strong>0ms (default):</strong> Real-time data, social feeds</li>
                        <li><strong>30s - 1min:</strong> Live dashboards, scores</li>
                        <li><strong>5-10min:</strong> User profiles, settings</li>
                        <li><strong>1hour+:</strong> Rarely changing data (countries, categories)</li>
                        <li><strong>Infinity:</strong> Static data (won't refetch until invalidated)</li>
                    </ul>
                </div>
            <!-- Section 5: Mutations -->
            <section id="section5">
                <h2>üîß Mutations: Updating Data</h2>
                
                <p>While queries are for reading data, <strong>mutations</strong> are for creating, updating, or deleting data. React Query's <code>useMutation</code> hook provides a powerful abstraction for modifying server state with automatic cache updates and optimistic UI patterns.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Mutation:</strong> A side effect that changes data on the server (POST, PUT, PATCH, DELETE requests). Mutations trigger cache invalidation and refetching to keep data synchronized.</p>
                </div>

                <h3>Basic Mutation Example</h3>

                <pre><code class="language-typescript">import { useMutation, useQueryClient } from '@tanstack/react-query';

interface CreateUserData {
  name: string;
  email: string;
}

interface User {
  id: string;
  name: string;
  email: string;
  createdAt: string;
}

// API function
const createUser = async (userData: CreateUserData): Promise&lt;User&gt; => {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData)
  });
  
  if (!response.ok) {
    throw new Error('Failed to create user');
  }
  
  return response.json();
};

// Component
function CreateUserForm() {
  const queryClient = useQueryClient();
  
  const mutation = useMutation({
    mutationFn: createUser,
    onSuccess: (data) => {
      // Invalidate and refetch users list
      queryClient.invalidateQueries({ queryKey: ['users'] });
      console.log('User created:', data);
    },
    onError: (error) => {
      console.error('Error creating user:', error);
    }
  });

  const handleSubmit = (e: React.FormEvent&lt;HTMLFormElement&gt;) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget);
    
    mutation.mutate({
      name: formData.get('name') as string,
      email: formData.get('email') as string
    });
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input name="name" placeholder="Name" required /&gt;
      &lt;input name="email" type="email" placeholder="Email" required /&gt;
      
      &lt;button 
        type="submit" 
        disabled={mutation.isPending}
      &gt;
        {mutation.isPending ? 'Creating...' : 'Create User'}
      &lt;/button&gt;
      
      {mutation.isError && (
        &lt;div className="error"&gt;
          Error: {mutation.error.message}
        &lt;/div&gt;
      )}
      
      {mutation.isSuccess && (
        &lt;div className="success"&gt;
          User created successfully!
        &lt;/div&gt;
      )}
    &lt;/form&gt;
  );
}</code></pre>

                <div class="mermaid">
graph LR
    A[User submits form] --> B[mutation.mutate called]
    B --> C[isPending = true]
    C --> D[API request]
    D --> E{Success?}
    E -->|Yes| F[onSuccess callback]
    E -->|No| G[onError callback]
    F --> H[Invalidate queries]
    H --> I[Refetch data]
    G --> J[Show error]
    I --> K[isSuccess = true]
    J --> L[isError = true]
    
    style F fill:#c8e6c9
    style G fill:#ffcdd2
    style C fill:#fff3cd
</div>

                <h3>Mutation States</h3>

                <pre><code class="language-typescript">const mutation = useMutation({ mutationFn: createUser });

// Access mutation states
mutation.isPending;   // true while request is in flight
mutation.isError;     // true if mutation failed
mutation.isSuccess;   // true if mutation succeeded
mutation.isIdle;      // true if mutation hasn't been called yet

mutation.error;       // Error object if failed
mutation.data;        // Response data if successful
mutation.status;      // 'idle' | 'pending' | 'error' | 'success'

// Call the mutation
mutation.mutate(userData);

// Or use async version with Promise
mutation.mutateAsync(userData)
  .then(data => console.log('Success:', data))
  .catch(error => console.error('Error:', error));</code></pre>

                <h3>Update and Delete Mutations</h3>

                <pre><code class="language-typescript">// Update mutation
const updateUser = async ({ id, data }: { 
  id: string; 
  data: Partial&lt;User&gt; 
}): Promise&lt;User&gt; => {
  const response = await fetch(`/api/users/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  });
  return response.json();
};

const updateMutation = useMutation({
  mutationFn: updateUser,
  onSuccess: (data, variables) => {
    // Invalidate specific user and list
    queryClient.invalidateQueries({ queryKey: ['users'] });
    queryClient.invalidateQueries({ queryKey: ['users', variables.id] });
  }
});

// Delete mutation
const deleteUser = async (userId: string): Promise&lt;void&gt; => {
  await fetch(`/api/users/${userId}`, {
    method: 'DELETE'
  });
};

const deleteMutation = useMutation({
  mutationFn: deleteUser,
  onSuccess: (_, deletedId) => {
    // Remove from cache
    queryClient.setQueryData&lt;User[]&gt;(['users'], (old) => 
      old?.filter(user => user.id !== deletedId)
    );
  }
});

// Usage
&lt;button onClick={() => updateMutation.mutate({ 
  id: user.id, 
  data: { name: 'New Name' } 
})}&gt;
  Update
&lt;/button&gt;

&lt;button onClick={() => deleteMutation.mutate(user.id)}&gt;
  Delete
&lt;/button&gt;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Mutation Best Practices</h4>
                    <ul>
                        <li><strong>Always invalidate affected queries</strong> in <code>onSuccess</code></li>
                        <li><strong>Use mutateAsync</strong> when you need Promise-based flow</li>
                        <li><strong>Handle errors gracefully</strong> with onError callbacks</li>
                        <li><strong>Show loading states</strong> using isPending</li>
                        <li><strong>Disable submit buttons</strong> during mutations</li>
                        <li><strong>Reset mutation state</strong> when appropriate with <code>mutation.reset()</code></li>
                    </ul>
                </div>

                <h3>Mutation with Variables</h3>

                <pre><code class="language-typescript">// Access mutation variables in callbacks
const mutation = useMutation({
  mutationFn: createUser,
  onMutate: async (variables) => {
    // Called before mutation function
    console.log('About to create:', variables);
    
    // Can return context for rollback
    return { timestamp: Date.now() };
  },
  onSuccess: (data, variables, context) => {
    console.log('Created:', data);
    console.log('With input:', variables);
    console.log('Context:', context);
  },
  onError: (error, variables, context) => {
    console.error('Failed to create:', variables);
    console.log('Rollback context:', context);
  },
  onSettled: (data, error, variables, context) => {
    // Called whether success or error
    console.log('Mutation finished');
  }
});

// All callbacks receive:
// - data: response from mutationFn (success only)
// - error: error object (error only)
// - variables: input passed to mutate()
// - context: value returned from onMutate</code></pre>

            </section>

            <!-- Section 6: Cache Invalidation and Refetching -->
            <section id="section6">
                <h2>üîÑ Cache Invalidation and Refetching</h2>
                
                <p>One of React Query's superpowers is intelligent cache management. Understanding when and how to invalidate queries ensures your UI always displays the most current data without unnecessary network requests.</p>

                <h3>Query Invalidation Strategies</h3>

                <pre><code class="language-typescript">import { useQueryClient } from '@tanstack/react-query';

function MyComponent() {
  const queryClient = useQueryClient();

  // 1. Invalidate exact query
  queryClient.invalidateQueries({ 
    queryKey: ['users', '123'] 
  });

  // 2. Invalidate all queries starting with key
  queryClient.invalidateQueries({ 
    queryKey: ['users'] 
  });
  // Invalidates: ['users'], ['users', '123'], ['users', 'list'], etc.

  // 3. Invalidate with predicate function
  queryClient.invalidateQueries({
    predicate: (query) => {
      return query.queryKey[0] === 'users' && 
             query.state.data !== undefined;
    }
  });

  // 4. Invalidate multiple query keys
  queryClient.invalidateQueries({ queryKey: ['users'] });
  queryClient.invalidateQueries({ queryKey: ['posts'] });

  // 5. Invalidate and refetch immediately
  await queryClient.invalidateQueries({ 
    queryKey: ['users'],
    refetchType: 'active' // 'active' | 'inactive' | 'all' | 'none'
  });
}</code></pre>

                <div class="mermaid">
graph TB
    A[Mutation Success] --> B[Invalidate Queries]
    B --> C{Query has active observers?}
    C -->|Yes| D[Mark stale + Refetch immediately]
    C -->|No| E[Mark stale only]
    
    D --> F[Fresh data in cache]
    E --> G[Will refetch on next mount]
    
    H[Component mounts] --> I{Query in cache?}
    I -->|Fresh| J[Use cached data]
    I -->|Stale| K[Show cached + Refetch]
    I -->|Not in cache| L[Fetch new data]
    
    style D fill:#c8e6c9
    style K fill:#fff3cd
    style L fill:#e3f2fd
</div>

                <h3>Manual Refetching</h3>

                <pre><code class="language-typescript">function UserProfile({ userId }: { userId: string }) {
  const { data, refetch, isRefetching } = useQuery({
    queryKey: ['users', userId],
    queryFn: () => getUser(userId)
  });

  return (
    &lt;div&gt;
      &lt;h2&gt;{data?.name}&lt;/h2&gt;
      
      &lt;button 
        onClick={() => refetch()}
        disabled={isRefetching}
      &gt;
        {isRefetching ? 'Refreshing...' : 'Refresh'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Refetch from outside component
const queryClient = useQueryClient();

// Refetch specific query
queryClient.refetchQueries({ queryKey: ['users', '123'] });

// Refetch all queries with key prefix
queryClient.refetchQueries({ queryKey: ['users'] });

// Refetch all active queries
queryClient.refetchQueries({ type: 'active' });</code></pre>

                <h3>Setting Query Data Directly</h3>

                <pre><code class="language-typescript">const queryClient = useQueryClient();

// 1. Set data directly (overwrite)
queryClient.setQueryData&lt;User&gt;(['users', '123'], {
  id: '123',
  name: 'John Doe',
  email: 'john@example.com'
});

// 2. Update data with function (merge)
queryClient.setQueryData&lt;User&gt;(['users', '123'], (oldData) => {
  if (!oldData) return oldData;
  return { ...oldData, name: 'Updated Name' };
});

// 3. Update list after creating item
const createMutation = useMutation({
  mutationFn: createUser,
  onSuccess: (newUser) => {
    // Add new user to cached list
    queryClient.setQueryData&lt;User[]&gt;(['users'], (old) => {
      return old ? [...old, newUser] : [newUser];
    });
  }
});

// 4. Update list after deleting item
const deleteMutation = useMutation({
  mutationFn: deleteUser,
  onSuccess: (_, deletedId) => {
    // Remove user from cached list
    queryClient.setQueryData&lt;User[]&gt;(['users'], (old) => {
      return old?.filter(user => user.id !== deletedId);
    });
  }
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Each Strategy</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Strategy</th>
                                <th>When to Use</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>invalidateQueries</strong></td>
                                <td>Default choice - marks stale and refetches active queries</td>
                            </tr>
                            <tr>
                                <td><strong>setQueryData</strong></td>
                                <td>When you have the new data and want instant updates</td>
                            </tr>
                            <tr>
                                <td><strong>refetchQueries</strong></td>
                                <td>Force immediate refetch regardless of stale status</td>
                            </tr>
                            <tr>
                                <td><strong>removeQueries</strong></td>
                                <td>Clear cache entirely (logout, data no longer valid)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Removing Queries from Cache</h3>

                <pre><code class="language-typescript">// Remove specific query
queryClient.removeQueries({ queryKey: ['users', '123'] });

// Remove all queries with prefix
queryClient.removeQueries({ queryKey: ['users'] });

// Clear entire cache
queryClient.clear();

// Example: Clear user data on logout
const logout = () => {
  // Clear all user-related queries
  queryClient.removeQueries({ queryKey: ['users'] });
  queryClient.removeQueries({ queryKey: ['profile'] });
  
  // Or clear everything
  queryClient.clear();
  
  // Then navigate to login
  navigate('/login');
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Pitfall: Over-Invalidation</h4>
                    <p>Invalidating too broadly can cause unnecessary refetches:</p>
                    <pre><code class="language-typescript">// ‚ùå BAD - Invalidates ALL queries
queryClient.invalidateQueries();

// ‚ùå BAD - Invalidates all user queries after updating one
queryClient.invalidateQueries({ queryKey: ['users'] });

// ‚úÖ GOOD - Only invalidate what changed
queryClient.invalidateQueries({ queryKey: ['users', userId] });</code></pre>
                </div>

            </section>

            <!-- Section 7: Optimistic Updates -->
            <section id="section7">
                <h2>‚ö° Optimistic Updates</h2>
                
                <p><strong>Optimistic updates</strong> make your app feel instant by updating the UI immediately, before waiting for the server response. If the server request fails, React Query automatically rolls back to the previous state.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Optimistic Update:</strong> Updating the UI immediately based on the expected result of an operation, before receiving server confirmation. Provides instant feedback and makes apps feel faster.</p>
                </div>

                <div class="mermaid">
sequenceDiagram
    participant User
    participant UI
    participant Cache
    participant Server
    
    User->>UI: Click "Like" button
    UI->>Cache: Update likes count (+1)
    UI->>User: Show liked state immediately
    UI->>Server: POST /api/like
    
    alt Success
        Server-->>UI: 200 OK
        Note over UI,Cache: Keep optimistic update
    else Error
        Server-->>UI: 500 Error
        UI->>Cache: Rollback to previous state
        UI->>User: Show error + unliked state
    end
</div>

                <h3>Basic Optimistic Update</h3>

                <pre><code class="language-typescript">interface Todo {
  id: string;
  title: string;
  completed: boolean;
}

const toggleTodo = async (id: string): Promise&lt;Todo&gt; => {
  const response = await fetch(`/api/todos/${id}/toggle`, {
    method: 'PATCH'
  });
  return response.json();
};

function TodoList() {
  const queryClient = useQueryClient();

  const toggleMutation = useMutation({
    mutationFn: toggleTodo,
    
    // Before mutation starts
    onMutate: async (todoId) => {
      // Cancel outgoing refetches (so they don't overwrite optimistic update)
      await queryClient.cancelQueries({ queryKey: ['todos'] });

      // Snapshot the previous value
      const previousTodos = queryClient.getQueryData&lt;Todo[]&gt;(['todos']);

      // Optimistically update the cache
      queryClient.setQueryData&lt;Todo[]&gt;(['todos'], (old) => {
        return old?.map(todo =>
          todo.id === todoId
            ? { ...todo, completed: !todo.completed }
            : todo
        );
      });

      // Return context with snapshot
      return { previousTodos };
    },
    
    // On error, rollback
    onError: (error, variables, context) => {
      queryClient.setQueryData(['todos'], context?.previousTodos);
      alert('Failed to update todo. Please try again.');
    },
    
    // Always refetch after error or success
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
    }
  });

  return (
    &lt;ul&gt;
      {todos?.map(todo => (
        &lt;li key={todo.id}&gt;
          &lt;input
            type="checkbox"
            checked={todo.completed}
            onChange={() => toggleMutation.mutate(todo.id)}
          /&gt;
          {todo.title}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>Optimistic Create</h3>

                <pre><code class="language-typescript">const createTodo = async (newTodo: { title: string }): Promise&lt;Todo&gt; => {
  const response = await fetch('/api/todos', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(newTodo)
  });
  return response.json();
};

const createMutation = useMutation({
  mutationFn: createTodo,
  
  onMutate: async (newTodo) => {
    await queryClient.cancelQueries({ queryKey: ['todos'] });
    
    const previousTodos = queryClient.getQueryData&lt;Todo[]&gt;(['todos']);
    
    // Create optimistic todo with temporary ID
    const optimisticTodo: Todo = {
      id: `temp-${Date.now()}`, // Temporary ID
      title: newTodo.title,
      completed: false
    };
    
    // Add optimistic todo to cache
    queryClient.setQueryData&lt;Todo[]&gt;(['todos'], (old) => {
      return old ? [...old, optimisticTodo] : [optimisticTodo];
    });
    
    return { previousTodos, optimisticTodo };
  },
  
  onSuccess: (newTodo, variables, context) => {
    // Replace temp todo with real one from server
    queryClient.setQueryData&lt;Todo[]&gt;(['todos'], (old) => {
      return old?.map(todo => 
        todo.id === context.optimisticTodo.id ? newTodo : todo
      );
    });
  },
  
  onError: (error, variables, context) => {
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },
  
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  }
});</code></pre>

                <h3>Optimistic Delete</h3>

                <pre><code class="language-typescript">const deleteTodo = async (id: string): Promise&lt;void&gt; => {
  await fetch(`/api/todos/${id}`, { method: 'DELETE' });
};

const deleteMutation = useMutation({
  mutationFn: deleteTodo,
  
  onMutate: async (todoId) => {
    await queryClient.cancelQueries({ queryKey: ['todos'] });
    
    const previousTodos = queryClient.getQueryData&lt;Todo[]&gt;(['todos']);
    
    // Remove todo optimistically
    queryClient.setQueryData&lt;Todo[]&gt;(['todos'], (old) => {
      return old?.filter(todo => todo.id !== todoId);
    });
    
    return { previousTodos };
  },
  
  onError: (error, variables, context) => {
    // Restore deleted todo on error
    queryClient.setQueryData(['todos'], context?.previousTodos);
    alert('Failed to delete todo');
  },
  
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] });
  }
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Optimistic Update Checklist</h4>
                    <ol>
                        <li><strong>Cancel queries:</strong> Prevent refetches from overwriting optimistic state</li>
                        <li><strong>Snapshot previous state:</strong> Save current data for rollback</li>
                        <li><strong>Update cache optimistically:</strong> Show expected result immediately</li>
                        <li><strong>Return context:</strong> Pass snapshot to error/success handlers</li>
                        <li><strong>Handle errors:</strong> Rollback to previous state on failure</li>
                        <li><strong>Invalidate on settled:</strong> Sync with server after success or error</li>
                    </ol>
                </div>

                <h3>Complex Optimistic Update: Like Button</h3>

                <pre><code class="language-typescript">interface Post {
  id: string;
  title: string;
  likes: number;
  likedBy: string[]; // Array of user IDs
}

const toggleLike = async ({ 
  postId, 
  userId 
}: { 
  postId: string; 
  userId: string 
}): Promise&lt;Post&gt; => {
  const response = await fetch(`/api/posts/${postId}/like`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ userId })
  });
  return response.json();
};

function LikeButton({ post, userId }: { post: Post; userId: string }) {
  const queryClient = useQueryClient();
  const isLiked = post.likedBy.includes(userId);

  const likeMutation = useMutation({
    mutationFn: toggleLike,
    
    onMutate: async ({ postId, userId }) => {
      await queryClient.cancelQueries({ queryKey: ['posts', postId] });
      
      const previousPost = queryClient.getQueryData&lt;Post&gt;(['posts', postId]);
      
      queryClient.setQueryData&lt;Post&gt;(['posts', postId], (old) => {
        if (!old) return old;
        
        const isCurrentlyLiked = old.likedBy.includes(userId);
        
        return {
          ...old,
          likes: isCurrentlyLiked ? old.likes - 1 : old.likes + 1,
          likedBy: isCurrentlyLiked
            ? old.likedBy.filter(id => id !== userId)
            : [...old.likedBy, userId]
        };
      });
      
      return { previousPost };
    },
    
    onError: (error, variables, context) => {
      if (context?.previousPost) {
        queryClient.setQueryData(['posts', variables.postId], context.previousPost);
      }
    },
    
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: ['posts', variables.postId] });
    }
  });

  return (
    &lt;button
      onClick={() => likeMutation.mutate({ postId: post.id, userId })}
      disabled={likeMutation.isPending}
      style={{
        color: isLiked ? 'red' : 'gray',
        opacity: likeMutation.isPending ? 0.6 : 1
      }}
    &gt;
      ‚ù§Ô∏è {post.likes}
    &lt;/button&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use Optimistic Updates</h4>
                    <ul>
                        <li><strong>Critical operations:</strong> Financial transactions, medical records</li>
                        <li><strong>Complex validation:</strong> When server might reject for many reasons</li>
                        <li><strong>Large payloads:</strong> When update logic is complex or data intensive</li>
                        <li><strong>Permission-based:</strong> When user might not have permission</li>
                    </ul>
                    <p>In these cases, show loading state and wait for server confirmation.</p>
                </div>

            </section>

            <!-- Section 8: Best Practices -->
            <section id="section8">
                <h2>üéØ Best Practices and Patterns</h2>
                
                <p>After mastering the basics of React Query, following these best practices will help you build maintainable, performant applications that leverage React Query's full power.</p>

                <h3>1. Organize API Functions</h3>

                <pre><code class="language-typescript">// api/users.ts
export interface User {
  id: string;
  name: string;
  email: string;
}

export const usersApi = {
  getAll: async (): Promise&lt;User[]&gt; => {
    const response = await fetch('/api/users');
    if (!response.ok) throw new Error('Failed to fetch users');
    return response.json();
  },
  
  getById: async (id: string): Promise&lt;User&gt; => {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) throw new Error('Failed to fetch user');
    return response.json();
  },
  
  create: async (data: Omit&lt;User, 'id'&gt;): Promise&lt;User&gt; => {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error('Failed to create user');
    return response.json();
  },
  
  update: async ({ id, data }: { id: string; data: Partial&lt;User&gt; }): Promise&lt;User&gt; => {
    const response = await fetch(`/api/users/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
    if (!response.ok) throw new Error('Failed to update user');
    return response.json();
  },
  
  delete: async (id: string): Promise&lt;void&gt; => {
    const response = await fetch(`/api/users/${id}`, { method: 'DELETE' });
    if (!response.ok) throw new Error('Failed to delete user');
  }
};</code></pre>

                <h3>2. Create Custom Hooks for Queries</h3>

                <pre><code class="language-typescript">// hooks/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { usersApi, User } from '../api/users';

// Query keys factory
export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

// Get all users
export function useUsers() {
  return useQuery({
    queryKey: userKeys.lists(),
    queryFn: usersApi.getAll,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}

// Get single user
export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => usersApi.getById(id),
    staleTime: 1000 * 60 * 5,
  });
}

// Create user
export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: usersApi.create,
    onSuccess: (newUser) => {
      // Optimistically add to list
      queryClient.setQueryData&lt;User[]&gt;(userKeys.lists(), (old) => {
        return old ? [...old, newUser] : [newUser];
      });
      // Invalidate to refetch from server
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}

// Update user
export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: usersApi.update,
    onSuccess: (updatedUser) => {
      // Update specific user cache
      queryClient.setQueryData(
        userKeys.detail(updatedUser.id),
        updatedUser
      );
      // Invalidate list
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    },
  });
}

// Delete user
export function useDeleteUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: usersApi.delete,
    onSuccess: (_, deletedId) => {
      // Remove from list cache
      queryClient.setQueryData&lt;User[]&gt;(userKeys.lists(), (old) => {
        return old?.filter(user => user.id !== deletedId);
      });
      // Remove detail cache
      queryClient.removeQueries({ queryKey: userKeys.detail(deletedId) });
    },
  });
}</code></pre>

                <h3>3. Configure Global Defaults</h3>

                <pre><code class="language-typescript">// App.tsx or main provider file
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Global defaults for ALL queries
      staleTime: 1000 * 60 * 5,        // 5 minutes
      gcTime: 1000 * 60 * 10,          // 10 minutes (was cacheTime)
      refetchOnWindowFocus: false,     // Don't refetch on tab focus
      refetchOnReconnect: true,        // Refetch on network reconnect
      retry: 1,                        // Retry failed requests once
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    mutations: {
      // Global defaults for ALL mutations
      retry: 0,                        // Don't retry mutations
      onError: (error) => {
        console.error('Mutation error:', error);
        // Show global error toast
      },
    },
  },
});

function App() {
  return (
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;YourApp /&gt;
      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
    &lt;/QueryClientProvider&gt;
  );
}</code></pre>

                <h3>4. Error Handling Patterns</h3>

                <pre><code class="language-typescript">// Create custom error class
class ApiError extends Error {
  constructor(
    message: string,
    public status: number,
    public data?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

// Enhanced fetch with error handling
async function fetchApi&lt;T&gt;(url: string, options?: RequestInit): Promise&lt;T&gt; {
  const response = await fetch(url, options);
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new ApiError(
      errorData.message || 'Request failed',
      response.status,
      errorData
    );
  }
  
  return response.json();
}

// Use in component with proper error typing
function UserProfile({ userId }: { userId: string }) {
  const { data, error, isError } = useQuery({
    queryKey: ['users', userId],
    queryFn: () => fetchApi&lt;User&gt;(`/api/users/${userId}`)
  });

  if (isError) {
    if (error instanceof ApiError) {
      if (error.status === 404) {
        return &lt;div&gt;User not found&lt;/div&gt;;
      }
      if (error.status === 403) {
        return &lt;div&gt;Access denied&lt;/div&gt;;
      }
    }
    return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  }

  return &lt;div&gt;{data?.name}&lt;/div&gt;;
}</code></pre>

                <h3>5. Prefetching Data</h3>

                <pre><code class="language-typescript">import { useQueryClient } from '@tanstack/react-query';

function UserList() {
  const queryClient = useQueryClient();
  const { data: users } = useUsers();

  // Prefetch user details on hover
  const prefetchUser = (userId: string) => {
    queryClient.prefetchQuery({
      queryKey: userKeys.detail(userId),
      queryFn: () => usersApi.getById(userId),
      staleTime: 1000 * 60 * 5,
    });
  };

  return (
    &lt;ul&gt;
      {users?.map(user => (
        &lt;li
          key={user.id}
          onMouseEnter={() => prefetchUser(user.id)}
        &gt;
          &lt;Link to={`/users/${user.id}`}&gt;{user.name}&lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Prefetch on route loader
function UserDetailPage() {
  const { userId } = useParams();
  const queryClient = useQueryClient();
  
  useEffect(() => {
    // Prefetch related data
    queryClient.prefetchQuery({
      queryKey: ['posts', userId],
      queryFn: () => getPostsByUser(userId!)
    });
  }, [userId, queryClient]);
  
  const { data } = useUser(userId!);
  
  return &lt;div&gt;{data?.name}&lt;/div&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° React Query Best Practices Summary</h4>
                    <ol>
                        <li><strong>Use query keys factory</strong> for consistent, typed keys</li>
                        <li><strong>Create custom hooks</strong> to encapsulate query logic</li>
                        <li><strong>Organize API functions</strong> in separate files</li>
                        <li><strong>Set sensible global defaults</strong> in QueryClient</li>
                        <li><strong>Handle errors properly</strong> with typed error classes</li>
                        <li><strong>Use optimistic updates</strong> for better UX</li>
                        <li><strong>Prefetch on hover/navigation</strong> for snappy experience</li>
                        <li><strong>Invalidate precisely</strong> to avoid unnecessary refetches</li>
                        <li><strong>Use DevTools</strong> for debugging cache state</li>
                        <li><strong>Test with React Query</strong> using testing-library</li>
                    </ol>
                </div>

                <h3>6. Dependent Queries</h3>

                <pre><code class="language-typescript">// Query B depends on data from Query A
function UserPosts({ userId }: { userId: string }) {
  // First query
  const { data: user } = useQuery({
    queryKey: ['users', userId],
    queryFn: () => getUser(userId)
  });

  // Second query depends on first
  const { data: posts } = useQuery({
    queryKey: ['posts', user?.id],
    queryFn: () => getPosts(user!.id),
    enabled: !!user, // Only run when user exists
  });

  return &lt;div&gt;{posts?.length} posts&lt;/div&gt;;
}

// Parallel dependent queries
function Dashboard() {
  const { data: user } = useUser();
  
  // These only run when user exists
  const queries = useQueries({
    queries: [
      {
        queryKey: ['posts', user?.id],
        queryFn: () => getPosts(user!.id),
        enabled: !!user,
      },
      {
        queryKey: ['comments', user?.id],
        queryFn: () => getComments(user!.id),
        enabled: !!user,
      },
      {
        queryKey: ['likes', user?.id],
        queryFn: () => getLikes(user!.id),
        enabled: !!user,
      },
    ],
  });

  const [postsQuery, commentsQuery, likesQuery] = queries;

  if (queries.some(q => q.isLoading)) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  return (
    &lt;div&gt;
      &lt;div&gt;Posts: {postsQuery.data?.length}&lt;/div&gt;
      &lt;div&gt;Comments: {commentsQuery.data?.length}&lt;/div&gt;
      &lt;div&gt;Likes: {likesQuery.data?.length}&lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

            </section>

            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>üèãÔ∏è Hands-On Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Blog Post Manager</h3>
                    <p><strong>Goal:</strong> Build a blog post manager with React Query that supports viewing, creating, updating, and deleting posts.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Fetch and display a list of blog posts</li>
                        <li>Show loading and error states</li>
                        <li>Create new posts with a form</li>
                        <li>Edit existing posts inline</li>
                        <li>Delete posts with confirmation</li>
                        <li>Use proper TypeScript types</li>
                        <li>Implement cache invalidation</li>
                        <li>Add optimistic updates for like button</li>
                    </ol>

                    <details>
                        <summary>üí° Hint #1: Project Structure</summary>
                        <pre><code class="language-typescript">// types/post.ts
export interface Post {
  id: string;
  title: string;
  content: string;
  author: string;
  likes: number;
  createdAt: string;
}

// api/posts.ts
export const postsApi = {
  getAll: async (): Promise&lt;Post[]&gt; => { /* ... */ },
  getById: async (id: string): Promise&lt;Post&gt; => { /* ... */ },
  create: async (data: Omit&lt;Post, 'id' | 'createdAt'&gt;): Promise&lt;Post&gt; => { /* ... */ },
  update: async (id: string, data: Partial&lt;Post&gt;): Promise&lt;Post&gt; => { /* ... */ },
  delete: async (id: string): Promise&lt;void&gt; => { /* ... */ },
  like: async (id: string): Promise&lt;Post&gt; => { /* ... */ }
};</code></pre>
                    </details>

                    <details>
                        <summary>üí° Hint #2: Custom Hooks</summary>
                        <pre><code class="language-typescript">// hooks/usePosts.ts
export const postKeys = {
  all: ['posts'] as const,
  lists: () => [...postKeys.all, 'list'] as const,
  details: () => [...postKeys.all, 'detail'] as const,
  detail: (id: string) => [...postKeys.details(), id] as const,
};

export function usePosts() {
  return useQuery({
    queryKey: postKeys.lists(),
    queryFn: postsApi.getAll
  });
}

export function useCreatePost() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: postsApi.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
    }
  });
}</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Full Solution</summary>
                        <pre><code class="language-typescript">// Full solution in next hint...</code></pre>
                        <p>Try implementing this yourself first! The solution combines all concepts from this lesson.</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Shopping Cart with Optimistic Updates</h3>
                    <p><strong>Goal:</strong> Build a shopping cart that updates instantly when adding/removing items.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Display product list from API</li>
                        <li>Show current cart items</li>
                        <li>Add items to cart with optimistic update</li>
                        <li>Remove items from cart with optimistic update</li>
                        <li>Update quantities with optimistic update</li>
                        <li>Rollback on error</li>
                        <li>Show total price (derived from cart)</li>
                        <li>Persist cart to server</li>
                    </ol>

                    <details>
                        <summary>üí° Hint: Optimistic Cart Update</summary>
                        <pre><code class="language-typescript">const addToCartMutation = useMutation({
  mutationFn: (productId: string) => addToCart(productId),
  
  onMutate: async (productId) => {
    await queryClient.cancelQueries({ queryKey: ['cart'] });
    
    const previousCart = queryClient.getQueryData&lt;CartItem[]&gt;(['cart']);
    
    queryClient.setQueryData&lt;CartItem[]&gt;(['cart'], (old) => {
      const existing = old?.find(item => item.productId === productId);
      if (existing) {
        return old?.map(item =>
          item.productId === productId
            ? { ...item, quantity: item.quantity + 1 }
            : item
        );
      }
      return [...(old || []), { productId, quantity: 1 }];
    });
    
    return { previousCart };
  },
  
  onError: (err, variables, context) => {
    queryClient.setQueryData(['cart'], context?.previousCart);
  },
  
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['cart'] });
  }
});</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Infinite Scroll with React Query</h3>
                    <p><strong>Goal:</strong> Implement infinite scrolling for a feed using <code>useInfiniteQuery</code>.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Fetch paginated posts</li>
                        <li>Load more on scroll or button click</li>
                        <li>Show loading state for next page</li>
                        <li>Handle end of data</li>
                        <li>Implement proper TypeScript types</li>
                    </ol>

                    <details>
                        <summary>üí° Hint: useInfiniteQuery Structure</summary>
                        <pre><code class="language-typescript">import { useInfiniteQuery } from '@tanstack/react-query';

interface Post {
  id: string;
  title: string;
  content: string;
}

interface PostsResponse {
  posts: Post[];
  nextCursor: string | null;
}

const fetchPosts = async ({ pageParam }: { pageParam: string | undefined }): Promise&lt;PostsResponse&gt; => {
  const url = pageParam 
    ? `/api/posts?cursor=${pageParam}`
    : '/api/posts';
  const response = await fetch(url);
  return response.json();
};

function InfinitePostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
  } = useInfiniteQuery({
    queryKey: ['posts', 'infinite'],
    queryFn: fetchPosts,
    initialPageParam: undefined,
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  });

  return (
    &lt;div&gt;
      {data?.pages.map((page, i) => (
        &lt;div key={i}&gt;
          {page.posts.map(post => (
            &lt;div key={post.id}&gt;{post.title}&lt;/div&gt;
          ))}
        &lt;/div&gt;
      ))}
      
      {hasNextPage && (
        &lt;button onClick={() => fetchNextPage()}&gt;
          {isFetchingNextPage ? 'Loading...' : 'Load More'}
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Quiz Section -->
            <section id="quiz">
                <h2>üß† Knowledge Check Quiz</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 1: Query vs Mutation</h3>
                    <p>What is the main difference between <code>useQuery</code> and <code>useMutation</code>?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong> <code>useQuery</code> is for reading/fetching data (GET requests), while <code>useMutation</code> is for creating, updating, or deleting data (POST, PUT, PATCH, DELETE requests). Queries run automatically and cache results, while mutations only run when explicitly called with <code>mutate()</code>.</p>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 2: Cache Invalidation</h3>
                    <p>When should you use <code>invalidateQueries</code> vs <code>setQueryData</code>?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>invalidateQueries:</strong> Use when you want to mark data as stale and trigger a refetch. Best for most cases where you want fresh data from the server.</li>
                                <li><strong>setQueryData:</strong> Use when you already have the new data and want to update the cache immediately without a server request. Perfect for optimistic updates and when mutations return the updated data.</li>
                            </ul>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 3: Optimistic Updates</h3>
                    <p>What are the key steps in implementing an optimistic update?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong> The key steps are:</p>
                            <ol>
                                <li><strong>Cancel queries</strong> to prevent refetches from overwriting optimistic state</li>
                                <li><strong>Snapshot previous state</strong> using getQueryData</li>
                                <li><strong>Update cache optimistically</strong> with setQueryData</li>
                                <li><strong>Return context</strong> with the snapshot from onMutate</li>
                                <li><strong>Rollback on error</strong> by restoring previous state in onError</li>
                                <li><strong>Invalidate queries</strong> in onSettled to sync with server</li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 4: Query Keys</h3>
                    <p>Why are query keys important, and what makes a good query key structure?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong> Query keys are crucial because they:</p>
                            <ul>
                                <li>Uniquely identify cached data</li>
                                <li>Enable precise cache invalidation</li>
                                <li>Support dependency tracking</li>
                            </ul>
                            <p>A good query key structure:</p>
                            <ul>
                                <li>Uses arrays: <code>['users', '123']</code></li>
                                <li>Orders from general to specific: <code>['posts', 'published', { page: 1 }]</code></li>
                                <li>Uses a key factory for consistency</li>
                                <li>Includes all variables that affect the query</li>
                            </ul>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 5: staleTime vs gcTime</h3>
                    <p>Explain the difference between <code>staleTime</code> and <code>gcTime</code> (formerly cacheTime).</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ul>
                                <li><strong>staleTime:</strong> How long data is considered "fresh" (won't refetch). Default is 0 (immediately stale). Use this to control when refetches happen.</li>
                                <li><strong>gcTime:</strong> How long unused data stays in cache before garbage collection. Default is 5 minutes. Use this to control memory usage.</li>
                            </ul>
                            <p><strong>Example:</strong> With staleTime=5min and gcTime=10min, data stays fresh for 5 minutes, becomes stale but cached for another 5 minutes, then gets removed from cache.</p>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 6: When to Use React Query</h3>
                    <p>Should you use React Query for all state management? When is it appropriate vs when should you use useState or another solution?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <p><strong>Use React Query for:</strong></p>
                            <ul>
                                <li>Server state (data from APIs)</li>
                                <li>Data that's cached and shared across components</li>
                                <li>Data that can become stale</li>
                                <li>Async data fetching</li>
                            </ul>
                            <p><strong>Use useState/useReducer for:</strong></p>
                            <ul>
                                <li>UI state (modal open/closed, form input values)</li>
                                <li>Client-only state that never touches the server</li>
                                <li>Temporary state that doesn't need caching</li>
                                <li>Component-local state</li>
                            </ul>
                            <p><strong>Use Zustand/Redux for:</strong></p>
                            <ul>
                                <li>Global client state</li>
                                <li>Complex state logic that's not server-related</li>
                                <li>State that needs to persist across route changes</li>
                            </ul>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2>üìù Lesson Summary</h2>
                
                <div class="card">
                    <h3>What You've Learned</h3>
                    <p>Congratulations! You've completed the React Query lesson. You now understand:</p>
                    
                    <ul>
                        <li>‚úÖ The difference between server state and client state</li>
                        <li>‚úÖ How to set up React Query with TypeScript</li>
                        <li>‚úÖ Using <code>useQuery</code> for data fetching with automatic caching</li>
                        <li>‚úÖ Query keys and cache management strategies</li>
                        <li>‚úÖ Using <code>useMutation</code> for create, update, delete operations</li>
                        <li>‚úÖ Cache invalidation patterns and when to use each</li>
                        <li>‚úÖ Implementing optimistic updates for instant UI feedback</li>
                        <li>‚úÖ React Query best practices and patterns</li>
                        <li>‚úÖ Organizing API functions and custom hooks</li>
                        <li>‚úÖ Error handling with typed errors</li>
                        <li>‚úÖ Prefetching and dependent queries</li>
                        <li>‚úÖ Global configuration and DevTools usage</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ol style="color: white;">
                        <li><strong>React Query is for server state:</strong> Use it for data from APIs, not UI state</li>
                        <li><strong>Queries auto-cache and refetch:</strong> No manual cache management needed</li>
                        <li><strong>Mutations update server state:</strong> Always invalidate affected queries</li>
                        <li><strong>Optimistic updates make apps feel instant:</strong> Update UI before server responds</li>
                        <li><strong>Query keys are crucial:</strong> Use a factory pattern for consistency</li>
                        <li><strong>Custom hooks encapsulate logic:</strong> One hook per resource type</li>
                        <li><strong>Configure sensible defaults:</strong> Set staleTime based on data volatility</li>
                        <li><strong>Use DevTools for debugging:</strong> Visualize cache state and queries</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üöÄ Next Steps</h3>
                    <p>Now that you've mastered React Query, you can:</p>
                    <ul>
                        <li>Refactor existing data fetching code to use React Query</li>
                        <li>Build applications with complex server state requirements</li>
                        <li>Implement real-time features with polling or WebSocket integration</li>
                        <li>Optimize performance with prefetching and parallel queries</li>
                        <li>Proceed to <strong>Lesson 8.5: Architecture Best Practices</strong></li>
                        <li>Complete the Module 8 Project: Social Media Feed</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üìö Additional Resources</h3>
                    <ul>
                        <li><a href="https://tanstack.com/query/latest" target="_blank">TanStack Query Official Documentation</a></li>
                        <li><a href="https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5" target="_blank">Migration Guide to v5</a></li>
                        <li><a href="https://tanstack.com/query/latest/docs/react/community/tkdodos-blog" target="_blank">TkDodo's React Query Blog</a> - Excellent deep dives</li>
                        <li><a href="https://tanstack.com/query/latest/docs/react/devtools" target="_blank">React Query DevTools Guide</a></li>
                        <li><a href="https://tanstack.com/query/latest/docs/react/typescript" target="_blank">TypeScript Guide for React Query</a></li>
                    </ul>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson navigation">
                <a href="lesson_8_3_redux_toolkit.html" class="nav-button prev-lesson">
                    <span class="arrow">‚Üê</span>
                    <span class="label">Previous</span>
                    <span class="title">Lesson 8.3: Redux Toolkit</span>
                </a>
                <a href="index.html" class="nav-button home">
                    <span class="label">Course Home</span>
                </a>
                <a href="lesson_8_5_architecture_best_practices.html" class="nav-button next-lesson">
                    <span class="label">Next</span>
                    <span class="title">Lesson 8.5: Architecture Best Practices</span>
                    <span class="arrow">‚Üí</span>
                </a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="mailto:support@example.com">Contact</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
