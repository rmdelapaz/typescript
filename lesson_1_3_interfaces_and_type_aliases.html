<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master TypeScript interfaces and type aliases - Learn how to define complex object shapes, extend types, and choose between interfaces and type aliases.">
    <meta name="author" content="PracticalAce">
    <title>Interfaces and Type Aliases - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module1">Module 1: TypeScript Fundamentals</a></li>
            <li aria-current="page">Lesson 1.3: Interfaces and Type Aliases</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üèóÔ∏è Interfaces and Type Aliases</h1>
                <p class="lead">Welcome to the world of complex types! If basic types are LEGO bricks, then interfaces and type aliases are the instruction manuals that show you how to build magnificent structures. In this lesson, we'll learn how to describe complex objects, create reusable type definitions, and make our code more maintainable and self-documenting. üé®</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Create and use interfaces to define object shapes</li>
                        <li>Understand the difference between interfaces and type aliases</li>
                        <li>Use optional and readonly properties effectively</li>
                        <li>Extend and compose interfaces for code reuse</li>
                        <li>Create index signatures for dynamic properties</li>
                        <li>Choose the right tool (interface vs type alias) for each scenario</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a type-safe user management system with complex data structures</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What Are Interfaces?</a></li>
                        <li><a href="#section2" class="toc-link">Creating Your First Interface</a></li>
                        <li><a href="#section3" class="toc-link">Optional and Readonly Properties</a></li>
                        <li><a href="#section4" class="toc-link">Type Aliases Explained</a></li>
                        <li><a href="#section5" class="toc-link">Interface vs Type Alias</a></li>
                        <li><a href="#section6" class="toc-link">Extending Interfaces</a></li>
                        <li><a href="#section7" class="toc-link">Index Signatures</a></li>
                        <li><a href="#section8" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What Are Interfaces? -->
            <section id="section1" class="lesson-section">
                <h2>What Are Interfaces?</h2>
                
                <p>Imagine you're designing a building. Before construction begins, you create a blueprint that shows exactly what the building should look like - how many floors, where the doors go, the size of each room. An interface is like a blueprint for your data structures. It defines the exact shape an object should have. üìê</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üìñ Definition</h3>
                    <p style="color: white;"><strong>Interface:</strong> A way to define the structure of an object in TypeScript. It describes what properties an object should have, what types those properties should be, and what methods the object should support. Think of it as a contract that objects must fulfill.</p>
                </div>

                <h3>Why Interfaces Matter</h3>
                <p>Without interfaces, you'd have to remember what properties each object has. With hundreds of objects in a real application, that's impossible! Interfaces solve this by:</p>

                <ul>
                    <li>üéØ <strong>Documenting structure:</strong> Anyone can see what an object should contain</li>
                    <li>üõ°Ô∏è <strong>Enforcing consistency:</strong> All objects of the same type have the same shape</li>
                    <li>üîç <strong>Enabling autocomplete:</strong> Your editor knows what properties exist</li>
                    <li>üêõ <strong>Catching errors early:</strong> TypeScript warns you if you miss a property</li>
                    <li>üîÑ <strong>Making refactoring safe:</strong> Change the interface, and TypeScript shows you what breaks</li>
                </ul>

                <h3>A Real-World Analogy</h3>
                <p>Think of interfaces like a job description. When you hire a "Software Developer," you expect certain skills - they should know how to code, debug, and work with teams. The job title (interface name) tells you what to expect. If someone applies for "Software Developer" but can't code, that's a problem! Similarly, if an object claims to implement an interface but is missing properties, TypeScript catches it. üíº</p>

                <div class="mermaid">
                    graph LR
                        A[Interface: Blueprint] --> B[Object 1: House]
                        A --> C[Object 2: Office]
                        A --> D[Object 3: School]
                        
                        B --> B1[‚úì Has required properties]
                        C --> C1[‚úì Has required properties]
                        D --> D1[‚úì Has required properties]
                        
                        E[Object Without Interface] --> E1[‚ùì What properties?]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style B1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style C1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style D1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style E1 fill:#f44336,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <blockquote>
                    <strong>üí° Key Insight:</strong> Interfaces don't create any JavaScript code. They exist only during development to help TypeScript check your code. Once compiled, they disappear completely - they're just documentation and validation!
                </blockquote>
            </section>

            <!-- Section 2: Creating Your First Interface -->
            <section id="section2" class="lesson-section">
                <h2>Creating Your First Interface</h2>
                
                <p>Let's dive right in and create some interfaces! We'll start simple and build up to more complex examples. üöÄ</p>

                <h3>Basic Interface Syntax</h3>
                <p>Here's the fundamental structure of an interface:</p>

                <pre><code class="language-typescript">// Define an interface
interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// Create an object that matches the interface
const user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    age: 28
};

// TypeScript is happy! ‚úÖ
console.log(user.name);  // "Alice"
</code></pre>

                <p>Let's break this down:</p>
                <ul>
                    <li><code>interface User</code> - The keyword <code>interface</code> followed by the name (PascalCase)</li>
                    <li>Inside curly braces: list each property with its type</li>
                    <li>Each property ends with a semicolon (or comma - both work!)</li>
                    <li>When creating an object, you must include ALL properties with correct types</li>
                </ul>

                <h3>What Happens When You Violate the Interface?</h3>
                <p>TypeScript enforces the interface strictly. Let's see what happens when we break the rules:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// ‚ùå Missing properties
const user1: User = {
    id: 1,
    name: "Bob"
    // Error! Property 'email' is missing
    // Error! Property 'age' is missing
};

// ‚ùå Wrong type
const user2: User = {
    id: "123",        // Error! Type 'string' is not assignable to type 'number'
    name: "Charlie",
    email: "charlie@example.com",
    age: 30
};

// ‚ùå Extra properties
const user3: User = {
    id: 1,
    name: "Diana",
    email: "diana@example.com",
    age: 25,
    country: "USA"    // Error! Property 'country' does not exist on type 'User'
};

// ‚úÖ This is correct!
const user4: User = {
    id: 1,
    name: "Eve",
    email: "eve@example.com",
    age: 32
};
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Strict Property Checking</h4>
                    <p>TypeScript is very strict about object literals. You can't have extra properties, missing properties, or wrong types. This strictness prevents bugs!</p>
                </div>

                <h3>Interfaces with Methods</h3>
                <p>Interfaces can describe methods (functions) too! This is perfect for describing objects that have behavior:</p>

                <pre><code class="language-typescript">interface Calculator {
    // Properties
    brand: string;
    model: string;
    
    // Methods
    add(a: number, b: number): number;
    subtract(a: number, b: number): number;
    clear(): void;
}

// Implement the interface
const myCalculator: Calculator = {
    brand: "Casio",
    model: "FX-991",
    
    add(a: number, b: number): number {
        return a + b;
    },
    
    subtract(a: number, b: number): number {
        return a - b;
    },
    
    clear(): void {
        console.log("Calculator cleared");
    }
};

// Use it
console.log(myCalculator.add(5, 3));     // 8
console.log(myCalculator.subtract(5, 3)); // 2
myCalculator.clear();                     // "Calculator cleared"
</code></pre>

                <h3>Nested Interfaces</h3>
                <p>Real-world objects are often complex with nested structures. Interfaces handle this beautifully:</p>

                <pre><code class="language-typescript">// Define a nested interface
interface Address {
    street: string;
    city: string;
    state: string;
    zipCode: string;
}

interface User {
    id: number;
    name: string;
    email: string;
    address: Address;  // Nested interface!
}

// Create an object with nested structure
const user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    address: {
        street: "123 Main St",
        city: "Springfield",
        state: "IL",
        zipCode: "62701"
    }
};

// Access nested properties
console.log(user.address.city);  // "Springfield"
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Compose Small Interfaces</h4>
                    <p>Instead of one giant interface, break it into smaller, reusable pieces. This makes your code more maintainable and easier to understand!</p>
                    <pre><code class="language-typescript">// Good: Small, focused interfaces
interface ContactInfo {
    email: string;
    phone: string;
}

interface PersonalInfo {
    firstName: string;
    lastName: string;
    dateOfBirth: string;
}

interface User {
    id: number;
    contact: ContactInfo;
    personal: PersonalInfo;
}
</code></pre>
                </div>

                <h3>Interfaces for Function Types</h3>
                <p>You can even use interfaces to describe function signatures:</p>

                <pre><code class="language-typescript">// Interface for a function
interface MathOperation {
    (a: number, b: number): number;
}

// Functions that match the interface
const add: MathOperation = (a, b) => a + b;
const multiply: MathOperation = (a, b) => a * b;

console.log(add(5, 3));       // 8
console.log(multiply(5, 3));  // 15

// This won't work - wrong signature
const concat: MathOperation = (a, b) => `${a}${b}`;  // ‚ùå Error! Returns string, not number
</code></pre>

                <h3>Real-World Example: E-Commerce Product</h3>
                <p>Let's model a realistic e-commerce product with all we've learned:</p>

                <pre><code class="language-typescript">interface Price {
    amount: number;
    currency: string;
}

interface Dimensions {
    length: number;
    width: number;
    height: number;
    unit: "cm" | "in";  // Literal type!
}

interface Review {
    userId: number;
    rating: number;
    comment: string;
    date: string;
}

interface Product {
    id: string;
    name: string;
    description: string;
    price: Price;
    inStock: boolean;
    dimensions: Dimensions;
    category: string;
    tags: string[];
    reviews: Review[];
    
    // Method
    getAverageRating(): number;
}

// Implement the product
const laptop: Product = {
    id: "LAPTOP-001",
    name: "ThinkPad X1 Carbon",
    description: "Lightweight business laptop",
    price: {
        amount: 1299.99,
        currency: "USD"
    },
    inStock: true,
    dimensions: {
        length: 32.3,
        width: 21.7,
        height: 1.49,
        unit: "cm"
    },
    category: "Electronics",
    tags: ["laptop", "business", "portable"],
    reviews: [
        {
            userId: 101,
            rating: 5,
            comment: "Excellent laptop!",
            date: "2024-01-15"
        },
        {
            userId: 102,
            rating: 4,
            comment: "Great, but expensive",
            date: "2024-01-20"
        }
    ],
    
    getAverageRating(): number {
        if (this.reviews.length === 0) return 0;
        const sum = this.reviews.reduce((acc, review) => acc + review.rating, 0);
        return sum / this.reviews.length;
    }
};

console.log(laptop.getAverageRating());  // 4.5
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Notice the Power!</h4>
                    <ul>
                        <li>‚úÖ Every product has the same structure - consistency guaranteed</li>
                        <li>‚úÖ Autocomplete works perfectly - your editor suggests properties</li>
                        <li>‚úÖ Typos are caught immediately - can't write <code>laptop.prise</code></li>
                        <li>‚úÖ Refactoring is safe - change the interface and find all affected code</li>
                        <li>‚úÖ Documentation is built-in - the interface IS the documentation!</li>
                    </ul>
                </div>
            </section>

            <!-- Section 3: Optional and Readonly Properties -->
            <section id="section3" class="lesson-section">
                <h2>Optional and Readonly Properties</h2>
                
                <p>Not all properties are created equal! Some are required, some are optional, and some should never change after creation. TypeScript gives us tools to express these nuances. Let's explore! üîß</p>

                <h3>Optional Properties (?)</h3>
                <p>Sometimes a property might not always be present. Use the <code>?</code> symbol to mark it as optional:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    age?: number;        // Optional - might not exist
    phone?: string;      // Optional
    website?: string;    // Optional
}

// All of these are valid!
const user1: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    age: 28,
    phone: "555-1234"
    // website is omitted - that's OK!
};

const user2: User = {
    id: 2,
    name: "Bob",
    email: "bob@example.com"
    // age, phone, and website all omitted - all OK!
};

const user3: User = {
    id: 3,
    name: "Charlie",
    email: "charlie@example.com",
    age: 35,
    phone: "555-5678",
    website: "https://charlie.dev"
    // All properties present - also OK!
};
</code></pre>

                <h4>Working with Optional Properties</h4>
                <p>When you access an optional property, TypeScript knows it might be <code>undefined</code>:</p>

                <pre><code class="language-typescript">interface User {
    name: string;
    age?: number;
}

function greetUser(user: User): string {
    // age might be undefined, so be careful!
    if (user.age) {
        return `Hello ${user.name}, you are ${user.age} years old`;
    } else {
        return `Hello ${user.name}`;
    }
    
    // Or use optional chaining
    return `Hello ${user.name}${user.age ? `, you are ${user.age}` : ''}`;
}

const user1: User = { name: "Alice", age: 28 };
const user2: User = { name: "Bob" };

console.log(greetUser(user1));  // "Hello Alice, you are 28 years old"
console.log(greetUser(user2));  // "Hello Bob"
</code></pre>

                <blockquote>
                    <strong>üí° Best Practice:</strong> Use optional properties for data that's truly optional - like a middle name, phone number, or profile picture. Don't overuse them - if a property is always needed, make it required!
                </blockquote>

                <h3>Readonly Properties (readonly)</h3>
                <p>Some properties should never change after they're set - like an ID or creation timestamp. Use <code>readonly</code> to enforce this:</p>

                <pre><code class="language-typescript">interface User {
    readonly id: number;           // Can't be changed after creation
    readonly createdAt: string;    // Can't be changed after creation
    name: string;                  // Can be changed
    email: string;                 // Can be changed
}

const user: User = {
    id: 1,
    createdAt: "2024-01-15",
    name: "Alice",
    email: "alice@example.com"
};

// These are allowed ‚úÖ
user.name = "Alice Smith";
user.email = "alice.smith@example.com";

// These cause errors ‚ùå
user.id = 2;              // Error! Cannot assign to 'id' because it is a read-only property
user.createdAt = "2024-01-20";  // Error! Cannot assign to 'createdAt'
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use readonly</h4>
                    <ul>
                        <li><strong>IDs:</strong> Identifiers should never change</li>
                        <li><strong>Timestamps:</strong> Creation/modification dates</li>
                        <li><strong>Configuration:</strong> Settings that shouldn't be modified</li>
                        <li><strong>Constants:</strong> Fixed values like API keys (from environment)</li>
                    </ul>
                </div>

                <h3>Combining Optional and Readonly</h3>
                <p>You can use both modifiers together:</p>

                <pre><code class="language-typescript">interface BlogPost {
    readonly id: string;              // Required, can't change
    readonly authorId: number;        // Required, can't change
    title: string;                    // Required, can change
    content: string;                  // Required, can change
    publishedAt?: readonly string;    // Optional, but if set, can't change
    tags?: string[];                  // Optional, can change
}

const post: BlogPost = {
    id: "post-123",
    authorId: 42,
    title: "Learning TypeScript",
    content: "TypeScript is awesome!",
    publishedAt: "2024-01-15"
};

// Allowed ‚úÖ
post.title = "Mastering TypeScript";
post.tags = ["typescript", "tutorial"];

// Not allowed ‚ùå
post.id = "post-456";           // Error! readonly
post.authorId = 99;             // Error! readonly
post.publishedAt = "2024-01-20"; // Error! readonly
</code></pre>

                <h3>Real-World Example: Immutable Configuration</h3>
                <p>Perfect for application config that shouldn't change at runtime:</p>

                <pre><code class="language-typescript">interface AppConfig {
    readonly apiUrl: string;
    readonly apiKey: string;
    readonly environment: "development" | "staging" | "production";
    readonly maxRetries: number;
    theme?: "light" | "dark";        // Optional, user can change
    language?: string;               // Optional, user can change
}

const config: AppConfig = {
    apiUrl: "https://api.example.com",
    apiKey: "secret-key-12345",
    environment: "production",
    maxRetries: 3,
    theme: "dark"
};

// User preferences can change ‚úÖ
config.theme = "light";
config.language = "es";

// But core config is locked ‚ùå
config.apiUrl = "https://hacker.com";  // Error! Can't change API URL
config.environment = "development";     // Error! Can't change environment
</code></pre>

                <div class="mermaid">
                    graph TD
                        A[Interface Properties] --> B[Required]
                        A --> C[Optional ?]
                        
                        B --> B1[Always present]
                        B --> B2[Must have value]
                        
                        C --> C1[May be absent]
                        C --> C2[Could be undefined]
                        
                        D[Property Modifiers] --> E[readonly]
                        D --> F[mutable]
                        
                        E --> E1[Set once]
                        E --> E2[Never changes]
                        
                        F --> F1[Can reassign]
                        F --> F2[Can modify]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style D fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>
            <!-- Section 4: Type Aliases Explained -->
            <section id="section4" class="lesson-section">
                <h2>Type Aliases Explained</h2>
                
                <p>So far we've focused on interfaces, but TypeScript has another powerful tool: type aliases. If interfaces are like blueprints, type aliases are like custom labels you can stick on anything. They're incredibly flexible! üè∑Ô∏è</p>

                <h3>What is a Type Alias?</h3>
                <p>A type alias creates a new name for any type - primitives, unions, tuples, objects, and more. Think of it as creating a shortcut or nickname for a type:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üìñ Definition</h3>
                    <p style="color: white;"><strong>Type Alias:</strong> A way to give a name to any type. Unlike interfaces which only describe object shapes, type aliases can represent any type at all - primitives, unions, tuples, intersections, and objects.</p>
                </div>

                <h3>Basic Type Alias Syntax</h3>
                <p>Use the <code>type</code> keyword to create an alias:</p>

                <pre><code class="language-typescript">// Alias for a primitive type
type ID = string | number;

// Alias for a union type
type Status = "pending" | "approved" | "rejected";

// Alias for an object type
type User = {
    id: ID;
    name: string;
    status: Status;
};

// Using the aliases
let userId: ID = 123;              // ‚úÖ number works
userId = "user-abc";               // ‚úÖ string works

let orderStatus: Status = "pending";  // ‚úÖ OK
// orderStatus = "completed";         // ‚ùå Error! Not in the union

const user: User = {
    id: 1,
    name: "Alice",
    status: "approved"
};
</code></pre>

                <h3>Type Aliases for Primitives and Unions</h3>
                <p>Type aliases shine when working with unions and complex combinations:</p>

                <pre><code class="language-typescript">// Simple primitive alias
type Age = number;
type Name = string;

// Union types (very common!)
type ID = string | number;
type Result = "success" | "failure" | "pending";
type Padding = number | string;  // Could be 10 or "10px"

// Complex unions
type Response = 
    | { success: true; data: any }
    | { success: false; error: string };

// Using them
function handleResponse(response: Response) {
    if (response.success) {
        console.log(response.data);   // TypeScript knows data exists here
    } else {
        console.log(response.error);  // TypeScript knows error exists here
    }
}
</code></pre>

                <h3>Type Aliases for Tuples</h3>
                <p>Type aliases are perfect for naming tuple types:</p>

                <pre><code class="language-typescript">// Without alias - hard to read
function getCoordinates(): [number, number] {
    return [10, 20];
}

// With alias - much clearer!
type Point = [number, number];

function getCoordinates(): Point {
    return [10, 20];
}

// More complex tuples
type RGB = [number, number, number];
type RGBA = [number, number, number, number];

const red: RGB = [255, 0, 0];
const semiTransparentBlue: RGBA = [0, 0, 255, 0.5];

// Named tuple members (TypeScript 4.0+)
type Range = [start: number, end: number];
type HTTPResponse = [status: number, body: string];

const range: Range = [0, 100];
const response: HTTPResponse = [200, "OK"];
</code></pre>

                <h3>Type Aliases for Object Types</h3>
                <p>Type aliases can describe object shapes just like interfaces:</p>

                <pre><code class="language-typescript">// Object type alias
type User = {
    id: number;
    name: string;
    email: string;
    isActive: boolean;
};

// With optional properties
type Product = {
    id: string;
    name: string;
    price: number;
    description?: string;     // Optional
    imageUrl?: string;        // Optional
};

// With readonly properties
type Config = {
    readonly apiUrl: string;
    readonly timeout: number;
    retries: number;          // Can be changed
};

// With methods
type Calculator = {
    add: (a: number, b: number) => number;
    subtract: (a: number, b: number) => number;
};

const calc: Calculator = {
    add: (a, b) => a + b,
    subtract: (a, b) => a - b
};
</code></pre>

                <h3>Type Aliases for Functions</h3>
                <p>Type aliases make function signatures reusable and readable:</p>

                <pre><code class="language-typescript">// Function type alias
type MathOperation = (a: number, b: number) => number;

// Use it multiple times
const add: MathOperation = (a, b) => a + b;
const multiply: MathOperation = (a, b) => a * b;
const divide: MathOperation = (a, b) => a / b;

// More complex function types
type Validator = (value: string) => boolean;
type AsyncFetcher = (url: string) => Promise<any>;
type EventHandler = (event: Event) => void;

// Callback function type
type ComparisonFunction<T> = (a: T, b: T) => number;

function sort<T>(items: T[], compare: ComparisonFunction<T>): T[] {
    return items.sort(compare);
}

const numbers = [3, 1, 4, 1, 5, 9];
const sorted = sort(numbers, (a, b) => a - b);
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Real-World Example: API Response Types</h4>
                    <pre><code class="language-typescript">// Define all possible response types
type SuccessResponse<T> = {
    status: "success";
    data: T;
    timestamp: string;
};

type ErrorResponse = {
    status: "error";
    message: string;
    code: number;
};

type LoadingResponse = {
    status: "loading";
};

// Union of all response types
type ApiResponse<T> = SuccessResponse<T> | ErrorResponse | LoadingResponse;

// Use with different data types
type UserResponse = ApiResponse<User>;
type ProductResponse = ApiResponse<Product[]>;

function handleUserResponse(response: UserResponse) {
    switch (response.status) {
        case "success":
            console.log(response.data.name);  // TypeScript knows data exists
            break;
        case "error":
            console.log(response.message);    // TypeScript knows message exists
            break;
        case "loading":
            console.log("Loading...");        // No additional properties
            break;
    }
}
</code></pre>
                </div>

                <h3>Intersection Types with Type Aliases</h3>
                <p>Type aliases can combine multiple types using <code>&</code> (intersection):</p>

                <pre><code class="language-typescript">// Combine types with intersection
type Timestamped = {
    createdAt: string;
    updatedAt: string;
};

type WithId = {
    id: number;
};

type User = {
    name: string;
    email: string;
};

// Combine them all!
type UserRecord = User & WithId & Timestamped;

// UserRecord now has ALL properties:
const user: UserRecord = {
    id: 1,
    name: "Alice",
    email: "alice@example.com",
    createdAt: "2024-01-15",
    updatedAt: "2024-01-15"
};
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Intersection types are like merging multiple objects into one. All properties from all types must be present. This is super useful for mixing in common properties like timestamps, IDs, or metadata!
                </blockquote>

                <h3>Mapped Types with Type Aliases</h3>
                <p>Type aliases enable powerful transformations (we'll explore this more later, but here's a taste):</p>

                <pre><code class="language-typescript">// Make all properties optional
type Partial<T> = {
    [P in keyof T]?: T[P];
};

// Make all properties readonly
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};

type User = {
    id: number;
    name: string;
    email: string;
};

type PartialUser = Partial<User>;     // All properties optional
type ReadonlyUser = Readonly<User>;   // All properties readonly

const partialUser: PartialUser = {
    name: "Alice"  // Only some properties - OK!
};

const readonlyUser: ReadonlyUser = {
    id: 1,
    name: "Bob",
    email: "bob@example.com"
};

// readonlyUser.name = "Charlie";  // ‚ùå Error! All properties are readonly
</code></pre>
            </section>

            <!-- Section 5: Interface vs Type Alias -->
            <section id="section5" class="lesson-section">
                <h2>Interface vs Type Alias: Which to Choose?</h2>
                
                <p>The million-dollar question: should you use <code>interface</code> or <code>type</code>? The good news is they're very similar and often interchangeable. But there are key differences that matter. Let's explore! ü§î</p>

                <h3>The Similarities</h3>
                <p>First, let's see what they have in common. Both can describe objects:</p>

                <pre><code class="language-typescript">// Interface
interface UserInterface {
    id: number;
    name: string;
    email: string;
}

// Type Alias
type UserType = {
    id: number;
    name: string;
    email: string;
};

// Both work the same way!
const user1: UserInterface = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};

const user2: UserType = {
    id: 2,
    name: "Bob",
    email: "bob@example.com"
};
</code></pre>

                <h3>Key Differences</h3>

                <h4>1. Declaration Merging (Interface Only)</h4>
                <p>Interfaces can be declared multiple times and TypeScript merges them. Type aliases cannot:</p>

                <pre><code class="language-typescript">// ‚úÖ Interface declaration merging works
interface User {
    id: number;
    name: string;
}

interface User {
    email: string;  // Merged with previous declaration
}

// User now has: id, name, AND email
const user: User = {
    id: 1,
    name: "Alice",
    email: "alice@example.com"
};

// ‚ùå Type aliases CANNOT be merged
type Person = {
    id: number;
    name: string;
};

type Person = {        // Error! Duplicate identifier 'Person'
    email: string;
};
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When Declaration Merging Matters</h4>
                    <p>Declaration merging is useful for extending third-party types or building libraries. For example, extending the global <code>Window</code> object:</p>
                    <pre><code class="language-typescript">// Extend the built-in Window interface
interface Window {
    myCustomProperty: string;
}

// Now you can use it
window.myCustomProperty = "hello";
</code></pre>
                </div>

                <h4>2. Extending vs Intersections</h4>
                <p>Interfaces use <code>extends</code>, type aliases use <code>&</code> (intersections):</p>

                <pre><code class="language-typescript">// Interface extending
interface Animal {
    name: string;
    age: number;
}

interface Dog extends Animal {
    breed: string;
    bark(): void;
}

const dog: Dog = {
    name: "Buddy",
    age: 3,
    breed: "Golden Retriever",
    bark() {
        console.log("Woof!");
    }
};

// Type alias intersection
type Animal2 = {
    name: string;
    age: number;
};

type Dog2 = Animal2 & {
    breed: string;
    bark(): void;
};

const dog2: Dog2 = {
    name: "Max",
    age: 5,
    breed: "Labrador",
    bark() {
        console.log("Woof!");
    }
};

// Both achieve the same result!
</code></pre>

                <h4>3. Union Types (Type Alias Only)</h4>
                <p>Type aliases can represent unions, interfaces cannot:</p>

                <pre><code class="language-typescript">// ‚úÖ Type alias can be a union
type Status = "pending" | "approved" | "rejected";
type ID = string | number;
type Result = Success | Error;

// ‚ùå Interface cannot be a union
interface Status = "pending" | "approved" | "rejected";  // Syntax error!

// Interfaces can only describe object shapes
interface Success {
    status: "success";
    data: any;
}

interface Error {
    status: "error";
    message: string;
}

// Use type alias to create union
type Result = Success | Error;
</code></pre>

                <h4>4. Tuple Types (Type Alias Only)</h4>
                <p>Tuples are best expressed with type aliases:</p>

                <pre><code class="language-typescript">// ‚úÖ Type alias for tuple
type Point = [number, number];
type RGB = [number, number, number];

// ‚ùå Interface for tuple (awkward and not recommended)
interface PointInterface {
    0: number;
    1: number;
    length: 2;
}

// Type alias is much cleaner for tuples!
</code></pre>

                <h4>5. Primitive Types (Type Alias Only)</h4>
                <p>Type aliases can name any type, interfaces only describe objects:</p>

                <pre><code class="language-typescript">// ‚úÖ Type alias can represent primitives
type Name = string;
type Age = number;
type IsActive = boolean;

// ‚ùå Interface cannot represent primitives
interface Name = string;  // Syntax error!
</code></pre>

                <h3>The Decision Matrix</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Interface</th>
                            <th>Type Alias</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Describe object shapes</td>
                            <td>‚úÖ Yes</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td>Declaration merging</td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>Extend/inherit</td>
                            <td>‚úÖ extends keyword</td>
                            <td>‚úÖ & intersection</td>
                        </tr>
                        <tr>
                            <td>Union types</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td>Tuple types</td>
                            <td>‚ö†Ô∏è Awkward</td>
                            <td>‚úÖ Perfect</td>
                        </tr>
                        <tr>
                            <td>Primitive types</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td>Mapped types</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td>Performance</td>
                            <td>‚ö° Slightly faster compile</td>
                            <td>‚ö° Very similar</td>
                        </tr>
                    </tbody>
                </table>

                <h3>When to Use Which?</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use Interface When:</h4>
                    <ul>
                        <li>Defining object shapes (the most common case)</li>
                        <li>You might need declaration merging (libraries, extending third-party types)</li>
                        <li>Creating public APIs that others might extend</li>
                        <li>You want slightly better error messages (interfaces show the name, types show the full definition)</li>
                    </ul>
                    <pre><code class="language-typescript">// Good use of interface
interface User {
    id: number;
    name: string;
    email: string;
}

interface Admin extends User {
    permissions: string[];
}
</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>‚úÖ Use Type Alias When:</h4>
                    <ul>
                        <li>Creating union types</li>
                        <li>Defining tuple types</li>
                        <li>Creating aliases for primitives</li>
                        <li>Using intersection types extensively</li>
                        <li>Creating complex mapped or conditional types</li>
                    </ul>
                    <pre><code class="language-typescript">// Good use of type alias
type Status = "pending" | "approved" | "rejected";
type Point = [number, number];
type ID = string | number;
type Result = Success | Error;
</code></pre>
                </div>

                <h3>The Practical Guideline</h3>
                <p>Here's a simple rule of thumb that works for most situations:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ The Golden Rule</h3>
                    <p style="color: white; font-size: 1.1rem;"><strong>Default to interfaces for object shapes. Use type aliases for unions, tuples, and everything else.</strong></p>
                    <p style="color: white; margin: 0;">If you're describing the structure of an object or class, use <code>interface</code>. For anything else (unions, intersections, tuples, utility types), use <code>type</code>.</p>
                </div>

                <h3>Mixed Example: Best of Both</h3>
                <p>In real projects, you'll use both! Here's a realistic example:</p>

                <pre><code class="language-typescript">// Union types - use type alias
type UserRole = "admin" | "editor" | "viewer";
type Status = "active" | "inactive" | "suspended";

// Object shapes - use interface
interface User {
    id: number;
    name: string;
    email: string;
    role: UserRole;        // Using type alias
    status: Status;        // Using type alias
}

interface Admin extends User {
    permissions: string[];
    canDelete: boolean;
}

// Complex response - use type alias
type ApiResponse<T> = 
    | { success: true; data: T }
    | { success: false; error: string };

// Function types - use type alias
type UserValidator = (user: User) => boolean;
type AsyncFetcher<T> = (id: number) => Promise<ApiResponse<T>>;

// Use them together!
const validateUser: UserValidator = (user) => {
    return user.status === "active" && user.email.includes("@");
};

const fetchUser: AsyncFetcher<User> = async (id) => {
    try {
        const response = await fetch(`/api/users/${id}`);
        const data = await response.json();
        return { success: true, data };
    } catch (error) {
        return { success: false, error: "Failed to fetch user" };
    }
};
</code></pre>

                <blockquote>
                    <strong>üí° Remember:</strong> Both interfaces and type aliases are equally valid. The TypeScript team doesn't recommend one over the other for all cases. Use what makes your code clearest and most maintainable!
                </blockquote>
            </section>

            <!-- Section 6: Extending Interfaces -->
            <section id="section6" class="lesson-section">
                <h2>Extending Interfaces</h2>
                
                <p>One of the most powerful features of interfaces is the ability to extend them - building new interfaces on top of existing ones. Think of it like inheritance in object-oriented programming, but for types! üèóÔ∏è</p>

                <h3>Basic Extension</h3>
                <p>Use the <code>extends</code> keyword to create an interface that includes all properties from another interface plus additional ones:</p>

                <pre><code class="language-typescript">// Base interface
interface Person {
    name: string;
    age: number;
}

// Extended interface - has everything from Person, plus more
interface Employee extends Person {
    employeeId: number;
    department: string;
    salary: number;
}

// Employee must have ALL properties: name, age, employeeId, department, salary
const employee: Employee = {
    name: "Alice",
    age: 30,
    employeeId: 12345,
    department: "Engineering",
    salary: 100000
};

console.log(employee.name);        // From Person
console.log(employee.employeeId);  // From Employee
</code></pre>

                <h3>Extending Multiple Interfaces</h3>
                <p>You can extend multiple interfaces at once - combining properties from all of them:</p>

                <pre><code class="language-typescript">interface Identifiable {
    id: number;
}

interface Timestamped {
    createdAt: string;
    updatedAt: string;
}

interface Taggable {
    tags: string[];
}

// BlogPost combines all three!
interface BlogPost extends Identifiable, Timestamped, Taggable {
    title: string;
    content: string;
    authorId: number;
}

const post: BlogPost = {
    // From Identifiable
    id: 1,
    
    // From Timestamped
    createdAt: "2024-01-15",
    updatedAt: "2024-01-20",
    
    // From Taggable
    tags: ["typescript", "tutorial"],
    
    // From BlogPost
    title: "Learning TypeScript",
    content: "TypeScript is awesome!",
    authorId: 42
};
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Extension</h4>
                    <ul>
                        <li><strong>Code reuse:</strong> Define common properties once, use everywhere</li>
                        <li><strong>Maintainability:</strong> Change base interface, all extensions update</li>
                        <li><strong>Clear relationships:</strong> Shows inheritance hierarchy clearly</li>
                        <li><strong>DRY principle:</strong> Don't Repeat Yourself - define once!</li>
                    </ul>
                </div>

                <h3>Overriding Properties</h3>
                <p>When extending, you can make a property more specific (but not less specific!):</p>

                <pre><code class="language-typescript">interface Animal {
    name: string;
    age: number;
    species: string;
}

interface Dog extends Animal {
    species: "dog";        // More specific! Must be exactly "dog"
    breed: string;
    bark(): void;
}

const dog: Dog = {
    name: "Buddy",
    age: 3,
    species: "dog",        // Must be "dog" exactly
    breed: "Golden Retriever",
    bark() {
        console.log("Woof!");
    }
};

// This won't work:
// const invalidDog: Dog = {
//     species: "cat"     // ‚ùå Error! Must be "dog"
// };
</code></pre>

                <h3>Chain of Extension</h3>
                <p>Interfaces can extend other extended interfaces, creating a hierarchy:</p>

                <pre><code class="language-typescript">// Base
interface Entity {
    id: number;
    createdAt: string;
}

// First level extension
interface User extends Entity {
    name: string;
    email: string;
}

// Second level extension
interface PremiumUser extends User {
    subscriptionLevel: "gold" | "platinum";
    expiresAt: string;
}

// Third level extension
interface AdminUser extends PremiumUser {
    permissions: string[];
    canDeleteUsers: boolean;
}

// AdminUser has ALL properties from the entire chain!
const admin: AdminUser = {
    // From Entity
    id: 1,
    createdAt: "2024-01-15",
    
    // From User
    name: "Alice",
    email: "alice@example.com",
    
    // From PremiumUser
    subscriptionLevel: "platinum",
    expiresAt: "2025-01-15",
    
    // From AdminUser
    permissions: ["read", "write", "delete"],
    canDeleteUsers: true
};
</code></pre>

                <div class="mermaid">
                    graph TD
                        A[Entity<br/>id, createdAt] --> B[User<br/>+ name, email]
                        B --> C[PremiumUser<br/>+ subscription, expiresAt]
                        C --> D[AdminUser<br/>+ permissions, canDelete]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style B fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                        style C fill:#f093fb,stroke:#333,stroke-width:2px,color:#fff
                        style D fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>Real-World Pattern: Base Entity</h3>
                <p>A common pattern is creating a base entity that all database models extend:</p>

                <pre><code class="language-typescript">// Base entity all database records share
interface BaseEntity {
    readonly id: number;
    readonly createdAt: string;
    readonly updatedAt: string;
    isDeleted: boolean;
}

// Specific entities extend the base
interface User extends BaseEntity {
    name: string;
    email: string;
    passwordHash: string;
}

interface Product extends BaseEntity {
    name: string;
    price: number;
    sku: string;
    inStock: boolean;
}

interface Order extends BaseEntity {
    userId: number;
    productIds: number[];
    totalAmount: number;
    status: "pending" | "shipped" | "delivered";
}

// All entities have id, createdAt, updatedAt, isDeleted automatically!
const user: User = {
    id: 1,
    createdAt: "2024-01-15",
    updatedAt: "2024-01-15",
    isDeleted: false,
    name: "Alice",
    email: "alice@example.com",
    passwordHash: "hashed-password"
};
</code></pre>

                <h3>Combining Extension with Type Aliases</h3>
                <p>You can extend interfaces using type aliases with intersections:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
}

// Type alias extending interface
type AdminUser = User & {
    permissions: string[];
    role: "admin";
};

const admin: AdminUser = {
    id: 1,
    name: "Alice",
    permissions: ["read", "write", "delete"],
    role: "admin"
};

// You can also extend interface with type
interface PremiumUser extends User {
    subscriptionLevel: "gold" | "platinum";
}

// And mix them!
type SuperAdmin = AdminUser & PremiumUser & {
    canAccessBilling: boolean;
};
</code></pre>

                <blockquote>
                    <strong>üí° Best Practice:</strong> Use extension to create clear hierarchies. Start with general interfaces and extend them to create more specific ones. This makes your code easier to understand and maintain!
                </blockquote>
            </section>
            <!-- Section 7: Index Signatures -->
            <section id="section7" class="lesson-section">
                <h2>Index Signatures</h2>
                
                <p>Sometimes you don't know all the property names in advance. Maybe you're working with a dictionary, a cache, or dynamic data from an API. Index signatures let you describe objects with dynamic keys! üîë</p>

                <h3>What Are Index Signatures?</h3>
                <p>An index signature tells TypeScript: "This object can have any number of properties with keys of this type and values of that type." It's like saying "a dictionary where keys are strings and values are numbers."</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üìñ Definition</h3>
                    <p style="color: white;"><strong>Index Signature:</strong> A way to describe objects with dynamic property names. It specifies the type of keys and the type of values for properties that aren't explicitly defined.</p>
                </div>

                <h3>Basic Index Signature Syntax</h3>
                <pre><code class="language-typescript">// String keys, number values
interface NumberDictionary {
    [key: string]: number;
}

const ages: NumberDictionary = {
    alice: 30,
    bob: 25,
    charlie: 35
};

// Add more properties dynamically
ages.diana = 28;        // ‚úÖ OK
ages.eve = 32;          // ‚úÖ OK

// Access dynamically
console.log(ages["alice"]);    // 30
console.log(ages.bob);         // 25

// Type checking still works!
// ages.frank = "thirty";      // ‚ùå Error! Must be a number
</code></pre>

                <h3>Different Key Types</h3>
                <p>Index signatures can use string, number, or symbol as key types:</p>

                <pre><code class="language-typescript">// String keys
interface StringIndex {
    [key: string]: string;
}

const stringDict: StringIndex = {
    name: "Alice",
    city: "New York",
    country: "USA"
};

// Number keys (array-like)
interface NumberIndex {
    [index: number]: string;
}

const numberDict: NumberIndex = {
    0: "first",
    1: "second",
    2: "third"
};

console.log(numberDict[0]);  // "first"
console.log(numberDict[1]);  // "second"

// Note: number keys are actually converted to strings in JavaScript!
// So [key: string] will also match number keys
</code></pre>

                <h3>Mixing Index Signatures with Known Properties</h3>
                <p>You can have both specific properties and an index signature:</p>

                <pre><code class="language-typescript">interface UserCache {
    // Known properties
    count: number;
    maxSize: number;
    
    // Dynamic properties (user IDs)
    [userId: string]: number | string;  // Must include types of known properties!
}

const cache: UserCache = {
    count: 3,
    maxSize: 100,
    
    // Dynamic user IDs
    "user_123": 25,
    "user_456": 30,
    "user_789": 35
};

console.log(cache.count);       // 3
console.log(cache["user_123"]); // 25
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Rule</h4>
                    <p>When mixing known properties with index signatures, the index signature type must include the types of all known properties. In the example above, <code>[userId: string]: number | string</code> includes both <code>number</code> (for count and maxSize) and <code>string</code>.</p>
                </div>

                <h3>Readonly Index Signatures</h3>
                <p>Make dynamic properties read-only:</p>

                <pre><code class="language-typescript">interface ReadonlyCache {
    readonly [key: string]: number;
}

const cache: ReadonlyCache = {
    user1: 100,
    user2: 200
};

console.log(cache.user1);  // 100

// Can't modify!
// cache.user1 = 150;         // ‚ùå Error! Index signature is readonly
// cache.user3 = 300;         // ‚ùå Error! Index signature is readonly
</code></pre>

                <h3>Real-World Examples</h3>

                <h4>Example 1: Configuration Object</h4>
                <pre><code class="language-typescript">interface AppConfig {
    // Core settings (always present)
    appName: string;
    version: string;
    
    // Feature flags (dynamic)
    [featureFlag: string]: boolean | string | number;
}

const config: AppConfig = {
    appName: "MyApp",
    version: "1.0.0",
    
    // Dynamic feature flags
    enableDarkMode: true,
    maxUploadSize: 5000000,
    apiEndpoint: "https://api.example.com"
};
</code></pre>

                <h4>Example 2: API Response with Metadata</h4>
                <pre><code class="language-typescript">interface ApiResponse<T> {
    data: T;
    status: number;
    timestamp: string;
    
    // Additional metadata (unknown in advance)
    [metadata: string]: any;
}

const response: ApiResponse<User[]> = {
    data: [
        { id: 1, name: "Alice", email: "alice@example.com" }
    ],
    status: 200,
    timestamp: "2024-01-15T10:30:00Z",
    
    // Dynamic metadata
    requestId: "req_123456",
    serverRegion: "us-east-1",
    processingTime: 45
};
</code></pre>

                <h4>Example 3: Translation Dictionary</h4>
                <pre><code class="language-typescript">interface Translations {
    // Known translations
    welcome: string;
    goodbye: string;
    
    // Any other translation keys
    [key: string]: string;
}

const englishTranslations: Translations = {
    welcome: "Welcome",
    goodbye: "Goodbye",
    
    // Dynamic translations
    hello: "Hello",
    thankyou: "Thank you",
    yes: "Yes",
    no: "No"
};

const spanishTranslations: Translations = {
    welcome: "Bienvenido",
    goodbye: "Adi√≥s",
    hello: "Hola",
    thankyou: "Gracias",
    yes: "S√≠",
    no: "No"
};

// Function that works with any translation object
function translate(key: string, translations: Translations): string {
    return translations[key] || key;  // Return key if translation missing
}

console.log(translate("hello", englishTranslations));  // "Hello"
console.log(translate("hello", spanishTranslations));  // "Hola"
</code></pre>

                <h3>Record Utility Type (Alternative)</h3>
                <p>TypeScript provides a built-in <code>Record</code> utility type that's often clearer than index signatures:</p>

                <pre><code class="language-typescript">// Using index signature
interface UserAges {
    [username: string]: number;
}

// Using Record (equivalent and more readable)
type UserAges2 = Record<string, number>;

// Both work the same way
const ages1: UserAges = {
    alice: 30,
    bob: 25
};

const ages2: UserAges2 = {
    charlie: 35,
    diana: 28
};

// Record is especially useful with literal types
type UserRole = "admin" | "editor" | "viewer";
type Permissions = Record<UserRole, string[]>;

const permissions: Permissions = {
    admin: ["read", "write", "delete"],
    editor: ["read", "write"],
    viewer: ["read"]
};
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Index Signatures vs Record</h4>
                    <ul>
                        <li><strong>Index signatures:</strong> When you need to mix known properties with dynamic ones</li>
                        <li><strong>Record:</strong> When all properties are dynamic and have the same type</li>
                    </ul>
                    <pre><code class="language-typescript">// Mix known + dynamic: use index signature
interface Config {
    version: string;
    [key: string]: string | number;
}

// All dynamic: use Record
type Cache = Record<string, number>;
</code></pre>
                </div>

                <h3>Index Signature Limitations</h3>
                <p>Index signatures have some important limitations to be aware of:</p>

                <pre><code class="language-typescript">interface Dictionary {
    [key: string]: number;
}

const dict: Dictionary = {
    a: 1,
    b: 2
};

// ‚ö†Ô∏è Accessing a missing property doesn't error!
console.log(dict.c);  // undefined (no TypeScript error)

// This is by design - index signatures assume any string key is valid
// To be safe, check if the property exists
if ("c" in dict) {
    console.log(dict.c);
}

// Or use optional chaining
console.log(dict["c"] ?? "default");
</code></pre>

                <blockquote>
                    <strong>üí° Best Practice:</strong> Use index signatures when you genuinely need dynamic keys. For known, fixed properties, always declare them explicitly - it's safer and more maintainable!
                </blockquote>

                <div class="mermaid">
                    graph TD
                        A[Dynamic Properties] --> B{Known Keys?}
                        B -->|Yes| C[Explicit Properties]
                        B -->|No| D{Mix of both?}
                        D -->|Yes| E[Index Signature<br/>+ Known Properties]
                        D -->|No| F[Record Utility Type]
                        
                        C --> C1[interface User &#123;<br/>  name: string;<br/>  age: number;<br/>&#125;]
                        E --> E1[interface Config &#123;<br/>  version: string;<br/>  [key: string]: any;<br/>&#125;]
                        F --> F1[type Cache = <br/>Record&lt;string, number&gt;]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style C1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style E1 fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                        style F1 fill:#FF9800,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 8: Hands-on Practice -->
            <section id="section8" class="lesson-section">
                <h2>Hands-on Practice: User Management System</h2>
                
                <p>Time to combine everything we've learned! We'll build a complete user management system using interfaces, type aliases, extensions, and index signatures. This is real-world code you'd see in production! üöÄ</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Project Goal</h3>
                    <p style="color: white;">Create a type-safe user management system with roles, permissions, authentication, and activity tracking. We'll use all the concepts from this lesson!</p>
                </div>

                <h3>Step 1: Define Base Types and Interfaces</h3>
                <pre><code class="language-typescript">// Type aliases for common types
type UserId = string;
type Timestamp = string;
type UserRole = "admin" | "moderator" | "user" | "guest";
type PermissionAction = "read" | "write" | "delete" | "manage";

// Base entity that all database records share
interface BaseEntity {
    readonly id: string;
    readonly createdAt: Timestamp;
    readonly updatedAt: Timestamp;
}

// User profile information
interface UserProfile {
    firstName: string;
    lastName: string;
    avatar?: string;
    bio?: string;
    website?: string;
}

// User contact information
interface ContactInfo {
    email: string;
    phone?: string;
    address?: {
        street: string;
        city: string;
        state: string;
        zipCode: string;
        country: string;
    };
}

// User preferences
interface UserPreferences {
    theme: "light" | "dark" | "auto";
    language: string;
    notifications: {
        email: boolean;
        push: boolean;
        sms: boolean;
    };
    privacy: {
        profileVisible: boolean;
        showEmail: boolean;
        showPhone: boolean;
    };
}
</code></pre>

                <h3>Step 2: Create the Main User Interface</h3>
                <pre><code class="language-typescript">// Main user interface combining all pieces
interface User extends BaseEntity {
    username: string;
    passwordHash: string;
    role: UserRole;
    profile: UserProfile;
    contact: ContactInfo;
    preferences: UserPreferences;
    isActive: boolean;
    isVerified: boolean;
    lastLoginAt?: Timestamp;
}

// Admin user with additional capabilities
interface AdminUser extends User {
    role: "admin";  // More specific!
    permissions: PermissionAction[];
    canAccessAdminPanel: boolean;
    managedUserIds: UserId[];
}

// Guest user (limited capabilities)
interface GuestUser extends Omit<User, "passwordHash" | "preferences"> {
    role: "guest";
    sessionId: string;
    expiresAt: Timestamp;
}
</code></pre>

                <h3>Step 3: Create Activity Tracking</h3>
                <pre><code class="language-typescript">// Activity log entry
interface ActivityLog extends BaseEntity {
    userId: UserId;
    action: string;
    resource: string;
    metadata: Record<string, any>;  // Dynamic metadata
    ipAddress: string;
    userAgent: string;
}

// User with activity tracking
interface UserWithActivity extends User {
    activityLog: ActivityLog[];
    
    // Method to log activity
    logActivity(action: string, resource: string, metadata?: Record<string, any>): void;
}
</code></pre>

                <h3>Step 4: Implement the User Management Class</h3>
                <pre><code class="language-typescript">class UserManager {
    // Store users with dynamic keys (userId -> User)
    private users: Record<UserId, User> = {};
    private activities: Record<UserId, ActivityLog[]> = {};
    
    // Create a new user
    createUser(userData: Omit<User, keyof BaseEntity>): User {
        const user: User = {
            id: `user_${Date.now()}`,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            ...userData
        };
        
        this.users[user.id] = user;
        this.logActivity(user.id, "user_created", "users", { username: user.username });
        
        return user;
    }
    
    // Get user by ID
    getUser(userId: UserId): User | undefined {
        return this.users[userId];
    }
    
    // Get users by role
    getUsersByRole(role: UserRole): User[] {
        return Object.values(this.users).filter(user => user.role === role);
    }
    
    // Update user
    updateUser(userId: UserId, updates: Partial<User>): User | null {
        const user = this.users[userId];
        
        if (!user) {
            return null;
        }
        
        const updatedUser: User = {
            ...user,
            ...updates,
            id: user.id,  // Can't change ID
            createdAt: user.createdAt,  // Can't change creation date
            updatedAt: new Date().toISOString()
        };
        
        this.users[userId] = updatedUser;
        this.logActivity(userId, "user_updated", "users", updates);
        
        return updatedUser;
    }
    
    // Promote user to admin
    promoteToAdmin(userId: UserId, permissions: PermissionAction[]): AdminUser | null {
        const user = this.users[userId];
        
        if (!user || user.role === "admin") {
            return null;
        }
        
        const adminUser: AdminUser = {
            ...user,
            role: "admin",
            permissions,
            canAccessAdminPanel: true,
            managedUserIds: [],
            updatedAt: new Date().toISOString()
        };
        
        this.users[userId] = adminUser;
        this.logActivity(userId, "promoted_to_admin", "users", { permissions });
        
        return adminUser;
    }
    
    // Log user activity
    logActivity(
        userId: UserId,
        action: string,
        resource: string,
        metadata: Record<string, any> = {}
    ): void {
        const log: ActivityLog = {
            id: `log_${Date.now()}`,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            userId,
            action,
            resource,
            metadata,
            ipAddress: "127.0.0.1",
            userAgent: "TypeScript/5.0"
        };
        
        if (!this.activities[userId]) {
            this.activities[userId] = [];
        }
        
        this.activities[userId].push(log);
    }
    
    // Get user activity
    getUserActivity(userId: UserId): ActivityLog[] {
        return this.activities[userId] || [];
    }
    
    // Get all users
    getAllUsers(): User[] {
        return Object.values(this.users);
    }
    
    // Get statistics
    getStats(): {
        totalUsers: number;
        activeUsers: number;
        verifiedUsers: number;
        usersByRole: Record<UserRole, number>;
    } {
        const users = this.getAllUsers();
        
        return {
            totalUsers: users.length,
            activeUsers: users.filter(u => u.isActive).length,
            verifiedUsers: users.filter(u => u.isVerified).length,
            usersByRole: {
                admin: users.filter(u => u.role === "admin").length,
                moderator: users.filter(u => u.role === "moderator").length,
                user: users.filter(u => u.role === "user").length,
                guest: users.filter(u => u.role === "guest").length
            }
        };
    }
}
</code></pre>

                <h3>Step 5: Use the System</h3>
                <pre><code class="language-typescript">// Create the user manager
const userManager = new UserManager();

// Create a regular user
const alice = userManager.createUser({
    username: "alice",
    passwordHash: "hashed_password_123",
    role: "user",
    profile: {
        firstName: "Alice",
        lastName: "Smith",
        bio: "Software developer"
    },
    contact: {
        email: "alice@example.com",
        phone: "555-1234"
    },
    preferences: {
        theme: "dark",
        language: "en",
        notifications: {
            email: true,
            push: true,
            sms: false
        },
        privacy: {
            profileVisible: true,
            showEmail: false,
            showPhone: false
        }
    },
    isActive: true,
    isVerified: true
});

console.log("Created user:", alice.username);

// Update user
const updatedAlice = userManager.updateUser(alice.id, {
    profile: {
        ...alice.profile,
        bio: "Senior software developer"
    }
});

// Promote to admin
const adminAlice = userManager.promoteToAdmin(alice.id, ["read", "write", "delete", "manage"]);

if (adminAlice) {
    console.log(`${adminAlice.username} is now an admin with permissions:`, adminAlice.permissions);
}

// Create more users
userManager.createUser({
    username: "bob",
    passwordHash: "hashed_password_456",
    role: "moderator",
    profile: { firstName: "Bob", lastName: "Jones" },
    contact: { email: "bob@example.com" },
    preferences: {
        theme: "light",
        language: "en",
        notifications: { email: true, push: false, sms: false },
        privacy: { profileVisible: true, showEmail: true, showPhone: false }
    },
    isActive: true,
    isVerified: true
});

// Get statistics
const stats = userManager.getStats();
console.log("User Statistics:", stats);

// Get activity log
const aliceActivity = userManager.getUserActivity(alice.id);
console.log(`Alice's activity (${aliceActivity.length} entries):`, aliceActivity);
</code></pre>

                <div class="card" style="background-color: #f0f0f0; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Console Output:</h4>
                    <pre><code>Created user: alice
alice is now an admin with permissions: ["read", "write", "delete", "manage"]
User Statistics: {
  totalUsers: 2,
  activeUsers: 2,
  verifiedUsers: 2,
  usersByRole: { admin: 1, moderator: 1, user: 0, guest: 0 }
}
Alice's activity (3 entries): [...]
</code></pre>
                </div>

                <h3>Your Challenge: Extend the System</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üèãÔ∏è Exercise: Add Team Management</h4>
                    <p><strong>Challenge:</strong> Create interfaces and methods to manage teams of users.</p>
                    <ol>
                        <li>Create a <code>Team</code> interface with properties: id, name, memberIds, ownerId, createdAt</li>
                        <li>Add methods to UserManager: <code>createTeam</code>, <code>addUserToTeam</code>, <code>removeUserFromTeam</code></li>
                        <li>Create a <code>TeamMember</code> interface that extends <code>User</code> with team-specific properties</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Think about using:</p>
                        <ul>
                            <li>A <code>Record&lt;TeamId, Team&gt;</code> to store teams</li>
                            <li>Interface extension for <code>TeamMember extends User</code></li>
                            <li>Index signatures for flexible team metadata</li>
                        </ul>
                    </details>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Excellent Work!</h3>
                    <p style="color: white; margin: 0;">You've built a production-quality user management system using interfaces, type aliases, extensions, and all the concepts from this lesson. This is exactly the kind of code you'll write in real applications! üöÄ</p>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" class="lesson-section">
                <h2>Best Practices</h2>
                
                <p>You've learned a lot! Now let's solidify that knowledge with the best practices that will make you a TypeScript pro. üåü</p>

                <h3>‚úÖ Do's: Good Interface Habits</h3>

                <h4>1. Use Clear, Descriptive Names</h4>
                <pre><code class="language-typescript">// ‚ùå Vague
interface Data {
    info: string;
    val: number;
}

// ‚úÖ Clear
interface UserProfile {
    username: string;
    age: number;
}
</code></pre>

                <h4>2. Keep Interfaces Focused and Small</h4>
                <pre><code class="language-typescript">// ‚ùå God interface - too much in one place
interface User {
    // Identity
    id: number;
    username: string;
    
    // Contact
    email: string;
    phone: string;
    
    // Preferences
    theme: string;
    language: string;
    
    // ... 50 more properties
}

// ‚úÖ Composed interfaces - single responsibility
interface UserIdentity {
    id: number;
    username: string;
}

interface UserContact {
    email: string;
    phone?: string;
}

interface UserPreferences {
    theme: string;
    language: string;
}

interface User extends UserIdentity, UserContact {
    preferences: UserPreferences;
}
</code></pre>

                <h4>3. Use Readonly for Immutable Properties</h4>
                <pre><code class="language-typescript">// ‚úÖ Good: ID and timestamps should never change
interface Entity {
    readonly id: string;
    readonly createdAt: string;
    name: string;  // Can be updated
}
</code></pre>

                <h4>4. Make Optional Properties Truly Optional</h4>
                <pre><code class="language-typescript">// ‚ùå Everything optional - too permissive
interface User {
    id?: number;
    name?: string;
    email?: string;
}

// ‚úÖ Only truly optional things are optional
interface User {
    id: number;           // Always required
    name: string;         // Always required
    email: string;        // Always required
    phone?: string;       // Truly optional
    middleName?: string;  // Truly optional
}
</code></pre>

                <h4>5. Document Complex Interfaces</h4>
                <pre><code class="language-typescript">/**
 * Represents a user in the system
 * @property id - Unique identifier (immutable)
 * @property role - User's permission level
 * @property lastLoginAt - ISO timestamp of last login (undefined if never logged in)
 */
interface User {
    readonly id: number;
    name: string;
    role: "admin" | "user";
    lastLoginAt?: string;
}
</code></pre>

                <h3>‚ùå Don'ts: Common Mistakes</h3>

                <h4>1. Don't Use any in Interfaces</h4>
                <pre><code class="language-typescript">// ‚ùå Defeats the purpose
interface User {
    id: number;
    data: any;  // What is this? Who knows!
}

// ‚úÖ Be specific
interface User {
    id: number;
    metadata: Record<string, string | number>;
}
</code></pre>

                <h4>2. Don't Create Overly Nested Structures</h4>
                <pre><code class="language-typescript">// ‚ùå Too nested - hard to work with
interface User {
    profile: {
        personal: {
            name: {
                first: string;
                middle?: string;
                last: string;
            };
        };
    };
}

// ‚úÖ Flatten or extract interfaces
interface FullName {
    first: string;
    middle?: string;
    last: string;
}

interface User {
    name: FullName;
    // Other flat properties
}
</code></pre>

                <h4>3. Don't Mix Interfaces and Types Inconsistently</h4>
                <pre><code class="language-typescript">// ‚ùå Inconsistent
interface User { }      // Using interface
type Admin = { };       // Using type
interface Moderator { } // Back to interface

// ‚úÖ Consistent pattern
interface User { }
interface Admin extends User { }
interface Moderator extends User { }

// Or use types consistently
type User = { };
type Admin = User & { };
type Moderator = User & { };
</code></pre>

                <h3>üí° Pro Tips</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 1: Use Utility Types</h4>
                    <p>TypeScript provides built-in utility types - use them!</p>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    password: string;
}

// Pick only certain properties
type PublicUser = Pick<User, "id" | "name">;

// Omit sensitive properties
type SafeUser = Omit<User, "password">;

// Make all properties optional
type UserUpdate = Partial<User>;

// Make all properties required
type CompleteUser = Required<User>;
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 2: Leverage Type Guards</h4>
                    <pre><code class="language-typescript">interface Admin {
    role: "admin";
    permissions: string[];
}

interface User {
    role: "user";
    name: string;
}

// Type guard function
function isAdmin(user: Admin | User): user is Admin {
    return user.role === "admin";
}

function handleUser(user: Admin | User) {
    if (isAdmin(user)) {
        // TypeScript knows user is Admin here
        console.log(user.permissions);
    }
}
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 3: Use Discriminated Unions</h4>
                    <pre><code class="language-typescript">// Each type has a unique discriminator
interface Success {
    status: "success";
    data: any;
}

interface Error {
    status: "error";
    message: string;
}

interface Loading {
    status: "loading";
}

type State = Success | Error | Loading;

function handleState(state: State) {
    // TypeScript narrows the type based on status
    switch (state.status) {
        case "success":
            console.log(state.data);     // TypeScript knows data exists
            break;
        case "error":
            console.log(state.message);   // TypeScript knows message exists
            break;
        case "loading":
            console.log("Loading...");    // No additional properties
            break;
    }
}
</code></pre>
                </div>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" class="lesson-section">
                <h2>Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Interfaces</strong> define the structure of objects - they're like blueprints</li>
                        <li><strong>Type aliases</strong> can represent any type - primitives, unions, tuples, objects</li>
                        <li><strong>Optional properties (?)</strong> may or may not be present</li>
                        <li><strong>Readonly properties</strong> cannot be changed after initialization</li>
                        <li><strong>Interfaces can extend</strong> other interfaces, building hierarchies</li>
                        <li><strong>Type aliases use intersection (&)</strong> to combine types</li>
                        <li><strong>Index signatures</strong> allow dynamic property names</li>
                        <li><strong>Declaration merging</strong> works with interfaces, not type aliases</li>
                        <li><strong>Use interfaces for objects</strong>, type aliases for unions/tuples</li>
                        <li><strong>Keep interfaces focused</strong> - single responsibility principle applies!</li>
                    </ul>
                </div>

                <h3>Quick Reference Table</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Syntax</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Basic Interface</td>
                            <td><code>interface User { name: string }</code></td>
                            <td>Define object structure</td>
                        </tr>
                        <tr>
                            <td>Optional Property</td>
                            <td><code>age?: number</code></td>
                            <td>Property may be absent</td>
                        </tr>
                        <tr>
                            <td>Readonly Property</td>
                            <td><code>readonly id: number</code></td>
                            <td>Immutable property</td>
                        </tr>
                        <tr>
                            <td>Type Alias</td>
                            <td><code>type ID = string | number</code></td>
                            <td>Name for any type</td>
                        </tr>
                        <tr>
                            <td>Interface Extension</td>
                            <td><code>interface Admin extends User</code></td>
                            <td>Inherit properties</td>
                        </tr>
                        <tr>
                            <td>Type Intersection</td>
                            <td><code>type Admin = User & { ... }</code></td>
                            <td>Combine types</td>
                        </tr>
                        <tr>
                            <td>Index Signature</td>
                            <td><code>[key: string]: number</code></td>
                            <td>Dynamic properties</td>
                        </tr>
                        <tr>
                            <td>Record Type</td>
                            <td><code>Record&lt;string, number&gt;</code></td>
                            <td>Object with dynamic keys</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Decision Tree</h3>
                <div class="mermaid">
                    graph TD
                        A[Need to Define a Type] --> B{What are you defining?}
                        B -->|Object Shape| C{Need Declaration Merging?}
                        B -->|Union/Tuple| D[Use Type Alias]
                        B -->|Primitive| D
                        
                        C -->|Yes| E[Use Interface]
                        C -->|No| F{Personal Preference}
                        F -->|Interface| E
                        F -->|Type| D
                        
                        style E fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style D fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/objects.html" target="_blank">TypeScript Handbook: Object Types</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#interfaces" target="_blank">TypeScript Handbook: Interfaces</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases" target="_blank">TypeScript Handbook: Type Aliases</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">TypeScript Utility Types</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>Functions in TypeScript</strong>. You'll learn how to:</p>
                <ul>
                    <li>Type function parameters and return values</li>
                    <li>Use optional and default parameters</li>
                    <li>Work with rest parameters</li>
                    <li>Create function overloads</li>
                    <li>Use generic functions for flexibility</li>
                </ul>

                <p>Functions are the workhorses of any application - let's make them type-safe! üí™</p>

                <h3>Quick Quiz</h3>
                <div class="card quiz-container">
                    <h4>üéØ Test Your Knowledge</h4>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What's the main difference between <code>interface</code> and <code>type</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Actually, both can describe objects!">
                                A) Interfaces can't describe objects
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Interfaces support declaration merging and can only describe objects. Type aliases can represent any type including unions and tuples.">
                                B) Interfaces support declaration merging, type aliases can represent unions/tuples
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Both are compiled away">
                                C) Type aliases exist at runtime
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> When should you use <code>readonly</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="That would be too restrictive">
                                A) For all properties
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Use readonly for properties that should never change after creation, like IDs and timestamps.">
                                B) For properties that shouldn't change after creation (IDs, timestamps)
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Readonly has important uses!">
                                C) Never, it's not useful
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> What does an index signature <code>[key: string]: number</code> mean?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly! The object can have any string keys, and all values must be numbers.">
                                A) Object can have any string keys with number values
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="It's the opposite - string keys, number values">
                                B) Object has number keys with string values
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Keys must be strings in this case">
                                C) Object must have exactly one key
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Fantastic Progress!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've mastered interfaces and type aliases! You can now create complex, maintainable type structures for real-world applications. These skills are the foundation of professional TypeScript development.</p>
                    <p style="color: white; font-size: 1.1rem; margin: 0;">Keep up the amazing work - you're becoming a TypeScript expert! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_1_2_basic_types_part_c.html" class="prev-lesson">‚Üê Previous: Basic Types</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_1_4_functions_in_typescript.html" class="next-lesson">Next: Functions in TypeScript ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce - React TypeScript Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build better applications with TypeScript and React.</p>
        <p style="margin-top: 1rem; font-size: 0.9rem;">
            <a href="index.html" style="color: white; text-decoration: underline;">Course Home</a> | 
            <a href="index.html#modules" style="color: white; text-decoration: underline;">All Modules</a> | 
            <a href="#main-content" style="color: white; text-decoration: underline;">Back to Top ‚Üë</a>
        </p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
