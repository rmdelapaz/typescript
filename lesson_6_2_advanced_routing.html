<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master advanced React Router concepts including nested routes, dynamic parameters, programmatic navigation, and the useParams, useNavigate, and useLocation hooks">
    <meta name="author" content="React TypeScript Course">
    <title>Lesson 6.2: Advanced Routing - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module6">Module 6: Routing and Navigation</a></li>
            <li aria-current="page">Lesson 6.2: Advanced Routing</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üöÄ Lesson 6.2: Advanced Routing</h1>
                <p class="lead">Take your React Router skills to the next level with nested routes, dynamic parameters, and programmatic navigation. Build complex, scalable routing architectures for real-world applications.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Create and manage nested routes with shared layouts</li>
                        <li>Use dynamic route parameters with useParams hook</li>
                        <li>Navigate programmatically using the useNavigate hook</li>
                        <li>Access location data with useLocation hook</li>
                        <li>Build complex multi-level navigation structures</li>
                        <li>Implement parent-child route relationships</li>
                        <li>Type dynamic routes properly with TypeScript</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Prerequisites:</strong> Lesson 6.1 - React Router Basics</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding Nested Routes</a></li>
                        <li><a href="#section2" class="toc-link">Dynamic Route Parameters</a></li>
                        <li><a href="#section3" class="toc-link">The useParams Hook</a></li>
                        <li><a href="#section4" class="toc-link">Programmatic Navigation with useNavigate</a></li>
                        <li><a href="#section5" class="toc-link">The useLocation Hook</a></li>
                        <li><a href="#section6" class="toc-link">Building a Blog with Advanced Routing</a></li>
                        <li><a href="#section7" class="toc-link">Advanced Patterns and Techniques</a></li>
                        <li><a href="#section8" class="toc-link">Summary and Next Steps</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Nested Routes -->
            <section id="section1" class="lesson-section">
                <h2>üóÇÔ∏è Understanding Nested Routes</h2>
                <p>Nested routes allow you to create complex layouts where some UI remains consistent while other parts change based on the route. This is perfect for dashboards, settings pages, and any application with shared layouts.</p>

                <h3>What Are Nested Routes?</h3>
                <p>Nested routes are routes defined inside other routes, creating a parent-child relationship. The parent route can have a layout that wraps all child routes.</p>

                <div class="mermaid">
                flowchart TD
                    A[App Layout] --> B[Dashboard Layout]
                    B --> C[Overview Page]
                    B --> D[Analytics Page]
                    B --> E[Settings Page]
                    
                    F[App Layout] --> G[Blog Layout]
                    G --> H[Post List]
                    G --> I[Post Detail]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#48bb78,color:#fff
                    style G fill:#48bb78,color:#fff
                </div>

                <h3>Why Use Nested Routes?</h3>
                <ul>
                    <li>üé® <strong>Shared Layouts:</strong> Common UI elements (sidebars, headers) persist across child routes</li>
                    <li>üìê <strong>Logical Organization:</strong> Group related routes together</li>
                    <li>üîÑ <strong>Partial Updates:</strong> Only the nested content re-renders, not the entire page</li>
                    <li>üóÇÔ∏è <strong>Better Structure:</strong> Mirror your URL structure in your component hierarchy</li>
                    <li>‚ö° <strong>Performance:</strong> Shared layouts don't unmount/remount</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Real-World Example</h4>
                    <p style="color: white;">Think of a dashboard at <code>/dashboard</code>. The sidebar and header stay the same, but when you navigate to <code>/dashboard/analytics</code> or <code>/dashboard/settings</code>, only the main content area changes. That's nested routing!</p>
                </div>

                <h3>The Outlet Component</h3>
                <p>The key to nested routes is the <code>Outlet</code> component. It acts as a placeholder where child routes will be rendered.</p>

                <pre><code class="language-typescript">import { Outlet } from 'react-router-dom';

function DashboardLayout() {
  return (
    &lt;div className="dashboard"&gt;
      &lt;aside className="sidebar"&gt;
        &lt;nav&gt;
          &lt;Link to="/dashboard"&gt;Overview&lt;/Link&gt;
          &lt;Link to="/dashboard/analytics"&gt;Analytics&lt;/Link&gt;
          &lt;Link to="/dashboard/settings"&gt;Settings&lt;/Link&gt;
        &lt;/nav&gt;
      &lt;/aside&gt;
      
      &lt;main className="dashboard-content"&gt;
        {/* Child routes render here! */}
        &lt;Outlet /&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° How Outlet Works</h4>
                    <p>When you navigate to a child route, React Router renders the parent component and replaces the <code>&lt;Outlet /&gt;</code> with the child route's component. The rest of the parent layout stays in place.</p>
                </div>

                <h3>Creating Nested Routes</h3>
                <p>There are two ways to define nested routes in React Router v6:</p>

                <h4>Method 1: Route Nesting in JSX</h4>
                <pre><code class="language-typescript">import { Routes, Route } from 'react-router-dom';
import DashboardLayout from './layouts/DashboardLayout';
import Overview from './pages/dashboard/Overview';
import Analytics from './pages/dashboard/Analytics';
import Settings from './pages/dashboard/Settings';

function App() {
  return (
    &lt;Routes&gt;
      {/* Parent route with nested children */}
      &lt;Route path="/dashboard" element={&lt;DashboardLayout /&gt;}&gt;
        {/* Child routes */}
        &lt;Route index element={&lt;Overview /&gt;} /&gt;
        &lt;Route path="analytics" element={&lt;Analytics /&gt;} /&gt;
        &lt;Route path="settings" element={&lt;Settings /&gt;} /&gt;
      &lt;/Route&gt;
    &lt;/Routes&gt;
  );
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Understanding the Routes</h4>
                    <ul style="color: white;">
                        <li><code>&lt;Route index&gt;</code>: Renders at <code>/dashboard</code> (matches parent exactly)</li>
                        <li><code>path="analytics"</code>: Renders at <code>/dashboard/analytics</code> (relative path)</li>
                        <li><code>path="settings"</code>: Renders at <code>/dashboard/settings</code></li>
                    </ul>
                    <p style="color: white;">Notice that child paths are <strong>relative</strong> to the parent path!</p>
                </div>

                <h4>Method 2: Route Configuration Object</h4>
                <pre><code class="language-typescript">import { useRoutes } from 'react-router-dom';
import DashboardLayout from './layouts/DashboardLayout';
import Overview from './pages/dashboard/Overview';
import Analytics from './pages/dashboard/Analytics';
import Settings from './pages/dashboard/Settings';

function App() {
  const routes = useRoutes([
    {
      path: '/dashboard',
      element: &lt;DashboardLayout /&gt;,
      children: [
        { index: true, element: &lt;Overview /&gt; },
        { path: 'analytics', element: &lt;Analytics /&gt; },
        { path: 'settings', element: &lt;Settings /&gt; }
      ]
    }
  ]);
  
  return routes;
}</code></pre>

                <h3>Index Routes Explained</h3>
                <p>An <code>index</code> route is a special type of child route that renders when the parent route matches exactly.</p>

                <pre><code class="language-typescript">// Without index route:
// /dashboard ‚Üí Shows DashboardLayout with empty Outlet
// /dashboard/analytics ‚Üí Shows Analytics in the Outlet

// With index route:
// /dashboard ‚Üí Shows DashboardLayout with Overview in the Outlet
// /dashboard/analytics ‚Üí Shows DashboardLayout with Analytics in the Outlet</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Index Route Best Practices</h4>
                    <ul>
                        <li>Use index routes for default content when visiting parent route</li>
                        <li>Common use cases: overview pages, home tabs, default views</li>
                        <li>Don't use a <code>path</code> prop on index routes (it's ignored)</li>
                        <li>Index routes inherit the parent's path exactly</li>
                    </ul>
                </div>

                <h3>Complete Example: Dashboard with Nested Routes</h3>
                <p>Let's build a complete dashboard with nested routes.</p>

                <p><strong>src/layouts/DashboardLayout.tsx:</strong></p>
                <pre><code class="language-typescript">import React from 'react';
import { Outlet, NavLink } from 'react-router-dom';
import './DashboardLayout.css';

function DashboardLayout() {
  const navLinks = [
    { to: '/dashboard', label: 'Overview', end: true },
    { to: '/dashboard/analytics', label: 'Analytics' },
    { to: '/dashboard/reports', label: 'Reports' },
    { to: '/dashboard/settings', label: 'Settings' }
  ];

  return (
    &lt;div className="dashboard-layout"&gt;
      {/* Sidebar Navigation */}
      &lt;aside className="dashboard-sidebar"&gt;
        &lt;div className="sidebar-header"&gt;
          &lt;h2&gt;üìä Dashboard&lt;/h2&gt;
        &lt;/div&gt;
        
        &lt;nav className="sidebar-nav"&gt;
          {navLinks.map(link => (
            &lt;NavLink
              key={link.to}
              to={link.to}
              end={link.end}
              className={({ isActive }) => 
                isActive ? 'nav-item nav-item-active' : 'nav-item'
              }
            &gt;
              {link.label}
            &lt;/NavLink&gt;
          ))}
        &lt;/nav&gt;
      &lt;/aside&gt;
      
      {/* Main Content Area */}
      &lt;main className="dashboard-main"&gt;
        &lt;div className="dashboard-container"&gt;
          {/* Child routes render here */}
          &lt;Outlet /&gt;
        &lt;/div&gt;
      &lt;/main&gt;
    &lt;/div&gt;
  );
}

export default DashboardLayout;</code></pre>

                <p><strong>src/pages/dashboard/Overview.tsx:</strong></p>
                <pre><code class="language-typescript">import React from 'react';

function Overview() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard Overview&lt;/h1&gt;
      &lt;p&gt;Welcome to your dashboard! Here's a summary of your account.&lt;/p&gt;
      
      &lt;div className="stats-grid"&gt;
        &lt;div className="stat-card"&gt;
          &lt;h3&gt;Total Users&lt;/h3&gt;
          &lt;p className="stat-value"&gt;1,234&lt;/p&gt;
        &lt;/div&gt;
        &lt;div className="stat-card"&gt;
          &lt;h3&gt;Revenue&lt;/h3&gt;
          &lt;p className="stat-value"&gt;$45,678&lt;/p&gt;
        &lt;/div&gt;
        &lt;div className="stat-card"&gt;
          &lt;h3&gt;Active Projects&lt;/h3&gt;
          &lt;p className="stat-value"&gt;23&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default Overview;</code></pre>

                <p><strong>src/pages/dashboard/Analytics.tsx:</strong></p>
                <pre><code class="language-typescript">import React from 'react';

function Analytics() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Analytics&lt;/h1&gt;
      &lt;p&gt;View detailed analytics and insights about your application.&lt;/p&gt;
      
      &lt;div className="charts"&gt;
        &lt;div className="chart-card"&gt;
          &lt;h3&gt;User Growth&lt;/h3&gt;
          &lt;p&gt;üìà Chart placeholder&lt;/p&gt;
        &lt;/div&gt;
        &lt;div className="chart-card"&gt;
          &lt;h3&gt;Revenue Trends&lt;/h3&gt;
          &lt;p&gt;üí∞ Chart placeholder&lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

export default Analytics;</code></pre>

                <p><strong>src/App.tsx:</strong></p>
                <pre><code class="language-typescript">import React from 'react';
import { Routes, Route } from 'react-router-dom';
import DashboardLayout from './layouts/DashboardLayout';
import Overview from './pages/dashboard/Overview';
import Analytics from './pages/dashboard/Analytics';
import Reports from './pages/dashboard/Reports';
import Settings from './pages/dashboard/Settings';
import Home from './pages/Home';
import NotFound from './pages/NotFound';

function App() {
  return (
    &lt;Routes&gt;
      {/* Regular routes */}
      &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
      
      {/* Nested dashboard routes */}
      &lt;Route path="/dashboard" element={&lt;DashboardLayout /&gt;}&gt;
        &lt;Route index element={&lt;Overview /&gt;} /&gt;
        &lt;Route path="analytics" element={&lt;Analytics /&gt;} /&gt;
        &lt;Route path="reports" element={&lt;Reports /&gt;} /&gt;
        &lt;Route path="settings" element={&lt;Settings /&gt;} /&gt;
      &lt;/Route&gt;
      
      {/* 404 */}
      &lt;Route path="*" element={&lt;NotFound /&gt;} /&gt;
    &lt;/Routes&gt;
  );
}

export default App;</code></pre>

                <h3>Styling the Dashboard</h3>
                <p>Create <code>src/layouts/DashboardLayout.css</code>:</p>

                <pre><code class="language-css">.dashboard-layout {
  display: flex;
  min-height: 100vh;
}

.dashboard-sidebar {
  width: 250px;
  background: #2d3748;
  color: white;
  display: flex;
  flex-direction: column;
}

.sidebar-header {
  padding: 1.5rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.sidebar-header h2 {
  margin: 0;
  font-size: 1.25rem;
}

.sidebar-nav {
  display: flex;
  flex-direction: column;
  padding: 1rem 0;
}

.nav-item {
  padding: 0.75rem 1.5rem;
  color: rgba(255, 255, 255, 0.7);
  text-decoration: none;
  transition: all 0.2s;
  border-left: 3px solid transparent;
}

.nav-item:hover {
  background: rgba(255, 255, 255, 0.05);
  color: white;
}

.nav-item-active {
  background: rgba(102, 126, 234, 0.1);
  color: white;
  border-left-color: #667eea;
}

.dashboard-main {
  flex: 1;
  background: #f7fafc;
  overflow-y: auto;
}

.dashboard-container {
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-top: 2rem;
}

.stat-card {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.stat-card h3 {
  margin: 0 0 0.5rem 0;
  font-size: 0.875rem;
  color: #718096;
  text-transform: uppercase;
}

.stat-value {
  margin: 0;
  font-size: 2rem;
  font-weight: bold;
  color: #667eea;
}

@media (max-width: 768px) {
  .dashboard-layout {
    flex-direction: column;
  }
  
  .dashboard-sidebar {
    width: 100%;
  }
  
  .sidebar-nav {
    flex-direction: row;
    overflow-x: auto;
  }
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise: Add More Dashboard Pages</h3>
                    <p>Add two more pages to the dashboard: "Users" and "Products". Create the page components and add them to the nested routes.</p>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create Users.tsx and Products.tsx in pages/dashboard/, then add Route components inside the dashboard parent route with paths "users" and "products".</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">// src/pages/dashboard/Users.tsx
function Users() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Users&lt;/h1&gt;
      &lt;p&gt;Manage your application users.&lt;/p&gt;
    &lt;/div&gt;
  );
}

// In App.tsx, add to dashboard routes:
&lt;Route path="users" element={&lt;Users /&gt;} /&gt;
&lt;Route path="products" element={&lt;Products /&gt;} /&gt;

// In DashboardLayout.tsx, add to navLinks:
{ to: '/dashboard/users', label: 'Users' },
{ to: '/dashboard/products', label: 'Products' }</code></pre>
                    </details>
                </div>

                <h3>Multiple Levels of Nesting</h3>
                <p>You can nest routes multiple levels deep:</p>

                <pre><code class="language-typescript">&lt;Routes&gt;
  &lt;Route path="/dashboard" element={&lt;DashboardLayout /&gt;}&gt;
    &lt;Route index element={&lt;Overview /&gt;} /&gt;
    
    {/* Settings has its own nested routes */}
    &lt;Route path="settings" element={&lt;SettingsLayout /&gt;}&gt;
      &lt;Route index element={&lt;GeneralSettings /&gt;} /&gt;
      &lt;Route path="profile" element={&lt;ProfileSettings /&gt;} /&gt;
      &lt;Route path="security" element={&lt;SecuritySettings /&gt;} /&gt;
    &lt;/Route&gt;
  &lt;/Route&gt;
&lt;/Routes&gt;

// URL structure:
// /dashboard/settings ‚Üí GeneralSettings
// /dashboard/settings/profile ‚Üí ProfileSettings
// /dashboard/settings/security ‚Üí SecuritySettings</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Nested Routes Recap</h4>
                    <ul>
                        <li>Parent routes render a layout with an <code>&lt;Outlet /&gt;</code></li>
                        <li>Child routes render inside the parent's Outlet</li>
                        <li>Index routes render at the parent's exact path</li>
                        <li>Child paths are relative to parent path</li>
                        <li>You can nest routes as many levels deep as needed</li>
                        <li>Shared UI stays mounted as you navigate between children</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Dynamic Route Parameters -->
            <section id="section2" class="lesson-section">
                <h2>üéØ Dynamic Route Parameters</h2>
                <p>Dynamic route parameters allow you to create flexible routes that match patterns instead of exact paths. This is essential for applications with user profiles, blog posts, product details, and more.</p>

                <h3>What Are Route Parameters?</h3>
                <p>Route parameters are variable parts of a URL path, denoted by a colon (<code>:</code>) prefix. They capture values from the URL and make them available in your components.</p>

                <pre><code class="language-typescript">// Static route (matches exactly one URL):
&lt;Route path="/users" element={&lt;UserList /&gt;} /&gt;
// Matches: /users

// Dynamic route (matches many URLs):
&lt;Route path="/users/:userId" element={&lt;UserProfile /&gt;} /&gt;
// Matches: /users/1, /users/123, /users/abc, etc.
// The userId part is captured as a parameter</code></pre>

                <div class="mermaid">
                flowchart LR
                    A[URL: /users/42] --> B[Route: /users/:userId]
                    B --> C[Captures: userId = 42]
                    C --> D[Renders: UserProfile with userId]
                    
                    style B fill:#667eea,color:#fff
                    style C fill:#48bb78,color:#fff
                </div>

                <h3>Defining Dynamic Routes</h3>
                <p>Dynamic routes are defined just like regular routes, but with parameter segments:</p>

                <pre><code class="language-typescript">import { Routes, Route } from 'react-router-dom';
import BlogList from './pages/BlogList';
import BlogPost from './pages/BlogPost';
import UserProfile from './pages/UserProfile';
import ProductDetail from './pages/ProductDetail';

function App() {
  return (
    &lt;Routes&gt;
      {/* Blog routes */}
      &lt;Route path="/blog" element={&lt;BlogList /&gt;} /&gt;
      &lt;Route path="/blog/:postId" element={&lt;BlogPost /&gt;} /&gt;
      
      {/* User routes */}
      &lt;Route path="/users/:userId" element={&lt;UserProfile /&gt;} /&gt;
      
      {/* Product routes */}
      &lt;Route path="/products/:productId" element={&lt;ProductDetail /&gt;} /&gt;
      
      {/* Multiple parameters */}
      &lt;Route path="/category/:categoryId/product/:productId" element={&lt;Product /&gt;} /&gt;
    &lt;/Routes&gt;
  );
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Parameter Naming</h4>
                    <p style="color: white;">Parameter names can be anything, but use descriptive names that make sense:</p>
                    <ul style="color: white;">
                        <li>‚úÖ <code>:userId</code>, <code>:postId</code>, <code>:productId</code></li>
                        <li>‚úÖ <code>:username</code>, <code>:slug</code>, <code>:id</code></li>
                        <li>‚ùå <code>:param</code>, <code>:x</code>, <code>:value</code> (too vague)</li>
                    </ul>
                </div>

                <h3>Multiple Parameters</h3>
                <p>Routes can have multiple parameters:</p>

                <pre><code class="language-typescript">// Two parameters in one route
&lt;Route path="/blog/:year/:month/:slug" element={&lt;BlogPost /&gt;} /&gt;
// Matches: /blog/2024/01/react-router-guide
// Captures: year=2024, month=01, slug=react-router-guide

// Nested segments
&lt;Route path="/store/:storeId/product/:productId" element={&lt;Product /&gt;} /&gt;
// Matches: /store/amazon/product/iphone-15
// Captures: storeId=amazon, productId=iphone-15</code></pre>

                <h3>Optional Parameters</h3>
                <p>Make a parameter optional by adding a question mark:</p>

                <pre><code class="language-typescript">// Optional page parameter
&lt;Route path="/blog/:category/:page?" element={&lt;BlogCategory /&gt;} /&gt;
// Matches: /blog/tech (page is undefined)
// Matches: /blog/tech/2 (page is "2")</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Optional Parameters Gotcha</h4>
                    <p>Optional parameters should come at the end of the route path. Putting them in the middle can lead to ambiguous route matching:</p>
                    <pre><code>// ‚ùå Confusing
/blog/:category?/:postId

// ‚úÖ Clear
/blog/:postId/:page?</code></pre>
                </div>

                <h3>Wildcard Parameters</h3>
                <p>Use an asterisk (<code>*</code>) to match remaining path segments:</p>

                <pre><code class="language-typescript">// Catch-all route
&lt;Route path="/docs/*" element={&lt;Documentation /&gt;} /&gt;
// Matches: /docs/getting-started
// Matches: /docs/api/components/button
// Matches: /docs/anything/here

// Named wildcard (React Router v6.4+)
&lt;Route path="/files/:filename/*" element={&lt;FileViewer /&gt;} /&gt;
// Matches: /files/document.pdf/preview
// Captures: filename=document.pdf, *=/preview</code></pre>

</section>

            <!-- Section 3: The useParams Hook -->
            <section id="section3" aria-labelledby="section3-title">
                <h2 id="section3-title">üéØ The useParams Hook</h2>
                <p>The <code>useParams</code> hook is how you access dynamic route parameters in your components. It returns an object containing all parameter values from the current URL.</p>

                <div class="mermaid">
                flowchart TD
                    A[URL: /users/42] --> B[React Router]
                    B --> C[useParams hook]
                    C --> D["{ userId: '42' }"]
                    D --> E[Component uses userId]
                    
                    style C fill:#667eea,color:#fff
                    style D fill:#48bb78,color:#fff
                </div>

                <h3>Basic useParams Usage</h3>
                <p>Here's how to use <code>useParams</code> to access route parameters:</p>

                <pre><code class="language-typescript">import { useParams } from 'react-router-dom';

// Route definition: /users/:userId

function UserProfile() {
  // Get the userId from the URL
  const { userId } = useParams();
  
  return (
    &lt;div&gt;
      &lt;h1&gt;User Profile&lt;/h1&gt;
      &lt;p&gt;Viewing profile for user: {userId}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// When user navigates to /users/42
// userId will be "42"</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Parameters Are Always Strings</h4>
                    <p>All route parameters come through as strings, even if they look like numbers in the URL:</p>
                    <pre><code>const { userId } = useParams();
// userId is "42", not 42

// Convert to number if needed:
const userIdNumber = Number(userId);
// or
const userIdNumber = parseInt(userId, 10);</code></pre>
                </div>

                <h3>Typing useParams with TypeScript</h3>
                <p>TypeScript needs to know what parameters to expect. Here's how to type <code>useParams</code> properly:</p>

                <pre><code class="language-typescript">import { useParams } from 'react-router-dom';

// Option 1: Define a type for your params
type UserParams = {
  userId: string;
};

function UserProfile() {
  const { userId } = useParams&lt;UserParams&gt;();
  // TypeScript knows userId is string | undefined
  
  // Handle the case where userId might be undefined
  if (!userId) {
    return &lt;div&gt;No user ID provided&lt;/div&gt;;
  }
  
  return &lt;div&gt;User ID: {userId}&lt;/div&gt;;
}

// Option 2: Inline type
function BlogPost() {
  const { postId } = useParams&lt;{ postId: string }&gt;();
  
  return &lt;div&gt;Post ID: {postId}&lt;/div&gt;;
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ React Router v6.4+ Typing</h4>
                    <p style="color: white;">In React Router v6.4+, <code>useParams</code> returns parameters as <code>string | undefined</code> by default. This is safer because params might not always be present:</p>
                    <pre style="background: rgba(0,0,0,0.2); color: white;"><code>// Type returned by useParams
const params: Readonly&lt;Params&lt;string&gt;&gt;

// Which means each param is: string | undefined
const { userId } = useParams();
// userId: string | undefined</code></pre>
                </div>

                <h3>Multiple Parameters</h3>
                <p>Access multiple parameters from the same route:</p>

                <pre><code class="language-typescript">import { useParams } from 'react-router-dom';

// Route: /blog/:year/:month/:slug

type BlogPostParams = {
  year: string;
  month: string;
  slug: string;
};

function BlogPost() {
  const { year, month, slug } = useParams&lt;BlogPostParams&gt;();
  
  // Validate and convert
  if (!year || !month || !slug) {
    return &lt;div&gt;Invalid blog post URL&lt;/div&gt;;
  }
  
  const yearNum = parseInt(year, 10);
  const monthNum = parseInt(month, 10);
  
  return (
    &lt;article&gt;
      &lt;h1&gt;{slug.replace(/-/g, ' ')}&lt;/h1&gt;
      &lt;p&gt;Published: {monthNum}/{yearNum}&lt;/p&gt;
    &lt;/article&gt;
  );
}</code></pre>

                <h3>Practical Example: Product Detail Page</h3>
                <p>Let's build a complete example with data fetching based on route parameters:</p>

                <pre><code class="language-typescript">import { useParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  imageUrl: string;
}

type ProductParams = {
  productId: string;
};

function ProductDetail() {
  const { productId } = useParams&lt;ProductParams&gt;();
  const [product, setProduct] = useState&lt;Product | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() => {
    // Validate parameter
    if (!productId) {
      setError('No product ID provided');
      setLoading(false);
      return;
    }
    
    // Fetch product data
    const fetchProduct = async () => {
      try {
        const response = await fetch(
          `https://api.example.com/products/${productId}`
        );
        
        if (!response.ok) {
          throw new Error('Product not found');
        }
        
        const data = await response.json();
        setProduct(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load product');
      } finally {
        setLoading(false);
      }
    };
    
    fetchProduct();
  }, [productId]);
  
  if (loading) {
    return &lt;div&gt;Loading product...&lt;/div&gt;;
  }
  
  if (error) {
    return &lt;div&gt;Error: {error}&lt;/div&gt;;
  }
  
  if (!product) {
    return &lt;div&gt;Product not found&lt;/div&gt;;
  }
  
  return (
    &lt;div className="product-detail"&gt;
      &lt;img src={product.imageUrl} alt={product.name} /&gt;
      &lt;h1&gt;{product.name}&lt;/h1&gt;
      &lt;p className="price"&gt;${product.price.toFixed(2)}&lt;/p&gt;
      &lt;p&gt;{product.description}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practices</h4>
                    <ul>
                        <li><strong>Always validate parameters</strong> - Check if they exist before using them</li>
                        <li><strong>Convert types as needed</strong> - Parse strings to numbers when required</li>
                        <li><strong>Handle missing params</strong> - Show appropriate error messages</li>
                        <li><strong>Use TypeScript types</strong> - Define param shapes for type safety</li>
                        <li><strong>Sanitize input</strong> - Validate parameter formats and values</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: User Profile with Tabs</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Create a user profile page that uses route parameters for both the user ID and the active tab.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Route pattern: <code>/users/:userId/:tab?</code></li>
                        <li>Extract both <code>userId</code> and optional <code>tab</code> parameters</li>
                        <li>Default to "overview" tab if no tab specified</li>
                        <li>Display different content for each tab: overview, posts, photos, settings</li>
                        <li>Show user's name based on the ID (can use mock data)</li>
                        <li>Properly type the parameters with TypeScript</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Define your params type with both required and optional parameters:</p>
                        <pre><code>type UserProfileParams = {
  userId: string;
  tab?: string;  // Optional parameter
};</code></pre>
                        <p>Use a default value when destructuring:</p>
                        <pre><code>const { userId, tab = 'overview' } = useParams&lt;UserProfileParams&gt;();</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useParams } from 'react-router-dom';

type UserProfileParams = {
  userId: string;
  tab?: string;
};

// Mock user data
const users: Record&lt;string, { name: string; email: string }&gt; = {
  '1': { name: 'Alice Johnson', email: 'alice@example.com' },
  '2': { name: 'Bob Smith', email: 'bob@example.com' },
  '3': { name: 'Charlie Davis', email: 'charlie@example.com' },
};

function UserProfile() {
  const { userId, tab = 'overview' } = useParams&lt;UserProfileParams&gt;();
  
  // Validate userId
  if (!userId || !users[userId]) {
    return (
      &lt;div&gt;
        &lt;h1&gt;User Not Found&lt;/h1&gt;
        &lt;p&gt;The user ID {userId} doesn't exist.&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  const user = users[userId];
  
  // Render different content based on active tab
  const renderTabContent = () => {
    switch (tab) {
      case 'overview':
        return (
          &lt;div&gt;
            &lt;h3&gt;Overview&lt;/h3&gt;
            &lt;p&gt;Email: {user.email}&lt;/p&gt;
            &lt;p&gt;Member since: January 2024&lt;/p&gt;
          &lt;/div&gt;
        );
      
      case 'posts':
        return (
          &lt;div&gt;
            &lt;h3&gt;Posts&lt;/h3&gt;
            &lt;p&gt;{user.name} hasn't posted anything yet.&lt;/p&gt;
          &lt;/div&gt;
        );
      
      case 'photos':
        return (
          &lt;div&gt;
            &lt;h3&gt;Photos&lt;/h3&gt;
            &lt;p&gt;{user.name} hasn't uploaded any photos.&lt;/p&gt;
          &lt;/div&gt;
        );
      
      case 'settings':
        return (
          &lt;div&gt;
            &lt;h3&gt;Settings&lt;/h3&gt;
            &lt;p&gt;Privacy settings and preferences.&lt;/p&gt;
          &lt;/div&gt;
        );
      
      default:
        return &lt;p&gt;Invalid tab: {tab}&lt;/p&gt;;
    }
  };
  
  return (
    &lt;div className="user-profile"&gt;
      &lt;header&gt;
        &lt;h1&gt;{user.name}&lt;/h1&gt;
        &lt;p&gt;User ID: {userId}&lt;/p&gt;
      &lt;/header&gt;
      
      &lt;nav className="profile-tabs"&gt;
        &lt;a 
          href={`/users/${userId}/overview`}
          className={tab === 'overview' ? 'active' : ''}
        &gt;
          Overview
        &lt;/a&gt;
        &lt;a 
          href={`/users/${userId}/posts`}
          className={tab === 'posts' ? 'active' : ''}
        &gt;
          Posts
        &lt;/a&gt;
        &lt;a 
          href={`/users/${userId}/photos`}
          className={tab === 'photos' ? 'active' : ''}
        &gt;
          Photos
        &lt;/a&gt;
        &lt;a 
          href={`/users/${userId}/settings`}
          className={tab === 'settings' ? 'active' : ''}
        &gt;
          Settings
        &lt;/a&gt;
      &lt;/nav&gt;
      
      &lt;main&gt;
        {renderTabContent()}
      &lt;/main&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 4: Programmatic Navigation with useNavigate -->
            <section id="section4" aria-labelledby="section4-title">
                <h2 id="section4-title">üß≠ Programmatic Navigation with useNavigate</h2>
                <p>The <code>useNavigate</code> hook allows you to navigate to different routes programmatically in response to user actions or application logic, rather than through link clicks.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ When to Use useNavigate</h4>
                    <ul style="color: white;">
                        <li><strong>After form submission</strong> - Navigate to success page after saving data</li>
                        <li><strong>Authentication flows</strong> - Redirect after login/logout</li>
                        <li><strong>Conditional navigation</strong> - Navigate based on user role or permissions</li>
                        <li><strong>Timeout redirects</strong> - Navigate after a delay</li>
                        <li><strong>Error handling</strong> - Redirect on errors</li>
                    </ul>
                </div>

                <h3>Basic useNavigate Usage</h3>
                <p>The <code>useNavigate</code> hook returns a navigation function:</p>

                <pre><code class="language-typescript">import { useNavigate } from 'react-router-dom';

function LoginForm() {
  const navigate = useNavigate();
  
  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();
    
    // Perform login logic...
    const success = await performLogin();
    
    if (success) {
      // Navigate to dashboard after successful login
      navigate('/dashboard');
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input type="email" name="email" /&gt;
      &lt;input type="password" name="password" /&gt;
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

<div class="mermaid">
flowchart LR
    A[User Action] --> B[Event Handler]
    B --> C[Business Logic]
    C --> D{Success?}
    D -->|Yes| E["navigate('/success')"]
    D -->|No| F[Show Error]
    E --> G[New Route Rendered]
    
    style E fill:#667eea,color:#fff
    style G fill:#48bb78,color:#fff
</div>

                <h3>Navigation Options</h3>
                <p>The navigate function accepts several options:</p>

                <pre><code class="language-typescript">import { useNavigate } from 'react-router-dom';

function MyComponent() {
  const navigate = useNavigate();
  
  // 1. Simple navigation to a path
  navigate('/about');
  
  // 2. Navigate with relative path
  navigate('../parent');  // Go up one level
  navigate('child');      // Go to child route
  
  // 3. Navigate with replace (replaces history entry)
  navigate('/login', { replace: true });
  
  // 4. Navigate backward/forward
  navigate(-1);  // Go back one page (like browser back)
  navigate(-2);  // Go back two pages
  navigate(1);   // Go forward one page
  
  // 5. Navigate with state
  navigate('/profile', { 
    state: { from: '/settings', userId: 42 } 
  });
}</code></pre>

                <h3>The Replace Option</h3>
                <p>Using <code>replace: true</code> replaces the current history entry instead of adding a new one:</p>

                <pre><code class="language-typescript">function RedirectExample() {
  const navigate = useNavigate();
  
  useEffect(() => {
    // Check authentication
    const isAuthenticated = checkAuth();
    
    if (!isAuthenticated) {
      // Replace current history entry
      // User can't go "back" to protected page
      navigate('/login', { replace: true });
    }
  }, [navigate]);
  
  return &lt;div&gt;Protected Content&lt;/div&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Replace vs. Push</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Behavior</th>
                                <th>Default (Push)</th>
                                <th>Replace</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>History stack</td>
                                <td>Adds new entry</td>
                                <td>Replaces current entry</td>
                            </tr>
                            <tr>
                                <td>Back button</td>
                                <td>Goes to previous page</td>
                                <td>Skips replaced page</td>
                            </tr>
                            <tr>
                                <td>Use case</td>
                                <td>Normal navigation</td>
                                <td>Redirects, auth flows</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Navigating with State</h3>
                <p>Pass data to the next route using the state option:</p>

                <pre><code class="language-typescript">import { useNavigate } from 'react-router-dom';

function ProductList() {
  const navigate = useNavigate();
  
  const handleProductClick = (product: Product) => {
    // Navigate and pass product data
    navigate(`/products/${product.id}`, {
      state: { 
        product,
        fromPage: 'listing',
        searchQuery: 'laptops'
      }
    });
  };
  
  return (
    &lt;div&gt;
      {products.map(product => (
        &lt;button 
          key={product.id}
          onClick={() => handleProductClick(product)}
        &gt;
          {product.name}
        &lt;/button&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Practical Example: Multi-Step Form</h3>
                <p>Here's a complete example showing programmatic navigation in a multi-step form:</p>

                <pre><code class="language-typescript">import { useNavigate } from 'react-router-dom';
import { useState } from 'react';

interface FormData {
  step1: {
    email: string;
    password: string;
  };
  step2: {
    firstName: string;
    lastName: string;
  };
  step3: {
    address: string;
    city: string;
  };
}

function RegistrationStep1() {
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    if (!email || !password) {
      alert('Please fill all fields');
      return;
    }
    
    // Navigate to next step with data
    navigate('/register/step2', {
      state: {
        step1: { email, password }
      }
    });
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h2&gt;Step 1: Account Details&lt;/h2&gt;
      
      &lt;input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        required
      /&gt;
      
      &lt;input
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
        required
      /&gt;
      
      &lt;button type="submit"&gt;Next Step &rarr;&lt;/button&gt;
    &lt;/form&gt;
  );
}

function RegistrationStep2() {
  const navigate = useNavigate();
  const location = useLocation();
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  
  // Get data from previous step
  const previousData = location.state as { step1: FormData['step1'] };
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Navigate to next step with accumulated data
    navigate('/register/step3', {
      state: {
        ...previousData,
        step2: { firstName, lastName }
      }
    });
  };
  
  const handleBack = () => {
    // Go back but preserve data
    navigate(-1);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h2&gt;Step 2: Personal Information&lt;/h2&gt;
      
      &lt;input
        type="text"
        value={firstName}
        onChange={(e) => setFirstName(e.target.value)}
        placeholder="First Name"
        required
      /&gt;
      
      &lt;input
        type="text"
        value={lastName}
        onChange={(e) => setLastName(e.target.value)}
        placeholder="Last Name"
        required
      /&gt;
      
      &lt;div className="button-group"&gt;
        &lt;button type="button" onClick={handleBack}&gt;
          &larr; Back
        &lt;/button&gt;
        &lt;button type="submit"&gt;
          Next Step &rarr;
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ useNavigate Best Practices</h4>
                    <ul>
                        <li><strong>Use replace for redirects</strong> - Prevent users from going back to redirect pages</li>
                        <li><strong>Don't navigate in render</strong> - Only navigate in event handlers or effects</li>
                        <li><strong>Handle navigation errors</strong> - Wrap navigate calls in try-catch when needed</li>
                        <li><strong>Pass minimal state</strong> - Only pass necessary data through location state</li>
                        <li><strong>Type your state</strong> - Define TypeScript interfaces for location state</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: Shopping Cart Checkout</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Build a checkout flow that uses programmatic navigation to guide users through the purchase process.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create three routes: /cart, /checkout, /success</li>
                        <li>From cart, navigate to checkout with cart items in state</li>
                        <li>On successful payment, navigate to success page with order details</li>
                        <li>Use replace: true when navigating to success page</li>
                        <li>Add a "Back to Cart" button on checkout page</li>
                        <li>Properly type all navigation state with TypeScript</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Define your state types first:</p>
                        <pre><code>interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
}

interface CheckoutState {
  items: CartItem[];
  total: number;
}

interface OrderState extends CheckoutState {
  orderId: string;
  orderDate: string;
}</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useNavigate, useLocation } from 'react-router-dom';
import { useState } from 'react';

interface CartItem {
  id: number;
  name: string;
  price: number;
  quantity: number;
}

interface CheckoutState {
  items: CartItem[];
  total: number;
}

// Cart Component
function Cart() {
  const navigate = useNavigate();
  const [items] = useState&lt;CartItem[]&gt;([
    { id: 1, name: 'Laptop', price: 999, quantity: 1 },
    { id: 2, name: 'Mouse', price: 29, quantity: 2 }
  ]);
  
  const total = items.reduce((sum, item) => 
    sum + (item.price * item.quantity), 0
  );
  
  const handleCheckout = () => {
    navigate('/checkout', {
      state: { items, total } as CheckoutState
    });
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Shopping Cart&lt;/h1&gt;
      {items.map(item => (
        &lt;div key={item.id}&gt;
          {item.name} - ${item.price} x {item.quantity}
        &lt;/div&gt;
      ))}
      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;
      &lt;button onClick={handleCheckout}&gt;
        Proceed to Checkout
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Checkout Component
function Checkout() {
  const navigate = useNavigate();
  const location = useLocation();
  const state = location.state as CheckoutState;
  
  if (!state || !state.items) {
    // Redirect if accessed directly
    navigate('/cart', { replace: true });
    return null;
  }
  
  const handlePayment = () => {
    // Simulate payment processing
    const orderId = `ORD-${Date.now()}`;
    
    navigate('/success', {
      replace: true, // Can't go back to checkout
      state: {
        ...state,
        orderId,
        orderDate: new Date().toISOString()
      }
    });
  };
  
  const handleBackToCart = () => {
    navigate('/cart');
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Checkout&lt;/h1&gt;
      &lt;h3&gt;Order Summary&lt;/h3&gt;
      {state.items.map(item => (
        &lt;div key={item.id}&gt;
          {item.name} - ${item.price} x {item.quantity}
        &lt;/div&gt;
      ))}
      &lt;p&gt;Total: ${state.total.toFixed(2)}&lt;/p&gt;
      
      &lt;div className="button-group"&gt;
        &lt;button onClick={handleBackToCart}&gt;
          ‚Üê Back to Cart
        &lt;/button&gt;
        &lt;button onClick={handlePayment}&gt;
          Complete Payment
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Success Component
function OrderSuccess() {
  const location = useLocation();
  const state = location.state as CheckoutState & {
    orderId: string;
    orderDate: string;
  };
  
  if (!state) {
    // Redirect if accessed directly
    navigate('/cart', { replace: true });
    return null;
  }
  
  return (
    &lt;div&gt;
      &lt;h1&gt;‚úÖ Order Complete!&lt;/h1&gt;
      &lt;p&gt;Order ID: {state.orderId}&lt;/p&gt;
      &lt;p&gt;Date: {new Date(state.orderDate).toLocaleDateString()}&lt;/p&gt;
      &lt;p&gt;Total: ${state.total.toFixed(2)}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 5: The useLocation Hook -->
            <section id="section5" aria-labelledby="section5-title">
                <h2 id="section5-title">üìç The useLocation Hook</h2>
                <p>The <code>useLocation</code> hook gives you access to the current location object, which contains information about the current URL, state passed through navigation, and more.</p>

                <div class="mermaid">
                flowchart TD
                    A[Current URL] --> B[useLocation]
                    B --> C[Location Object]
                    C --> D[pathname]
                    C --> E[search]
                    C --> F[hash]
                    C --> G[state]
                    C --> H[key]
                    
                    style B fill:#667eea,color:#fff
                    style C fill:#48bb78,color:#fff
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Location Object Properties</h4>
                    <ul style="color: white;">
                        <li><strong>pathname</strong> - The path of the URL (e.g., "/users/42")</li>
                        <li><strong>search</strong> - The query string (e.g., "?sort=name&order=asc")</li>
                        <li><strong>hash</strong> - The URL hash (e.g., "#section3")</li>
                        <li><strong>state</strong> - State passed from previous navigation</li>
                        <li><strong>key</strong> - Unique key for this location entry</li>
                    </ul>
                </div>

                <h3>Basic useLocation Usage</h3>
                <p>Access location information in your components:</p>

                <pre><code class="language-typescript">import { useLocation } from 'react-router-dom';

function CurrentPath() {
  const location = useLocation();
  
  return (
    &lt;div&gt;
      &lt;h3&gt;Current Location Info&lt;/h3&gt;
      &lt;p&gt;Pathname: {location.pathname}&lt;/p&gt;
      &lt;p&gt;Search: {location.search}&lt;/p&gt;
      &lt;p&gt;Hash: {location.hash}&lt;/p&gt;
      &lt;p&gt;Key: {location.key}&lt;/p&gt;
    &lt;/div&gt;
  );
}

// Example URL: /products?category=electronics#reviews
// Pathname: /products
// Search: ?category=electronics
// Hash: #reviews</code></pre>

                <h3>Accessing Navigation State</h3>
                <p>Retrieve state that was passed during navigation:</p>

                <pre><code class="language-typescript">import { useLocation, useNavigate } from 'react-router-dom';

// Component that navigates WITH state
function ProductList() {
  const navigate = useNavigate();
  
  const handleProductClick = (productId: number) => {
    navigate(`/products/${productId}`, {
      state: { 
        fromPage: 'listing',
        category: 'electronics',
        scrollPosition: window.scrollY
      }
    });
  };
  
  return &lt;div&gt;{/* Product list */}&lt;/div&gt;;
}

// Component that receives the state
interface LocationState {
  fromPage?: string;
  category?: string;
  scrollPosition?: number;
}

function ProductDetail() {
  const location = useLocation();
  const navigate = useNavigate();
  
  // Type assertion for the state
  const state = location.state as LocationState;
  
  const handleBack = () => {
    if (state?.fromPage === 'listing') {
      // Go back to listing
      navigate('/products', {
        state: { 
          scrollTo: state.scrollPosition 
        }
      });
    } else {
      // Default back behavior
      navigate(-1);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={handleBack}&gt;
        {state?.fromPage ? `‚Üê Back to ${state.fromPage}` : '‚Üê Back'}
      &lt;/button&gt;
      {state?.category && (
        &lt;p&gt;Category: {state.category}&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Location State Warning</h4>
                    <p>Location state is stored in browser memory and will be lost on page refresh. Don't rely on it for critical data:</p>
                    <ul>
                        <li>‚úÖ Good: UI state, scroll position, previous page info</li>
                        <li>‚ùå Bad: User data, authentication tokens, form inputs</li>
                    </ul>
                    <p>For persistent data, use URL parameters, localStorage, or fetch data based on URL params.</p>
                </div>

                <h3>Conditional Rendering Based on Location</h3>
                <p>Use location to render different UI based on the current route:</p>

                <pre><code class="language-typescript">import { useLocation } from 'react-router-dom';

function Navigation() {
  const location = useLocation();
  
  // Highlight active navigation item
  const isActive = (path: string) => {
    return location.pathname === path;
  };
  
  // Check if we're in a specific section
  const inAdminSection = location.pathname.startsWith('/admin');
  
  return (
    &lt;nav&gt;
      &lt;a 
        href="/" 
        className={isActive('/') ? 'active' : ''}
      &gt;
        Home
      &lt;/a&gt;
      
      &lt;a 
        href="/products" 
        className={isActive('/products') ? 'active' : ''}
      &gt;
        Products
      &lt;/a&gt;
      
      &lt;a 
        href="/about" 
        className={isActive('/about') ? 'active' : ''}
      &gt;
        About
      &lt;/a&gt;
      
      {inAdminSection && (
        &lt;a href="/admin/dashboard"&gt;
          Admin Dashboard
        &lt;/a&gt;
      )}
    &lt;/nav&gt;
  );
}</code></pre>

                <h3>Tracking Location Changes</h3>
                <p>React to location changes with useEffect:</p>

                <pre><code class="language-typescript">import { useLocation } from 'react-router-dom';
import { useEffect } from 'react';

function PageTracker() {
  const location = useLocation();
  
  useEffect(() => {
    // Track page view
    console.log('Page view:', location.pathname);
    
    // Send analytics
    if (window.gtag) {
      window.gtag('config', 'GA_MEASUREMENT_ID', {
        page_path: location.pathname + location.search
      });
    }
    
    // Scroll to top on route change
    window.scrollTo(0, 0);
    
    // Or scroll to hash if present
    if (location.hash) {
      const element = document.querySelector(location.hash);
      element?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [location]);
  
  return null; // This component doesn't render anything
}</code></pre>

                <h3>Practical Example: Breadcrumbs</h3>
                <p>Build dynamic breadcrumbs based on the current location:</p>

                <pre><code class="language-typescript">import { useLocation, Link } from 'react-router-dom';

function Breadcrumbs() {
  const location = useLocation();
  
  // Split pathname into segments
  const pathnames = location.pathname.split('/').filter(x => x);
  
  // Build breadcrumb items
  const breadcrumbs = pathnames.map((segment, index) => {
    // Build the path up to this segment
    const path = `/${pathnames.slice(0, index + 1).join('/')}`;
    
    // Format the segment name
    const name = segment
      .replace(/-/g, ' ')
      .replace(/\b\w/g, char => char.toUpperCase());
    
    return { path, name };
  });
  
  return (
    &lt;nav aria-label="Breadcrumb"&gt;
      &lt;ol className="breadcrumb"&gt;
        &lt;li&gt;
          &lt;Link to="/"&gt;Home&lt;/Link&gt;
        &lt;/li&gt;
        
        {breadcrumbs.map((crumb, index) => {
          const isLast = index === breadcrumbs.length - 1;
          
          return (
            &lt;li key={crumb.path}&gt;
              {isLast ? (
                &lt;span aria-current="page"&gt;{crumb.name}&lt;/span&gt;
              ) : (
                &lt;Link to={crumb.path}&gt;{crumb.name}&lt;/Link&gt;
              )}
            &lt;/li&gt;
          );
        })}
      &lt;/ol&gt;
    &lt;/nav&gt;
  );
}

// Example usage:
// URL: /products/electronics/laptops
// Renders: Home > Products > Electronics > Laptops</code></pre>

                <h3>Location with Authentication</h3>
                <p>Store and retrieve redirect paths for authentication flows:</p>

                <pre><code class="language-typescript">import { useLocation, useNavigate } from 'react-router-dom';
import { useEffect } from 'react';

// Protected Route Component
function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const location = useLocation();
  const navigate = useNavigate();
  const isAuthenticated = checkAuth(); // Your auth check
  
  useEffect(() => {
    if (!isAuthenticated) {
      // Redirect to login, storing the intended destination
      navigate('/login', {
        state: { from: location.pathname },
        replace: true
      });
    }
  }, [isAuthenticated, location, navigate]);
  
  return isAuthenticated ? &lt;&gt;{children}&lt;/&gt; : null;
}

// Login Component
interface LoginLocationState {
  from?: string;
}

function Login() {
  const location = useLocation();
  const navigate = useNavigate();
  
  const state = location.state as LoginLocationState;
  const from = state?.from || '/dashboard';
  
  const handleLogin = async (credentials: LoginCredentials) => {
    const success = await performLogin(credentials);
    
    if (success) {
      // Navigate to the page they were trying to access
      navigate(from, { replace: true });
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Login&lt;/h1&gt;
      {state?.from && (
        &lt;p&gt;Please log in to access {state.from}&lt;/p&gt;
      )}
      &lt;LoginForm onSubmit={handleLogin} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ useLocation Best Practices</h4>
                    <ul>
                        <li><strong>Type your state</strong> - Always define TypeScript interfaces for location state</li>
                        <li><strong>Handle missing state</strong> - Check if state exists before using it</li>
                        <li><strong>Use for ephemeral data</strong> - Only pass temporary UI state, not critical data</li>
                        <li><strong>Track in useEffect</strong> - Use location as dependency for side effects</li>
                        <li><strong>Combine with other hooks</strong> - Often used together with useNavigate and useParams</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: Return-to-Previous Functionality</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Create a "Return to where you came from" feature that remembers the previous page.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create a SearchResults component that passes search context</li>
                        <li>Create a ProductDetail component that receives the context</li>
                        <li>Add a smart "Back" button that shows different text based on where user came from</li>
                        <li>If from search, show "Back to Search Results"</li>
                        <li>If from category, show "Back to Category"</li>
                        <li>Otherwise, show generic "Back"</li>
                        <li>Properly type all location state</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Define a state interface with optional properties:</p>
                        <pre><code>interface NavigationState {
  from?: 'search' | 'category' | 'home';
  searchQuery?: string;
  categoryName?: string;
}</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useLocation, useNavigate, Link } from 'react-router-dom';

interface NavigationState {
  from?: 'search' | 'category' | 'home';
  searchQuery?: string;
  categoryName?: string;
}

// Search Results Component
function SearchResults() {
  const [query] = useState('laptop');
  const products = [
    { id: 1, name: 'Gaming Laptop' },
    { id: 2, name: 'Business Laptop' }
  ];
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Search Results for "{query}"&lt;/h1&gt;
      {products.map(product => (
        &lt;Link
          key={product.id}
          to={`/products/${product.id}`}
          state={{
            from: 'search',
            searchQuery: query
          } as NavigationState}
        &gt;
          {product.name}
        &lt;/Link&gt;
      ))}
    &lt;/div&gt;
  );
}

// Category Component
function Category() {
  const categoryName = 'Electronics';
  const products = [
    { id: 1, name: 'Gaming Laptop' },
    { id: 3, name: 'Wireless Mouse' }
  ];
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{categoryName}&lt;/h1&gt;
      {products.map(product => (
        &lt;Link
          key={product.id}
          to={`/products/${product.id}`}
          state={{
            from: 'category',
            categoryName
          } as NavigationState}
        &gt;
          {product.name}
        &lt;/Link&gt;
      ))}
    &lt;/div&gt;
  );
}

// Product Detail Component
function ProductDetail() {
  const location = useLocation();
  const navigate = useNavigate();
  const { productId } = useParams&lt;{ productId: string }&gt;();
  
  const state = location.state as NavigationState;
  
  // Determine back button text and action
  const getBackButton = () => {
    if (state?.from === 'search') {
      return {
        text: `‚Üê Back to Search Results "${state.searchQuery}"`,
        path: `/search?q=${state.searchQuery}`
      };
    }
    
    if (state?.from === 'category') {
      return {
        text: `‚Üê Back to ${state.categoryName}`,
        path: `/categories/${state.categoryName?.toLowerCase()}`
      };
    }
    
    if (state?.from === 'home') {
      return {
        text: '‚Üê Back to Home',
        path: '/'
      };
    }
    
    // Default fallback
    return {
      text: '‚Üê Back',
      path: null // Will use navigate(-1)
    };
  };
  
  const backButton = getBackButton();
  
  const handleBack = () => {
    if (backButton.path) {
      navigate(backButton.path);
    } else {
      navigate(-1);
    }
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={handleBack}&gt;
        {backButton.text}
      &lt;/button&gt;
      
      &lt;h1&gt;Product {productId}&lt;/h1&gt;
      &lt;p&gt;Product details here...&lt;/p&gt;
      
      {state?.from && (
        &lt;p className="breadcrumb-info"&gt;
          You came from: {state.from}
        &lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 6: Building a Blog with Advanced Routing -->
            <section id="section6" aria-labelledby="section6-title">
                <h2 id="section6-title">üìù Building a Blog with Advanced Routing</h2>
                <p>Let's put everything together by building a complete blog application that demonstrates nested routes, dynamic parameters, and programmatic navigation.</p>

                <div class="mermaid">
                flowchart TD
                    A[Blog Home] --> B[All Posts]
                    A --> C[Categories]
                    B --> D[Post Detail]
                    C --> E[Category Posts]
                    E --> D
                    D --> F[Edit Post]
                    F --> G[Save & Navigate]
                    
                    style A fill:#667eea,color:#fff
                    style D fill:#48bb78,color:#fff
                </div>

                <h3>Blog Application Structure</h3>
                <p>Our blog will have the following route structure:</p>

                <pre><code class="language-typescript">// Route structure:
/                          // Home page
/blog                      // Blog listing
/blog/:postId              // Individual post
/blog/category/:category   // Posts by category
/blog/author/:authorId     // Posts by author
/blog/edit/:postId         // Edit post
/blog/new                  // Create new post</code></pre>

                <h3>Complete Blog Application</h3>
                <p>Here's the full implementation with all advanced routing features:</p>

                <pre><code class="language-typescript">import { 
  BrowserRouter, 
  Routes, 
  Route, 
  Link,
  useParams,
  useNavigate,
  useLocation 
} from 'react-router-dom';
import { useState, useEffect } from 'react';

// Types
interface BlogPost {
  id: number;
  title: string;
  content: string;
  category: string;
  authorId: number;
  date: string;
}

interface Author {
  id: number;
  name: string;
}

// Mock data
const authors: Record&lt;number, Author&gt; = {
  1: { id: 1, name: 'Jane Smith' },
  2: { id: 2, name: 'John Doe' }
};

const mockPosts: BlogPost[] = [
  {
    id: 1,
    title: 'Getting Started with React Router',
    content: 'React Router is a powerful routing library...',
    category: 'React',
    authorId: 1,
    date: '2024-01-15'
  },
  {
    id: 2,
    title: 'TypeScript Best Practices',
    content: 'TypeScript helps us write safer code...',
    category: 'TypeScript',
    authorId: 2,
    date: '2024-01-20'
  },
  {
    id: 3,
    title: 'Advanced Hooks Patterns',
    content: 'Custom hooks are reusable pieces...',
    category: 'React',
    authorId: 1,
    date: '2024-01-25'
  }
];

// Blog Home - Shows all posts
function BlogHome() {
  const [posts] = useState&lt;BlogPost[]&gt;(mockPosts);
  
  // Get unique categories
  const categories = [...new Set(posts.map(p => p.category))];
  
  return (
    &lt;div className="blog-home"&gt;
      &lt;h1&gt;üìù My Blog&lt;/h1&gt;
      
      &lt;nav className="category-nav"&gt;
        &lt;h3&gt;Categories&lt;/h3&gt;
        {categories.map(category => (
          &lt;Link 
            key={category}
            to={`/blog/category/${category}`}
          &gt;
            {category}
          &lt;/Link&gt;
        ))}
      &lt;/nav&gt;
      
      &lt;div className="posts-list"&gt;
        &lt;h2&gt;Recent Posts&lt;/h2&gt;
        {posts.map(post => (
          &lt;article key={post.id} className="post-preview"&gt;
            &lt;h3&gt;
              &lt;Link 
                to={`/blog/${post.id}`}
                state={{ from: 'home' }}
              &gt;
                {post.title}
              &lt;/Link&gt;
            &lt;/h3&gt;
            &lt;p&gt;{post.content.substring(0, 100)}...&lt;/p&gt;
            &lt;div className="post-meta"&gt;
              &lt;span&gt;{post.category}&lt;/span&gt;
              &lt;span&gt;By {authors[post.authorId].name}&lt;/span&gt;
              &lt;span&gt;{post.date}&lt;/span&gt;
            &lt;/div&gt;
          &lt;/article&gt;
        ))}
      &lt;/div&gt;
      
      &lt;Link to="/blog/new" className="create-post-btn"&gt;
        ‚ûï Create New Post
      &lt;/Link&gt;
    &lt;/div&gt;
  );
}

// Individual Post View
function BlogPost() {
  const { postId } = useParams&lt;{ postId: string }&gt;();
  const location = useLocation();
  const navigate = useNavigate();
  const [post, setPost] = useState&lt;BlogPost | null&gt;(null);
  
  const state = location.state as { from?: string };
  
  useEffect(() => {
    if (!postId) return;
    
    const postIdNum = parseInt(postId, 10);
    const foundPost = mockPosts.find(p => p.id === postIdNum);
    setPost(foundPost || null);
  }, [postId]);
  
  if (!post) {
    return &lt;div&gt;Post not found&lt;/div&gt;;
  }
  
  const author = authors[post.authorId];
  
  const handleEdit = () => {
    navigate(`/blog/edit/${post.id}`, {
      state: { post }
    });
  };
  
  const handleBack = () => {
    if (state?.from) {
      navigate(-1);
    } else {
      navigate('/blog');
    }
  };
  
  return (
    &lt;article className="blog-post"&gt;
      &lt;button onClick={handleBack}&gt;‚Üê Back&lt;/button&gt;
      
      &lt;header&gt;
        &lt;h1&gt;{post.title}&lt;/h1&gt;
        &lt;div className="post-meta"&gt;
          &lt;Link to={`/blog/category/${post.category}`}&gt;
            {post.category}
          &lt;/Link&gt;
          &lt;span&gt; | &lt;/span&gt;
          &lt;Link to={`/blog/author/${post.authorId}`}&gt;
            {author.name}
          &lt;/Link&gt;
          &lt;span&gt; | {post.date}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/header&gt;
      
      &lt;div className="post-content"&gt;
        {post.content}
      &lt;/div&gt;
      
      &lt;button onClick={handleEdit}&gt;
        ‚úèÔ∏è Edit Post
      &lt;/button&gt;
    &lt;/article&gt;
  );
}

// Posts by Category
function CategoryPosts() {
  const { category } = useParams&lt;{ category: string }&gt;();
  const [posts, setPosts] = useState&lt;BlogPost[]&gt;([]);
  
  useEffect(() => {
    if (!category) return;
    
    const filtered = mockPosts.filter(
      p => p.category.toLowerCase() === category.toLowerCase()
    );
    setPosts(filtered);
  }, [category]);
  
  return (
    &lt;div&gt;
      &lt;Link to="/blog"&gt;‚Üê Back to Blog&lt;/Link&gt;
      
      &lt;h1&gt;Posts in {category}&lt;/h1&gt;
      
      {posts.length === 0 ? (
        &lt;p&gt;No posts in this category yet.&lt;/p&gt;
      ) : (
        &lt;div className="posts-list"&gt;
          {posts.map(post => (
            &lt;article key={post.id}&gt;
              &lt;h3&gt;
                &lt;Link 
                  to={`/blog/${post.id}`}
                  state={{ from: `category-${category}` }}
                &gt;
                  {post.title}
                &lt;/Link&gt;
              &lt;/h3&gt;
              &lt;p&gt;{post.content.substring(0, 100)}...&lt;/p&gt;
            &lt;/article&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}

// Edit Post
interface EditPostLocationState {
  post?: BlogPost;
}

function EditPost() {
  const { postId } = useParams&lt;{ postId: string }&gt;();
  const location = useLocation();
  const navigate = useNavigate();
  
  const state = location.state as EditPostLocationState;
  const [title, setTitle] = useState(state?.post?.title || '');
  const [content, setContent] = useState(state?.post?.content || '');
  
  useEffect(() => {
    // If no state, fetch the post
    if (!state?.post && postId) {
      const postIdNum = parseInt(postId, 10);
      const post = mockPosts.find(p => p.id === postIdNum);
      if (post) {
        setTitle(post.title);
        setContent(post.content);
      }
    }
  }, [postId, state]);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Save post logic here
    console.log('Saving post:', { title, content });
    
    // Navigate back to post with success message
    navigate(`/blog/${postId}`, {
      state: { message: 'Post updated successfully!' }
    });
  };
  
  return (
    &lt;div className="edit-post"&gt;
      &lt;h1&gt;Edit Post&lt;/h1&gt;
      
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;div&gt;
          &lt;label&gt;Title&lt;/label&gt;
          &lt;input
            type="text"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
          /&gt;
        &lt;/div&gt;
        
        &lt;div&gt;
          &lt;label&gt;Content&lt;/label&gt;
          &lt;textarea
            value={content}
            onChange={(e) => setContent(e.target.value)}
            rows={10}
            required
          /&gt;
        &lt;/div&gt;
        
        &lt;div className="button-group"&gt;
          &lt;button 
            type="button"
            onClick={() => navigate(-1)}
          &gt;
            Cancel
          &lt;/button&gt;
          &lt;button type="submit"&gt;
            Save Changes
          &lt;/button&gt;
        &lt;/div&gt;
      &lt;/form&gt;
    &lt;/div&gt;
  );
}

// App with all routes
function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;HomePage /&gt;} /&gt;
        &lt;Route path="/blog" element={&lt;BlogHome /&gt;} /&gt;
        &lt;Route path="/blog/:postId" element={&lt;BlogPost /&gt;} /&gt;
        &lt;Route path="/blog/category/:category" element={&lt;CategoryPosts /&gt;} /&gt;
        &lt;Route path="/blog/edit/:postId" element={&lt;EditPost /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Patterns Demonstrated</h4>
                    <ul>
                        <li><strong>Dynamic routes</strong> - <code>:postId</code>, <code>:category</code> parameters</li>
                        <li><strong>useParams</strong> - Accessing route parameters in components</li>
                        <li><strong>useNavigate</strong> - Programmatic navigation after actions</li>
                        <li><strong>useLocation</strong> - Passing and retrieving navigation state</li>
                        <li><strong>Smart back buttons</strong> - Context-aware navigation</li>
                        <li><strong>TypeScript typing</strong> - Properly typed params and state</li>
                    </ul>
                </div>


            </section>

            <!-- Section 7: Advanced Patterns and Techniques -->
            <section id="section7" aria-labelledby="section7-title">
                <h2 id="section7-title">üé® Advanced Patterns and Techniques</h2>
                <p>Now that we've covered the core hooks, let's explore some advanced patterns and techniques for building sophisticated routing solutions.</p>

                <h3>Combining All Three Hooks</h3>
                <p>Often, you'll use <code>useParams</code>, <code>useNavigate</code>, and <code>useLocation</code> together for complex navigation scenarios:</p>

                <pre><code class="language-typescript">import { useParams, useNavigate, useLocation } from 'react-router-dom';

interface ProductDetailState {
  from?: string;
  category?: string;
  filters?: Record&lt;string, string&gt;;
}

function ProductDetail() {
  const { productId } = useParams&lt;{ productId: string }&gt;();
  const navigate = useNavigate();
  const location = useLocation();
  
  const state = location.state as ProductDetailState;
  const [product, setProduct] = useState&lt;Product | null&gt;(null);
  
  // Fetch product using params
  useEffect(() => {
    if (!productId) return;
    
    fetchProduct(productId).then(setProduct);
  }, [productId]);
  
  // Handle adding to cart with navigation
  const handleAddToCart = () => {
    addToCart(product);
    
    // Navigate to cart, preserving where they came from
    navigate('/cart', {
      state: {
        from: location.pathname,
        returnTo: state?.from || '/products'
      }
    });
  };
  
  // Smart back button using location state
  const handleBack = () => {
    if (state?.from === 'search' && state?.filters) {
      // Return to search with filters
      const params = new URLSearchParams(state.filters);
      navigate(`/search?${params.toString()}`);
    } else if (state?.category) {
      // Return to category
      navigate(`/category/${state.category}`);
    } else {
      // Default back
      navigate(-1);
    }
  };
  
  if (!product) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  
  return (
    &lt;div&gt;
      &lt;button onClick={handleBack}&gt;
        {state?.from ? `‚Üê Back to ${state.from}` : '‚Üê Back'}
      &lt;/button&gt;
      
      &lt;h1&gt;{product.name}&lt;/h1&gt;
      &lt;p&gt;${product.price}&lt;/p&gt;
      
      &lt;button onClick={handleAddToCart}&gt;
        Add to Cart
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Type-Safe Route Parameters</h3>
                <p>Create a centralized route configuration with TypeScript to ensure type safety across your app:</p>

                <pre><code class="language-typescript">// routes.ts - Centralized route definitions
export const ROUTES = {
  home: '/',
  products: {
    list: '/products',
    detail: (id: number | string) => `/products/${id}`,
    edit: (id: number | string) => `/products/${id}/edit`,
    category: (category: string) => `/products/category/${category}`,
  },
  user: {
    profile: (userId: number | string) => `/users/${userId}`,
    settings: '/settings',
  },
  blog: {
    list: '/blog',
    post: (postId: number | string) => `/blog/${postId}`,
    category: (category: string) => `/blog/category/${category}`,
    author: (authorId: number | string) => `/blog/author/${authorId}`,
  }
} as const;

// Usage in components
import { ROUTES } from './routes';
import { useNavigate } from 'react-router-dom';

function ProductList() {
  const navigate = useNavigate();
  
  const handleProductClick = (productId: number) => {
    // Type-safe navigation
    navigate(ROUTES.products.detail(productId));
  };
  
  return (
    &lt;div&gt;
      &lt;Link to={ROUTES.products.list}&gt;All Products&lt;/Link&gt;
      &lt;Link to={ROUTES.products.category('electronics')}&gt;
        Electronics
      &lt;/Link&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Benefits of Centralized Routes</h4>
                    <ul style="color: white;">
                        <li><strong>Type safety</strong> - Catch invalid routes at compile time</li>
                        <li><strong>Refactoring</strong> - Change URLs in one place</li>
                        <li><strong>Autocomplete</strong> - IDE suggestions for all routes</li>
                        <li><strong>Documentation</strong> - Clear overview of all routes</li>
                        <li><strong>Consistency</strong> - Enforce URL structure patterns</li>
                    </ul>
                </div>

                <h3>Custom Navigation Hook</h3>
                <p>Create a custom hook that wraps <code>useNavigate</code> with common navigation patterns:</p>

                <pre><code class="language-typescript">import { useNavigate, NavigateOptions } from 'react-router-dom';
import { useCallback } from 'react';

interface NavigationState {
  from?: string;
  [key: string]: unknown;
}

export function useAppNavigation() {
  const navigate = useNavigate();
  
  // Navigate with automatic "from" tracking
  const navigateTo = useCallback((
    path: string, 
    state?: NavigationState,
    options?: NavigateOptions
  ) => {
    navigate(path, {
      ...options,
      state: {
        from: window.location.pathname,
        ...state
      }
    });
  }, [navigate]);
  
  // Navigate back with fallback
  const navigateBack = useCallback((fallbackPath: string = '/') => {
    if (window.history.length > 1) {
      navigate(-1);
    } else {
      navigate(fallbackPath);
    }
  }, [navigate]);
  
  // Navigate and scroll to top
  const navigateAndScroll = useCallback((
    path: string,
    state?: NavigationState
  ) => {
    navigate(path, { state });
    window.scrollTo(0, 0);
  }, [navigate]);
  
  // Replace current route (for redirects)
  const redirect = useCallback((path: string) => {
    navigate(path, { replace: true });
  }, [navigate]);
  
  return {
    navigateTo,
    navigateBack,
    navigateAndScroll,
    redirect,
    navigate // Still expose raw navigate if needed
  };
}

// Usage
function MyComponent() {
  const { navigateTo, navigateBack } = useAppNavigation();
  
  const handleAction = () => {
    // Automatically tracks "from" location
    navigateTo('/products/123', {
      category: 'electronics'
    });
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={handleAction}&gt;View Product&lt;/button&gt;
      &lt;button onClick={() => navigateBack('/home')}&gt;
        Back
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Route Parameter Validation</h3>
                <p>Validate and parse route parameters with a custom hook:</p>

                <pre><code class="language-typescript">import { useParams, useNavigate } from 'react-router-dom';
import { useEffect } from 'react';

// Generic parameter validator
function useValidatedParams&lt;T extends Record&lt;string, unknown&gt;&gt;(
  validators: {
    [K in keyof T]: (value: string | undefined) => T[K] | null;
  }
): T | null {
  const params = useParams();
  const navigate = useNavigate();
  
  const validated = Object.entries(validators).reduce(
    (acc, [key, validator]) => {
      const value = params[key];
      const validated = validator(value);
      
      if (validated === null) {
        return null;
      }
      
      return { ...acc, [key]: validated };
    },
    {} as T | null
  );
  
  useEffect(() => {
    if (validated === null) {
      // Redirect on invalid params
      navigate('/404', { replace: true });
    }
  }, [validated, navigate]);
  
  return validated;
}

// Validator functions
const validators = {
  productId: (value: string | undefined): number | null => {
    if (!value) return null;
    const num = parseInt(value, 10);
    return !isNaN(num) && num > 0 ? num : null;
  },
  
  userId: (value: string | undefined): number | null => {
    if (!value) return null;
    const num = parseInt(value, 10);
    return !isNaN(num) && num > 0 ? num : null;
  },
  
  slug: (value: string | undefined): string | null => {
    if (!value) return null;
    // Validate slug format: lowercase, hyphens, alphanumeric
    return /^[a-z0-9-]+$/.test(value) ? value : null;
  }
};

// Usage
interface ProductParams {
  productId: number;
  slug: string;
}

function ProductDetail() {
  const params = useValidatedParams&lt;ProductParams&gt;({
    productId: validators.productId,
    slug: validators.slug
  });
  
  if (!params) {
    return null; // Will redirect to 404
  }
  
  // TypeScript knows productId is number and slug is string
  return (
    &lt;div&gt;
      &lt;h1&gt;Product {params.productId}&lt;/h1&gt;
      &lt;p&gt;Slug: {params.slug}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Navigation Guards</h3>
                <p>Implement navigation guards to control access to routes:</p>

                <pre><code class="language-typescript">import { useLocation, useNavigate } from 'react-router-dom';
import { useEffect } from 'react';

interface GuardOptions {
  requireAuth?: boolean;
  requireRole?: string[];
  redirectTo?: string;
}

function useNavigationGuard(options: GuardOptions) {
  const location = useLocation();
  const navigate = useNavigate();
  
  useEffect(() => {
    const checkAccess = () => {
      // Check authentication
      if (options.requireAuth) {
        const isAuthenticated = checkAuth(); // Your auth check
        
        if (!isAuthenticated) {
          navigate(options.redirectTo || '/login', {
            state: { from: location.pathname },
            replace: true
          });
          return false;
        }
      }
      
      // Check roles
      if (options.requireRole) {
        const userRole = getUserRole(); // Your role check
        
        if (!options.requireRole.includes(userRole)) {
          navigate('/unauthorized', { replace: true });
          return false;
        }
      }
      
      return true;
    };
    
    checkAccess();
  }, [location, navigate, options]);
}

// Usage
function AdminDashboard() {
  useNavigationGuard({
    requireAuth: true,
    requireRole: ['admin', 'moderator'],
    redirectTo: '/login'
  });
  
  return &lt;div&gt;Admin Dashboard&lt;/div&gt;;
}

function UserProfile() {
  useNavigationGuard({
    requireAuth: true,
    redirectTo: '/login'
  });
  
  return &lt;div&gt;User Profile&lt;/div&gt;;
}</code></pre>

                <h3>Breadcrumb Hook</h3>
                <p>Create a reusable breadcrumb hook:</p>

                <pre><code class="language-typescript">import { useLocation } from 'react-router-dom';
import { useMemo } from 'react';

interface Breadcrumb {
  path: string;
  label: string;
  isLast: boolean;
}

// Route label mapping
const routeLabels: Record&lt;string, string&gt; = {
  '/products': 'Products',
  '/users': 'Users',
  '/settings': 'Settings',
  '/blog': 'Blog',
  '/admin': 'Administration',
  '/dashboard': 'Dashboard'
};

function useBreadcrumbs(): Breadcrumb[] {
  const location = useLocation();
  
  const breadcrumbs = useMemo(() => {
    const pathnames = location.pathname.split('/').filter(x => x);
    
    if (pathnames.length === 0) {
      return [];
    }
    
    return pathnames.map((segment, index) => {
      const path = `/${pathnames.slice(0, index + 1).join('/')}`;
      const isLast = index === pathnames.length - 1;
      
      // Try to get custom label, or format the segment
      const label = routeLabels[path] || 
        segment
          .replace(/-/g, ' ')
          .replace(/\b\w/g, char => char.toUpperCase());
      
      return { path, label, isLast };
    });
  }, [location.pathname]);
  
  return breadcrumbs;
}

// Usage
function BreadcrumbNav() {
  const breadcrumbs = useBreadcrumbs();
  
  if (breadcrumbs.length === 0) {
    return null;
  }
  
  return (
    &lt;nav className="breadcrumb"&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
      {breadcrumbs.map(crumb => (
        &lt;span key={crumb.path}&gt;
          &lt;span className="separator"&gt; / &lt;/span&gt;
          {crumb.isLast ? (
            &lt;span&gt;{crumb.label}&lt;/span&gt;
          ) : (
            &lt;Link to={crumb.path}&gt;{crumb.label}&lt;/Link&gt;
          )}
        &lt;/span&gt;
      ))}
    &lt;/nav&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Advanced Pattern Best Practices</h4>
                    <ul>
                        <li><strong>Centralize route definitions</strong> - Use constants for all routes</li>
                        <li><strong>Create custom hooks</strong> - Wrap common patterns in reusable hooks</li>
                        <li><strong>Validate parameters</strong> - Don't trust URL parameters, validate them</li>
                        <li><strong>Handle edge cases</strong> - Always have fallbacks for missing data</li>
                        <li><strong>Type everything</strong> - Use TypeScript for all route-related code</li>
                        <li><strong>Guard routes</strong> - Protect sensitive routes with navigation guards</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: Advanced Blog Navigation</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Enhance the blog application with advanced navigation features.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create a centralized ROUTES object with all blog routes</li>
                        <li>Create a custom <code>useBlogNavigation</code> hook</li>
                        <li>Add route parameter validation for postId (must be positive integer)</li>
                        <li>Implement a breadcrumb component using <code>useLocation</code></li>
                        <li>Add navigation guards for the edit post route</li>
                        <li>Track navigation history and show "recently viewed posts"</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Structure your solution in steps:</p>
                        <ol>
                            <li>Define ROUTES object first</li>
                            <li>Create custom navigation hook</li>
                            <li>Add validation logic</li>
                            <li>Implement breadcrumbs</li>
                            <li>Add guards last</li>
                        </ol>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">// routes.ts
export const ROUTES = {
  home: '/',
  blog: {
    home: '/blog',
    post: (id: number | string) => `/blog/${id}`,
    category: (cat: string) => `/blog/category/${cat}`,
    edit: (id: number | string) => `/blog/edit/${id}`,
    new: '/blog/new'
  }
} as const;

// useBlogNavigation.ts
export function useBlogNavigation() {
  const navigate = useNavigate();
  const location = useLocation();
  
  const toPost = useCallback((
    postId: number, 
    from?: string
  ) => {
    navigate(ROUTES.blog.post(postId), {
      state: { from: from || location.pathname }
    });
  }, [navigate, location]);
  
  const toCategory = useCallback((category: string) => {
    navigate(ROUTES.blog.category(category));
  }, [navigate]);
  
  const toEdit = useCallback((postId: number) => {
    navigate(ROUTES.blog.edit(postId));
  }, [navigate]);
  
  return { toPost, toCategory, toEdit };
}

// useValidatedPostId.ts
function useValidatedPostId(): number | null {
  const { postId } = useParams&lt;{ postId: string }&gt;();
  const navigate = useNavigate();
  
  const validated = useMemo(() => {
    if (!postId) return null;
    const num = parseInt(postId, 10);
    return !isNaN(num) && num > 0 ? num : null;
  }, [postId]);
  
  useEffect(() => {
    if (validated === null) {
      navigate('/blog', { replace: true });
    }
  }, [validated, navigate]);
  
  return validated;
}

// BlogPost.tsx
function BlogPost() {
  const postId = useValidatedPostId();
  const { toEdit } = useBlogNavigation();
  
  if (!postId) return null;
  
  return (
    &lt;article&gt;
      &lt;BlogBreadcrumbs /&gt;
      &lt;h1&gt;Post {postId}&lt;/h1&gt;
      &lt;button onClick={() => toEdit(postId)}&gt;
        Edit
      &lt;/button&gt;
    &lt;/article&gt;
  );
}

// BlogBreadcrumbs.tsx
function BlogBreadcrumbs() {
  const location = useLocation();
  const segments = location.pathname.split('/').filter(x => x);
  
  return (
    &lt;nav&gt;
      &lt;Link to={ROUTES.home}&gt;Home&lt;/Link&gt;
      {segments.map((seg, i) => (
        &lt;span key={i}&gt;
          {' / '}
          &lt;Link to={`/${segments.slice(0, i + 1).join('/')}`}&gt;
            {seg}
          &lt;/Link&gt;
        &lt;/span&gt;
      ))}
    &lt;/nav&gt;
  );
}

// EditPost.tsx
function EditPost() {
  const postId = useValidatedPostId();
  
  // Navigation guard
  useEffect(() => {
    const canEdit = checkEditPermissions(postId);
    if (!canEdit) {
      navigate('/unauthorized', { replace: true });
    }
  }, [postId]);
  
  if (!postId) return null;
  
  return &lt;div&gt;Edit Post {postId}&lt;/div&gt;;
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 8: Summary and Next Steps -->
            <section id="section8" aria-labelledby="section8-title">
                <h2 id="section8-title">üéØ Summary and Next Steps</h2>
                
                <h3>What You've Learned</h3>
                <p>In this lesson, you've mastered advanced React Router concepts:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìö Key Concepts Covered</h4>
                    <ul style="color: white;">
                        <li><strong>Nested Routes</strong> - Building hierarchical route structures with shared layouts</li>
                        <li><strong>Dynamic Parameters</strong> - Creating flexible routes with URL parameters</li>
                        <li><strong>useParams Hook</strong> - Accessing and typing route parameters with TypeScript</li>
                        <li><strong>useNavigate Hook</strong> - Programmatic navigation and state passing</li>
                        <li><strong>useLocation Hook</strong> - Accessing current location and navigation state</li>
                        <li><strong>Advanced Patterns</strong> - Custom hooks, validation, guards, and centralized routes</li>
                    </ul>
                </div>

                <h3>Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Hook</th>
                            <th>Purpose</th>
                            <th>Common Use Cases</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>useParams</code></td>
                            <td>Access URL parameters</td>
                            <td>User IDs, post slugs, product IDs</td>
                        </tr>
                        <tr>
                            <td><code>useNavigate</code></td>
                            <td>Navigate programmatically</td>
                            <td>Form submissions, redirects, after actions</td>
                        </tr>
                        <tr>
                            <td><code>useLocation</code></td>
                            <td>Access current location</td>
                            <td>Breadcrumbs, analytics, state passing</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Patterns Cheat Sheet</h3>
                <pre><code class="language-typescript">// Pattern 1: Get URL parameter
const { userId } = useParams&lt;{ userId: string }&gt;();

// Pattern 2: Navigate after action
const navigate = useNavigate();
const handleSubmit = () => {
  // ... save data
  navigate('/success');
};

// Pattern 3: Navigate with state
navigate('/products/123', {
  state: { from: 'search', query: 'laptop' }
});

// Pattern 4: Navigate with replace
navigate('/login', { replace: true });

// Pattern 5: Go back
navigate(-1);

// Pattern 6: Access location state
const location = useLocation();
const state = location.state as MyStateType;

// Pattern 7: Conditional back button
const handleBack = () => {
  if (state?.from) {
    navigate(state.from);
  } else {
    navigate(-1);
  }
};

// Pattern 8: Validate parameters
const postId = parseInt(useParams().postId || '', 10);
if (isNaN(postId)) {
  navigate('/404', { replace: true });
}</code></pre>

                <h3>Best Practices Checklist</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do's</h4>
                    <ul>
                        <li>Always type your route parameters with TypeScript</li>
                        <li>Validate URL parameters before using them</li>
                        <li>Handle missing or invalid parameters gracefully</li>
                        <li>Use <code>replace: true</code> for redirects</li>
                        <li>Create custom hooks for common patterns</li>
                        <li>Centralize route definitions</li>
                        <li>Pass minimal state through navigation</li>
                        <li>Provide fallback navigation for edge cases</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Don'ts</h4>
                    <ul>
                        <li>Don't assume parameters are always present</li>
                        <li>Don't store sensitive data in location state</li>
                        <li>Don't navigate during render (use useEffect)</li>
                        <li>Don't use <code>any</code> type for parameters</li>
                        <li>Don't rely on location state after refresh</li>
                        <li>Don't forget to handle navigation errors</li>
                        <li>Don't hardcode URLs (use constants)</li>
                    </ul>
                </div>

                <h3>Common Gotchas</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>‚ö†Ô∏è Watch Out For</h4>
                    
                    <p><strong>1. Parameters are always strings</strong></p>
                    <pre><code>const { userId } = useParams();
// userId is "42", not 42
const userIdNum = parseInt(userId || '0', 10);</code></pre>

                    <p><strong>2. Location state disappears on refresh</strong></p>
                    <pre><code>// ‚ùå Don't rely on this after refresh
const state = location.state;

// ‚úÖ Always have a fallback
const userId = state?.userId || fetchFromUrl();</code></pre>

                    <p><strong>3. Optional parameters</strong></p>
                    <pre><code>// Route: /users/:userId/:tab?
const { tab = 'overview' } = useParams();
// Provide default for optional params</code></pre>

                    <p><strong>4. Navigation in render causes errors</strong></p>
                    <pre><code>// ‚ùå Don't do this
if (!user) navigate('/login');

// ‚úÖ Use useEffect
useEffect(() => {
  if (!user) navigate('/login');
}, [user]);</code></pre>
                </div>

                <h3>Practice Projects</h3>
                <p>Solidify your understanding with these practice projects:</p>

                <ol>
                    <li>
                        <strong>E-commerce Product Catalog</strong>
                        <ul>
                            <li>Product listing with category filters</li>
                            <li>Product detail pages with dynamic routes</li>
                            <li>Shopping cart with navigation state</li>
                            <li>Checkout flow with multi-step navigation</li>
                        </ul>
                    </li>
                    <li>
                        <strong>User Dashboard</strong>
                        <ul>
                            <li>User profile with tabbed navigation</li>
                            <li>Settings pages with nested routes</li>
                            <li>Activity feed with pagination in URL</li>
                            <li>Smart breadcrumbs</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Documentation Site</strong>
                        <ul>
                            <li>Hierarchical documentation structure</li>
                            <li>Search with URL query parameters</li>
                            <li>Version selection in routes</li>
                            <li>Previous/next page navigation</li>
                        </ul>
                    </li>
                </ol>

                <h3>Next Lesson Preview</h3>
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üîú Coming Up: Lesson 6.3 - Route Protection and Loading</h4>
                    <p style="color: white;">In the next lesson, you'll learn:</p>
                    <ul style="color: white;">
                        <li>Protected routes and authentication</li>
                        <li>Route guards and permissions</li>
                        <li>Lazy loading routes for better performance</li>
                        <li>React Suspense with routing</li>
                        <li>Loading states and error boundaries</li>
                        <li>Redirect patterns and strategies</li>
                    </ul>
                </div>

                <h3>Additional Resources</h3>
                <ul>
                    <li><a href="https://reactrouter.com/en/main/hooks/use-params" target="_blank">React Router: useParams Documentation</a></li>
                    <li><a href="https://reactrouter.com/en/main/hooks/use-navigate" target="_blank">React Router: useNavigate Documentation</a></li>
                    <li><a href="https://reactrouter.com/en/main/hooks/use-location" target="_blank">React Router: useLocation Documentation</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">TypeScript: Type Narrowing</a></li>
                    <li><a href="https://react.dev/learn/passing-data-deeply-with-context" target="_blank">React: Context (for comparison with routing state)</a></li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéâ Congratulations!</h4>
                    <p>You've completed Lesson 6.2 and now have a solid understanding of advanced React Router concepts. You can:</p>
                    <ul>
                        <li>‚úÖ Build complex nested route structures</li>
                        <li>‚úÖ Work with dynamic route parameters</li>
                        <li>‚úÖ Navigate programmatically with full control</li>
                        <li>‚úÖ Manage navigation state effectively</li>
                        <li>‚úÖ Create type-safe routing with TypeScript</li>
                        <li>‚úÖ Implement advanced routing patterns</li>
                    </ul>
                    <p><strong>Keep practicing and experimenting with these patterns!</strong></p>
                </div>
            </section>

        </div>
    </main>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_6_1_react_router_basics.html" class="prev-lesson">
            <span class="nav-label">‚Üê Previous Lesson</span>
            <span class="nav-title">React Router Basics</span>
        </a>
        <a href="index.html" class="home-link">
            <span class="nav-label">Home</span>
            <span class="nav-title">All Modules</span>
        </a>
        <a href="lesson_6_3_route_protection_loading.html" class="next-lesson">
            <span class="nav-label">Next Lesson ‚Üí</span>
            <span class="nav-title">Route Protection and Loading</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="#">Course Resources</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
