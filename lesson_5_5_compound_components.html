<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master the Compound Components Pattern in React - Learn component composition, implicit state sharing, Context integration, and building flexible reusable component APIs with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>Compound Components Pattern - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.5: Compound Components Pattern</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üß© Compound Components Pattern</h1>
                <p class="lead">Welcome to one of React's most elegant design patterns! You've learned about components, hooks, and context - but what if you could create components that work together like a team, sharing state invisibly while giving users maximum flexibility? That's the power of compound components! Think of them like LEGO blocks that automatically know how to connect - you can arrange them however you want, but they still work together seamlessly. This pattern is used by popular libraries like React Router, Reach UI, and Material-UI. It's the secret sauce behind flexible, intuitive APIs that make developers say "Wow, this just works!" Let's learn how to build components that play nice together! üéØ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what compound components are and why they're useful</li>
                        <li>Build compound components that share state implicitly</li>
                        <li>Use Context API to enable communication between compound components</li>
                        <li>Create flexible, composable component APIs</li>
                        <li>Type compound components properly with TypeScript</li>
                        <li>Implement real-world compound component patterns (Tabs, Accordion, Dropdown)</li>
                        <li>Balance flexibility with developer experience</li>
                        <li>Handle edge cases and provide helpful error messages</li>
                        <li>Compare compound components with other composition patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build flexible Accordion, Tabs, and Select components</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What Are Compound Components?</a></li>
                        <li><a href="#section2" class="toc-link">Why Use Compound Components?</a></li>
                        <li><a href="#section3" class="toc-link">Basic Compound Component Example</a></li>
                        <li><a href="#section4" class="toc-link">Implicit State Sharing with Context</a></li>
                        <li><a href="#section5" class="toc-link">Building a Tabs Component</a></li>
                        <li><a href="#section6" class="toc-link">Building an Accordion Component</a></li>
                        <li><a href="#section7" class="toc-link">Typing Compound Components</a></li>
                        <li><a href="#section8" class="toc-link">Advanced Patterns</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Common Mistakes</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What Are Compound Components? -->
            <section id="section1" class="lesson-section">
                <h2>üéØ What Are Compound Components?</h2>
                <p>Compound components are a pattern where multiple components work together to form a complete, cohesive UI element, sharing state implicitly through context.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Compound Components:</strong> A design pattern where a set of components work together, sharing implicit state through Context, to provide a flexible and intuitive API. The parent component manages state, while child components access it automatically.</p>
                </div>

                <h3>Real-World Analogy</h3>
                <div class="card">
                    <h4>üé∏ The Band Analogy</h4>
                    <p>Think of a rock band:</p>
                    <ul>
                        <li><strong>The Band (Parent Component):</strong> Provides the overall direction and tempo - everyone follows the same beat</li>
                        <li><strong>Individual Musicians (Child Components):</strong> Each plays their own part, but they all share the same rhythm and key</li>
                        <li><strong>Implicit Communication:</strong> Musicians don't need to explicitly tell each other the tempo - they all "feel" it</li>
                        <li><strong>Flexibility:</strong> You can arrange musicians in different orders, but they still play together harmoniously</li>
                    </ul>
                    <p>That's exactly how compound components work - each child component knows how to coordinate with its siblings without explicit instructions!</p>
                </div>

                <h3>Visual Example</h3>
                <p>Here's how compound components look in code:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Compound Components - Flexible and Intuitive
&lt;Tabs defaultValue="profile"&gt;
    &lt;TabList&gt;
        &lt;Tab value="profile"&gt;Profile&lt;/Tab&gt;
        &lt;Tab value="settings"&gt;Settings&lt;/Tab&gt;
        &lt;Tab value="notifications"&gt;Notifications&lt;/Tab&gt;
    &lt;/TabList&gt;
    
    &lt;TabPanel value="profile"&gt;
        &lt;h2&gt;Your Profile&lt;/h2&gt;
        &lt;p&gt;Profile content here...&lt;/p&gt;
    &lt;/TabPanel&gt;
    
    &lt;TabPanel value="settings"&gt;
        &lt;h2&gt;Settings&lt;/h2&gt;
        &lt;p&gt;Settings content here...&lt;/p&gt;
    &lt;/TabPanel&gt;
    
    &lt;TabPanel value="notifications"&gt;
        &lt;h2&gt;Notifications&lt;/h2&gt;
        &lt;p&gt;Notifications content here...&lt;/p&gt;
    &lt;/TabPanel&gt;
&lt;/Tabs&gt;

// Notice:
// - Tab, TabPanel components "just know" which tab is active
// - No explicit state management from the user
// - Flexible arrangement - you can reorder components
// - Clean, declarative API</code></pre>
                </div>

                <h3>Compare with Traditional Approach</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Traditional Prop-based Approach - Rigid and Verbose
&lt;Tabs
    defaultValue="profile"
    tabs={[
        { value: 'profile', label: 'Profile' },
        { value: 'settings', label: 'Settings' },
        { value: 'notifications', label: 'Notifications' }
    ]}
    panels={[
        { value: 'profile', content: &lt;ProfileContent /&gt; },
        { value: 'settings', content: &lt;SettingsContent /&gt; },
        { value: 'notifications', content: &lt;NotificationsContent /&gt; }
    ]}
/&gt;

// Problems:
// - Less flexible - all data must be in arrays
// - Harder to customize individual tabs/panels
// - Less intuitive - not declarative
// - Awkward to conditionally render tabs</code></pre>
                </div>

                <h3>Key Characteristics</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Characteristic</th>
                            <th>Description</th>
                            <th>Benefit</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Implicit State Sharing</strong></td>
                            <td>Child components access parent state via Context</td>
                            <td>No prop drilling, cleaner API</td>
                        </tr>
                        <tr>
                            <td><strong>Flexible Composition</strong></td>
                            <td>Components can be arranged in any order</td>
                            <td>Adapts to different use cases</td>
                        </tr>
                        <tr>
                            <td><strong>Declarative API</strong></td>
                            <td>UI structure matches component structure</td>
                            <td>Easy to understand and maintain</td>
                        </tr>
                        <tr>
                            <td><strong>Separation of Concerns</strong></td>
                            <td>Parent manages state, children render UI</td>
                            <td>Clear responsibilities</td>
                        </tr>
                    </tbody>
                </table>

                <h3>How They Work</h3>
                <div class="mermaid">
                graph TD
                    A[Parent Component] --> B[Creates Context]
                    B --> C[Manages State]
                    C --> D[Provides State via Context]
                    D --> E[Child Component 1]
                    D --> F[Child Component 2]
                    D --> G[Child Component 3]
                    
                    E --> H[Consumes Context]
                    F --> I[Consumes Context]
                    G --> J[Consumes Context]
                    
                    H --> K[Accesses Shared State]
                    I --> K
                    J --> K
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style K fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Magic</h4>
                    <p>The "magic" of compound components is that child components automatically access parent state through Context, without the user needing to pass props explicitly. This makes the API feel natural and intuitive!</p>
                </div>
            </section>

            <!-- Section 2: Why Use Compound Components? -->
            <section id="section2" class="lesson-section">
                <h2>ü§î Why Use Compound Components?</h2>
                <p>Compound components solve several common problems in component design. Let's explore the benefits and when to use this pattern.</p>

                <h3>Problem 1: Prop Drilling</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Without Compound Components - Prop Drilling Hell
function Select({ value, onChange, options }: SelectProps) {
    return (
        &lt;div&gt;
            &lt;SelectTrigger value={value} /&gt;
            &lt;SelectDropdown
                isOpen={isOpen}
                value={value}
                onChange={onChange}
                onClose={() => setIsOpen(false)}
            &gt;
                {options.map(opt => (
                    &lt;SelectOption
                        key={opt.value}
                        value={opt.value}
                        isSelected={value === opt.value}
                        onClick={() => {
                            onChange(opt.value);
                            setIsOpen(false);
                        }}
                    &gt;
                        {opt.label}
                    &lt;/SelectOption&gt;
                ))}
            &lt;/SelectDropdown&gt;
        &lt;/div&gt;
    );
}

// So much prop passing! And users can't even customize the structure!</code></pre>
                </div>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ With Compound Components - Clean and Flexible
&lt;Select value={selected} onChange={setSelected}&gt;
    &lt;SelectTrigger /&gt;
    &lt;SelectDropdown&gt;
        &lt;SelectOption value="red"&gt;Red&lt;/SelectOption&gt;
        &lt;SelectOption value="blue"&gt;Blue&lt;/SelectOption&gt;
        &lt;SelectOption value="green"&gt;Green&lt;/SelectOption&gt;
    &lt;/SelectDropdown&gt;
&lt;/Select&gt;

// All components automatically access value, onChange, etc. via Context!
// No prop drilling needed!</code></pre>
                </div>

                <h3>Problem 2: Inflexible APIs</h3>
                <div class="card">
                    <h4>Scenario: You need to customize a Tab component</h4>
                    <p><strong>With traditional props:</strong></p>
                    <ul>
                        <li>Want an icon in one tab? Need to add iconPosition prop</li>
                        <li>Want a badge? Need to add badge prop</li>
                        <li>Want custom styling? Need to add className prop</li>
                        <li>Soon you have 20+ props and it's still not flexible enough!</li>
                    </ul>
                    <p><strong>With compound components:</strong></p>
                    <ul>
                        <li>Just put whatever you want inside &lt;Tab&gt;...&lt;/Tab&gt;</li>
                        <li>Icons, badges, tooltips - anything!</li>
                        <li>Full control, minimal API surface</li>
                    </ul>
                </div>

                <h3>Problem 3: Poor Developer Experience</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Traditional Approach</th>
                            <th>Compound Components</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Pass arrays of configuration objects</td>
                            <td>Write declarative JSX</td>
                        </tr>
                        <tr>
                            <td>Hard to conditionally render items</td>
                            <td>Use standard JavaScript conditions</td>
                        </tr>
                        <tr>
                            <td>Difficult to customize individual items</td>
                            <td>Customize each component directly</td>
                        </tr>
                        <tr>
                            <td>Need to learn custom configuration format</td>
                            <td>Already know JSX!</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Benefits of Compound Components</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li><strong>Flexibility:</strong> Users can arrange and customize components however they need</li>
                        <li><strong>Intuitive API:</strong> Declarative JSX feels natural to React developers</li>
                        <li><strong>Minimal Prop Drilling:</strong> State shared implicitly through Context</li>
                        <li><strong>Extensibility:</strong> Easy to add new child components without breaking changes</li>
                        <li><strong>Separation of Concerns:</strong> Parent manages logic, children handle presentation</li>
                        <li><strong>Composability:</strong> Easy to combine with other patterns and components</li>
                        <li><strong>Type Safety:</strong> TypeScript can enforce component relationships</li>
                    </ul>
                </div>

                <h3>When to Use Compound Components</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Perfect Use Cases</h4>
                    <ul>
                        <li><strong>UI Controls:</strong> Tabs, Accordions, Dropdowns, Selects, Modals</li>
                        <li><strong>Navigation:</strong> Menus, Breadcrumbs, Pagination</li>
                        <li><strong>Layout Components:</strong> Split panes, Grids, Cards with headers/footers</li>
                        <li><strong>Forms:</strong> Form groups with labels, inputs, and error messages</li>
                        <li><strong>Data Display:</strong> Tables with sortable columns, expandable rows</li>
                        <li><strong>Interactive Widgets:</strong> Carousels, Steppers, Wizards</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use</h4>
                    <ul>
                        <li>Simple components with few variants (overkill)</li>
                        <li>Components that don't need shared state</li>
                        <li>When the component structure should always be the same</li>
                        <li>When performance is critical (Context can cause re-renders)</li>
                        <li>When you need strict control over component order</li>
                    </ul>
                </div>

                <h3>Real-World Examples</h3>
                <p>Many popular libraries use compound components:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// React Router - Compound components for routing
&lt;BrowserRouter&gt;
    &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
    &lt;/Routes&gt;
&lt;/BrowserRouter&gt;

// Reach UI - Accessible components
&lt;Menu&gt;
    &lt;MenuButton&gt;Actions&lt;/MenuButton&gt;
    &lt;MenuList&gt;
        &lt;MenuItem onSelect={() => {}}&gt;Download&lt;/MenuItem&gt;
        &lt;MenuItem onSelect={() => {}}&gt;Copy&lt;/MenuItem&gt;
        &lt;MenuItem onSelect={() => {}}&gt;Delete&lt;/MenuItem&gt;
    &lt;/MenuList&gt;
&lt;/Menu&gt;

// Radix UI - Headless UI components
&lt;Dialog.Root&gt;
    &lt;Dialog.Trigger&gt;Open&lt;/Dialog.Trigger&gt;
    &lt;Dialog.Portal&gt;
        &lt;Dialog.Overlay /&gt;
        &lt;Dialog.Content&gt;
            &lt;Dialog.Title&gt;Title&lt;/Dialog.Title&gt;
            &lt;Dialog.Description&gt;Description&lt;/Dialog.Description&gt;
            &lt;Dialog.Close&gt;Close&lt;/Dialog.Close&gt;
        &lt;/Dialog.Content&gt;
    &lt;/Dialog.Portal&gt;
&lt;/Dialog.Root&gt;</code></pre>
                </div>
            </section>

            <!-- Section 3: Basic Compound Component Example -->
            <section id="section3" class="lesson-section">
                <h2>üéØ Basic Compound Component Example</h2>
                <p>Let's build a simple compound component from scratch to understand the pattern. We'll create a Counter with separate buttons for increment and decrement.</p>

                <h3>Step 1: Create the Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, useState, ReactNode } from 'react';

// Define the shape of our shared state
interface CounterContextValue {
    count: number;
    increment: () => void;
    decrement: () => void;
}

// Create the context
const CounterContext = createContext&lt;CounterContextValue | undefined&gt;(undefined);

// Custom hook to access the context
function useCounter() {
    const context = useContext(CounterContext);
    if (!context) {
        throw new Error('Counter compound components must be used within Counter');
    }
    return context;
}</code></pre>
                </div>

                <h3>Step 2: Create the Parent Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface CounterProps {
    children: ReactNode;
    initialCount?: number;
}

function Counter({ children, initialCount = 0 }: CounterProps) {
    const [count, setCount] = useState(initialCount);
    
    const increment = () => setCount(c => c + 1);
    const decrement = () => setCount(c => c - 1);
    
    const value: CounterContextValue = {
        count,
        increment,
        decrement
    };
    
    return (
        &lt;CounterContext.Provider value={value}&gt;
            &lt;div className="counter"&gt;
                {children}
            &lt;/div&gt;
        &lt;/CounterContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Step 3: Create Child Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Display Component
function CounterDisplay() {
    const { count } = useCounter();
    return &lt;div className="counter-display"&gt;Count: {count}&lt;/div&gt;;
}

// Increment Button
function CounterIncrement({ children }: { children: ReactNode }) {
    const { increment } = useCounter();
    return (
        &lt;button onClick={increment} className="counter-button"&gt;
            {children || '+'}
        &lt;/button&gt;
    );
}

// Decrement Button
function CounterDecrement({ children }: { children: ReactNode }) {
    const { decrement } = useCounter();
    return (
        &lt;button onClick={decrement} className="counter-button"&gt;
            {children || '-'}
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Step 4: Attach Components to Parent</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Attach child components as properties of parent
Counter.Display = CounterDisplay;
Counter.Increment = CounterIncrement;
Counter.Decrement = CounterDecrement;

// Export the compound component
export { Counter };</code></pre>
                </div>

                <h3>Step 5: Usage</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Basic usage
function App() {
    return (
        &lt;Counter initialCount={10}&gt;
            &lt;Counter.Display /&gt;
            &lt;Counter.Increment /&gt;
            &lt;Counter.Decrement /&gt;
        &lt;/Counter&gt;
    );
}

// ‚úÖ Flexible arrangement
function App2() {
    return (
        &lt;Counter&gt;
            &lt;Counter.Increment&gt;Add One&lt;/Counter.Increment&gt;
            &lt;Counter.Display /&gt;
            &lt;Counter.Decrement&gt;Subtract One&lt;/Counter.Decrement&gt;
        &lt;/Counter&gt;
    );
}

// ‚úÖ Custom layout
function App3() {
    return (
        &lt;Counter&gt;
            &lt;div className="counter-controls"&gt;
                &lt;Counter.Decrement /&gt;
                &lt;Counter.Display /&gt;
                &lt;Counter.Increment /&gt;
            &lt;/div&gt;
        &lt;/Counter&gt;
    );
}

// Notice: No props needed! Components access state via Context.</code></pre>
                </div>

                <h3>Complete Example</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Full implementation in one place
import { createContext, useContext, useState, ReactNode } from 'react';

// Context
interface CounterContextValue {
    count: number;
    increment: () => void;
    decrement: () => void;
}

const CounterContext = createContext&lt;CounterContextValue | undefined&gt;(undefined);

function useCounter() {
    const context = useContext(CounterContext);
    if (!context) {
        throw new Error('Counter compound components must be used within Counter');
    }
    return context;
}

// Parent Component
interface CounterProps {
    children: ReactNode;
    initialCount?: number;
}

function Counter({ children, initialCount = 0 }: CounterProps) {
    const [count, setCount] = useState(initialCount);
    
    const value: CounterContextValue = {
        count,
        increment: () => setCount(c => c + 1),
        decrement: () => setCount(c => c - 1)
    };
    
    return (
        &lt;CounterContext.Provider value={value}&gt;
            &lt;div className="counter"&gt;{children}&lt;/div&gt;
        &lt;/CounterContext.Provider&gt;
    );
}

// Child Components
Counter.Display = function CounterDisplay() {
    const { count } = useCounter();
    return &lt;div className="counter-display"&gt;{count}&lt;/div&gt;;
};

Counter.Increment = function CounterIncrement({ 
    children = '+' 
}: { 
    children?: ReactNode 
}) {
    const { increment } = useCounter();
    return &lt;button onClick={increment}&gt;{children}&lt;/button&gt;;
};

Counter.Decrement = function CounterDecrement({ 
    children = '-' 
}: { 
    children?: ReactNode 
}) {
    const { decrement } = useCounter();
    return &lt;button onClick={decrement}&gt;{children}&lt;/button&gt;;
};

export { Counter };</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Takeaways</h4>
                    <ul>
                        <li>Parent component creates Context and provides state</li>
                        <li>Child components consume Context via custom hook</li>
                        <li>Child components attached as properties of parent (Counter.Display)</li>
                        <li>Error thrown if child used outside parent (helpful for developers)</li>
                        <li>Users get flexible, intuitive API without prop drilling</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Implicit State Sharing with Context -->
            <section id="section4" class="lesson-section">
                <h2>üîó Implicit State Sharing with Context</h2>
                <p>The power of compound components comes from Context. Let's dive deeper into how to use Context effectively for implicit state sharing.</p>

                <h3>Understanding Implicit vs Explicit State</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Approach</th>
                            <th>How It Works</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Explicit (Props)</strong></td>
                            <td>Parent passes state to each child via props</td>
                            <td>&lt;Tab isActive={true} onClick={...} /&gt;</td>
                        </tr>
                        <tr>
                            <td><strong>Implicit (Context)</strong></td>
                            <td>Children automatically access parent's context</td>
                            <td>&lt;Tab /&gt; {/* Knows if it's active! */}</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Context Pattern for Compound Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { createContext, useContext, ReactNode } from 'react';

// 1. Define the context value type
interface MyComponentContextValue {
    // Shared state
    isOpen: boolean;
    selectedId: string | null;
    
    // Shared actions
    open: () => void;
    close: () => void;
    select: (id: string) => void;
}

// 2. Create the context with undefined default
const MyComponentContext = createContext&lt;MyComponentContextValue | undefined&gt;(undefined);

// 3. Create a custom hook with error checking
function useMyComponent() {
    const context = useContext(MyComponentContext);
    
    if (context === undefined) {
        throw new Error(
            'useMyComponent must be used within a MyComponent. ' +
            'Make sure child components are wrapped in &lt;MyComponent&gt;...&lt;/MyComponent&gt;'
        );
    }
    
    return context;
}

// 4. Parent provides the context
function MyComponent({ children }: { children: ReactNode }) {
    const [isOpen, setIsOpen] = useState(false);
    const [selectedId, setSelectedId] = useState&lt;string | null&gt;(null);
    
    const value: MyComponentContextValue = {
        isOpen,
        selectedId,
        open: () => setIsOpen(true),
        close: () => setIsOpen(false),
        select: (id) => setSelectedId(id)
    };
    
    return (
        &lt;MyComponentContext.Provider value={value}&gt;
            {children}
        &lt;/MyComponentContext.Provider&gt;
    );
}

// 5. Children consume the context
function MyComponentChild() {
    const { isOpen, open, close } = useMyComponent();
    
    return (
        &lt;button onClick={isOpen ? close : open}&gt;
            {isOpen ? 'Close' : 'Open'}
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Advanced Context Pattern: Separation of Concerns</h3>
                <p>For more complex components, separate state management from context provision:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Custom hook for state logic
function useTabsState(defaultValue?: string) {
    const [activeTab, setActiveTab] = useState(defaultValue);
    
    const selectTab = useCallback((value: string) => {
        setActiveTab(value);
    }, []);
    
    const isActive = useCallback((value: string) => {
        return activeTab === value;
    }, [activeTab]);
    
    return {
        activeTab,
        selectTab,
        isActive
    };
}

// Context type
interface TabsContextValue {
    activeTab: string | undefined;
    selectTab: (value: string) => void;
    isActive: (value: string) => boolean;
}

const TabsContext = createContext&lt;TabsContextValue | undefined&gt;(undefined);

// Parent component
interface TabsProps {
    children: ReactNode;
    defaultValue?: string;
    value?: string;
    onChange?: (value: string) => void;
}

function Tabs({ children, defaultValue, value, onChange }: TabsProps) {
    const state = useTabsState(defaultValue);
    
    // Controlled vs Uncontrolled
    const activeTab = value !== undefined ? value : state.activeTab;
    const selectTab = onChange !== undefined ? onChange : state.selectTab;
    
    const contextValue: TabsContextValue = {
        activeTab,
        selectTab,
        isActive: (val) => activeTab === val
    };
    
    return (
        &lt;TabsContext.Provider value={contextValue}&gt;
            &lt;div className="tabs"&gt;{children}&lt;/div&gt;
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Controlled vs Uncontrolled Compound Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Uncontrolled - Component manages its own state
function UncontrolledExample() {
    return (
        &lt;Tabs defaultValue="home"&gt;
            &lt;TabList&gt;
                &lt;Tab value="home"&gt;Home&lt;/Tab&gt;
                &lt;Tab value="profile"&gt;Profile&lt;/Tab&gt;
            &lt;/TabList&gt;
        &lt;/Tabs&gt;
    );
}

// Controlled - Parent manages state
function ControlledExample() {
    const [activeTab, setActiveTab] = useState('home');
    
    return (
        &lt;Tabs value={activeTab} onChange={setActiveTab}&gt;
            &lt;TabList&gt;
                &lt;Tab value="home"&gt;Home&lt;/Tab&gt;
                &lt;Tab value="profile"&gt;Profile&lt;/Tab&gt;
            &lt;/TabList&gt;
        &lt;/Tabs&gt;
    );
}

// Hybrid - Support both patterns
function Tabs({ children, defaultValue, value, onChange }: TabsProps) {
    const [internalValue, setInternalValue] = useState(defaultValue);
    
    // Use external value if provided, otherwise internal
    const currentValue = value !== undefined ? value : internalValue;
    const handleChange = onChange !== undefined ? onChange : setInternalValue;
    
    const contextValue = {
        activeTab: currentValue,
        selectTab: handleChange,
        isActive: (val: string) => currentValue === val
    };
    
    return (
        &lt;TabsContext.Provider value={contextValue}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Performance Optimization with Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ö†Ô∏è Problem: Context value recreated every render
function TabsBad({ children }: { children: ReactNode }) {
    const [activeTab, setActiveTab] = useState('home');
    
    // New object every render! Causes all consumers to re-render
    const value = {
        activeTab,
        selectTab: setActiveTab,
        isActive: (val: string) => activeTab === val
    };
    
    return (
        &lt;TabsContext.Provider value={value}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}

// ‚úÖ Solution: Memoize context value
function TabsGood({ children }: { children: ReactNode }) {
    const [activeTab, setActiveTab] = useState('home');
    
    const value = useMemo(() => ({
        activeTab,
        selectTab: setActiveTab,
        isActive: (val: string) => activeTab === val
    }), [activeTab]);
    
    return (
        &lt;TabsContext.Provider value={value}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}

// üî• Best: Memoize functions separately
function TabsBest({ children }: { children: ReactNode }) {
    const [activeTab, setActiveTab] = useState('home');
    
    const selectTab = useCallback((value: string) => {
        setActiveTab(value);
    }, []);
    
    const isActive = useCallback((value: string) => {
        return value === activeTab;
    }, [activeTab]);
    
    const value = useMemo(() => ({
        activeTab,
        selectTab,
        isActive
    }), [activeTab, selectTab, isActive]);
    
    return (
        &lt;TabsContext.Provider value={value}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Context Best Practices</h4>
                    <ul>
                        <li>Always provide helpful error messages when context is undefined</li>
                        <li>Memoize context value to prevent unnecessary re-renders</li>
                        <li>Use useCallback for functions in context</li>
                        <li>Support both controlled and uncontrolled modes when possible</li>
                        <li>Keep context value as minimal as possible</li>
                        <li>Consider splitting into multiple contexts for complex state</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Context Pitfalls</h4>
                    <ul>
                        <li>Forgetting to memoize context value (causes unnecessary re-renders)</li>
                        <li>Not checking if context is undefined in custom hook</li>
                        <li>Putting too much state in one context (split it up!)</li>
                        <li>Creating new functions in context value on every render</li>
                        <li>Not supporting both controlled and uncontrolled modes</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Building a Tabs Component -->
            <section id="section5" class="lesson-section">
                <h2>üìë Building a Tabs Component</h2>
                <p>Let's build a complete, production-ready Tabs component using the compound components pattern.</p>

                <h3>Planning the API</h3>
                <p>First, let's decide what our Tabs component should do:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Desired usage
&lt;Tabs defaultValue="profile"&gt;
    &lt;TabList&gt;
        &lt;Tab value="profile"&gt;Profile&lt;/Tab&gt;
        &lt;Tab value="settings"&gt;Settings&lt;/Tab&gt;
        &lt;Tab value="notifications"&gt;Notifications&lt;/Tab&gt;
    &lt;/TabList&gt;
    
    &lt;TabPanel value="profile"&gt;
        Profile content
    &lt;/TabPanel&gt;
    
    &lt;TabPanel value="settings"&gt;
        Settings content
    &lt;/TabPanel&gt;
    
    &lt;TabPanel value="notifications"&gt;
        Notifications content
    &lt;/TabPanel&gt;
&lt;/Tabs&gt;</code></pre>
                </div>

                <h3>Step 1: Context Setup</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { 
    createContext, 
    useContext, 
    useState, 
    useCallback,
    useMemo,
    ReactNode 
} from 'react';

// Context value type
interface TabsContextValue {
    activeTab: string | undefined;
    selectTab: (value: string) => void;
    isActive: (value: string) => boolean;
}

// Create context
const TabsContext = createContext&lt;TabsContextValue | undefined&gt;(undefined);

// Custom hook
function useTabs() {
    const context = useContext(TabsContext);
    
    if (context === undefined) {
        throw new Error(
            'Tabs compound components must be used within &lt;Tabs&gt;. ' +
            'Wrap TabList, Tab, and TabPanel in &lt;Tabs&gt;...&lt;/Tabs&gt;'
        );
    }
    
    return context;
}</code></pre>
                </div>

                <h3>Step 2: Parent Tabs Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface TabsProps {
    children: ReactNode;
    defaultValue?: string;
    value?: string;
    onChange?: (value: string) => void;
    className?: string;
}

function Tabs({ 
    children, 
    defaultValue, 
    value, 
    onChange,
    className = ''
}: TabsProps) {
    // Internal state for uncontrolled mode
    const [internalValue, setInternalValue] = useState(defaultValue);
    
    // Use controlled value if provided, otherwise use internal
    const activeTab = value !== undefined ? value : internalValue;
    
    // Memoized select function
    const selectTab = useCallback((newValue: string) => {
        if (onChange) {
            onChange(newValue); // Controlled mode
        } else {
            setInternalValue(newValue); // Uncontrolled mode
        }
    }, [onChange]);
    
    // Memoized active check
    const isActive = useCallback((tabValue: string) => {
        return activeTab === tabValue;
    }, [activeTab]);
    
    // Memoized context value
    const contextValue = useMemo(() => ({
        activeTab,
        selectTab,
        isActive
    }), [activeTab, selectTab, isActive]);
    
    return (
        &lt;TabsContext.Provider value={contextValue}&gt;
            &lt;div className={`tabs ${className}`}&gt;
                {children}
            &lt;/div&gt;
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Step 3: TabList Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface TabListProps {
    children: ReactNode;
    className?: string;
    'aria-label'?: string;
}

function TabList({ 
    children, 
    className = '',
    'aria-label': ariaLabel = 'Tabs'
}: TabListProps) {
    return (
        &lt;div 
            role="tablist" 
            aria-label={ariaLabel}
            className={`tab-list ${className}`}
        &gt;
            {children}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Step 4: Tab Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface TabProps {
    children: ReactNode;
    value: string;
    disabled?: boolean;
    className?: string;
}

function Tab({ 
    children, 
    value, 
    disabled = false,
    className = ''
}: TabProps) {
    const { isActive, selectTab } = useTabs();
    const active = isActive(value);
    
    const handleClick = () => {
        if (!disabled) {
            selectTab(value);
        }
    };
    
    const handleKeyDown = (e: React.KeyboardEvent) => {
        if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            if (!disabled) {
                selectTab(value);
            }
        }
    };
    
    return (
        &lt;button
            role="tab"
            aria-selected={active}
            aria-controls={`panel-${value}`}
            id={`tab-${value}`}
            tabIndex={active ? 0 : -1}
            disabled={disabled}
            onClick={handleClick}
            onKeyDown={handleKeyDown}
            className={`tab ${active ? 'tab-active' : ''} ${disabled ? 'tab-disabled' : ''} ${className}`}
        &gt;
            {children}
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Step 5: TabPanel Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface TabPanelProps {
    children: ReactNode;
    value: string;
    className?: string;
}

function TabPanel({ 
    children, 
    value,
    className = ''
}: TabPanelProps) {
    const { isActive } = useTabs();
    const active = isActive(value);
    
    if (!active) {
        return null; // Don't render inactive panels
    }
    
    return (
        &lt;div
            role="tabpanel"
            id={`panel-${value}`}
            aria-labelledby={`tab-${value}`}
            tabIndex={0}
            className={`tab-panel ${className}`}
        &gt;
            {children}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Step 6: Attach Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Attach child components to parent
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Export
export { Tabs };
export type { TabsProps, TabListProps, TabProps, TabPanelProps };</code></pre>
                </div>

                <h3>Complete Usage Example</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { Tabs } from './Tabs';

function UserProfile() {
    return (
        &lt;Tabs defaultValue="profile"&gt;
            &lt;Tabs.List&gt;
                &lt;Tabs.Tab value="profile"&gt;
                    üë§ Profile
                &lt;/Tabs.Tab&gt;
                &lt;Tabs.Tab value="settings"&gt;
                    ‚öôÔ∏è Settings
                &lt;/Tabs.Tab&gt;
                &lt;Tabs.Tab value="notifications"&gt;
                    üîî Notifications
                &lt;/Tabs.Tab&gt;
                &lt;Tabs.Tab value="billing" disabled&gt;
                    üí≥ Billing
                &lt;/Tabs.Tab&gt;
            &lt;/Tabs.List&gt;
            
            &lt;Tabs.Panel value="profile"&gt;
                &lt;h2&gt;Your Profile&lt;/h2&gt;
                &lt;p&gt;Manage your personal information&lt;/p&gt;
            &lt;/Tabs.Panel&gt;
            
            &lt;Tabs.Panel value="settings"&gt;
                &lt;h2&gt;Settings&lt;/h2&gt;
                &lt;p&gt;Customize your experience&lt;/p&gt;
            &lt;/Tabs.Panel&gt;
            
            &lt;Tabs.Panel value="notifications"&gt;
                &lt;h2&gt;Notifications&lt;/h2&gt;
                &lt;p&gt;Manage your notifications&lt;/p&gt;
            &lt;/Tabs.Panel&gt;
            
            &lt;Tabs.Panel value="billing"&gt;
                &lt;h2&gt;Billing&lt;/h2&gt;
                &lt;p&gt;Manage your subscription&lt;/p&gt;
            &lt;/Tabs.Panel&gt;
        &lt;/Tabs&gt;
    );
}

// Controlled mode
function ControlledTabs() {
    const [activeTab, setActiveTab] = useState('profile');
    
    useEffect(() => {
        console.log('Active tab changed to:', activeTab);
    }, [activeTab]);
    
    return (
        &lt;Tabs value={activeTab} onChange={setActiveTab}&gt;
            {/* ... same as above */}
        &lt;/Tabs&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Tabs Component Features</h4>
                    <ul>
                        <li>‚úÖ Both controlled and uncontrolled modes</li>
                        <li>‚úÖ Keyboard navigation support</li>
                        <li>‚úÖ Accessible with proper ARIA attributes</li>
                        <li>‚úÖ Disabled tabs support</li>
                        <li>‚úÖ Flexible styling with className props</li>
                        <li>‚úÖ Type-safe with TypeScript</li>
                        <li>‚úÖ Performance optimized with useMemo and useCallback</li>
                        <li>‚úÖ Helpful error messages</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Building an Accordion Component -->
            <section id="section6" class="lesson-section">
                <h2>üìÇ Building an Accordion Component</h2>
                <p>Now let's build an Accordion component that allows multiple items to be expanded or enforces single expansion.</p>

                <h3>Planning the API</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Single expansion mode
&lt;Accordion type="single" defaultValue="item-1"&gt;
    &lt;Accordion.Item value="item-1"&gt;
        &lt;Accordion.Trigger&gt;What is React?&lt;/Accordion.Trigger&gt;
        &lt;Accordion.Content&gt;
            React is a JavaScript library for building user interfaces.
        &lt;/Accordion.Content&gt;
    &lt;/Accordion.Item&gt;
    
    &lt;Accordion.Item value="item-2"&gt;
        &lt;Accordion.Trigger&gt;What is TypeScript?&lt;/Accordion.Trigger&gt;
        &lt;Accordion.Content&gt;
            TypeScript is a typed superset of JavaScript.
        &lt;/Accordion.Content&gt;
    &lt;/Accordion.Item&gt;
&lt;/Accordion&gt;

// Multiple expansion mode
&lt;Accordion type="multiple" defaultValue={["item-1", "item-2"]}&gt;
    {/* Same structure */}
&lt;/Accordion&gt;</code></pre>
                </div>

                <h3>Implementation</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { 
    createContext, 
    useContext, 
    useState, 
    useCallback,
    useMemo,
    ReactNode 
} from 'react';

// Context types
interface AccordionContextValue {
    type: 'single' | 'multiple';
    openItems: string[];
    toggleItem: (value: string) => void;
    isOpen: (value: string) => boolean;
}

const AccordionContext = createContext&lt;AccordionContextValue | undefined&gt;(undefined);

function useAccordion() {
    const context = useContext(AccordionContext);
    if (!context) {
        throw new Error('Accordion components must be used within &lt;Accordion&gt;');
    }
    return context;
}

// Item Context (for nested components)
interface AccordionItemContextValue {
    value: string;
    isOpen: boolean;
}

const AccordionItemContext = createContext&lt;AccordionItemContextValue | undefined&gt;(undefined);

function useAccordionItem() {
    const context = useContext(AccordionItemContext);
    if (!context) {
        throw new Error('AccordionTrigger/Content must be used within AccordionItem');
    }
    return context;
}

// Parent Accordion Component
interface AccordionProps {
    children: ReactNode;
    type: 'single' | 'multiple';
    defaultValue?: string | string[];
    value?: string | string[];
    onChange?: (value: string | string[]) => void;
    collapsible?: boolean; // For single mode - allow closing active item
}

function Accordion({
    children,
    type,
    defaultValue,
    value,
    onChange,
    collapsible = false
}: AccordionProps) {
    // Normalize default value to array
    const normalizedDefault = Array.isArray(defaultValue) 
        ? defaultValue 
        : defaultValue 
            ? [defaultValue] 
            : [];
    
    const [internalValue, setInternalValue] = useState&lt;string[]&gt;(normalizedDefault);
    
    // Get current open items
    const openItems = value !== undefined
        ? (Array.isArray(value) ? value : [value])
        : internalValue;
    
    const toggleItem = useCallback((itemValue: string) => {
        const newValue = type === 'single'
            ? (openItems.includes(itemValue) && collapsible
                ? [] // Close if already open and collapsible
                : [itemValue]) // Open the new one
            : (openItems.includes(itemValue)
                ? openItems.filter(v => v !== itemValue) // Remove from array
                : [...openItems, itemValue]); // Add to array
        
        if (onChange) {
            onChange(type === 'single' ? newValue[0] || '' : newValue);
        } else {
            setInternalValue(newValue);
        }
    }, [type, openItems, onChange, collapsible]);
    
    const isOpen = useCallback((itemValue: string) => {
        return openItems.includes(itemValue);
    }, [openItems]);
    
    const contextValue = useMemo(() => ({
        type,
        openItems,
        toggleItem,
        isOpen
    }), [type, openItems, toggleItem, isOpen]);
    
    return (
        &lt;AccordionContext.Provider value={contextValue}&gt;
            &lt;div className="accordion"&gt;
                {children}
            &lt;/div&gt;
        &lt;/AccordionContext.Provider&gt;
    );
}

// Item Component
interface AccordionItemProps {
    children: ReactNode;
    value: string;
    className?: string;
}

function AccordionItem({ children, value, className = '' }: AccordionItemProps) {
    const { isOpen } = useAccordion();
    const open = isOpen(value);
    
    const itemContextValue = useMemo(() => ({
        value,
        isOpen: open
    }), [value, open]);
    
    return (
        &lt;AccordionItemContext.Provider value={itemContextValue}&gt;
            &lt;div className={`accordion-item ${open ? 'open' : ''} ${className}`}&gt;
                {children}
            &lt;/div&gt;
        &lt;/AccordionItemContext.Provider&gt;
    );
}

// Trigger Component
interface AccordionTriggerProps {
    children: ReactNode;
    className?: string;
}

function AccordionTrigger({ children, className = '' }: AccordionTriggerProps) {
    const { toggleItem } = useAccordion();
    const { value, isOpen } = useAccordionItem();
    
    return (
        &lt;button
            type="button"
            aria-expanded={isOpen}
            aria-controls={`accordion-content-${value}`}
            id={`accordion-trigger-${value}`}
            onClick={() => toggleItem(value)}
            className={`accordion-trigger ${className}`}
        &gt;
            {children}
            &lt;span className={`accordion-icon ${isOpen ? 'open' : ''}`}&gt;
                {isOpen ? '‚àí' : '+'}
            &lt;/span&gt;
        &lt;/button&gt;
    );
}

// Content Component
interface AccordionContentProps {
    children: ReactNode;
    className?: string;
}

function AccordionContent({ children, className = '' }: AccordionContentProps) {
    const { value, isOpen } = useAccordionItem();
    
    return (
        &lt;div
            id={`accordion-content-${value}`}
            role="region"
            aria-labelledby={`accordion-trigger-${value}`}
            className={`accordion-content ${isOpen ? 'open' : 'closed'} ${className}`}
            style={{ display: isOpen ? 'block' : 'none' }}
        &gt;
            {children}
        &lt;/div&gt;
    );
}

// Attach and export
Accordion.Item = AccordionItem;
Accordion.Trigger = AccordionTrigger;
Accordion.Content = AccordionContent;

export { Accordion };</code></pre>
                </div>

                <h3>Usage Examples</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Single expansion mode
function FAQSingle() {
    return (
        &lt;Accordion type="single" defaultValue="q1" collapsible&gt;
            &lt;Accordion.Item value="q1"&gt;
                &lt;Accordion.Trigger&gt;How do I get started?&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    &lt;p&gt;Getting started is easy! Just follow our setup guide.&lt;/p&gt;
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
            
            &lt;Accordion.Item value="q2"&gt;
                &lt;Accordion.Trigger&gt;Is there a free trial?&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    &lt;p&gt;Yes! We offer a 14-day free trial with no credit card required.&lt;/p&gt;
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
            
            &lt;Accordion.Item value="q3"&gt;
                &lt;Accordion.Trigger&gt;How do I cancel?&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    &lt;p&gt;You can cancel anytime from your account settings.&lt;/p&gt;
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
        &lt;/Accordion&gt;
    );
}

// Multiple expansion mode
function FeaturesList() {
    const [openItems, setOpenItems] = useState&lt;string[]&gt;(['feature-1']);
    
    return (
        &lt;Accordion 
            type="multiple" 
            value={openItems} 
            onChange={setOpenItems}
        &gt;
            &lt;Accordion.Item value="feature-1"&gt;
                &lt;Accordion.Trigger&gt;üöÄ Performance&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    Lightning-fast load times and smooth interactions.
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
            
            &lt;Accordion.Item value="feature-2"&gt;
                &lt;Accordion.Trigger&gt;üîí Security&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    Enterprise-grade security with end-to-end encryption.
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
            
            &lt;Accordion.Item value="feature-3"&gt;
                &lt;Accordion.Trigger&gt;üì± Mobile-First&lt;/Accordion.Trigger&gt;
                &lt;Accordion.Content&gt;
                    Optimized for mobile devices with responsive design.
                &lt;/Accordion.Content&gt;
            &lt;/Accordion.Item&gt;
        &lt;/Accordion&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Accordion Component Features</h4>
                    <ul>
                        <li>‚úÖ Single or multiple expansion modes</li>
                        <li>‚úÖ Collapsible option for single mode</li>
                        <li>‚úÖ Both controlled and uncontrolled</li>
                        <li>‚úÖ Nested context for items</li>
                        <li>‚úÖ Accessible with ARIA attributes</li>
                        <li>‚úÖ Smooth animations (via CSS)</li>
                        <li>‚úÖ Flexible and composable</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Typing Compound Components -->
            <section id="section7" class="lesson-section">
                <h2>üìò Typing Compound Components</h2>
                <p>TypeScript makes compound components even more powerful by catching errors at compile time and providing excellent autocomplete. Let's explore advanced typing techniques.</p>

                <h3>Basic Component Typing</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { ReactNode, ReactElement } from 'react';

// Parent component props
interface MyComponentProps {
    children: ReactNode;
    defaultValue?: string;
    onChange?: (value: string) => void;
}

// Child component props
interface MyComponentItemProps {
    children: ReactNode;
    value: string;
    disabled?: boolean;
}

// Context value type
interface MyComponentContextValue {
    selectedValue: string | undefined;
    select: (value: string) => void;
    isSelected: (value: string) => boolean;
}</code></pre>
                </div>

                <h3>Typing Attached Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Define the main component
function Select({ children }: { children: ReactNode }) {
    // Implementation
    return &lt;div&gt;{children}&lt;/div&gt;;
}

// Define child components
function SelectTrigger({ children }: { children: ReactNode }) {
    return &lt;button&gt;{children}&lt;/button&gt;;
}

function SelectOption({ value, children }: { value: string; children: ReactNode }) {
    return &lt;div&gt;{children}&lt;/div&gt;;
}

// Create a type that includes the attached components
type SelectComponent = typeof Select & {
    Trigger: typeof SelectTrigger;
    Option: typeof SelectOption;
};

// Attach components
const TypedSelect = Select as SelectComponent;
TypedSelect.Trigger = SelectTrigger;
TypedSelect.Option = SelectOption;

// Export with proper types
export { TypedSelect as Select };

// Usage - TypeScript knows about attached components!
&lt;Select&gt;
    &lt;Select.Trigger /&gt; {/* ‚úÖ Autocomplete works! */}
    &lt;Select.Option value="1"&gt;Option 1&lt;/Select.Option&gt;
&lt;/Select&gt;</code></pre>
                </div>

                <h3>Generic Compound Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Generic select that works with any type
interface SelectProps&lt;T&gt; {
    children: ReactNode;
    value?: T;
    onChange?: (value: T) => void;
    defaultValue?: T;
}

interface SelectContextValue&lt;T&gt; {
    selectedValue: T | undefined;
    select: (value: T) => void;
    isSelected: (value: T) => boolean;
}

// Create generic context
const SelectContext = createContext&lt;SelectContextValue&lt;any&gt; | undefined&gt;(undefined);

function Select&lt;T&gt;({ children, value, onChange, defaultValue }: SelectProps&lt;T&gt;) {
    const [internalValue, setInternalValue] = useState&lt;T | undefined&gt;(defaultValue);
    
    const selectedValue = value !== undefined ? value : internalValue;
    
    const contextValue: SelectContextValue&lt;T&gt; = {
        selectedValue,
        select: (newValue: T) => {
            onChange ? onChange(newValue) : setInternalValue(newValue);
        },
        isSelected: (checkValue: T) => selectedValue === checkValue
    };
    
    return (
        &lt;SelectContext.Provider value={contextValue}&gt;
            &lt;div className="select"&gt;{children}&lt;/div&gt;
        &lt;/SelectContext.Provider&gt;
    );
}

// Typed option component
interface SelectOptionProps&lt;T&gt; {
    value: T;
    children: ReactNode;
}

function SelectOption&lt;T&gt;({ value, children }: SelectOptionProps&lt;T&gt;) {
    const context = useContext(SelectContext) as SelectContextValue&lt;T&gt;;
    
    return (
        &lt;button onClick={() => context.select(value)}&gt;
            {children}
        &lt;/button&gt;
    );
}

// Usage with type inference
function App() {
    // TypeScript infers the type from defaultValue
    return (
        &lt;Select&lt;number&gt; defaultValue={1}&gt;
            &lt;SelectOption value={1}&gt;One&lt;/SelectOption&gt;
            &lt;SelectOption value={2}&gt;Two&lt;/SelectOption&gt;
            {/* &lt;SelectOption value="3"&gt;Three&lt;/SelectOption&gt; */}
            {/* ‚ùå Type error! Can't pass string */}
        &lt;/Select&gt;
    );
}</code></pre>
                </div>

                <h3>Enforcing Component Relationships</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { Children, ReactElement, isValidElement } from 'react';

// Only allow specific children
interface TabListProps {
    children: ReactElement&lt;TabProps&gt; | ReactElement&lt;TabProps&gt;[];
}

function TabList({ children }: TabListProps) {
    // Validate children at runtime
    const validChildren = Children.toArray(children).filter(child => {
        if (!isValidElement(child)) return false;
        
        // Check if child is a Tab component
        return child.type === Tab;
    });
    
    if (validChildren.length === 0) {
        console.warn('TabList should contain Tab components');
    }
    
    return &lt;div role="tablist"&gt;{validChildren}&lt;/div&gt;;
}

// More strict: Only accept Tab components
function StrictTabList({ children }: { 
    children: ReactElement&lt;typeof Tab&gt; | ReactElement&lt;typeof Tab&gt;[] 
}) {
    return &lt;div role="tablist"&gt;{children}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Discriminated Union Types</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Different props based on mode
type AccordionSingleProps = {
    type: 'single';
    value?: string;
    defaultValue?: string;
    onChange?: (value: string) => void;
    collapsible?: boolean;
    children: ReactNode;
};

type AccordionMultipleProps = {
    type: 'multiple';
    value?: string[];
    defaultValue?: string[];
    onChange?: (value: string[]) => void;
    children: ReactNode;
};

type AccordionProps = AccordionSingleProps | AccordionMultipleProps;

function Accordion(props: AccordionProps) {
    // TypeScript knows which props are available based on type
    if (props.type === 'single') {
        // props.value is string | undefined
        // props.collapsible is available
        const { value, defaultValue, onChange, collapsible } = props;
        // ...
    } else {
        // props.value is string[] | undefined
        // props.collapsible is NOT available
        const { value, defaultValue, onChange } = props;
        // ...
    }
    
    return &lt;div&gt;{props.children}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Utility Types for Props</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { ComponentPropsWithoutRef, ElementRef } from 'react';

// Extend native element props
type ButtonProps = ComponentPropsWithoutRef&lt;'button'&gt; & {
    variant?: 'primary' | 'secondary';
};

function CustomButton({ variant = 'primary', ...props }: ButtonProps) {
    return &lt;button className={`btn-${variant}`} {...props} /&gt;;
}

// Get the ref type of an element
type ButtonRef = ElementRef&lt;'button'&gt;; // HTMLButtonElement

// Use with forwardRef
const ForwardedButton = forwardRef&lt;ButtonRef, ButtonProps&gt;(
    ({ variant = 'primary', ...props }, ref) => {
        return &lt;button ref={ref} className={`btn-${variant}`} {...props} /&gt;;
    }
);

// Omit specific props
type SelectTriggerProps = Omit&lt;ButtonProps, 'onClick'&gt; & {
    // onClick is managed internally
};

// Pick specific props
type MinimalButtonProps = Pick&lt;ButtonProps, 'children' | 'disabled'&gt;;</code></pre>
                </div>

                <h3>Advanced: Slot-based Typing</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Define slots with specific types
interface CardSlots {
    header?: ReactNode;
    content: ReactNode;
    footer?: ReactNode;
    actions?: ReactElement&lt;typeof Button&gt; | ReactElement&lt;typeof Button&gt;[];
}

interface CardProps {
    slots: CardSlots;
    className?: string;
}

function Card({ slots, className }: CardProps) {
    return (
        &lt;div className={`card ${className || ''}`}&gt;
            {slots.header && (
                &lt;div className="card-header"&gt;{slots.header}&lt;/div&gt;
            )}
            &lt;div className="card-content"&gt;{slots.content}&lt;/div&gt;
            {slots.footer && (
                &lt;div className="card-footer"&gt;{slots.footer}&lt;/div&gt;
            )}
            {slots.actions && (
                &lt;div className="card-actions"&gt;{slots.actions}&lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}

// Usage with type checking
&lt;Card
    slots={{
        header: &lt;h2&gt;Title&lt;/h2&gt;,
        content: &lt;p&gt;Content here&lt;/p&gt;,
        footer: &lt;small&gt;Footer text&lt;/small&gt;,
        actions: [
            &lt;Button key="1"&gt;Save&lt;/Button&gt;,
            &lt;Button key="2"&gt;Cancel&lt;/Button&gt;
        ]
    }}
/&gt;</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Best Practices</h4>
                    <ul>
                        <li>Use discriminated unions for different modes/variants</li>
                        <li>Leverage generics for flexible, reusable components</li>
                        <li>Extend native element types with ComponentPropsWithoutRef</li>
                        <li>Type attached components properly for autocomplete</li>
                        <li>Use utility types (Omit, Pick, Partial) to modify props</li>
                        <li>Validate children at runtime when TypeScript can't</li>
                        <li>Provide helpful JSDoc comments for complex types</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Advanced Patterns -->
            <section id="section8" class="lesson-section">
                <h2>üöÄ Advanced Patterns</h2>
                <p>Let's explore some advanced patterns and techniques for building even more powerful compound components.</p>

                <h3>Pattern 1: Render Props with Compound Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Combine render props with compound components for max flexibility
interface DropdownProps {
    children: ReactNode;
}

function Dropdown({ children }: DropdownProps) {
    const [isOpen, setIsOpen] = useState(false);
    
    return (
        &lt;DropdownContext.Provider value={{ isOpen, setIsOpen }}&gt;
            &lt;div className="dropdown"&gt;{children}&lt;/div&gt;
        &lt;/DropdownContext.Provider&gt;
    );
}

// Trigger with render prop for custom rendering
interface DropdownTriggerProps {
    children: (props: { isOpen: boolean; toggle: () => void }) => ReactNode;
}

Dropdown.Trigger = function DropdownTrigger({ children }: DropdownTriggerProps) {
    const { isOpen, setIsOpen } = useDropdown();
    
    const toggle = () => setIsOpen(!isOpen);
    
    return &lt;&gt;{children({ isOpen, toggle })}&lt;/&gt;;
};

// Usage
&lt;Dropdown&gt;
    &lt;Dropdown.Trigger&gt;
        {({ isOpen, toggle }) => (
            &lt;button onClick={toggle}&gt;
                {isOpen ? '‚ñ≤' : '‚ñº'} Menu
            &lt;/button&gt;
        )}
    &lt;/Dropdown.Trigger&gt;
    &lt;Dropdown.Menu&gt;...&lt;/Dropdown.Menu&gt;
&lt;/Dropdown&gt;</code></pre>
                </div>

                <h3>Pattern 2: Polymorphic Components</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Component that can render as different elements
type AsProp&lt;C extends React.ElementType&gt; = {
    as?: C;
};

type PropsToOmit&lt;C extends React.ElementType, P&gt; = keyof (AsProp&lt;C&gt; & P);

type PolymorphicComponentProp&lt;
    C extends React.ElementType,
    Props = {}
&gt; = React.PropsWithChildren&lt;Props & AsProp&lt;C&gt;&gt; &
    Omit&lt;React.ComponentPropsWithoutRef&lt;C&gt;, PropsToOmit&lt;C, Props&gt;&gt;;

interface TabProps {
    value: string;
    disabled?: boolean;
}

type TabComponent = &lt;C extends React.ElementType = 'button'&gt;(
    props: PolymorphicComponentProp&lt;C, TabProps&gt;
) => React.ReactElement | null;

const Tab: TabComponent = ({ 
    as, 
    value, 
    disabled, 
    children, 
    ...props 
}) => {
    const Component = as || 'button';
    const { selectTab, isActive } = useTabs();
    
    return (
        &lt;Component
            role="tab"
            aria-selected={isActive(value)}
            disabled={disabled}
            onClick={() => selectTab(value)}
            {...props}
        &gt;
            {children}
        &lt;/Component&gt;
    );
};

// Usage - can render as different elements
&lt;Tab value="home"&gt;Home&lt;/Tab&gt; {/* button */}
&lt;Tab as="a" href="#home" value="home"&gt;Home&lt;/Tab&gt; {/* anchor */}
&lt;Tab as="div" value="home"&gt;Home&lt;/Tab&gt; {/* div */}</code></pre>
                </div>

                <h3>Pattern 3: Context Splitting for Performance</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Split context into state and actions to prevent unnecessary re-renders

// State context - changes frequently
interface TabsStateContextValue {
    activeTab: string | undefined;
}

const TabsStateContext = createContext&lt;TabsStateContextValue | undefined&gt;(undefined);

// Actions context - stable, rarely changes
interface TabsActionsContextValue {
    selectTab: (value: string) => void;
    isActive: (value: string) => boolean;
}

const TabsActionsContext = createContext&lt;TabsActionsContextValue | undefined&gt;(undefined);

function Tabs({ children, defaultValue }: TabsProps) {
    const [activeTab, setActiveTab] = useState(defaultValue);
    
    // State context value
    const stateValue = useMemo(() => ({
        activeTab
    }), [activeTab]);
    
    // Actions context value - doesn't change
    const actionsValue = useMemo(() => ({
        selectTab: setActiveTab,
        isActive: (value: string) => activeTab === value
    }), [activeTab]);
    
    return (
        &lt;TabsStateContext.Provider value={stateValue}&gt;
            &lt;TabsActionsContext.Provider value={actionsValue}&gt;
                {children}
            &lt;/TabsActionsContext.Provider&gt;
        &lt;/TabsStateContext.Provider&gt;
    );
}

// Separate hooks
function useTabsState() {
    const context = useContext(TabsStateContext);
    if (!context) throw new Error('...');
    return context;
}

function useTabsActions() {
    const context = useContext(TabsActionsContext);
    if (!context) throw new Error('...');
    return context;
}

// Components only subscribe to what they need
function Tab({ value }: { value: string }) {
    const { activeTab } = useTabsState(); // Re-renders when active tab changes
    const { selectTab } = useTabsActions(); // Stable, doesn't cause re-renders
    
    return (
        &lt;button onClick={() => selectTab(value)}&gt;
            {value} {activeTab === value && '‚úì'}
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 4: Imperative Handle</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useImperativeHandle, forwardRef } from 'react';

// Expose methods to parent
interface TabsHandle {
    selectTab: (value: string) => void;
    getActiveTab: () => string | undefined;
    nextTab: () => void;
    prevTab: () => void;
}

interface TabsProps {
    children: ReactNode;
    defaultValue?: string;
}

const Tabs = forwardRef&lt;TabsHandle, TabsProps&gt;(
    ({ children, defaultValue }, ref) => {
        const [activeTab, setActiveTab] = useState(defaultValue);
        const [tabs, setTabs] = useState&lt;string[]&gt;([]);
        
        // Register tabs as they mount
        const registerTab = useCallback((value: string) => {
            setTabs(prev => [...prev, value]);
        }, []);
        
        // Expose methods to parent
        useImperativeHandle(ref, () => ({
            selectTab: setActiveTab,
            getActiveTab: () => activeTab,
            nextTab: () => {
                const currentIndex = tabs.indexOf(activeTab || '');
                const nextIndex = (currentIndex + 1) % tabs.length;
                setActiveTab(tabs[nextIndex]);
            },
            prevTab: () => {
                const currentIndex = tabs.indexOf(activeTab || '');
                const prevIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                setActiveTab(tabs[prevIndex]);
            }
        }), [activeTab, tabs]);
        
        return (
            &lt;TabsContext.Provider value={{ activeTab, setActiveTab, registerTab }}&gt;
                {children}
            &lt;/TabsContext.Provider&gt;
        );
    }
);

// Usage from parent
function App() {
    const tabsRef = useRef&lt;TabsHandle&gt;(null);
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => tabsRef.current?.nextTab()}&gt;Next Tab&lt;/button&gt;
            &lt;button onClick={() => tabsRef.current?.prevTab()}&gt;Prev Tab&lt;/button&gt;
            
            &lt;Tabs ref={tabsRef} defaultValue="home"&gt;
                &lt;Tab value="home"&gt;Home&lt;/Tab&gt;
                &lt;Tab value="profile"&gt;Profile&lt;/Tab&gt;
                &lt;Tab value="settings"&gt;Settings&lt;/Tab&gt;
            &lt;/Tabs&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 5: Compound Component with Slots</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Collect children into named slots
import { Children, ReactElement, isValidElement } from 'react';

interface ModalProps {
    children: ReactNode;
    isOpen: boolean;
    onClose: () => void;
}

function Modal({ children, isOpen, onClose }: ModalProps) {
    // Extract different child types into slots
    const slots = {
        header: null as ReactNode,
        body: null as ReactNode,
        footer: null as ReactNode
    };
    
    Children.forEach(children, (child) => {
        if (isValidElement(child)) {
            if (child.type === ModalHeader) {
                slots.header = child;
            } else if (child.type === ModalBody) {
                slots.body = child;
            } else if (child.type === ModalFooter) {
                slots.footer = child;
            }
        }
    });
    
    if (!isOpen) return null;
    
    return (
        &lt;div className="modal-overlay" onClick={onClose}&gt;
            &lt;div className="modal" onClick={(e) => e.stopPropagation()}&gt;
                {slots.header && &lt;div className="modal-header"&gt;{slots.header}&lt;/div&gt;}
                {slots.body && &lt;div className="modal-body"&gt;{slots.body}&lt;/div&gt;}
                {slots.footer && &lt;div className="modal-footer"&gt;{slots.footer}&lt;/div&gt;}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

function ModalHeader({ children }: { children: ReactNode }) {
    return &lt;&gt;{children}&lt;/&gt;;
}

function ModalBody({ children }: { children: ReactNode }) {
    return &lt;&gt;{children}&lt;/&gt;;
}

function ModalFooter({ children }: { children: ReactNode }) {
    return &lt;&gt;{children}&lt;/&gt;;
}

Modal.Header = ModalHeader;
Modal.Body = ModalBody;
Modal.Footer = ModalFooter;

// Usage - order doesn't matter!
&lt;Modal isOpen={true} onClose={close}&gt;
    &lt;Modal.Footer&gt;
        &lt;button&gt;Close&lt;/button&gt;
    &lt;/Modal.Footer&gt;
    &lt;Modal.Header&gt;
        &lt;h2&gt;Confirm&lt;/h2&gt;
    &lt;/Modal.Header&gt;
    &lt;Modal.Body&gt;
        &lt;p&gt;Are you sure?&lt;/p&gt;
    &lt;/Modal.Body&gt;
&lt;/Modal&gt;</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Advanced Pattern Use Cases</h4>
                    <ul>
                        <li><strong>Render Props:</strong> Maximum flexibility for custom rendering</li>
                        <li><strong>Polymorphic:</strong> Components that can render as different elements</li>
                        <li><strong>Context Splitting:</strong> Optimize performance by separating state and actions</li>
                        <li><strong>Imperative Handle:</strong> Parent controls compound component programmatically</li>
                        <li><strong>Slots:</strong> Children can be in any order, automatically organized</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to apply what you've learned! Complete these exercises to master compound components.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Build a Select Component</h3>
                    <p><strong>Goal:</strong> Create a compound Select component with dropdown functionality.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Select, SelectTrigger, SelectOption components</li>
                        <li>Show/hide dropdown on trigger click</li>
                        <li>Close dropdown when option selected</li>
                        <li>Display selected value in trigger</li>
                        <li>Support controlled and uncontrolled modes</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>You'll need context for: isOpen, selected value, select function, and toggle function. Don't forget to close the dropdown when clicking outside!</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">const SelectContext = createContext&lt;{
    isOpen: boolean;
    toggle: () => void;
    selectedValue: string | undefined;
    select: (value: string) => void;
} | undefined&gt;(undefined);

function useSelect() {
    const context = useContext(SelectContext);
    if (!context) throw new Error('Must be used within Select');
    return context;
}

function Select({ 
    children, 
    value, 
    onChange, 
    defaultValue 
}: {
    children: ReactNode;
    value?: string;
    onChange?: (value: string) => void;
    defaultValue?: string;
}) {
    const [isOpen, setIsOpen] = useState(false);
    const [internalValue, setInternalValue] = useState(defaultValue);
    
    const selectedValue = value !== undefined ? value : internalValue;
    
    const contextValue = useMemo(() => ({
        isOpen,
        toggle: () => setIsOpen(!isOpen),
        selectedValue,
        select: (newValue: string) => {
            onChange ? onChange(newValue) : setInternalValue(newValue);
            setIsOpen(false);
        }
    }), [isOpen, selectedValue, onChange]);
    
    return (
        &lt;SelectContext.Provider value={contextValue}&gt;
            &lt;div className="select"&gt;{children}&lt;/div&gt;
        &lt;/SelectContext.Provider&gt;
    );
}

Select.Trigger = function SelectTrigger({ children }: { children?: ReactNode }) {
    const { toggle, selectedValue } = useSelect();
    return (
        &lt;button onClick={toggle}&gt;
            {children || selectedValue || 'Select...'}
        &lt;/button&gt;
    );
};

Select.Dropdown = function SelectDropdown({ children }: { children: ReactNode }) {
    const { isOpen } = useSelect();
    if (!isOpen) return null;
    return &lt;div className="dropdown"&gt;{children}&lt;/div&gt;;
};

Select.Option = function SelectOption({ 
    value, 
    children 
}: { 
    value: string; 
    children: ReactNode 
}) {
    const { select, selectedValue } = useSelect();
    return (
        &lt;button
            onClick={() => select(value)}
            className={selectedValue === value ? 'selected' : ''}
        &gt;
            {children}
        &lt;/button&gt;
    );
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Build a Card Component</h3>
                    <p><strong>Goal:</strong> Create a flexible Card compound component with header, body, and footer.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Card, Card.Header, Card.Body, Card.Footer components</li>
                        <li>Optional collapse/expand functionality</li>
                        <li>Context to share collapsible state</li>
                        <li>Support cards without headers or footers</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">const CardContext = createContext&lt;{
    isCollapsed: boolean;
    toggleCollapse: () => void;
    collapsible: boolean;
} | undefined&gt;(undefined);

function useCard() {
    const context = useContext(CardContext);
    if (!context) throw new Error('Must be used within Card');
    return context;
}

function Card({ 
    children, 
    collapsible = false,
    defaultCollapsed = false 
}: {
    children: ReactNode;
    collapsible?: boolean;
    defaultCollapsed?: boolean;
}) {
    const [isCollapsed, setIsCollapsed] = useState(defaultCollapsed);
    
    const contextValue = useMemo(() => ({
        isCollapsed,
        toggleCollapse: () => setIsCollapsed(!isCollapsed),
        collapsible
    }), [isCollapsed, collapsible]);
    
    return (
        &lt;CardContext.Provider value={contextValue}&gt;
            &lt;div className="card"&gt;{children}&lt;/div&gt;
        &lt;/CardContext.Provider&gt;
    );
}

Card.Header = function CardHeader({ children }: { children: ReactNode }) {
    const { collapsible, isCollapsed, toggleCollapse } = useCard();
    
    return (
        &lt;div className="card-header"&gt;
            {children}
            {collapsible && (
                &lt;button onClick={toggleCollapse}&gt;
                    {isCollapsed ? '‚ñº' : '‚ñ≤'}
                &lt;/button&gt;
            )}
        &lt;/div&gt;
    );
};

Card.Body = function CardBody({ children }: { children: ReactNode }) {
    const { isCollapsed } = useCard();
    
    if (isCollapsed) return null;
    
    return &lt;div className="card-body"&gt;{children}&lt;/div&gt;;
};

Card.Footer = function CardFooter({ children }: { children: ReactNode }) {
    const { isCollapsed } = useCard();
    
    if (isCollapsed) return null;
    
    return &lt;div className="card-footer"&gt;{children}&lt;/div&gt;;
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Build a Menu Component</h3>
                    <p><strong>Goal:</strong> Create a dropdown menu with keyboard navigation.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Menu, Menu.Button, Menu.Items, Menu.Item components</li>
                        <li>Open/close on button click</li>
                        <li>Close on item selection or outside click</li>
                        <li>Arrow key navigation between items</li>
                        <li>Enter key to select focused item</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use refs to track menu items and manage focus. Track focused index in state for keyboard navigation.</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: Build a Stepper/Wizard Component</h3>
                    <p><strong>Goal:</strong> Create a multi-step wizard with navigation.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Stepper, Stepper.Step components</li>
                        <li>Track current step</li>
                        <li>Next/Previous navigation methods</li>
                        <li>Validation before proceeding</li>
                        <li>Optional completion callback</li>
                        <li>Display step indicators</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution Skeleton</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">interface StepperContextValue {
    currentStep: number;
    totalSteps: number;
    goToStep: (step: number) => void;
    nextStep: () => void;
    prevStep: () => void;
    canGoNext: boolean;
    canGoPrev: boolean;
}

function Stepper({ 
    children, 
    onComplete 
}: {
    children: ReactNode;
    onComplete?: () => void;
}) {
    const [currentStep, setCurrentStep] = useState(0);
    const steps = Children.toArray(children);
    const totalSteps = steps.length;
    
    // Implement context and navigation logic
    // ...
    
    return (
        &lt;StepperContext.Provider value={contextValue}&gt;
            &lt;div className="stepper"&gt;
                &lt;StepIndicators /&gt;
                &lt;div className="step-content"&gt;
                    {steps[currentStep]}
                &lt;/div&gt;
                &lt;StepNavigation /&gt;
            &lt;/div&gt;
        &lt;/StepperContext.Provider&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>‚úÖ Best Practices</h2>
                <p>Follow these guidelines to build excellent compound components that are flexible, maintainable, and performant.</p>

                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Provide helpful error messages:</strong> Tell developers exactly what went wrong and how to fix it</li>
                    <li><strong>Support both controlled and uncontrolled modes:</strong> Give users flexibility in how they manage state</li>
                    <li><strong>Memoize context values:</strong> Prevent unnecessary re-renders with useMemo and useCallback</li>
                    <li><strong>Use proper TypeScript types:</strong> Make your components type-safe and provide great autocomplete</li>
                    <li><strong>Add accessibility features:</strong> ARIA attributes, keyboard navigation, focus management</li>
                    <li><strong>Document your API:</strong> Clear examples and JSDoc comments help developers understand usage</li>
                    <li><strong>Keep context minimal:</strong> Only share what's necessary between components</li>
                    <li><strong>Name components clearly:</strong> Parent.Child naming makes relationships obvious</li>
                    <li><strong>Provide sensible defaults:</strong> Make the simple case simple, complex case possible</li>
                    <li><strong>Test with real use cases:</strong> Ensure your API works for actual scenarios</li>
                </ul>

                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't overuse the pattern:</strong> Not every component needs to be compound</li>
                    <li><strong>Don't forget to memoize:</strong> Unmemoized context causes unnecessary re-renders</li>
                    <li><strong>Don't make the API too flexible:</strong> Too many options create confusion</li>
                    <li><strong>Don't put everything in one context:</strong> Split state and actions for better performance</li>
                    <li><strong>Don't ignore accessibility:</strong> Compound components should be accessible by default</li>
                    <li><strong>Don't skip error handling:</strong> Helpful errors save developers hours of debugging</li>
                    <li><strong>Don't break composition:</strong> Allow custom wrappers and styling</li>
                    <li><strong>Don't forget about SSR:</strong> Ensure components work with server-side rendering</li>
                    <li><strong>Don't create circular dependencies:</strong> Keep context dependencies clear</li>
                    <li><strong>Don't sacrifice type safety:</strong> Use proper TypeScript even if it's more complex</li>
                </ul>

                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Start simple, add complexity as needed:</strong> Build the basic version first</li>
                    <li><strong>Look at popular libraries:</strong> Study Radix UI, Reach UI, Headless UI for inspiration</li>
                    <li><strong>Use render props for ultimate flexibility:</strong> Combine with compound components when needed</li>
                    <li><strong>Consider polymorphic 'as' prop:</strong> Let components render as different elements</li>
                    <li><strong>Provide escape hatches:</strong> Allow users to override default behavior</li>
                    <li><strong>Document component relationships:</strong> Make it clear which components work together</li>
                    <li><strong>Test keyboard navigation:</strong> Ensure components work without a mouse</li>
                    <li><strong>Version your API carefully:</strong> Breaking changes in compound components affect many users</li>
                    <li><strong>Consider mobile interactions:</strong> Touch gestures, smaller screens</li>
                    <li><strong>Profile performance:</strong> Use React DevTools to identify bottlenecks</li>
                </ul>

                <h3>üìã Compound Component Checklist</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Before Publishing Your Component</h4>
                    <ul>
                        <li>‚òê Context throws helpful error when used incorrectly</li>
                        <li>‚òê Context value is memoized to prevent re-renders</li>
                        <li>‚òê Supports both controlled and uncontrolled modes</li>
                        <li>‚òê All child components properly typed</li>
                        <li>‚òê ARIA attributes for accessibility</li>
                        <li>‚òê Keyboard navigation works correctly</li>
                        <li>‚òê Focus management is intuitive</li>
                        <li>‚òê Components can be styled with className</li>
                        <li>‚òê Works with React DevTools</li>
                        <li>‚òê Documented with examples</li>
                        <li>‚òê Tested with real use cases</li>
                        <li>‚òê Works with SSR (if applicable)</li>
                    </ul>
                </div>

                <h3>üéØ API Design Principles</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>Creating Intuitive APIs</h4>
                    <ol>
                        <li><strong>Make it obvious:</strong> API should be self-explanatory</li>
                        <li><strong>Minimize required props:</strong> Sensible defaults for everything</li>
                        <li><strong>Fail fast with helpful errors:</strong> Don't let bugs hide</li>
                        <li><strong>Be consistent:</strong> Similar components should work similarly</li>
                        <li><strong>Optimize for the common case:</strong> Simple things should be simple</li>
                        <li><strong>Provide escape hatches:</strong> Complex things should be possible</li>
                        <li><strong>Think about composition:</strong> Components should work well together</li>
                    </ol>
                </div>

                <h3>üîß Maintenance Tips</h3>
                <ul>
                    <li><strong>Version carefully:</strong> Compound components have more surface area for breaking changes</li>
                    <li><strong>Deprecate gradually:</strong> Give users time to migrate</li>
                    <li><strong>Keep examples updated:</strong> Documentation is crucial</li>
                    <li><strong>Monitor usage patterns:</strong> See how people actually use your components</li>
                    <li><strong>Gather feedback:</strong> Users will tell you what's confusing</li>
                    <li><strong>Write integration tests:</strong> Test how components work together</li>
                </ul>
            </section>

            <!-- Section 11: Common Mistakes -->
            <section id="section11" class="lesson-section">
                <h2>‚ö†Ô∏è Common Mistakes to Avoid</h2>
                <p>Learn from these common pitfalls so you don't have to make them yourself!</p>

                <h3>Mistake 1: Forgetting to Memoize Context</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - new object every render
function Tabs({ children }: { children: ReactNode }) {
    const [activeTab, setActiveTab] = useState('home');
    
    // This creates a new object on every render!
    // All consumers re-render unnecessarily
    const value = {
        activeTab,
        setActiveTab
    };
    
    return (
        &lt;TabsContext.Provider value={value}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}

// ‚úÖ Good - memoized value
function Tabs({ children }: { children: ReactNode }) {
    const [activeTab, setActiveTab] = useState('home');
    
    const value = useMemo(() => ({
        activeTab,
        setActiveTab
    }), [activeTab]);
    
    return (
        &lt;TabsContext.Provider value={value}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 2: Poor Error Messages</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - unhelpful error
function useTabs() {
    const context = useContext(TabsContext);
    if (!context) {
        throw new Error('Error'); // What error?!
    }
    return context;
}

// ‚úÖ Good - clear, actionable error
function useTabs() {
    const context = useContext(TabsContext);
    if (!context) {
        throw new Error(
            'useTabs must be used within a &lt;Tabs&gt; component. ' +
            'Wrap your Tab, TabList, and TabPanel components in ' +
            '&lt;Tabs&gt;...&lt;/Tabs&gt; to fix this error.'
        );
    }
    return context;
}</code></pre>
                </div>

                <h3>Mistake 3: Not Supporting Controlled Mode</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - only uncontrolled
function Tabs({ children, defaultValue }: TabsProps) {
    const [activeTab, setActiveTab] = useState(defaultValue);
    
    // Can't be controlled from parent!
    return (
        &lt;TabsContext.Provider value={{ activeTab, setActiveTab }}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}

// ‚úÖ Good - supports both modes
function Tabs({ children, defaultValue, value, onChange }: TabsProps) {
    const [internalValue, setInternalValue] = useState(defaultValue);
    
    // Use controlled value if provided
    const activeTab = value !== undefined ? value : internalValue;
    const setActiveTab = onChange || setInternalValue;
    
    return (
        &lt;TabsContext.Provider value={{ activeTab, setActiveTab }}&gt;
            {children}
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 4: Tight Coupling</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - can't customize structure
function Tabs({ children }: { children: ReactNode }) {
    return (
        &lt;div className="tabs"&gt;
            &lt;div className="tab-list"&gt;
                {/* Hardcoded - no flexibility! */}
                {children}
            &lt;/div&gt;
            &lt;div className="tab-panels"&gt;
                {/* Where do panels go? */}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ Good - flexible composition
function Tabs({ children }: { children: ReactNode }) {
    return (
        &lt;TabsContext.Provider value={contextValue}&gt;
            &lt;div className="tabs"&gt;
                {children} {/* User controls structure */}
            &lt;/div&gt;
        &lt;/TabsContext.Provider&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 5: Missing TypeScript Types</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - loose typing
function Tabs({ children }: any) {
    // ...
}

Tabs.Tab = function Tab({ value, children }: any) {
    // ...
};

// ‚úÖ Good - proper types
interface TabsProps {
    children: ReactNode;
    defaultValue?: string;
    value?: string;
    onChange?: (value: string) => void;
}

function Tabs({ children, defaultValue, value, onChange }: TabsProps) {
    // ...
}

interface TabProps {
    value: string;
    children: ReactNode;
    disabled?: boolean;
}

Tabs.Tab = function Tab({ value, children, disabled }: TabProps) {
    // ...
};</code></pre>
                </div>

                <h3>Mistake 6: Ignoring Accessibility</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - no accessibility
function Tab({ value, children }: TabProps) {
    const { selectTab } = useTabs();
    return (
        &lt;div onClick={() => selectTab(value)}&gt;
            {children}
        &lt;/div&gt;
    );
}

// ‚úÖ Good - accessible
function Tab({ value, children }: TabProps) {
    const { selectTab, isActive } = useTabs();
    const active = isActive(value);
    
    return (
        &lt;button
            role="tab"
            aria-selected={active}
            aria-controls={`panel-${value}`}
            id={`tab-${value}`}
            tabIndex={active ? 0 : -1}
            onClick={() => selectTab(value)}
            onKeyDown={(e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    selectTab(value);
                }
            }}
        &gt;
            {children}
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 7: Too Much Context State</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - everything in one context
interface MegaContextValue {
    tabs: Tab[];
    activeTab: string;
    hoveredTab: string | null;
    focusedTab: string | null;
    tabPositions: Record&lt;string, DOMRect&gt;;
    animationState: 'idle' | 'animating';
    // ... 20 more properties
}

// ‚úÖ Good - split into multiple contexts
interface TabsStateContext {
    activeTab: string;
}

interface TabsActionsContext {
    selectTab: (value: string) => void;
}

interface TabsMetadataContext {
    tabs: Tab[];
    registerTab: (tab: Tab) => void;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Remember</h4>
                    <ul>
                        <li>Always memoize context values</li>
                        <li>Provide clear, actionable error messages</li>
                        <li>Support both controlled and uncontrolled modes</li>
                        <li>Keep components loosely coupled and composable</li>
                        <li>Use proper TypeScript types for safety</li>
                        <li>Build accessibility in from the start</li>
                        <li>Split large contexts into smaller ones</li>
                    </ul>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Compound components</strong> are multiple components that work together by sharing implicit state through Context</li>
                        <li><strong>They provide flexible, intuitive APIs</strong> that feel natural to React developers</li>
                        <li><strong>Context enables implicit state sharing</strong> without prop drilling</li>
                        <li><strong>Support both modes:</strong> Controlled (parent manages state) and uncontrolled (component manages state)</li>
                        <li><strong>Memoize context values</strong> to prevent unnecessary re-renders</li>
                        <li><strong>TypeScript makes them safer</strong> with proper types and autocomplete</li>
                        <li><strong>Common use cases:</strong> Tabs, Accordions, Dropdowns, Menus, Modals</li>
                        <li><strong>Advanced patterns:</strong> Render props, polymorphic components, context splitting</li>
                        <li><strong>Accessibility matters:</strong> ARIA attributes, keyboard navigation, focus management</li>
                        <li><strong>Balance flexibility with simplicity</strong> - make simple things simple, complex things possible</li>
                    </ul>
                </div>

                <h3>üìä Compound Components vs Alternatives</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>Best For</th>
                            <th>Pros</th>
                            <th>Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Compound Components</strong></td>
                            <td>Flexible UI controls</td>
                            <td>Intuitive API, flexible composition</td>
                            <td>More setup, Context overhead</td>
                        </tr>
                        <tr>
                            <td><strong>Props-based</strong></td>
                            <td>Simple, fixed components</td>
                            <td>Simple, explicit</td>
                            <td>Less flexible, prop drilling</td>
                        </tr>
                        <tr>
                            <td><strong>Render Props</strong></td>
                            <td>Maximum flexibility</td>
                            <td>Ultimate control</td>
                            <td>Complex, harder to read</td>
                        </tr>
                        <tr>
                            <td><strong>Hooks-based</strong></td>
                            <td>Headless components</td>
                            <td>Separation of logic/UI</td>
                            <td>Users build everything</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üéØ When to Use Compound Components</h3>
                <div class="card">
                    <h4>‚úÖ Perfect Use Cases</h4>
                    <ul>
                        <li>UI controls with multiple related parts (Tabs, Accordions, Selects)</li>
                        <li>Components where users need layout flexibility</li>
                        <li>When you want declarative, JSX-based APIs</li>
                        <li>Building component libraries or design systems</li>
                        <li>Components with shared internal state</li>
                    </ul>
                    
                    <h4>‚ùå Not Ideal When</h4>
                    <ul>
                        <li>Component is simple with few variants</li>
                        <li>Structure should always be the same</li>
                        <li>No need for shared state between children</li>
                        <li>Performance is extremely critical (Context overhead)</li>
                        <li>Simple props-based approach is sufficient</li>
                    </ul>
                </div>

                <h3>üîë Key Patterns Review</h3>
                <div class="card">
                    <h4>1. Basic Pattern</h4>
                    <pre><code class="language-typescript">// Context ‚Üí Parent provides ‚Üí Children consume
const Context = createContext(undefined);
function Parent({ children }) {
    return &lt;Context.Provider value={...}&gt;{children}&lt;/Context.Provider&gt;;
}
Parent.Child = function Child() {
    const context = useContext(Context);
    return ...;
};</code></pre>
                </div>

                <div class="card">
                    <h4>2. Controlled/Uncontrolled</h4>
                    <pre><code class="language-typescript">// Support both by checking if value/onChange provided
const activeValue = value !== undefined ? value : internalValue;
const handleChange = onChange || setInternalValue;</code></pre>
                </div>

                <div class="card">
                    <h4>3. Performance Optimization</h4>
                    <pre><code class="language-typescript">// Memoize context value
const value = useMemo(() => ({
    state,
    actions: useCallback(...)
}), [dependencies]);</code></pre>
                </div>

                <h3>üéì What You've Learned</h3>
                <p>Congratulations! You now understand:</p>
                <ul>
                    <li>‚úÖ What compound components are and why they're useful</li>
                    <li>‚úÖ How to use Context for implicit state sharing</li>
                    <li>‚úÖ Building real-world components: Tabs, Accordion</li>
                    <li>‚úÖ TypeScript typing for compound components</li>
                    <li>‚úÖ Advanced patterns: render props, polymorphic, context splitting</li>
                    <li>‚úÖ Best practices for API design and maintainability</li>
                    <li>‚úÖ Common mistakes and how to avoid them</li>
                    <li>‚úÖ Accessibility considerations</li>
                </ul>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://kentcdodds.com/blog/compound-components-with-react-hooks" target="_blank" rel="noopener">Kent C. Dodds - Compound Components with React Hooks</a></li>
                    <li><a href="https://www.radix-ui.com/" target="_blank" rel="noopener">Radix UI - Unstyled, accessible components</a></li>
                    <li><a href="https://reach.tech/" target="_blank" rel="noopener">Reach UI - Accessible React components</a></li>
                    <li><a href="https://headlessui.com/" target="_blank" rel="noopener">Headless UI - Unstyled, accessible UI components</a></li>
                    <li><a href="https://www.patterns.dev/posts/compound-pattern" target="_blank" rel="noopener">Patterns.dev - Compound Pattern</a></li>
                    <li><a href="https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase/#compound-components" target="_blank" rel="noopener">React TypeScript Cheatsheet - Compound Components</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>Congratulations on completing Module 5: Advanced Hooks and Patterns! üéâ</p>
                <p>You've mastered:</p>
                <ul>
                    <li>useReducer for complex state management</li>
                    <li>useContext for sharing data across components</li>
                    <li>useRef for DOM access and mutable values</li>
                    <li>useMemo and useCallback for performance optimization</li>
                    <li>Compound Components pattern for flexible APIs</li>
                </ul>
                <p>In <strong>Module 6: Routing and Navigation</strong>, you'll learn how to build multi-page applications with React Router, including:</p>
                <ul>
                    <li>Single Page Applications (SPAs)</li>
                    <li>Client-side routing</li>
                    <li>Dynamic routes and parameters</li>
                    <li>Protected routes and navigation guards</li>
                    <li>And building a complete multi-page blog application!</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Practice Challenge</h3>
                    <p style="color: white;">Before moving on, try building one of these projects using compound components:</p>
                    <ul style="color: white;">
                        <li><strong>Form Builder:</strong> Create a flexible form component with Form, Form.Field, Form.Label, Form.Input, Form.Error</li>
                        <li><strong>Data Table:</strong> Build a sortable, filterable table with Table, Table.Header, Table.Row, Table.Cell</li>
                        <li><strong>Navigation Menu:</strong> Create a multi-level menu with Menu, Menu.Item, Menu.Submenu</li>
                        <li><strong>Dialog System:</strong> Build modals with Dialog, Dialog.Trigger, Dialog.Content, Dialog.Actions</li>
                        <li><strong>Timeline Component:</strong> Create a timeline with Timeline, Timeline.Item, Timeline.Marker</li>
                    </ul>
                </div>

                <h3>üí° Final Thoughts</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Compound components are a powerful pattern that balances flexibility with simplicity. They make your component APIs feel natural and intuitive while giving users the freedom to compose components however they need.</p>
                    <p><strong>Key principles to remember:</strong></p>
                    <ul>
                        <li>‚úÖ Make simple things simple (good defaults)</li>
                        <li>‚úÖ Make complex things possible (flexibility)</li>
                        <li>‚úÖ Fail fast with helpful errors (great DX)</li>
                        <li>‚úÖ Be consistent (predictable APIs)</li>
                        <li>‚úÖ Think about accessibility (inclusive by default)</li>
                    </ul>
                    <p>This pattern is used by all major React component libraries for a reason - it works! Now you have the knowledge to create amazing, flexible components. Go build something awesome! üöÄ</p>
                </div>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've completed Module 5 and mastered advanced React patterns! You now know how to build flexible, composable components with elegant APIs. You understand compound components, performance optimization, advanced hooks, and how to create components that developers love to use. These are professional-level skills that will serve you well in any React project. You're now ready to tackle complex UI challenges with confidence! Keep up the incredible work! üåü</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_5_4_usememo_usecallback.html" class="prev-lesson">‚Üê Previous: Lesson 5.4 - useMemo and useCallback</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="module_project_5_ecommerce_catalog.html" class="next-lesson">Next: Module 5 Project - E-commerce Catalog ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to build amazing React applications with TypeScript.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
