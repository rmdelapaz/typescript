<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React architecture best practices and design patterns for building scalable, maintainable applications. Learn feature-based folder structure, component organization, separation of concerns, custom hooks, service layers, and professional code organization with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.5: Architecture Best Practices - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                â˜°
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">ğŸŒ™</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.5: Architecture Best Practices</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>ğŸ—ï¸ Lesson 8.5: Architecture Best Practices</h1>
                <p class="lead">Welcome to the final lesson of Module 8! Great code isn't just about writing featuresâ€”it's about building applications that scale, adapt to change, and remain maintainable as your team and codebase grow. In this comprehensive lesson, you'll learn professional architecture patterns that separate great React applications from good ones. Whether you're building a small side project or an enterprise application, these architectural principles will serve you throughout your career as a React developer.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>ğŸ¯ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the principles of scalable React architecture</li>
                        <li>Implement feature-based folder structures</li>
                        <li>Organize components by responsibility and reusability</li>
                        <li>Apply separation of concerns to React applications</li>
                        <li>Extract business logic into custom hooks</li>
                        <li>Design service layers for API communication</li>
                        <li>Structure TypeScript types and interfaces effectively</li>
                        <li>Implement proper error handling strategies</li>
                        <li>Design for testability from the start</li>
                        <li>Make architectural decisions that support growth</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 8.1-8.4 (State Management, Zustand, Redux Toolkit, React Query), All previous modules</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">ğŸ“‘ In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Principles of Good Architecture</a></li>
                        <li><a href="#section2" class="toc-link">Feature-Based Folder Structure</a></li>
                        <li><a href="#section3" class="toc-link">Component Organization Patterns</a></li>
                        <li><a href="#section4" class="toc-link">Separation of Concerns</a></li>
                        <li><a href="#section5" class="toc-link">Custom Hooks for Business Logic</a></li>
                        <li><a href="#section6" class="toc-link">Service Layer Pattern</a></li>
                        <li><a href="#section7" class="toc-link">Type Organization</a></li>
                        <li><a href="#section8" class="toc-link">Error Handling Architecture</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Principles of Good Architecture -->
            <section id="section1">
                <h2>ğŸ¯ Principles of Good Architecture</h2>
                
                <p>Before diving into specific patterns, let's understand the fundamental principles that guide architectural decisions in React applications. These principles apply regardless of project size or specific technologies used.</p>

                <h3>The Core Principles</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>ğŸ“– Architecture Principles</h4>
                    <p style="color: white;"><strong>Good architecture</strong> is about making your codebase easy to understand, modify, and extend. It prioritizes <strong>maintainability</strong> over cleverness, <strong>clarity</strong> over brevity, and <strong>consistency</strong> over individual preferences. The goal is to minimize the cognitive load required to work with your code, both for yourself in the future and for your teammates.</p>
                </div>

                <h3>1. Separation of Concerns</h3>

                <p>Each part of your application should have a single, well-defined responsibility. When components, hooks, and utilities each focus on one thing, they become easier to understand, test, and reuse.</p>

                <pre><code class="language-typescript">// âŒ BAD - Component doing too much
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, []);
  
  const saveUser = (data) => {
    fetch('/api/user', {
      method: 'PUT',
      body: JSON.stringify(data)
    }).then(/* ... */);
  };
  
  return (
    &lt;div&gt;
      {loading ? &lt;Spinner /&gt; : (
        &lt;form onSubmit={/* validation logic */}&gt;
          {/* lots of form fields and UI logic */}
        &lt;/form&gt;
      )}
    &lt;/div&gt;
  );
}

// âœ… GOOD - Separated concerns
function UserProfile() {
  const { user, isLoading } = useUser();
  
  return (
    &lt;div&gt;
      {isLoading ? &lt;Spinner /&gt; : &lt;UserForm user={user} /&gt;}
    &lt;/div&gt;
  );
}

// Custom hook handles data fetching
function useUser() {
  return useQuery({
    queryKey: ['user'],
    queryFn: userService.getProfile
  });
}

// Service handles API calls
const userService = {
  getProfile: () => fetch('/api/user').then(r => r.json()),
  updateProfile: (data) => fetch('/api/user', { 
    method: 'PUT', 
    body: JSON.stringify(data) 
  })
};

// Component handles only UI and user interactions
function UserForm({ user }: { user: User }) {
  const updateMutation = useUpdateUser();
  // Form logic...
}</code></pre>

                <div class="mermaid">
graph TB
    A[UserProfile Component] --> B[Presentation Layer]
    A --> C[Data Layer useUser]
    A --> D[Business Logic Layer]
    
    C --> E[Service Layer]
    E --> F[API Calls]
    
    B --> G[UserForm Component]
    B --> H[Spinner Component]
    
    D --> I[Custom Hooks]
    I --> J[useUpdateUser]
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style C fill:#fff3cd
    style D fill:#f8bbd0
    style E fill:#d1c4e9
</div>

                <h3>2. DRY (Don't Repeat Yourself)</h3>

                <p>Duplicated code multiplies maintenance work and increases the chance of bugs. Extract common logic into reusable functions, hooks, and components.</p>

                <pre><code class="language-typescript">// âŒ BAD - Repeated logic
function UsersList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  // ... component JSX
}

function PostsList() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/posts')
      .then(res => res.json())
      .then(data => {
        setPosts(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  // ... component JSX
}

// âœ… GOOD - Reusable hook
function useFetch&lt;T&gt;(url: string) {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  useEffect(() => {
    let cancelled = false;
    
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!cancelled) {
          setData(data);
          setLoading(false);
        }
      })
      .catch(err => {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      });
    
    return () => { cancelled = true; };
  }, [url]);
  
  return { data, loading, error };
}

// Now both components are simple
function UsersList() {
  const { data: users, loading, error } = useFetch&lt;User[]&gt;('/api/users');
  // ... component JSX
}

function PostsList() {
  const { data: posts, loading, error } = useFetch&lt;Post[]&gt;('/api/posts');
  // ... component JSX
}</code></pre>

                <h3>3. KISS (Keep It Simple, Stupid)</h3>

                <p>Simple solutions are easier to understand, test, and maintain. Avoid over-engineering and premature optimization.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Signs of Good Simplicity</h4>
                    <ul>
                        <li>A new team member can understand a component in under 5 minutes</li>
                        <li>Testing feels natural, not like fighting the code</li>
                        <li>Naming clearly describes what something does</li>
                        <li>You don't need comments to explain "why" (but you might need them for "what")</li>
                        <li>Changes in one area rarely require changes in unrelated areas</li>
                    </ul>
                </div>

                <h3>4. Single Responsibility Principle</h3>

                <p>Each component, function, or module should have one reason to change. This makes code predictable and reduces the ripple effect of modifications.</p>

                <pre><code class="language-typescript">// âŒ BAD - Component has multiple responsibilities
function UserDashboard() {
  return (
    &lt;div&gt;
      {/* Analytics tracking logic */}
      {/* User data fetching */}
      {/* Navigation rendering */}
      {/* User profile display */}
      {/* Settings management */}
      {/* Notifications handling */}
    &lt;/div&gt;
  );
}

// âœ… GOOD - Each component has one responsibility
function UserDashboard() {
  useAnalytics('dashboard-view');
  const { user } = useUser();
  
  return (
    &lt;DashboardLayout&gt;
      &lt;UserHeader user={user} /&gt;
      &lt;UserStats userId={user.id} /&gt;
      &lt;RecentActivity userId={user.id} /&gt;
      &lt;QuickActions /&gt;
    &lt;/DashboardLayout&gt;
  );
}</code></pre>

                <h3>5. Composition Over Inheritance</h3>

                <p>React's component model encourages composition. Build complex UIs by combining simple, focused components rather than creating deep inheritance hierarchies.</p>

                <pre><code class="language-typescript">// âœ… GOOD - Composition pattern
function Card({ children }: { children: React.ReactNode }) {
  return &lt;div className="card"&gt;{children}&lt;/div&gt;;
}

function CardHeader({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-header"&gt;{children}&lt;/div&gt;;
}

function CardBody({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-body"&gt;{children}&lt;/div&gt;;
}

// Compose them together
function UserCard({ user }: { user: User }) {
  return (
    &lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;/CardHeader&gt;
      &lt;CardBody&gt;
        &lt;p&gt;{user.bio}&lt;/p&gt;
      &lt;/CardBody&gt;
    &lt;/Card&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ The Testing Principle</h4>
                    <p>A good architecture test: If a component is hard to test, it's probably doing too much. Difficulty testing is often a sign that you need to break things down or separate concerns better.</p>
                </div>

                <h3>Architecture Anti-Patterns to Avoid</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Anti-Pattern</th>
                            <th>Problem</th>
                            <th>Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>God Components</strong></td>
                            <td>Components that do everything</td>
                            <td>Break into smaller, focused components</td>
                        </tr>
                        <tr>
                            <td><strong>Prop Drilling</strong></td>
                            <td>Passing props through many layers</td>
                            <td>Use Context, state management, or composition</td>
                        </tr>
                        <tr>
                            <td><strong>Mixed Concerns</strong></td>
                            <td>Business logic in components</td>
                            <td>Extract to custom hooks or services</td>
                        </tr>
                        <tr>
                            <td><strong>Tight Coupling</strong></td>
                            <td>Components depend on implementation details</td>
                            <td>Use interfaces and dependency injection</td>
                        </tr>
                        <tr>
                            <td><strong>Premature Abstraction</strong></td>
                            <td>Creating abstractions before needed</td>
                            <td>Wait for the third use case</td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <!-- Section 2: Feature-Based Folder Structure -->
            <section id="section2">
                <h2>ğŸ“ Feature-Based Folder Structure</h2>
                
                <p>As applications grow, organizing files by type (all components together, all hooks together) becomes unwieldy. A <strong>feature-based structure</strong> groups related files together, making it easier to understand and modify features as complete units.</p>

                <h3>Traditional vs Feature-Based Structure</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                    <div>
                        <h4>âŒ Type-Based (Doesn't Scale)</h4>
                        <pre><code class="language-bash">src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”œâ”€â”€ UserCard.tsx
â”‚   â”œâ”€â”€ UserForm.tsx
â”‚   â”œâ”€â”€ PostList.tsx
â”‚   â”œâ”€â”€ PostCard.tsx
â”‚   â”œâ”€â”€ PostForm.tsx
â”‚   â”œâ”€â”€ CommentList.tsx
â”‚   â””â”€â”€ ...50+ more
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useUsers.ts
â”‚   â”œâ”€â”€ usePosts.ts
â”‚   â”œâ”€â”€ useComments.ts
â”‚   â””â”€â”€ ...30+ more
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ userService.ts
â”‚   â”œâ”€â”€ postService.ts
â”‚   â””â”€â”€ ...20+ more
â””â”€â”€ types/
    â”œâ”€â”€ user.ts
    â”œâ”€â”€ post.ts
    â””â”€â”€ ...20+ more</code></pre>
                    </div>
                    <div>
                        <h4>âœ… Feature-Based (Scales Well)</h4>
                        <pre><code class="language-bash">src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ UserCard.tsx
â”‚   â”‚   â”‚   â””â”€â”€ UserForm.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â””â”€â”€ useUsers.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ userService.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ user.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â””â”€â”€ comments/
â”‚       â””â”€â”€ ...
â””â”€â”€ shared/
    â”œâ”€â”€ components/
    â”œâ”€â”€ hooks/
    â””â”€â”€ utils/</code></pre>
                    </div>
                </div>

                <h3>Complete Feature-Based Architecture</h3>

                <pre><code class="language-bash">src/
â”œâ”€â”€ features/                    # Feature modules
â”‚   â”œâ”€â”€ auth/                   # Authentication feature
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginForm.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterForm.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ProtectedRoute.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”‚   â””â”€â”€ useLogin.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ authService.ts
â”‚   â”‚   â”œâ”€â”€ store/             # Feature-specific state
â”‚   â”‚   â”‚   â””â”€â”€ authStore.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ auth.types.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ tokenManager.ts
â”‚   â”‚   â””â”€â”€ index.ts           # Public API
â”‚   â”‚
â”‚   â”œâ”€â”€ users/                 # Users feature
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserList/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.test.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserList.module.css
â”‚   â”‚   â”‚   â”œâ”€â”€ UserCard/
â”‚   â”‚   â”‚   â””â”€â”€ UserProfile/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useUsers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useUser.ts
â”‚   â”‚   â”‚   â””â”€â”€ useUpdateUser.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ userService.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ user.types.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ posts/
â”‚   â”œâ”€â”€ comments/
â”‚   â””â”€â”€ dashboard/
â”‚
â”œâ”€â”€ shared/                     # Shared across features
â”‚   â”œâ”€â”€ components/            # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â””â”€â”€ Modal/
â”‚   â”œâ”€â”€ hooks/                 # Reusable hooks
â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â”œâ”€â”€ useDebounce.ts
â”‚   â”‚   â””â”€â”€ useMediaQuery.ts
â”‚   â”œâ”€â”€ utils/                 # Utility functions
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ helpers.ts
â”‚   â”œâ”€â”€ types/                 # Shared types
â”‚   â”‚   â””â”€â”€ common.types.ts
â”‚   â””â”€â”€ constants/
â”‚       â””â”€â”€ config.ts
â”‚
â”œâ”€â”€ lib/                       # Third-party setup
â”‚   â”œâ”€â”€ react-query.ts        # React Query config
â”‚   â”œâ”€â”€ axios.ts              # Axios instance
â”‚   â””â”€â”€ i18n.ts               # Internationalization
â”‚
â”œâ”€â”€ pages/                     # Route components (or routes/)
â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”œâ”€â”€ UsersPage.tsx
â”‚   â”œâ”€â”€ UserDetailPage.tsx
â”‚   â””â”€â”€ NotFoundPage.tsx
â”‚
â”œâ”€â”€ layouts/                   # Layout components
â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â”œâ”€â”€ AuthLayout.tsx
â”‚   â””â”€â”€ DashboardLayout.tsx
â”‚
â”œâ”€â”€ styles/                    # Global styles
â”‚   â”œâ”€â”€ globals.css
â”‚   â”œâ”€â”€ variables.css
â”‚   â””â”€â”€ theme.css
â”‚
â”œâ”€â”€ App.tsx                    # Root component
â”œâ”€â”€ main.tsx                   # Entry point
â””â”€â”€ vite-env.d.ts             # Vite types</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Benefits of Feature-Based Structure</h4>
                    <ul>
                        <li><strong>Scalability:</strong> Add new features without cluttering existing folders</li>
                        <li><strong>Maintainability:</strong> All related code lives together</li>
                        <li><strong>Team collaboration:</strong> Multiple devs can work on different features</li>
                        <li><strong>Code ownership:</strong> Clear boundaries for feature teams</li>
                        <li><strong>Easier refactoring:</strong> Feature can be moved or removed as a unit</li>
                        <li><strong>Better imports:</strong> Feature's public API through index.ts</li>
                    </ul>
                </div>

                <h3>Feature Module Example</h3>

                <pre><code class="language-typescript">// features/users/index.ts - Public API
export { UserList } from './components/UserList';
export { UserCard } from './components/UserCard';
export { useUsers, useUser } from './hooks';
export type { User, UserFilters } from './types/user.types';

// Other files import from the feature
import { UserList, useUsers, User } from '@/features/users';

// NOT from internal paths
// âŒ DON'T: import { UserList } from '@/features/users/components/UserList';</code></pre>

                <h3>Shared vs Feature-Specific</h3>

                <p>Deciding what goes in <code>shared/</code> vs <code>features/</code>:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Put in shared/</th>
                            <th>Put in feature/</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Used by 3+ features</td>
                            <td>Used by only 1-2 features</td>
                        </tr>
                        <tr>
                            <td>Generic UI components (Button, Input)</td>
                            <td>Domain-specific components (UserCard)</td>
                        </tr>
                        <tr>
                            <td>Generic utilities (formatDate, debounce)</td>
                            <td>Domain logic (calculateUserScore)</td>
                        </tr>
                        <tr>
                            <td>No business logic</td>
                            <td>Contains business logic</td>
                        </tr>
                        <tr>
                            <td>Could be open-sourced</td>
                            <td>Specific to this app</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>âš ï¸ Avoid Premature Sharing</h4>
                    <p>When creating a new component, start in the feature folder. Move it to <code>shared/</code> only when you actually need it in a second place. The "Rule of Three" applies: extract to shared when you need it the third time.</p>
                </div>

            </section>

            <!-- Section 3: Component Organization Patterns -->
            <section id="section3">
                <h2>ğŸ§© Component Organization Patterns</h2>
                
                <p>Not all components are created equal. Understanding different component types and their roles helps you organize them effectively and make better architectural decisions.</p>

                <h3>The Component Hierarchy</h3>

                <div class="mermaid">
graph TB
    A[Pages/Routes] --> B[Features]
    A --> C[Layouts]
    
    B --> D[Container Components]
    D --> E[Presentational Components]
    
    E --> F[UI Components]
    F --> G[Shared Components]
    
    C --> F
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style D fill:#fff3cd
    style E fill:#f8bbd0
    style F fill:#d1c4e9
    style G fill:#ffccbc
</div>

                <h3>1. Page Components (Route Components)</h3>

                <p>Top-level components that correspond to routes. They orchestrate feature components and manage page-level concerns.</p>

                <pre><code class="language-typescript">// pages/UsersPage.tsx
import { UserList } from '@/features/users';
import { PageHeader } from '@/shared/components';
import { MainLayout } from '@/layouts';

export function UsersPage() {
  return (
    &lt;MainLayout&gt;
      &lt;PageHeader 
        title="Users" 
        description="Manage all users in your application"
      /&gt;
      &lt;UserList /&gt;
    &lt;/MainLayout&gt;
  );
}

// Characteristics:
// - Maps to a route
// - Minimal logic (mostly composition)
// - Uses layouts and features
// - Handles page-level data fetching
// - Sets page metadata (title, etc.)</code></pre>

                <h3>2. Container Components (Smart Components)</h3>

                <p>Manage state, data fetching, and business logic. They connect to stores, hooks, and APIs, then pass data down to presentational components.</p>

                <pre><code class="language-typescript">// features/users/components/UserList/UserListContainer.tsx
import { useUsers } from '../../hooks/useUsers';
import { UserListView } from './UserListView';

export function UserListContainer() {
  const { 
    users, 
    isLoading, 
    error, 
    refetch 
  } = useUsers();
  
  const [filters, setFilters] = useState&lt;UserFilters&gt;({});
  
  const handleFilterChange = (newFilters: UserFilters) => {
    setFilters(newFilters);
  };
  
  const filteredUsers = useMemo(() => {
    return users?.filter(user => {
      // Filtering logic
      return true;
    });
  }, [users, filters]);
  
  if (isLoading) return &lt;LoadingSpinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} onRetry={refetch} /&gt;;
  
  return (
    &lt;UserListView
      users={filteredUsers}
      filters={filters}
      onFilterChange={handleFilterChange}
    /&gt;
  );
}

// Characteristics:
// - Manages state and side effects
// - Connects to data sources
// - Contains business logic
// - Handles loading and error states
// - Passes data to presentational components</code></pre>

                <h3>3. Presentational Components (Dumb Components)</h3>

                <p>Focus purely on rendering UI. They receive data through props and notify parents of user interactions through callback props.</p>

                <pre><code class="language-typescript">// features/users/components/UserList/UserListView.tsx
interface UserListViewProps {
  users: User[];
  filters: UserFilters;
  onFilterChange: (filters: UserFilters) => void;
}

export function UserListView({ 
  users, 
  filters, 
  onFilterChange 
}: UserListViewProps) {
  return (
    &lt;div className="user-list"&gt;
      &lt;UserFilters 
        filters={filters} 
        onChange={onFilterChange} 
      /&gt;
      
      &lt;div className="user-grid"&gt;
        {users.map(user => (
          &lt;UserCard key={user.id} user={user} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Characteristics:
// - Pure presentation logic
// - No state or side effects
// - Easy to test
// - Reusable with different data
// - Can be used in Storybook</code></pre>