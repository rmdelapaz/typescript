<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React Testing Library fundamentals. Learn the Testing Library philosophy, how to render components, query elements, simulate user interactions, and write effective component tests.">
    <meta name="author" content="Ray">
    <title>Lesson 9.2: React Testing Library - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 9: Testing React Applications</a></li>
            <li aria-current="page">Lesson 9.2: React Testing Library</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>‚öõÔ∏è Lesson 9.2: React Testing Library</h1>
                <p class="lead">Master React Testing Library and learn to test your components the way users interact with them. Discover the Testing Library philosophy, query methods, user interaction testing, and best practices for component testing.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the Testing Library philosophy and why it matters</li>
                        <li>Set up React Testing Library in a TypeScript project</li>
                        <li>Render React components in tests and query elements effectively</li>
                        <li>Distinguish between getBy, findBy, and queryBy query methods</li>
                        <li>Simulate user interactions with userEvent</li>
                        <li>Test asynchronous behavior in React components</li>
                        <li>Write type-safe tests for React components with TypeScript</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Test a complete React component with user interactions</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Introduction to React Testing Library</a></li>
                        <li><a href="#philosophy" class="toc-link">The Testing Library Philosophy</a></li>
                        <li><a href="#setup" class="toc-link">Setting Up React Testing Library</a></li>
                        <li><a href="#rendering" class="toc-link">Rendering Components</a></li>
                        <li><a href="#queries" class="toc-link">Query Methods</a></li>
                        <li><a href="#user-interactions" class="toc-link">Simulating User Interactions</a></li>
                        <li><a href="#async-testing" class="toc-link">Testing Async Behavior</a></li>
                        <li><a href="#typescript-typing" class="toc-link">TypeScript and Testing</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#best-practices" class="toc-link">Best Practices</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Introduction to React Testing Library</h2>
                
                <p>In the previous lesson, we learned to test utility functions with Jest. But React applications aren't just functions‚Äîthey're interactive user interfaces built with components. How do we test something visual and interactive?</p>

                <p>Enter <strong>React Testing Library (RTL)</strong>‚Äîthe most popular and recommended way to test React components. It's built on a simple but powerful philosophy: <em>test your components the way users use them</em>.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What is React Testing Library?</h4>
                    <p style="color: white;"><strong>React Testing Library</strong> is a lightweight testing library that provides utilities for testing React components by interacting with them as a user would. It encourages testing behavior over implementation details.</p>
                </div>

                <h3>Why React Testing Library?</h3>
                <p>Before RTL, React developers often used Enzyme, which exposed component internals like state and props. While powerful, this led to brittle tests that broke whenever you refactored. RTL took a different approach:</p>

                <div class="mermaid">
                    graph LR
                    A[Old Approach<br/>Enzyme] --> B[Test Internal State]
                    A --> C[Test Props]
                    A --> D[Test Methods]
                    E[RTL Approach] --> F[Test What User Sees]
                    E --> G[Test User Interactions]
                    E --> H[Test UI Changes]
                    
                    style A fill:#ff6b6b,stroke:#c92a2a,stroke-width:2px,color:#fff
                    style E fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The RTL Advantage</h4>
                    <p>React Testing Library helps you write tests that:</p>
                    <ul>
                        <li><strong>Stay stable during refactoring:</strong> Tests don't break when you change implementation</li>
                        <li><strong>Catch real bugs:</strong> Focus on user-facing functionality</li>
                        <li><strong>Improve accessibility:</strong> Encourages finding elements by accessible attributes</li>
                        <li><strong>Build confidence:</strong> If tests pass, the UI actually works for users</li>
                    </ul>
                </div>

                <h3>What Can You Test with RTL?</h3>
                <ul>
                    <li><strong>Rendering:</strong> Does the component display correctly?</li>
                    <li><strong>User interactions:</strong> What happens when users click, type, or navigate?</li>
                    <li><strong>Props:</strong> Does the component respond correctly to different props?</li>
                    <li><strong>Conditional rendering:</strong> Does the right content show in different scenarios?</li>
                    <li><strong>Async operations:</strong> Do loading states and data fetching work?</li>
                    <li><strong>Accessibility:</strong> Can the component be used with assistive technologies?</li>
                </ul>

                <blockquote>
                    <strong>üí¨ From the Creator:</strong> "The more your tests resemble the way your software is used, the more confidence they can give you." ‚Äì Kent C. Dodds, creator of React Testing Library
                </blockquote>
            </section>

            <!-- Section 2: Philosophy -->
            <section id="philosophy" class="lesson-section">
                <h2>üé≠ The Testing Library Philosophy</h2>
                
                <p>Understanding the philosophy behind React Testing Library is crucial to writing effective tests. Let's explore the core principles that guide how we test components.</p>

                <h3>Principle 1: Test Behavior, Not Implementation</h3>
                <p>Users don't care about your component's state or prop names. They care about what they see and how it behaves.</p>

                <div class="card" style="background: #f0f0f0; border-left: 4px solid #667eea;">
                    <h4>‚ùå Bad: Testing Implementation</h4>
                    <pre><code class="language-typescript">
// DON'T DO THIS
test('counter increments state', () => {
  const { container } = render(&lt;Counter /&gt;);
  const component = container.querySelector('.counter');
  
  // Testing internal state - BAD!
  expect(component.state.count).toBe(0);
  component.instance().increment();
  expect(component.state.count).toBe(1);
});
                    </code></pre>

                    <h4>‚úÖ Good: Testing Behavior</h4>
                    <pre><code class="language-typescript">
// DO THIS INSTEAD
test('counter displays incremented value when button is clicked', () => {
  render(&lt;Counter /&gt;);
  
  // Test what the user sees
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  
  // Test user interaction
  fireEvent.click(screen.getByRole('button', { name: /increment/i }));
  
  // Verify the visible result
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
                    </code></pre>
                </div>

                <h3>Principle 2: Query By Accessibility</h3>
                <p>RTL encourages finding elements the way assistive technologies do. This makes your tests and your components more accessible.</p>

                <table>
                    <thead>
                        <tr>
                            <th>Priority</th>
                            <th>Query Method</th>
                            <th>When to Use</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>1st (Best)</td>
                            <td><code>getByRole</code></td>
                            <td>Buttons, links, form fields with accessible roles</td>
                            <td><code>getByRole('button', { name: 'Submit' })</code></td>
                        </tr>
                        <tr>
                            <td>2nd</td>
                            <td><code>getByLabelText</code></td>
                            <td>Form inputs with labels</td>
                            <td><code>getByLabelText('Email')</code></td>
                        </tr>
                        <tr>
                            <td>3rd</td>
                            <td><code>getByPlaceholderText</code></td>
                            <td>Inputs with placeholder text</td>
                            <td><code>getByPlaceholderText('Enter email...')</code></td>
                        </tr>
                        <tr>
                            <td>4th</td>
                            <td><code>getByText</code></td>
                            <td>Non-interactive text content</td>
                            <td><code>getByText('Welcome!')</code></td>
                        </tr>
                        <tr>
                            <td>5th</td>
                            <td><code>getByDisplayValue</code></td>
                            <td>Form inputs with current values</td>
                            <td><code>getByDisplayValue('john@example.com')</code></td>
                        </tr>
                        <tr>
                            <td>6th (Last Resort)</td>
                            <td><code>getByTestId</code></td>
                            <td>When no other query works</td>
                            <td><code>getByTestId('custom-component')</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Why Query Priority Matters</h4>
                    <p>Using <code>getByRole</code> first ensures your components are accessible. If you can't find an element by role, it might not be accessible to screen reader users. This makes your tests a tool for improving accessibility!</p>
                </div>

                <h3>Principle 3: No Implementation Details</h3>
                <p>RTL intentionally doesn't give you access to component internals. You can't access:</p>
                <ul>
                    <li>Component state</li>
                    <li>Component instance methods</li>
                    <li>Props (except through their effects on the UI)</li>
                    <li>Lifecycle methods</li>
                </ul>

                <p>This might feel limiting at first, but it's actually liberating! Your tests become resilient to refactoring.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Real-World Example</h4>
                    <p>Imagine you have a <code>LoginForm</code> component. You refactor it from:</p>
                    <ul>
                        <li>Class component ‚Üí Functional component</li>
                        <li>Local state ‚Üí useReducer</li>
                        <li>One big component ‚Üí Multiple smaller components</li>
                    </ul>
                    <p>With RTL, your tests don't need to change at all! As long as users can still log in, the tests pass. This is the power of testing behavior.</p>
                </div>

                <h3>Principle 4: Prefer User-Facing Queries</h3>
                <p>When multiple query options exist, choose the one closest to how users experience your app:</p>

                <pre><code class="language-typescript">
// ‚ùå Less ideal: Using test IDs
&lt;button data-testid="submit-btn"&gt;Submit&lt;/button&gt;
getByTestId('submit-btn')

// ‚úÖ Better: Using accessible role
&lt;button&gt;Submit&lt;/button&gt;
getByRole('button', { name: 'Submit' })

// ‚úÖ Even better: Using semantic HTML and labels
&lt;button aria-label="Submit registration form"&gt;Submit&lt;/button&gt;
getByRole('button', { name: /submit registration/i })
                </code></pre>

                <h3>The Mindset Shift</h3>
                <p>Testing with RTL requires a mindset shift:</p>

                <div class="mermaid">
                    graph TD
                    A[Developer Thinking] --> B["How did I implement this?"]
                    A --> C["What's the state value?"]
                    A --> D["What props did I pass?"]
                    
                    E[User Thinking] --> F["What do I see on screen?"]
                    E --> G["What can I click/type?"]
                    E --> H["What happens when I interact?"]
                    
                    I[RTL Testing] --> E
                    
                    style A fill:#ff6b6b,stroke:#c92a2a,stroke-width:2px,color:#fff
                    style E fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style I fill:#4dabf7,stroke:#1971c2,stroke-width:2px,color:#fff
                </div>

                <p>When writing tests, constantly ask yourself: <em>"How would a user accomplish this task?"</em> Then test exactly that.</p>
            </section>

            <!-- Section 3: Setup -->
            <section id="setup" class="lesson-section">
                <h2>‚öôÔ∏è Setting Up React Testing Library</h2>
                
                <p>Let's set up React Testing Library in a TypeScript project. If you created your project with Vite, some of this might already be configured!</p>

                <h3>Installation</h3>
                <p>Install React Testing Library and its dependencies:</p>

                <pre><code class="language-bash">
# Core testing libraries
npm install --save-dev @testing-library/react
npm install --save-dev @testing-library/jest-dom
npm install --save-dev @testing-library/user-event

# TypeScript types
npm install --save-dev @types/jest
npm install --save-dev @types/react
npm install --save-dev @types/react-dom

# If using Vitest (for Vite projects)
npm install --save-dev vitest jsdom @vitest/ui
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Package Breakdown</h4>
                    <ul>
                        <li><strong>@testing-library/react:</strong> Core RTL functionality for rendering and querying</li>
                        <li><strong>@testing-library/jest-dom:</strong> Custom matchers for asserting on DOM nodes</li>
                        <li><strong>@testing-library/user-event:</strong> Realistic user interaction simulation</li>
                        <li><strong>jsdom:</strong> Browser-like environment for Node.js</li>
                    </ul>
                </div>

                <h3>Configure Vitest (for Vite Projects)</h3>
                <p>Create or update <code>vitest.config.ts</code>:</p>

                <pre><code class="language-typescript">
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    css: true,
  },
});
                </code></pre>

                <h3>Setup File</h3>
                <p>Create <code>src/test/setup.ts</code> to configure testing utilities:</p>

                <pre><code class="language-typescript">
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach } from 'vitest';

// Cleanup after each test
afterEach(() => {
  cleanup();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What Does This Setup Do?</h4>
                    <ul>
                        <li><strong>@testing-library/jest-dom:</strong> Adds helpful matchers like <code>.toBeInTheDocument()</code></li>
                        <li><strong>cleanup():</strong> Unmounts components after each test to prevent memory leaks</li>
                        <li><strong>jsdom environment:</strong> Simulates a browser DOM in Node.js</li>
                    </ul>
                </div>

                <h3>TypeScript Configuration</h3>
                <p>Update your <code>tsconfig.json</code> to include test types:</p>

                <pre><code class="language-json">
{
  "compilerOptions": {
    "types": ["vitest/globals", "@testing-library/jest-dom"],
    "jsx": "react-jsx",
    // ... other options
  },
  "include": ["src/**/*", "src/**/*.test.tsx"]
}
                </code></pre>

                <h3>Add Test Scripts</h3>
                <p>Update <code>package.json</code> with test commands:</p>

                <pre><code class="language-json">
{
  "scripts": {
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage"
  }
}
                </code></pre>

                <h3>File Naming Convention</h3>
                <p>Place test files next to the components they test:</p>

                <pre><code class="language-plaintext">
src/
  components/
    Button/
      Button.tsx
      Button.test.tsx    ‚Üê Test file
      Button.css
    Counter/
      Counter.tsx
      Counter.test.tsx   ‚Üê Test file
                </code></pre>

                <h3>Verify Setup</h3>
                <p>Create a simple test to verify everything works:</p>

                <pre><code class="language-typescript">
// src/App.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';

describe('Setup Test', () => {
  it('renders without crashing', () => {
    render(&lt;div&gt;Hello, Testing!&lt;/div&gt;);
    expect(screen.getByText('Hello, Testing!')).toBeInTheDocument();
  });
});
                </code></pre>

                <p>Run the test:</p>

                <pre><code class="language-bash">
npm test
                </code></pre>

                <p>You should see:</p>

                <pre><code class="language-plaintext">
 ‚úì src/App.test.tsx (1)
   ‚úì Setup Test (1)
     ‚úì renders without crashing

Test Files  1 passed (1)
     Tests  1 passed (1)
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéâ Setup Complete!</h4>
                    <p>If you see the green checkmark, you're ready to start testing React components! The setup ensures that every test has access to React Testing Library utilities and custom matchers.</p>
                </div>
            </section>

            <!-- Section 4: Rendering Components -->
            <section id="rendering" class="lesson-section">
                <h2>üé® Rendering Components</h2>
                
                <p>The first step in testing a React component is rendering it. React Testing Library provides the <code>render</code> function to mount components in a test environment.</p>

                <h3>Basic Rendering</h3>
                <p>Let's start with a simple component and test it:</p>

                <pre><code class="language-typescript">
// Greeting.tsx
interface GreetingProps {
  name: string;
}

export function Greeting({ name }: GreetingProps) {
  return &lt;h1&gt;Hello, {name}!&lt;/h1&gt;;
}
                </code></pre>

                <pre><code class="language-typescript">
// Greeting.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { Greeting } from './Greeting';

describe('Greeting', () => {
  it('displays the greeting with the provided name', () => {
    // Arrange & Act: Render the component
    render(&lt;Greeting name="Alice" /&gt;);
    
    // Assert: Check if the text appears
    expect(screen.getByText('Hello, Alice!')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Understanding render()</h4>
                    <p style="color: white;"><strong>render()</strong> mounts a React component in a test environment and provides utilities to query and interact with it. It returns an object with query methods, but we usually use the <code>screen</code> object instead for more readable tests.</p>
                </div>

                <h3>The screen Object</h3>
                <p>Instead of destructuring queries from <code>render()</code>, we use the <code>screen</code> object:</p>

                <pre><code class="language-typescript">
// ‚ùå Old style - harder to read
const { getByText, getByRole } = render(&lt;MyComponent /&gt;);
expect(getByText('Hello')).toBeInTheDocument();

// ‚úÖ Preferred style - cleaner and more consistent
render(&lt;MyComponent /&gt;);
expect(screen.getByText('Hello')).toBeInTheDocument();
expect(screen.getByRole('button')).toBeInTheDocument();
                </code></pre>

                <h3>Rendering with Props</h3>
                <p>Test components with different prop combinations:</p>

                <pre><code class="language-typescript">
// Button.tsx
interface ButtonProps {
  label: string;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
  onClick?: () => void;
}

export function Button({ 
  label, 
  variant = 'primary', 
  disabled = false,
  onClick 
}: ButtonProps) {
  return (
    &lt;button 
      className={`btn btn-${variant}`}
      disabled={disabled}
      onClick={onClick}
    &gt;
      {label}
    &lt;/button&gt;
  );
}
                </code></pre>

                <pre><code class="language-typescript">
// Button.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { Button } from './Button';

describe('Button', () => {
  it('renders with label text', () => {
    render(&lt;Button label="Click me" /&gt;);
    expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
  });
  
  it('applies primary variant by default', () => {
    render(&lt;Button label="Submit" /&gt;);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('btn-primary');
  });
  
  it('applies secondary variant when specified', () => {
    render(&lt;Button label="Cancel" variant="secondary" /&gt;);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('btn-secondary');
  });
  
  it('renders as disabled when disabled prop is true', () => {
    render(&lt;Button label="Disabled" disabled /&gt;);
    expect(screen.getByRole('button')).toBeDisabled();
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Test Multiple Scenarios</h4>
                    <p>For components with props, test:</p>
                    <ul>
                        <li>Default prop values</li>
                        <li>Each variant or state</li>
                        <li>Edge cases (empty strings, null, undefined)</li>
                        <li>Different prop combinations</li>
                    </ul>
                </div>

                <h3>Rendering with Children</h3>
                <p>Components that accept children need special consideration:</p>

                <pre><code class="language-typescript">
// Card.tsx
interface CardProps {
  title: string;
  children: React.ReactNode;
}

export function Card({ title, children }: CardProps) {
  return (
    &lt;div className="card"&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div className="card-body"&gt;
        {children}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
                </code></pre>

                <pre><code class="language-typescript">
// Card.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { Card } from './Card';

describe('Card', () => {
  it('renders title and children', () => {
    render(
      &lt;Card title="My Card"&gt;
        &lt;p&gt;Card content here&lt;/p&gt;
      &lt;/Card&gt;
    );
    
    expect(screen.getByRole('heading', { name: 'My Card' })).toBeInTheDocument();
    expect(screen.getByText('Card content here')).toBeInTheDocument();
  });
  
  it('renders multiple children', () => {
    render(
      &lt;Card title="Multiple Items"&gt;
        &lt;p&gt;First paragraph&lt;/p&gt;
        &lt;p&gt;Second paragraph&lt;/p&gt;
        &lt;button&gt;Action&lt;/button&gt;
      &lt;/Card&gt;
    );
    
    expect(screen.getByText('First paragraph')).toBeInTheDocument();
    expect(screen.getByText('Second paragraph')).toBeInTheDocument();
    expect(screen.getByRole('button', { name: 'Action' })).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Rerendering Components</h3>
                <p>Sometimes you need to test how a component updates when props change:</p>

                <pre><code class="language-typescript">
// Counter.tsx
interface CounterProps {
  initialCount?: number;
}

export function Counter({ initialCount = 0 }: CounterProps) {
  const [count, setCount] = React.useState(initialCount);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(c => c + 1)}&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
  );
}
                </code></pre>

                <pre><code class="language-typescript">
// Counter.test.tsx
import { render, screen } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { Counter } from './Counter';

describe('Counter', () => {
  it('updates when initialCount prop changes', () => {
    // Initial render
    const { rerender } = render(&lt;Counter initialCount={0} /&gt;);
    expect(screen.getByText('Count: 0')).toBeInTheDocument();
    
    // Rerender with new prop
    rerender(&lt;Counter initialCount={5} /&gt;);
    expect(screen.getByText('Count: 5')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use rerender()</h4>
                    <p>Use <code>rerender()</code> when testing:</p>
                    <ul>
                        <li>How components respond to prop changes</li>
                        <li>Memoization and optimization behavior</li>
                        <li>Effects that depend on props</li>
                    </ul>
                    <p>Note: Most tests won't need <code>rerender()</code>‚Äîfocus on user interactions instead.</p>
                </div>

                <h3>Unmounting Components</h3>
                <p>Test cleanup and unmounting behavior:</p>

                <pre><code class="language-typescript">
describe('Component cleanup', () => {
  it('cleans up resources on unmount', () => {
    const cleanup = vi.fn();
    
    function ComponentWithCleanup() {
      React.useEffect(() => {
        return cleanup; // Cleanup function
      }, []);
      
      return &lt;div&gt;Test&lt;/div&gt;;
    }
    
    const { unmount } = render(&lt;ComponentWithCleanup /&gt;);
    
    // Cleanup hasn't been called yet
    expect(cleanup).not.toHaveBeenCalled();
    
    // Unmount the component
    unmount();
    
    // Now cleanup should have been called
    expect(cleanup).toHaveBeenCalledTimes(1);
  });
});
                </code></pre>
            </section>

            <!-- Section 5: Query Methods -->
            <section id="queries" class="lesson-section">
                <h2>üîç Query Methods</h2>
                
                <p>React Testing Library provides three types of query methods, each with different behavior. Understanding when to use each type is crucial for writing effective tests.</p>

                <h3>Query Types: getBy, queryBy, findBy</h3>
                <p>Each query comes in three variants with different behaviors:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Query Type</th>
                            <th>Returns</th>
                            <th>Throws Error?</th>
                            <th>Async?</th>
                            <th>Use When</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>getBy...</code></td>
                            <td>Element</td>
                            <td>Yes (if not found)</td>
                            <td>No</td>
                            <td>Element should be present</td>
                        </tr>
                        <tr>
                            <td><code>queryBy...</code></td>
                            <td>Element or null</td>
                            <td>No</td>
                            <td>No</td>
                            <td>Element might not exist</td>
                        </tr>
                        <tr>
                            <td><code>findBy...</code></td>
                            <td>Promise&lt;Element&gt;</td>
                            <td>Yes (if not found)</td>
                            <td>Yes</td>
                            <td>Element appears asynchronously</td>
                        </tr>
                        <tr>
                            <td><code>getAllBy...</code></td>
                            <td>Element[]</td>
                            <td>Yes (if none found)</td>
                            <td>No</td>
                            <td>Multiple elements present</td>
                        </tr>
                        <tr>
                            <td><code>queryAllBy...</code></td>
                            <td>Element[]</td>
                            <td>No</td>
                            <td>No</td>
                            <td>Multiple elements might exist</td>
                        </tr>
                        <tr>
                            <td><code>findAllBy...</code></td>
                            <td>Promise&lt;Element[]&gt;</td>
                            <td>Yes (if none found)</td>
                            <td>Yes</td>
                            <td>Multiple elements appear async</td>
                        </tr>
                    </tbody>
                </table>

                <h3>1. getBy Queries (Most Common)</h3>
                <p>Use <code>getBy</code> when you expect the element to be in the document:</p>

                <pre><code class="language-typescript">
test('getBy examples', () => {
  render(
    &lt;div&gt;
      &lt;h1&gt;Welcome&lt;/h1&gt;
      &lt;button&gt;Click me&lt;/button&gt;
      &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
      &lt;input id="email" type="email" /&gt;
    &lt;/div&gt;
  );
  
  // These all throw if element not found
  expect(screen.getByText('Welcome')).toBeInTheDocument();
  expect(screen.getByRole('button', { name: 'Click me' })).toBeInTheDocument();
  expect(screen.getByLabelText('Email')).toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use getBy</h4>
                    <p>Use <code>getBy</code> when:</p>
                    <ul>
                        <li>You're asserting the element exists</li>
                        <li>The element should always be present</li>
                        <li>You want an error if the element is missing</li>
                    </ul>
                    <p>This is your default choice for most queries!</p>
                </div>

                <h3>2. queryBy Queries (For Absence)</h3>
                <p>Use <code>queryBy</code> when checking if an element does NOT exist:</p>

                <pre><code class="language-typescript">
test('queryBy examples', () => {
  render(&lt;div&gt;&lt;p&gt;Visible content&lt;/p&gt;&lt;/div&gt;);
  
  // This works - element exists
  expect(screen.queryByText('Visible content')).toBeInTheDocument();
  
  // This also works - checking for absence
  expect(screen.queryByText('Hidden content')).not.toBeInTheDocument();
  
  // This would FAIL with getBy (throws error)
  // expect(screen.getByText('Hidden content')).not.toBeInTheDocument();
});
                </code></pre>

                <pre><code class="language-typescript">
// Practical example: Testing conditional rendering
function ConditionalContent({ isLoggedIn }: { isLoggedIn: boolean }) {
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;button&gt;Logout&lt;/button&gt;
      ) : (
        &lt;button&gt;Login&lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}

test('shows login button when not logged in', () => {
  render(&lt;ConditionalContent isLoggedIn={false} /&gt;);
  
  expect(screen.getByRole('button', { name: 'Login' })).toBeInTheDocument();
  expect(screen.queryByRole('button', { name: 'Logout' })).not.toBeInTheDocument();
});

test('shows logout button when logged in', () => {
  render(&lt;ConditionalContent isLoggedIn={true} /&gt;);
  
  expect(screen.getByRole('button', { name: 'Logout' })).toBeInTheDocument();
  expect(screen.queryByRole('button', { name: 'Login' })).not.toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use queryBy</h4>
                    <p>Use <code>queryBy</code> when:</p>
                    <ul>
                        <li>Testing that an element does NOT exist</li>
                        <li>Checking conditional rendering</li>
                        <li>Verifying elements are hidden or removed</li>
                    </ul>
                </div>

                <h3>3. findBy Queries (For Async)</h3>
                <p>Use <code>findBy</code> when elements appear asynchronously:</p>

                <pre><code class="language-typescript">
function AsyncComponent() {
  const [data, setData] = React.useState&lt;string | null&gt;(null);
  
  React.useEffect(() => {
    // Simulate async data loading
    setTimeout(() => {
      setData('Loaded data!');
    }, 100);
  }, []);
  
  return (
    &lt;div&gt;
      {data ? &lt;p&gt;{data}&lt;/p&gt; : &lt;p&gt;Loading...&lt;/p&gt;}
    &lt;/div&gt;
  );
}

test('displays data after loading', async () => {
  render(&lt;AsyncComponent /&gt;);
  
  // Initially shows loading
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  // Wait for data to appear (findBy returns a Promise)
  const dataElement = await screen.findByText('Loaded data!');
  expect(dataElement).toBeInTheDocument();
  
  // Loading message should be gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake: Using getBy for Async</h4>
                    <pre><code class="language-typescript">
// ‚ùå This will fail - getBy doesn't wait
test('wrong approach', () => {
  render(&lt;AsyncComponent /&gt;);
  expect(screen.getByText('Loaded data!')).toBeInTheDocument(); // Error!
});

// ‚úÖ Use findBy instead
test('correct approach', async () => {
  render(&lt;AsyncComponent /&gt;);
  expect(await screen.findByText('Loaded data!')).toBeInTheDocument();
});
                    </code></pre>
                </div>

                <h3>Query Methods Reference</h3>
                <p>Each query type has multiple methods for finding elements:</p>

                <pre><code class="language-typescript">
// By Role (BEST - most accessible)
screen.getByRole('button', { name: 'Submit' })
screen.getByRole('heading', { level: 1 })
screen.getByRole('textbox', { name: 'Email' })

// By Label Text (great for forms)
screen.getByLabelText('Username')
screen.getByLabelText(/email/i) // Case-insensitive regex

// By Placeholder
screen.getByPlaceholderText('Enter your email...')

// By Text
screen.getByText('Welcome back!')
screen.getByText(/welcome/i) // Case-insensitive

// By Display Value (current input value)
screen.getByDisplayValue('john@example.com')

// By Alt Text (for images)
screen.getByAltText('Profile picture')

// By Title
screen.getByTitle('Close dialog')

// By Test ID (last resort)
screen.getByTestId('custom-element')
                </code></pre>

                <h3>Query Options</h3>
                <p>Queries accept options to refine your search:</p>

                <pre><code class="language-typescript">
// Exact match (default: true)
screen.getByText('Submit', { exact: true })
screen.getByText('Sub', { exact: false }) // Matches "Submit"

// Case sensitivity
screen.getByText('hello', { exact: false }) // Matches "Hello"

// Using regex for flexible matching
screen.getByText(/submit/i) // Case-insensitive
screen.getByText(/^Welcome/) // Starts with "Welcome"

// Role with name
screen.getByRole('button', { 
  name: 'Submit Form' // Accessible name
})

// Role with description
screen.getByRole('button', {
  description: 'Submits the registration form'
})

// Multiple options
screen.getByRole('heading', {
  level: 2,
  name: /user profile/i
})
                </code></pre>

                <h3>Debugging Queries</h3>
                <p>When a query fails, RTL provides helpful debugging tools:</p>

                <pre><code class="language-typescript">
test('debugging example', () => {
  render(&lt;MyComponent /&gt;);
  
  // Print the current DOM
  screen.debug();
  
  // Print a specific element
  const button = screen.getByRole('button');
  screen.debug(button);
  
  // Get suggested queries (very helpful!)
  screen.logTestingPlaygroundURL();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Query Selection Guide</h4>
                    <ol>
                        <li>Can you use <code>getByRole</code>? Use it! (Most accessible)</li>
                        <li>Is it a form field with a label? Use <code>getByLabelText</code></li>
                        <li>Is it text content? Use <code>getByText</code></li>
                        <li>Is it async? Use <code>findBy...</code></li>
                        <li>Checking absence? Use <code>queryBy...</code></li>
                        <li>Multiple elements? Use <code>getAllBy...</code> or <code>findAllBy...</code></li>
                        <li>Last resort? Use <code>getByTestId</code></li>
                    </ol>
                </div>
            </section>

            <!-- Section 6: User Interactions -->
            <section id="user-interactions" class="lesson-section">
                <h2>üëÜ Simulating User Interactions</h2>
                
                <p>Testing how components respond to user interactions is where React Testing Library really shines. We'll use <code>@testing-library/user-event</code> for realistic user interactions.</p>

                <h3>user-event vs fireEvent</h3>
                <p>RTL provides two ways to simulate interactions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>fireEvent</th>
                            <th>user-event</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Realism</td>
                            <td>Triggers single event</td>
                            <td>Simulates complete user interaction</td>
                        </tr>
                        <tr>
                            <td>Example: Click</td>
                            <td>Just triggers 'click'</td>
                            <td>mousedown ‚Üí focus ‚Üí mouseup ‚Üí click</td>
                        </tr>
                        <tr>
                            <td>Example: Type</td>
                            <td>Just changes value</td>
                            <td>keydown ‚Üí keypress ‚Üí input ‚Üí keyup (per character)</td>
                        </tr>
                        <tr>
                            <td>Async</td>
                            <td>Synchronous</td>
                            <td>Returns promises (async)</td>
                        </tr>
                        <tr>
                            <td>Recommendation</td>
                            <td>Avoid (unless debugging)</td>
                            <td>Prefer this (more realistic)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why user-event?</h4>
                    <p><code>user-event</code> simulates interactions more realistically. For example, clicking a button with <code>user-event</code> triggers hover, focus, mousedown, mouseup, and click events‚Äîjust like a real user. This catches bugs that <code>fireEvent</code> would miss!</p>
                </div>

                <h3>Setting Up user-event</h3>
                <pre><code class="language-typescript">
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect } from 'vitest';

describe('Component with interactions', () => {
  it('handles user interactions', async () => {
    // Setup user-event
    const user = userEvent.setup();
    
    render(&lt;MyComponent /&gt;);
    
    // Use the user object for interactions
    await user.click(screen.getByRole('button'));
  });
});
                </code></pre>

                <h3>Clicking Elements</h3>
                <pre><code class="language-typescript">
function ClickCounter() {
  const [count, setCount] = React.useState(0);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() => setCount(c => c + 1)}&gt;
        Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

test('increments count when button is clicked', async () => {
  const user = userEvent.setup();
  render(&lt;ClickCounter /&gt;);
  
  // Initial state
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  
  // Click the button
  await user.click(screen.getByRole('button', { name: 'Increment' }));
  
  // Verify the update
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
  
  // Click again
  await user.click(screen.getByRole('button', { name: 'Increment' }));
  expect(screen.getByText('Count: 2')).toBeInTheDocument();
});
                </code></pre>

                <h3>Typing in Inputs</h3>
                <pre><code class="language-typescript">
function SearchForm() {
  const [query, setQuery] = React.useState('');
  const [results, setResults] = React.useState&lt;string[]&gt;([]);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    setResults([`Result for: ${query}`]);
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="search"&gt;Search&lt;/label&gt;
      &lt;input
        id="search"
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      /&gt;
      &lt;button type="submit"&gt;Search&lt;/button&gt;
      
      &lt;ul&gt;
        {results.map((result, i) => (
          &lt;li key={i}&gt;{result}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/form&gt;
  );
}

test('searches when user types and submits', async () => {
  const user = userEvent.setup();
  render(&lt;SearchForm /&gt;);
  
  // Type in the search input
  const searchInput = screen.getByLabelText('Search');
  await user.type(searchInput, 'React Testing');
  
  // Verify the input value
  expect(searchInput).toHaveValue('React Testing');
  
  // Submit the form
  await user.click(screen.getByRole('button', { name: 'Search' }));
  
  // Verify results appear
  expect(screen.getByText('Result for: React Testing')).toBeInTheDocument();
});
                </code></pre>

                <h3>Typing Special Keys</h3>
                <pre><code class="language-typescript">
test('handles keyboard shortcuts', async () => {
  const user = userEvent.setup();
  render(&lt;TextEditor /&gt;);
  
  const textarea = screen.getByRole('textbox');
  
  // Type text
  await user.type(textarea, 'Hello World');
  
  // Select all (Ctrl+A)
  await user.keyboard('{Control>}a{/Control}');
  
  // Delete
  await user.keyboard('{Backspace}');
  
  expect(textarea).toHaveValue('');
});

test('handles Enter key', async () => {
  const user = userEvent.setup();
  const handleSubmit = vi.fn();
  
  render(&lt;ChatInput onSubmit={handleSubmit} /&gt;);
  
  await user.type(screen.getByRole('textbox'), 'Hello{Enter}');
  
  expect(handleSubmit).toHaveBeenCalledWith('Hello');
});
                </code></pre>

                <h3>Selecting Options</h3>
                <pre><code class="language-typescript">
function CountrySelector() {
  const [country, setCountry] = React.useState('');
  
  return (
    &lt;div&gt;
      &lt;label htmlFor="country"&gt;Country&lt;/label&gt;
      &lt;select 
        id="country" 
        value={country}
        onChange={(e) => setCountry(e.target.value)}
      &gt;
        &lt;option value=""&gt;Select a country&lt;/option&gt;
        &lt;option value="us"&gt;United States&lt;/option&gt;
        &lt;option value="uk"&gt;United Kingdom&lt;/option&gt;
        &lt;option value="ca"&gt;Canada&lt;/option&gt;
      &lt;/select&gt;
      
      {country && &lt;p&gt;Selected: {country}&lt;/p&gt;}
    &lt;/div&gt;
  );
}

test('selects a country from dropdown', async () => {
  const user = userEvent.setup();
  render(&lt;CountrySelector /&gt;);
  
  // Select an option
  await user.selectOptions(
    screen.getByLabelText('Country'),
    'uk'
  );
  
  // Verify selection
  expect(screen.getByText('Selected: uk')).toBeInTheDocument();
  expect(screen.getByRole('combobox')).toHaveValue('uk');
});
                </code></pre>

                <h3>Checking Checkboxes and Radio Buttons</h3>
                <pre><code class="language-typescript">
function NewsletterForm() {
  const [agreed, setAgreed] = React.useState(false);
  const [frequency, setFrequency] = React.useState('');
  
  return (
    &lt;form&gt;
      &lt;label&gt;
        &lt;input
          type="checkbox"
          checked={agreed}
          onChange={(e) => setAgreed(e.target.checked)}
        /&gt;
        I agree to receive newsletters
      &lt;/label&gt;
      
      &lt;fieldset&gt;
        &lt;legend&gt;Frequency&lt;/legend&gt;
        &lt;label&gt;
          &lt;input
            type="radio"
            name="frequency"
            value="daily"
            checked={frequency === 'daily'}
            onChange={(e) => setFrequency(e.target.value)}
          /&gt;
          Daily
        &lt;/label&gt;
        &lt;label&gt;
          &lt;input
            type="radio"
            name="frequency"
            value="weekly"
            checked={frequency === 'weekly'}
            onChange={(e) => setFrequency(e.target.value)}
          /&gt;
          Weekly
        &lt;/label&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
  );
}

test('handles checkbox and radio interactions', async () => {
  const user = userEvent.setup();
  render(&lt;NewsletterForm /&gt;);
  
  // Check the checkbox
  const checkbox = screen.getByRole('checkbox');
  await user.click(checkbox);
  expect(checkbox).toBeChecked();
  
  // Select a radio button
  await user.click(screen.getByRole('radio', { name: 'Weekly' }));
  expect(screen.getByRole('radio', { name: 'Weekly' })).toBeChecked();
  expect(screen.getByRole('radio', { name: 'Daily' })).not.toBeChecked();
});
                </code></pre>

                <h3>Hovering</h3>
                <pre><code class="language-typescript">
function Tooltip() {
  const [visible, setVisible] = React.useState(false);
  
  return (
    &lt;div&gt;
      &lt;button
        onMouseEnter={() => setVisible(true)}
        onMouseLeave={() => setVisible(false)}
      &gt;
        Hover me
      &lt;/button&gt;
      {visible && &lt;div role="tooltip"&gt;Tooltip content&lt;/div&gt;}
    &lt;/div&gt;
  );
}

test('shows tooltip on hover', async () => {
  const user = userEvent.setup();
  render(&lt;Tooltip /&gt;);
  
  const button = screen.getByRole('button');
  
  // Tooltip not visible initially
  expect(screen.queryByRole('tooltip')).not.toBeInTheDocument();
  
  // Hover over button
  await user.hover(button);
  expect(screen.getByRole('tooltip')).toBeInTheDocument();
  
  // Unhover
  await user.unhover(button);
  expect(screen.queryByRole('tooltip')).not.toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ user-event Methods</h4>
                    <ul>
                        <li><code>user.click(element)</code> - Click an element</li>
                        <li><code>user.dblClick(element)</code> - Double click</li>
                        <li><code>user.type(element, text)</code> - Type text</li>
                        <li><code>user.clear(element)</code> - Clear input</li>
                        <li><code>user.selectOptions(element, values)</code> - Select dropdown options</li>
                        <li><code>user.deselectOptions(element, values)</code> - Deselect options</li>
                        <li><code>user.upload(element, file)</code> - Upload file</li>
                        <li><code>user.hover(element)</code> - Hover over element</li>
                        <li><code>user.unhover(element)</code> - Stop hovering</li>
                        <li><code>user.tab()</code> - Tab to next element</li>
                        <li><code>user.keyboard(text)</code> - Press keyboard keys</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Testing Async Behavior -->
            <section id="async-testing" class="lesson-section">
                <h2>‚è±Ô∏è Testing Async Behavior</h2>
                
                <p>Modern React applications are full of asynchronous operations‚Äîdata fetching, delayed interactions, animations. Testing these requires special techniques to wait for changes to happen.</p>

                <h3>The Problem with Async</h3>
                <p>Consider this component that fetches data:</p>

                <pre><code class="language-typescript">
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = React.useState&lt;User | null&gt;(null);
  const [loading, setLoading] = React.useState(true);
  
  React.useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}
                </code></pre>

                <p>If we test this synchronously, we'll only see the loading state:</p>

                <pre><code class="language-typescript">
// ‚ùå This test fails - doesn't wait for data
test('displays user name', () => {
  render(&lt;UserProfile userId="123" /&gt;);
  
  // This will fail - still showing loading state!
  expect(screen.getByText('John Doe')).toBeInTheDocument();
});
                </code></pre>

                <h3>Solution 1: findBy Queries</h3>
                <p>The simplest solution is using <code>findBy</code> queries, which automatically wait:</p>

                <pre><code class="language-typescript">
test('displays user name after loading', async () => {
  render(&lt;UserProfile userId="123" /&gt;);
  
  // findBy waits up to 1000ms by default
  const userName = await screen.findByText('John Doe');
  expect(userName).toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ findBy Behavior</h4>
                    <p><code>findBy</code> queries:</p>
                    <ul>
                        <li>Return a Promise that resolves when the element appears</li>
                        <li>Retry multiple times (default: every 50ms for up to 1000ms)</li>
                        <li>Reject if element never appears</li>
                        <li>Perfect for elements that appear after async operations</li>
                    </ul>
                </div>

                <h3>Solution 2: waitFor</h3>
                <p>For more complex async scenarios, use <code>waitFor</code>:</p>

                <pre><code class="language-typescript">
import { render, screen, waitFor } from '@testing-library/react';

test('handles multiple async updates', async () => {
  render(&lt;ComplexComponent /&gt;);
  
  // Wait for multiple conditions
  await waitFor(() => {
    expect(screen.getByText('Data loaded')).toBeInTheDocument();
    expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Loading States</h3>
                <pre><code class="language-typescript">
test('shows loading state then data', async () => {
  render(&lt;UserProfile userId="123" /&gt;);
  
  // Initially shows loading
  expect(screen.getByText('Loading...')).toBeInTheDocument();
  
  // Wait for data to appear
  await screen.findByText('John Doe');
  
  // Loading state should be gone
  expect(screen.queryByText('Loading...')).not.toBeInTheDocument();
});
                </code></pre>

                <h3>Testing Error States</h3>
                <pre><code class="language-typescript">
function UserProfileWithError({ userId }: { userId: string }) {
  const [user, setUser] = React.useState&lt;User | null&gt;(null);
  const [error, setError] = React.useState&lt;string | null&gt;(null);
  const [loading, setLoading] = React.useState(true);
  
  React.useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch');
        return res.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}

test('displays error message when fetch fails', async () => {
  // Mock fetch to simulate failure
  global.fetch = vi.fn(() => 
    Promise.reject(new Error('Failed to fetch'))
  );
  
  render(&lt;UserProfileWithError userId="123" /&gt;);
  
  // Wait for error message
  const errorMessage = await screen.findByText(/error/i);
  expect(errorMessage).toBeInTheDocument();
});
                </code></pre>

                <h3>Custom Timeout</h3>
                <p>Adjust timeout for slower operations:</p>

                <pre><code class="language-typescript">
test('waits for slow operation', async () => {
  render(&lt;SlowComponent /&gt;);
  
  // Wait up to 5 seconds
  const result = await screen.findByText('Done', {}, { timeout: 5000 });
  expect(result).toBeInTheDocument();
});

// Or with waitFor
test('waits with custom timeout', async () => {
  render(&lt;SlowComponent /&gt;);
  
  await waitFor(
    () => {
      expect(screen.getByText('Done')).toBeInTheDocument();
    },
    { timeout: 5000 }
  );
});
                </code></pre>

                <h3>Testing Debounced/Throttled Functions</h3>
                <pre><code class="language-typescript">
function SearchWithDebounce() {
  const [query, setQuery] = React.useState('');
  const [results, setResults] = React.useState&lt;string[]&gt;([]);
  
  // Debounced search (waits 300ms after last keystroke)
  React.useEffect(() => {
    const timer = setTimeout(() => {
      if (query) {
        setResults([`Result for: ${query}`]);
      }
    }, 300);
    
    return () => clearTimeout(timer);
  }, [query]);
  
  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      /&gt;
      &lt;ul&gt;
        {results.map((result, i) => (
          &lt;li key={i}&gt;{result}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

test('debounces search input', async () => {
  const user = userEvent.setup();
  render(&lt;SearchWithDebounce /&gt;);
  
  const input = screen.getByPlaceholderText('Search...');
  
  // Type quickly
  await user.type(input, 'React');
  
  // Results shouldn't appear immediately
  expect(screen.queryByText(/Result for:/)).not.toBeInTheDocument();
  
  // Wait for debounced function to execute
  await screen.findByText('Result for: React');
  expect(screen.getByText('Result for: React')).toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Async Testing Mistakes</h4>
                    <ol>
                        <li><strong>Not using async/await:</strong> Always mark test functions as <code>async</code> when using <code>findBy</code> or <code>waitFor</code></li>
                        <li><strong>Using getBy for async elements:</strong> Use <code>findBy</code> instead</li>
                        <li><strong>Not waiting long enough:</strong> Increase timeout if operations are slow</li>
                        <li><strong>Testing implementation timing:</strong> Don't test that something happens in exactly 300ms‚Äîtest that it eventually happens</li>
                    </ol>
                </div>

                <h3>waitForElementToBeRemoved</h3>
                <p>Wait for elements to disappear:</p>

                <pre><code class="language-typescript">
import { waitForElementToBeRemoved } from '@testing-library/react';

test('loading spinner disappears after data loads', async () => {
  render(&lt;DataComponent /&gt;);
  
  const spinner = screen.getByText('Loading...');
  
  // Wait for spinner to be removed
  await waitForElementToBeRemoved(spinner);
  
  // Data should now be visible
  expect(screen.getByText('Data loaded')).toBeInTheDocument();
});
                </code></pre>
            </section>

            <!-- Section 8: TypeScript and Testing -->
            <section id="typescript-typing" class="lesson-section">
                <h2>üìò TypeScript and Testing</h2>
                
                <p>TypeScript provides excellent type safety for your tests. Let's explore how to write properly typed tests.</p>

                <h3>Typing Component Props</h3>
                <pre><code class="language-typescript">
// Component with typed props
interface UserCardProps {
  user: {
    id: string;
    name: string;
    email: string;
  };
  onEdit?: (id: string) => void;
}

function UserCard({ user, onEdit }: UserCardProps) {
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
      {onEdit && (
        &lt;button onClick={() => onEdit(user.id)}&gt;Edit&lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}

// Type-safe test
test('displays user information', () => {
  const mockUser: UserCardProps['user'] = {
    id: '1',
    name: 'Alice',
    email: 'alice@example.com'
  };
  
  render(&lt;UserCard user={mockUser} /&gt;);
  
  expect(screen.getByText('Alice')).toBeInTheDocument();
  expect(screen.getByText('alice@example.com')).toBeInTheDocument();
});
                </code></pre>

                <h3>Typing Mock Functions</h3>
                <pre><code class="language-typescript">
import { vi } from 'vitest';

test('calls onEdit with correct user ID', async () => {
  const user = userEvent.setup();
  
  // Properly typed mock function
  const mockOnEdit = vi.fn&lt;[string], void&gt;();
  
  const mockUser: UserCardProps['user'] = {
    id: '123',
    name: 'Bob',
    email: 'bob@example.com'
  };
  
  render(&lt;UserCard user={mockUser} onEdit={mockOnEdit} /&gt;);
  
  await user.click(screen.getByRole('button', { name: 'Edit' }));
  
  expect(mockOnEdit).toHaveBeenCalledWith('123');
  expect(mockOnEdit).toHaveBeenCalledTimes(1);
});
                </code></pre>

                <h3>Typing Custom Render Functions</h3>
                <p>Create a custom render function with providers:</p>

                <pre><code class="language-typescript">
// test-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement } from 'react';
import { ThemeProvider } from './ThemeProvider';

interface CustomRenderOptions extends Omit&lt;RenderOptions, 'wrapper'&gt; {
  theme?: 'light' | 'dark';
}

function customRender(
  ui: ReactElement,
  { theme = 'light', ...options }: CustomRenderOptions = {}
) {
  function Wrapper({ children }: { children: React.ReactNode }) {
    return &lt;ThemeProvider theme={theme}&gt;{children}&lt;/ThemeProvider&gt;;
  }
  
  return render(ui, { wrapper: Wrapper, ...options });
}

// Re-export everything
export * from '@testing-library/react';
export { customRender as render };
                </code></pre>

                <pre><code class="language-typescript">
// Using the custom render
import { render, screen } from './test-utils';

test('renders with theme provider', () => {
  render(&lt;ThemedComponent /&gt;, { theme: 'dark' });
  expect(screen.getByTestId('theme')).toHaveTextContent('dark');
});
                </code></pre>

                <h3>Typing Async Queries</h3>
                <pre><code class="language-typescript">
test('properly types async queries', async () => {
  render(&lt;AsyncComponent /&gt;);
  
  // findBy returns Promise&lt;HTMLElement&gt;
  const element: HTMLElement = await screen.findByText('Loaded');
  
  // Can assert on the element
  expect(element).toBeInTheDocument();
  expect(element).toHaveClass('success');
});
                </code></pre>

                <h3>Typing User Event</h3>
                <pre><code class="language-typescript">
import userEvent from '@testing-library/user-event';
import type { UserEvent } from '@testing-library/user-event';

test('types user event correctly', async () => {
  const user: UserEvent = userEvent.setup();
  
  render(&lt;Form /&gt;);
  
  // All methods are properly typed
  await user.type(screen.getByRole('textbox'), 'test');
  await user.click(screen.getByRole('button'));
});
                </code></pre>

                <h3>Asserting on Typed Elements</h3>
                <pre><code class="language-typescript">
test('asserts on specific element types', () => {
  render(&lt;Form /&gt;);
  
  // Get element as specific type
  const input = screen.getByRole('textbox') as HTMLInputElement;
  
  // Now TypeScript knows it's an input
  expect(input.value).toBe('');
  expect(input.type).toBe('text');
  
  // Or use type guards
  const button = screen.getByRole('button');
  if (button instanceof HTMLButtonElement) {
    expect(button.disabled).toBe(false);
  }
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript Testing Benefits</h4>
                    <ul>
                        <li><strong>Autocomplete:</strong> Your IDE suggests available matchers and methods</li>
                        <li><strong>Type safety:</strong> Catch errors before running tests</li>
                        <li><strong>Refactoring confidence:</strong> Type errors highlight tests that need updates</li>
                        <li><strong>Documentation:</strong> Types serve as inline documentation</li>
                    </ul>
                </div>

                <h3>Common Type Issues and Solutions</h3>
                <pre><code class="language-typescript">
// Problem: Type error with toBeInTheDocument
// Solution: Import jest-dom types
import '@testing-library/jest-dom';

// Problem: Element type is too generic
// Solution: Assert specific type
const input = screen.getByRole('textbox') as HTMLInputElement;

// Problem: Mock function type errors
// Solution: Explicitly type the mock
const mockFn = vi.fn&lt;[string, number], boolean&gt;();

// Problem: Custom matcher not recognized
// Solution: Extend jest matchers
declare global {
  namespace Vi {
    interface Matchers&lt;R&gt; {
      toBeInTheDocument(): R;
    }
  }
}
                </code></pre>
            </section>

            <!-- Section 9: Hands-on Exercises -->
            <section id="exercises" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Todo List Component</h3>
                    <p><strong>Objective:</strong> Test a complete todo list with add, delete, and toggle functionality.</p>
                    
                    <h4>Component to Test:</h4>
                    <pre><code class="language-typescript">
interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

export function TodoList() {
  const [todos, setTodos] = React.useState&lt;Todo[]&gt;([]);
  const [input, setInput] = React.useState('');
  
  const addTodo = () => {
    if (input.trim()) {
      setTodos([...todos, {
        id: Date.now().toString(),
        text: input,
        completed: false
      }]);
      setInput('');
    }
  };
  
  const toggleTodo = (id: string) => {
    setTodos(todos.map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const deleteTodo = (id: string) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder="Add todo..."
      /&gt;
      &lt;button onClick={addTodo}&gt;Add&lt;/button&gt;
      
      &lt;ul&gt;
        {todos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
              aria-label={`Toggle ${todo.text}`}
            /&gt;
            &lt;span style={{ 
              textDecoration: todo.completed ? 'line-through' : 'none' 
            }}&gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => deleteTodo(todo.id)}&gt;Delete&lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}
                    </code></pre>
                    
                    <h4>Write Tests For:</h4>
                    <ol>
                        <li>Adding a new todo</li>
                        <li>Toggling a todo's completed status</li>
                        <li>Deleting a todo</li>
                        <li>Not adding empty todos</li>
                        <li>Clearing input after adding</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>getByRole</code> for buttons and inputs. Use <code>getByPlaceholderText</code> for the input field. Use <code>getByLabelText</code> for checkboxes with aria-labels.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect } from 'vitest';
import { TodoList } from './TodoList';

describe('TodoList', () => {
  it('adds a new todo when Add button is clicked', async () => {
    const user = userEvent.setup();
    render(&lt;TodoList /&gt;);
    
    const input = screen.getByPlaceholderText('Add todo...');
    const addButton = screen.getByRole('button', { name: 'Add' });
    
    await user.type(input, 'Buy groceries');
    await user.click(addButton);
    
    expect(screen.getByText('Buy groceries')).toBeInTheDocument();
  });
  
  it('toggles todo completed status', async () => {
    const user = userEvent.setup();
    render(&lt;TodoList /&gt;);
    
    // Add a todo
    await user.type(screen.getByPlaceholderText('Add todo...'), 'Test todo');
    await user.click(screen.getByRole('button', { name: 'Add' }));
    
    // Toggle it
    const checkbox = screen.getByRole('checkbox', { name: 'Toggle Test todo' });
    await user.click(checkbox);
    
    expect(checkbox).toBeChecked();
    
    // Toggle again
    await user.click(checkbox);
    expect(checkbox).not.toBeChecked();
  });
  
  it('deletes a todo', async () => {
    const user = userEvent.setup();
    render(&lt;TodoList /&gt;);
    
    // Add a todo
    await user.type(screen.getByPlaceholderText('Add todo...'), 'To delete');
    await user.click(screen.getByRole('button', { name: 'Add' }));
    
    expect(screen.getByText('To delete')).toBeInTheDocument();
    
    // Delete it
    await user.click(screen.getByRole('button', { name: 'Delete' }));
    
    expect(screen.queryByText('To delete')).not.toBeInTheDocument();
  });
  
  it('does not add empty todos', async () => {
    const user = userEvent.setup();
    render(&lt;TodoList /&gt;);
    
    const addButton = screen.getByRole('button', { name: 'Add' });
    
    // Click Add without typing anything
    await user.click(addButton);
    
    // No todos should be added
    expect(screen.queryByRole('listitem')).not.toBeInTheDocument();
  });
  
  it('clears input after adding todo', async () => {
    const user = userEvent.setup();
    render(&lt;TodoList /&gt;);
    
    const input = screen.getByPlaceholderText('Add todo...');
    
    await user.type(input, 'New todo');
    await user.click(screen.getByRole('button', { name: 'Add' }));
    
    expect(input).toHaveValue('');
  });
});
                        </code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Login Form with Validation</h3>
                    <p><strong>Objective:</strong> Test form validation and submission.</p>
                    
                    <h4>Component to Test:</h4>
                    <pre><code class="language-typescript">
interface LoginFormProps {
  onSubmit: (email: string, password: string) => Promise&lt;void&gt;;
}

export function LoginForm({ onSubmit }: LoginFormProps) {
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');
  const [errors, setErrors] = React.useState&lt;string[]&gt;([]);
  const [loading, setLoading] = React.useState(false);
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    const newErrors: string[] = [];
    if (!email) newErrors.push('Email is required');
    if (!email.includes('@')) newErrors.push('Email must be valid');
    if (!password) newErrors.push('Password is required');
    if (password.length &lt; 6) newErrors.push('Password must be at least 6 characters');
    
    if (newErrors.length > 0) {
      setErrors(newErrors);
      return;
    }
    
    setErrors([]);
    setLoading(true);
    
    try {
      await onSubmit(email, password);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
      &lt;input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      /&gt;
      
      &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
      &lt;input
        id="password"
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      /&gt;
      
      &lt;button type="submit" disabled={loading}&gt;
        {loading ? 'Logging in...' : 'Login'}
      &lt;/button&gt;
      
      {errors.length > 0 && (
        &lt;ul role="alert"&gt;
          {errors.map((error, i) => (
            &lt;li key={i}&gt;{error}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/form&gt;
  );
}
                    </code></pre>
                    
                    <h4>Write Tests For:</h4>
                    <ol>
                        <li>Shows validation errors for empty fields</li>
                        <li>Shows validation error for invalid email</li>
                        <li>Shows validation error for short password</li>
                        <li>Calls onSubmit with correct values when valid</li>
                        <li>Shows loading state during submission</li>
                    </ol>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { LoginForm } from './LoginForm';

describe('LoginForm', () => {
  it('shows validation errors for empty fields', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;LoginForm onSubmit={mockOnSubmit} /&gt;);
    
    await user.click(screen.getByRole('button', { name: 'Login' }));
    
    expect(screen.getByText('Email is required')).toBeInTheDocument();
    expect(screen.getByText('Password is required')).toBeInTheDocument();
    expect(mockOnSubmit).not.toHaveBeenCalled();
  });
  
  it('shows validation error for invalid email', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;LoginForm onSubmit={mockOnSubmit} /&gt;);
    
    await user.type(screen.getByLabelText('Email'), 'notanemail');
    await user.type(screen.getByLabelText('Password'), 'password123');
    await user.click(screen.getByRole('button', { name: 'Login' }));
    
    expect(screen.getByText('Email must be valid')).toBeInTheDocument();
  });
  
  it('shows validation error for short password', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;LoginForm onSubmit={mockOnSubmit} /&gt;);
    
    await user.type(screen.getByLabelText('Email'), 'test@example.com');
    await user.type(screen.getByLabelText('Password'), '123');
    await user.click(screen.getByRole('button', { name: 'Login' }));
    
    expect(screen.getByText('Password must be at least 6 characters')).toBeInTheDocument();
  });
  
  it('calls onSubmit with correct values when valid', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn().mockResolvedValue(undefined);
    
    render(&lt;LoginForm onSubmit={mockOnSubmit} /&gt;);
    
    await user.type(screen.getByLabelText('Email'), 'test@example.com');
    await user.type(screen.getByLabelText('Password'), 'password123');
    await user.click(screen.getByRole('button', { name: 'Login' }));
    
    expect(mockOnSubmit).toHaveBeenCalledWith('test@example.com', 'password123');
  });
  
  it('shows loading state during submission', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn(() => 
      new Promise(resolve => setTimeout(resolve, 100))
    );
    
    render(&lt;LoginForm onSubmit={mockOnSubmit} /&gt;);
    
    await user.type(screen.getByLabelText('Email'), 'test@example.com');
    await user.type(screen.getByLabelText('Password'), 'password123');
    await user.click(screen.getByRole('button', { name: 'Login' }));
    
    expect(screen.getByRole('button', { name: 'Logging in...' })).toBeDisabled();
    
    await screen.findByRole('button', { name: 'Login' });
  });
});
                        </code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="best-practices" class="lesson-section">
                <h2>‚ú® Best Practices</h2>
                
                <h3>‚úÖ Do's</h3>

                <h4>1. Query by Accessibility First</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - accessible and resilient
screen.getByRole('button', { name: 'Submit' })
screen.getByLabelText('Email')

// ‚ùå Avoid - brittle and not accessibility-focused
screen.getByTestId('submit-btn')
screen.getByClassName('email-input')
                </code></pre>

                <h4>2. Use user-event Over fireEvent</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - realistic user interaction
const user = userEvent.setup();
await user.click(button);
await user.type(input, 'text');

// ‚ùå Avoid - less realistic
fireEvent.click(button);
fireEvent.change(input, { target: { value: 'text' } });
                </code></pre>

                <h4>3. Test Behavior, Not Implementation</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - tests user-facing behavior
test('increments counter', async () => {
  const user = userEvent.setup();
  render(&lt;Counter /&gt;);
  
  expect(screen.getByText('Count: 0')).toBeInTheDocument();
  await user.click(screen.getByRole('button'));
  expect(screen.getByText('Count: 1')).toBeInTheDocument();
});

// ‚ùå Avoid - tests implementation
test('calls setState with incremented value', () => {
  // Don't test internal state or methods
});
                </code></pre>

                <h4>4. Use findBy for Async Elements</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - waits for element
test('loads data', async () => {
  render(&lt;AsyncComponent /&gt;);
  expect(await screen.findByText('Data loaded')).toBeInTheDocument();
});

// ‚ùå Wrong - doesn't wait
test('loads data', () => {
  render(&lt;AsyncComponent /&gt;);
  expect(screen.getByText('Data loaded')).toBeInTheDocument(); // Fails!
});
                </code></pre>

                <h4>5. Use queryBy to Assert Absence</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - checks element doesn't exist
expect(screen.queryByText('Error')).not.toBeInTheDocument();

// ‚ùå Wrong - throws error if not found
expect(screen.getByText('Error')).not.toBeInTheDocument();
                </code></pre>

                <h3>‚ùå Don'ts</h3>

                <h4>1. Don't Query by Classes or IDs</h4>
                <pre><code class="language-typescript">
// ‚ùå Bad - implementation details
const element = container.querySelector('.my-class');
const element = container.querySelector('#my-id');

// ‚úÖ Good - user-facing queries
screen.getByRole('button');
screen.getByText('Submit');
                </code></pre>

                <h4>2. Don't Test Third-Party Libraries</h4>
                <pre><code class="language-typescript">
// ‚ùå Don't test that React Router works
test('Route component renders', () => {
  render(&lt;Route path="/" component={Home} /&gt;);
  // Testing React Router, not your code
});

// ‚úÖ Test your component's behavior with routing
test('navigates to profile on click', async () => {
  const user = userEvent.setup();
  render(&lt;App /&gt;);
  
  await user.click(screen.getByRole('link', { name: 'Profile' }));
  expect(screen.getByText('Profile Page')).toBeInTheDocument();
});
                </code></pre>

                <h4>3. Don't Make Tests Depend on Each Other</h4>
                <pre><code class="language-typescript">
// ‚ùå Bad - tests depend on order
let component;

test('renders component', () => {
  component = render(&lt;MyComponent /&gt;);
});

test('handles click', () => {
  // Depends on previous test
  fireEvent.click(component.getByRole('button'));
});

// ‚úÖ Good - independent tests
test('renders component', () => {
  render(&lt;MyComponent /&gt;);
  expect(screen.getByRole('button')).toBeInTheDocument();
});

test('handles click', async () => {
  const user = userEvent.setup();
  render(&lt;MyComponent /&gt;);
  await user.click(screen.getByRole('button'));
});
                </code></pre>

                <h3>üí° Pro Tips</h3>

                <h4>1. Use screen.debug() for Troubleshooting</h4>
                <pre><code class="language-typescript">
test('debugging test', () => {
  render(&lt;MyComponent /&gt;);
  
  // See the entire DOM
  screen.debug();
  
  // See a specific element
  screen.debug(screen.getByRole('button'));
});
                </code></pre>

                <h4>2. Create Custom Render Functions</h4>
                <pre><code class="language-typescript">
// test-utils.tsx
export function renderWithProviders(ui: React.ReactElement) {
  return render(
    &lt;ThemeProvider&gt;
      &lt;QueryClientProvider client={queryClient}&gt;
        {ui}
      &lt;/QueryClientProvider&gt;
    &lt;/ThemeProvider&gt;
  );
}
                </code></pre>

                <h4>3. Use Testing Playground</h4>
                <pre><code class="language-typescript">
test('get query suggestions', () => {
  render(&lt;MyComponent /&gt;);
  
  // Logs URL to testing playground
  screen.logTestingPlaygroundURL();
  
  // Visit the URL to see suggested queries
});
                </code></pre>

                <h4>4. Test Error Boundaries</h4>
                <pre><code class="language-typescript">
test('error boundary catches errors', () => {
  const ThrowError = () => {
    throw new Error('Test error');
  };
  
  render(
    &lt;ErrorBoundary&gt;
      &lt;ThrowError /&gt;
    &lt;/ErrorBoundary&gt;
  );
  
  expect(screen.getByText(/something went wrong/i)).toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Testing Checklist</h4>
                    <ul>
                        <li>‚úì Tests are independent and can run in any order</li>
                        <li>‚úì Queries prioritize accessibility (role, label, text)</li>
                        <li>‚úì user-event is used for interactions</li>
                        <li>‚úì Async operations use findBy or waitFor</li>
                        <li>‚úì Tests focus on user behavior, not implementation</li>
                        <li>‚úì Error states and edge cases are tested</li>
                        <li>‚úì Tests are well-named and describe behavior</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Summary -->
            <section id="summary" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>RTL Philosophy:</strong> Test components the way users interact with them, not how they're implemented</li>
                        <li><strong>Query Priority:</strong> Use getByRole first, then getByLabelText, then getByText. Avoid getByTestId unless necessary</li>
                        <li><strong>Three Query Types:</strong> getBy (element should exist), queryBy (checking absence), findBy (async elements)</li>
                        <li><strong>user-event over fireEvent:</strong> Simulates realistic user interactions with proper event sequences</li>
                        <li><strong>Async Testing:</strong> Use findBy queries or waitFor for elements that appear asynchronously</li>
                        <li><strong>TypeScript Integration:</strong> Properly type props, mocks, and custom utilities for type safety</li>
                        <li><strong>Accessibility Focus:</strong> Writing tests with RTL encourages accessible components</li>
                        <li><strong>Test Behavior:</strong> Focus on what users see and do, not internal state or methods</li>
                    </ul>
                </div>
                
                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank">React Testing Library Documentation</a> - Official docs and guides</li>
                    <li><a href="https://testing-library.com/docs/queries/about#priority" target="_blank">Query Priority Guide</a> - Which query to use when</li>
                    <li><a href="https://testing-playground.com/" target="_blank">Testing Playground</a> - Interactive tool to find the best queries</li>
                    <li><a href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library" target="_blank">Common RTL Mistakes</a> - Kent C. Dodds' guide to avoiding pitfalls</li>
                    <li><a href="https://testing-library.com/docs/user-event/intro" target="_blank">user-event Documentation</a> - Complete guide to user interactions</li>
                </ul>
                
                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll dive deeper into <strong>Testing User Interactions</strong> and explore:</p>
                <ul>
                    <li>Advanced form testing techniques</li>
                    <li>Testing custom hooks</li>
                    <li>Creating custom render functions with providers</li>
                    <li>Testing components with complex state</li>
                    <li>Testing context and global state</li>
                    <li>Practical patterns for real-world applications</li>
                </ul>

                <blockquote>
                    <strong>üí° Remember:</strong> The best tests are those that give you confidence your app works for users. If you can test it the way a user would use it, you're on the right track. Don't worry about coverage numbers‚Äîworry about testing the right things!
                </blockquote>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've mastered React Testing Library! You now know how to render components, query elements accessibly, simulate user interactions, and test async behavior. These skills will help you build robust, user-focused React applications with confidence.</p>
                    <p style="color: white; margin-top: 1rem;">Keep practicing, and remember: every test you write makes your application better!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_9_1_testing_fundamentals.html" class="prev-lesson">‚Üê Previous: Lesson 9.1 - Testing Fundamentals</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_9_3_testing_user_interactions.html" class="next-lesson">Next: Lesson 9.3 - Testing User Interactions ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 Ray. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals through quality education.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
