<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Understand state management in React applications. Learn when to use local vs global state, explore state management libraries, architectural patterns, and how to select the right tool for your application.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.1: State Management Overview - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.1: State Management Overview</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üèóÔ∏è Lesson 8.1: State Management Overview</h1>
                <p class="lead">Welcome to Module 8! As your React applications grow, managing state becomes increasingly challenging. What starts as simple useState calls can evolve into prop drilling nightmares, performance bottlenecks, and maintenance headaches. In this lesson, you'll learn to recognize different types of state, understand when to use various state management solutions, and make informed architectural decisions that scale with your application.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Distinguish between local state, shared state, server state, and URL state</li>
                        <li>Identify when to keep state local vs. when to lift it up</li>
                        <li>Understand the trade-offs between different state management solutions</li>
                        <li>Recognize the signs that your application needs a state management library</li>
                        <li>Compare popular state management libraries and their use cases</li>
                        <li>Apply architectural patterns for organizing application state</li>
                        <li>Select the right state management tool for your specific needs</li>
                        <li>Plan a scalable state management strategy from the beginning</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Prerequisites:</strong> Modules 1-7, especially Module 5 (Advanced Hooks and Patterns)</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What is State Management?</a></li>
                        <li><a href="#section2" class="toc-link">Types of State in React Applications</a></li>
                        <li><a href="#section3" class="toc-link">Local vs Global State</a></li>
                        <li><a href="#section4" class="toc-link">Common State Management Problems</a></li>
                        <li><a href="#section5" class="toc-link">State Management Solutions Landscape</a></li>
                        <li><a href="#section6" class="toc-link">Comparing State Management Libraries</a></li>
                        <li><a href="#section7" class="toc-link">Architectural Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Decision Framework</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What is State Management? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What is State Management?</h2>
                
                <p>Before diving into different solutions, let's establish what we mean by "state" and why managing it effectively is crucial to building maintainable React applications.</p>

                <h3>Defining State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>State</strong> is any data that changes over time in your application. It represents the current "snapshot" of your application at any given moment‚Äîwhat the user sees, what data has been loaded, what the user has selected, and so on.</p>
                </div>

                <p>Think of state as your application's memory. Just as you remember what you had for breakfast or what tabs you have open in your browser, your application needs to "remember" things like:</p>

                <ul>
                    <li>Is the user logged in?</li>
                    <li>What items are in the shopping cart?</li>
                    <li>Which theme is active (light or dark)?</li>
                    <li>Is a modal currently open?</li>
                    <li>What data did we fetch from the API?</li>
                    <li>What text is the user typing in the search box?</li>
                </ul>

                <h3>Why State Management Matters</h3>

                <p>As applications grow, managing state becomes one of the most challenging aspects of frontend development. Here's why:</p>

                <div class="mermaid">
                    graph TB
                    A[State Management Challenges] --> B[Synchronization]
                    A --> C[Performance]
                    A --> D[Debugging]
                    A --> E[Maintainability]
                    
                    B --> B1[Multiple components need same data]
                    B --> B2[Keeping UI in sync with state]
                    B --> B3[Avoiding stale data]
                    
                    C --> C1[Unnecessary re-renders]
                    C --> C2[Large component trees]
                    C --> C3[Frequent updates]
                    
                    D --> D1[Where did this value come from?]
                    D --> D2[Why did this component re-render?]
                    D --> D3[What changed this state?]
                    
                    E --> E1[Prop drilling]
                    E --> E2[Scattered state logic]
                    E --> E3[Hard to understand data flow]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>The Evolution of an Application's State</h3>

                <p>Let's look at how state management evolves as an application grows:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Application Size</th>
                            <th>State Complexity</th>
                            <th>Typical Solution</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Small</strong><br/>(1-5 components)</td>
                            <td>Simple, contained</td>
                            <td>Local useState</td>
                            <td>Counter, toggle button</td>
                        </tr>
                        <tr>
                            <td><strong>Medium</strong><br/>(5-20 components)</td>
                            <td>Shared between siblings</td>
                            <td>Lifting state up, props</td>
                            <td>Todo list, simple form</td>
                        </tr>
                        <tr>
                            <td><strong>Large</strong><br/>(20-50 components)</td>
                            <td>Many distant components need access</td>
                            <td>Context API, custom hooks</td>
                            <td>E-commerce cart, user auth</td>
                        </tr>
                        <tr>
                            <td><strong>Very Large</strong><br/>(50+ components)</td>
                            <td>Complex interdependencies</td>
                            <td>State management library (Zustand, Redux)</td>
                            <td>Admin dashboard, social media app</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>State management isn't about choosing a fancy library‚Äîit's about making data flow in your application predictable, debuggable, and maintainable. The best state management solution is often the simplest one that solves your specific problems.</p>
                </div>

                <h3>State Management Goals</h3>

                <p>Good state management should achieve these goals:</p>

                <ol>
                    <li><strong>Predictability:</strong> Given the same state and actions, the application behaves the same way</li>
                    <li><strong>Maintainability:</strong> Easy to understand, modify, and extend</li>
                    <li><strong>Debuggability:</strong> Easy to trace state changes and identify bugs</li>
                    <li><strong>Performance:</strong> Efficient updates without unnecessary re-renders</li>
                    <li><strong>Developer Experience:</strong> Pleasant to work with, good TypeScript support</li>
                    <li><strong>Testability:</strong> Easy to test state logic in isolation</li>
                </ol>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Golden Rule</h4>
                    <p><strong>Start simple, scale when needed.</strong> Don't reach for Redux on day one if useState and props work fine. But also don't hesitate to refactor when you feel pain points. The best architecture evolves with your application's needs.</p>
                </div>
            </section>

            <!-- Section 2: Types of State in React Applications -->
            <section id="section2" class="lesson-section">
                <h2>üéØ Types of State in React Applications</h2>
                
                <p>Not all state is created equal. Understanding the different categories of state helps you choose the right management approach for each type.</p>

                <h3>The Four Categories of State</h3>

                <div class="mermaid">
                    graph LR
                    A[Application State] --> B[Local State]
                    A --> C[Shared State]
                    A --> D[Server State]
                    A --> E[URL State]
                    
                    B --> B1[Component-specific]
                    C --> C1[Multiple components]
                    D --> D1[From backend APIs]
                    E --> E1[From URL params]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>1. Local State (UI State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Local state</strong> is data that only a single component (and possibly its children) needs to know about. It's ephemeral, lives only as long as the component is mounted, and doesn't need to be shared globally.</p>
                </div>

                <p><strong>Examples of local state:</strong></p>
                <ul>
                    <li>Form input values (before submission)</li>
                    <li>Is a dropdown menu open?</li>
                    <li>Current tab in a tabbed interface</li>
                    <li>Is a tooltip visible?</li>
                    <li>Hover state of a button</li>
                </ul>

                <p><strong>Best managed with:</strong> <code>useState</code>, <code>useReducer</code></p>

                <pre><code class="language-typescript">// Example: Local state for a dropdown
function Dropdown({ options }: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState&lt;string | null&gt;(null);

  return (
    &lt;div&gt;
      &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
        {selected || 'Select an option'}
      &lt;/button&gt;
      {isOpen && (
        &lt;ul&gt;
          {options.map(option => (
            &lt;li 
              key={option.value}
              onClick={() => {
                setSelected(option.label);
                setIsOpen(false);
              }}
            &gt;
              {option.label}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Local State</h4>
                    <p><strong>Use local state when:</strong> Only one component needs it, it doesn't persist when unmounted, and it doesn't need to be synchronized with other parts of the app.</p>
                </div>

                <h3>2. Shared State (Application State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Shared state</strong> is data that multiple components across your application need access to. It typically persists longer than a single component's lifecycle and needs to stay synchronized.</p>
                </div>

                <p><strong>Examples of shared state:</strong></p>
                <ul>
                    <li>User authentication status</li>
                    <li>Current theme (light/dark mode)</li>
                    <li>Shopping cart items</li>
                    <li>Notification system</li>
                    <li>Active language/locale</li>
                    <li>Sidebar collapsed/expanded state</li>
                </ul>

                <p><strong>Best managed with:</strong> Context API, Zustand, Redux, Jotai</p>

                <pre><code class="language-typescript">// Example: Shared state with Context
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Used anywhere in the app
function Header() {
  const { theme, toggleTheme } = useContext(ThemeContext)!;
  
  return (
    &lt;header className={theme}&gt;
      &lt;button onClick={toggleTheme}&gt;
        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      &lt;/button&gt;
    &lt;/header&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Shared State</h4>
                    <p><strong>Use shared state when:</strong> Multiple components in different parts of the tree need the same data, the data needs to persist across route changes, or you're experiencing "prop drilling" pain.</p>
                </div>

                <h3>3. Server State (Remote State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Server state</strong> is data that originates from a remote server and is cached on the client. It's unique because you don't fully control it‚Äîthe server is the source of truth, and your local copy might be stale.</p>
                </div>

                <p><strong>Examples of server state:</strong></p>
                <ul>
                    <li>User profile data fetched from API</li>
                    <li>List of products in an e-commerce store</li>
                    <li>Blog posts and articles</li>
                    <li>Real-time data (stock prices, chat messages)</li>
                    <li>Search results</li>
                </ul>

                <p><strong>Unique characteristics of server state:</strong></p>
                <ul>
                    <li>Asynchronous by nature</li>
                    <li>Can become stale and need refreshing</li>
                    <li>Multiple components may request the same data</li>
                    <li>Needs error handling and loading states</li>
                    <li>May need caching and invalidation strategies</li>
                    <li>Can have race conditions</li>
                </ul>

                <p><strong>Best managed with:</strong> React Query (TanStack Query), SWR, RTK Query, Apollo Client (for GraphQL)</p>

                <pre><code class="language-typescript">// Example: Server state with React Query
import { useQuery } from '@tanstack/react-query';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile({ userId }: { userId: number }) {
  const { data, isLoading, error } = useQuery&lt;User&gt;({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // Data is fresh for 5 minutes
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h1&gt;{data.name}&lt;/h1&gt;
      &lt;p&gt;{data.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't treat server state the same as client state! Putting API data in Redux/Zustand forces you to manually handle loading states, caching, refetching, and cache invalidation‚Äîall things that specialized libraries do automatically.</p>
                </div>

                <h3>4. URL State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>URL state</strong> is information stored in the URL itself‚Äîincluding the pathname, query parameters, and hash. It's special because it's shareable, bookmarkable, and survives page refreshes.</p>
                </div>

                <p><strong>Examples of URL state:</strong></p>
                <ul>
                    <li>Current page/route</li>
                    <li>Search query</li>
                    <li>Filter and sort parameters</li>
                    <li>Selected tab</li>
                    <li>Pagination state</li>
                    <li>Modal or dialog state (for deep linking)</li>
                </ul>

                <p><strong>Best managed with:</strong> React Router, Next.js router, browser URLSearchParams API</p>

                <pre><code class="language-typescript">// Example: URL state with React Router
import { useSearchParams } from 'react-router-dom';

function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const category = searchParams.get('category') || 'all';
  const sortBy = searchParams.get('sort') || 'name';
  const page = Number(searchParams.get('page')) || 1;

  const updateFilters = (newCategory: string) => {
    setSearchParams({
      category: newCategory,
      sort: sortBy,
      page: '1' // Reset to first page on filter change
    });
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Products - {category}&lt;/h2&gt;
      &lt;select value={category} onChange={e => updateFilters(e.target.value)}&gt;
        &lt;option value="all"&gt;All Products&lt;/option&gt;
        &lt;option value="electronics"&gt;Electronics&lt;/option&gt;
        &lt;option value="clothing"&gt;Clothing&lt;/option&gt;
      &lt;/select&gt;
      {/* Product list here */}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use URL State</h4>
                    <p><strong>Use URL state when:</strong> Users should be able to share or bookmark the current view, state should persist through refreshes, or you want browser back/forward buttons to work naturally.</p>
                </div>

                <h3>State Type Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>State Type</th>
                            <th>Lifespan</th>
                            <th>Scope</th>
                            <th>Persistence</th>
                            <th>Best Tool</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Local</strong></td>
                            <td>Component mount</td>
                            <td>Single component</td>
                            <td>Lost on unmount</td>
                            <td>useState</td>
                        </tr>
                        <tr>
                            <td><strong>Shared</strong></td>
                            <td>App lifecycle</td>
                            <td>Multiple components</td>
                            <td>While app is running</td>
                            <td>Context/Zustand/Redux</td>
                        </tr>
                        <tr>
                            <td><strong>Server</strong></td>
                            <td>Configurable cache</td>
                            <td>Global (cached)</td>
                            <td>Managed by library</td>
                            <td>React Query/SWR</td>
                        </tr>
                        <tr>
                            <td><strong>URL</strong></td>
                            <td>Until navigation</td>
                            <td>Global (in URL)</td>
                            <td>Survives refresh</td>
                            <td>React Router</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip</h4>
                    <p>Many state management problems can be solved by simply using the right type of state. For example, if you're putting search filters in Redux, consider using URL params instead‚Äîthey're more user-friendly and require zero extra code for persistence!</p>
                </div>
            </section>

            <!-- Section 3: Local vs Global State -->
            <section id="section3" class="lesson-section">
                <h2>‚öñÔ∏è Local vs Global State</h2>
                
                <p>One of the most important architectural decisions in React is determining where state should live. Let's explore the principles and patterns for making this decision.</p>

                <h3>The Principle of Colocation</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Colocation Principle</h4>
                    <p style="color: white;"><strong>"State should live as close as possible to where it's used."</strong></p>
                    <p style="color: white;">This means keeping state local by default and only "lifting it up" when multiple components genuinely need to share it.</p>
                </div>

                <h3>Why Colocation Matters</h3>

                <p>Keeping state local has several benefits:</p>

                <ol>
                    <li><strong>Easier to understand:</strong> The state and the components that use it are in the same file</li>
                    <li><strong>Better performance:</strong> State changes only re-render the components that need to update</li>
                    <li><strong>Simpler testing:</strong> Components with local state are self-contained and easier to test</li>
                    <li><strong>Easier refactoring:</strong> Moving or removing components doesn't affect distant parts of the app</li>
                    <li><strong>Less cognitive load:</strong> You don't need to understand the entire app to work on one component</li>
                </ol>

                <h3>When to Keep State Local</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Keep State Local When</h4>
                    <ul>
                        <li>Only one component (and maybe its children) needs the state</li>
                        <li>The state is UI-specific (hover, focus, open/closed)</li>
                        <li>The state doesn't need to persist when the component unmounts</li>
                        <li>The state isn't needed by sibling components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Good: Local state for accordion
function Accordion({ items }: { items: Item[] }) {
  const [openIndex, setOpenIndex] = useState&lt;number | null&gt;(null);

  return (
    &lt;div&gt;
      {items.map((item, index) => (
        &lt;div key={item.id}&gt;
          &lt;button onClick={() => setOpenIndex(index === openIndex ? null : index)}&gt;
            {item.title}
          &lt;/button&gt;
          {openIndex === index && &lt;div&gt;{item.content}&lt;/div&gt;}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>When to Lift State Up</h3>

                <p>Sometimes state needs to be "lifted up" to a common ancestor so multiple components can access it:</p>

                <div class="mermaid">
                    graph TB
                    A[Parent Component<br/>State Lives Here] --> B[Child A<br/>Reads State]
                    A --> C[Child B<br/>Updates State]
                    A --> D[Child C<br/>Reads State]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                    style D fill:#4CAF50,color:#fff
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Lift State Up When</h4>
                    <ul>
                        <li>Multiple sibling components need the same state</li>
                        <li>One component needs to update state that another component displays</li>
                        <li>Parent needs to coordinate behavior between children</li>
                        <li>State needs to be synchronized across components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Example: Lifting state up
function SearchPage() {
  // State lifted to parent so both children can access it
  const [searchQuery, setSearchQuery] = useState('');
  const [results, setResults] = useState&lt;Result[]&gt;([]);

  return (
    &lt;div&gt;
      {/* Child A updates the state */}
      &lt;SearchBar 
        value={searchQuery} 
        onChange={setSearchQuery}
        onSearch={() => fetchResults(searchQuery).then(setResults)}
      /&gt;
      
      {/* Child B reads the state */}
      &lt;SearchResults 
        query={searchQuery} 
        results={results} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>The Prop Drilling Problem</h3>

                <p>When you lift state too high or need to pass it through many layers of components, you encounter "prop drilling":</p>

                <pre><code class="language-typescript">// ‚ùå Prop drilling problem
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return &lt;Layout user={user} setUser={setUser} /&gt;;
}

function Layout({ user, setUser }: LayoutProps) {
  return (
    &lt;div&gt;
      &lt;Sidebar user={user} setUser={setUser} /&gt;
      &lt;Content user={user} /&gt;
    &lt;/div&gt;
  );
}

function Sidebar({ user, setUser }: SidebarProps) {
  return (
    &lt;nav&gt;
      &lt;UserMenu user={user} setUser={setUser} /&gt;
    &lt;/nav&gt;
  );
}

function UserMenu({ user, setUser }: UserMenuProps) {
  // Finally using it here!
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Problems with prop drilling:</strong></p>
                <ul>
                    <li>Intermediate components need props they don't use (Layout, Sidebar)</li>
                    <li>Hard to refactor‚Äîchanging prop names affects many files</li>
                    <li>Makes component trees rigid and brittle</li>
                    <li>TypeScript types become verbose and repetitive</li>
                </ul>

                <h3>Solutions to Prop Drilling</h3>

                <p>When prop drilling becomes painful, consider these solutions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>When to Use</th>
                            <th>Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Component Composition</strong></td>
                            <td>Layout components, wrapper components</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>Context API</strong></td>
                            <td>Theme, auth, 2-5 globally shared values</td>
                            <td>Low-Medium</td>
                        </tr>
                        <tr>
                            <td><strong>Custom Hooks</strong></td>
                            <td>Shared logic with local state</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>State Library</strong></td>
                            <td>Many global values, complex updates</td>
                            <td>Medium-High</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Component Composition Pattern</h3>

                <p>Often overlooked, component composition can eliminate prop drilling without any state management library:</p>

                <pre><code class="language-typescript">// ‚úÖ Better: Component composition
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return (
    &lt;Layout
      sidebar={&lt;Sidebar userMenu={&lt;UserMenu user={user} setUser={setUser} /&gt;} /&gt;}
      content={&lt;Content user={user} /&gt;}
    /&gt;
  );
}

function Layout({ sidebar, content }: LayoutProps) {
  // No user props needed!
  return (
    &lt;div&gt;
      {sidebar}
      {content}
    &lt;/div&gt;
  );
}

function Sidebar({ userMenu }: SidebarProps) {
  // No user props needed!
  return &lt;nav&gt;{userMenu}&lt;/nav&gt;;
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Decision Tree</h4>
                    <ol>
                        <li><strong>Start:</strong> Keep state in the component that needs it</li>
                        <li><strong>If siblings need it:</strong> Lift to common parent</li>
                        <li><strong>If prop drilling 3+ levels:</strong> Try component composition</li>
                        <li><strong>If composition doesn't help:</strong> Use Context or state library</li>
                    </ol>
                </div>
            </section>

            <!-- Section 4: Common State Management Problems -->
            <section id="section4" class="lesson-section">
                <h2>üö® Common State Management Problems</h2>
                
                <p>As applications grow, certain state management patterns emerge. Recognizing these problems helps you know when it's time to refactor or adopt a different approach.</p>

                <h3>Problem 1: Prop Drilling Hell</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>You're passing props through 4+ levels of components that don't use them, just to get data to deeply nested children.</p>
                </div>

                <p><strong>Signs you have this problem:</strong></p>
                <ul>
                    <li>Components have props they don't use, only pass through</li>
                    <li>Changing a prop name requires editing many files</li>
                    <li>Adding a new prop requires touching many components</li>
                    <li>Component function signatures are getting long and unwieldy</li>
                </ul>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use Context API for truly global data (theme, auth)</li>
                    <li>Apply component composition to avoid prop threading</li>
                    <li>Consider a state management library if you have many such cases</li>
                </ul>

                <h3>Problem 2: Scattered State Updates</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>The same piece of state is being updated in many different places, making it hard to track down bugs.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Cart state updated in many places
function ProductCard({ product }: ProductCardProps) {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = () => {
    setCart([...cart, { ...product, quantity: 1 }]);
  };
  
  return &lt;button onClick={addToCart}&gt;Add to Cart&lt;/button&gt;;
}

function CartButton() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const clearCart = () => {
    setCart([]);
  };
  
  return &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;;
}

// Updates also in CartItem, CheckoutForm, etc...</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Create custom hooks that encapsulate update logic</li>
                    <li>Use useReducer to centralize state updates</li>
                    <li>Use a state library with action creators</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Centralized updates via custom hook
function useCart() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = (product: Product) => {
    setCart(prev => [...prev, { ...product, quantity: 1 }]);
  };
  
  const removeFromCart = (productId: string) => {
    setCart(prev => prev.filter(item => item.id !== productId));
  };
  
  const clearCart = () => {
    setCart([]);
  };
  
  return { cart, addToCart, removeFromCart, clearCart };
}

// Now components only call the hook methods
function ProductCard({ product }: ProductCardProps) {
  const { addToCart } = useCart();
  return &lt;button onClick={() => addToCart(product)}&gt;Add&lt;/button&gt;;
}</code></pre>

                <h3>Problem 3: Stale Closures</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Event handlers or effects are using old values of state, causing unexpected behavior.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Stale closure
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Count:', count); // Always logs 0!
      setCount(count + 1); // Always sets to 1!
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Empty deps = stale closure
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use functional updates: <code>setCount(prev => prev + 1)</code></li>
                    <li>Include dependencies in useEffect array</li>
                    <li>Use useRef for values you want to reference but not trigger re-renders</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Functional update
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => {
        console.log('Count:', prev);
        return prev + 1;
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Now safe with empty deps
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <h3>Problem 4: Race Conditions</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Async operations complete out of order, causing the wrong data to be displayed (e.g., search results for an old query showing up after newer results).</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Race condition
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    fetchResults(query).then(data => {
      setResults(data); // Might be stale!
    });
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use cleanup function to ignore stale responses</li>
                    <li>Use AbortController to cancel old requests</li>
                    <li>Use libraries like React Query that handle this automatically</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Cleanup ignores stale results
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    let ignore = false;
    
    fetchResults(query).then(data => {
      if (!ignore) {
        setResults(data);
      }
    });
    
    return () => {
      ignore = true; // Cleanup: ignore stale response
    };
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <h3>Problem 5: Unnecessary Re-renders</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Components re-render even though the data they display hasn't changed, causing performance problems.</p>
                </div>

                <p><strong>Common causes:</strong></p>
                <ul>
                    <li>Creating new objects/arrays on every render</li>
                    <li>Passing inline functions as props</li>
                    <li>Context value changes on every render</li>
                    <li>Not memoizing expensive computations</li>
                </ul>

                <pre><code class="language-typescript">// ‚ùå Problem: Context re-renders everything
function AppProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [theme, setTheme] = useState('light');
  
  // New object on every render!
  const value = { user, setUser, theme, setTheme };
  
  return (
    &lt;AppContext.Provider value={value}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Every component using this context re-renders when ANY value changes!</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>useMemo to memoize context values</li>
                    <li>Split contexts by concern (UserContext, ThemeContext)</li>
                    <li>Use React.memo for expensive components</li>
                    <li>State management libraries with fine-grained reactivity</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Separate contexts
function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  
  return &lt;UserContext.Provider value={value}&gt;{children}&lt;/UserContext.Provider&gt;;
}

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState('light');
  const value = useMemo(() => ({ theme, setTheme }), [theme]);
  
  return &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;;
}

// Now changing theme doesn't re-render components that only use user!</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When Problems Indicate You Need a Library</h4>
                    <p>If you're experiencing <strong>multiple</strong> of these problems simultaneously, and simple refactoring isn't helping, it's probably time to consider a dedicated state management library.</p>
                </div>
            </section>
            <!-- Section 5: State Management Solutions Landscape -->
            <section id="section5" class="lesson-section">
                <h2>üó∫Ô∏è State Management Solutions Landscape</h2>
                
                <p>The React ecosystem offers numerous state management solutions, each designed to solve different problems. Let's explore the landscape and understand where each tool fits.</p>

                <h3>The State Management Spectrum</h3>

                <div class="mermaid">
                    graph LR
                    A[Built-in React] --> B[Context + Hooks]
                    B --> C[Lightweight Libraries]
                    C --> D[Full-Featured Libraries]
                    D --> E[Server State Libraries]
                    
                    A1[useState<br/>useReducer] -.-> A
                    B1[Context API<br/>Custom Hooks] -.-> B
                    C1[Zustand<br/>Jotai<br/>Valtio] -.-> C
                    D1[Redux Toolkit<br/>MobX<br/>XState] -.-> D
                    E1[React Query<br/>SWR<br/>Apollo] -.-> E
                    
                    style A fill:#667eea,color:#fff
                    style E fill:#4CAF50,color:#fff
                </div>

                <h3>Category 1: Built-in React Solutions</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üì¶ What's Included</h4>
                    <ul style="color: white;">
                        <li><strong>useState:</strong> Local state management</li>
                        <li><strong>useReducer:</strong> Complex local state with actions</li>
                        <li><strong>useContext:</strong> Sharing state without prop drilling</li>
                        <li><strong>useRef:</strong> Mutable values that don't trigger re-renders</li>
                    </ul>
                </div>

                <p><strong>Best for:</strong> Small to medium apps, localized state, simple sharing between components</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Zero dependencies‚Äîbuilt into React</li>
                    <li>‚úÖ Simple API, easy to learn</li>
                    <li>‚úÖ Great TypeScript support</li>
                    <li>‚úÖ Perfect for local component state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Context can cause unnecessary re-renders</li>
                    <li>‚ùå No built-in devtools</li>
                    <li>‚ùå Boilerplate increases with app complexity</li>
                    <li>‚ùå No built-in async handling or middleware</li>
                </ul>

                <h3>Category 2: Lightweight State Libraries</h3>

                <p>These libraries provide global state with minimal boilerplate and excellent performance:</p>

                <h4>Zustand</h4>
                <pre><code class="language-typescript">// Simple, hook-based global state
import create from 'zustand';

interface BearStore {
  bears: number;
  addBear: () => void;
  removeAllBears: () => void;
}

const useStore = create&lt;BearStore&gt;((set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 })
}));

function BearCounter() {
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears} bears&lt;/h1&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Most React applications, simple to moderate state complexity</p>

                <h4>Jotai</h4>
                <pre><code class="language-typescript">// Atomic state management
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() => setCount(c => c + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Bottom-up state architecture, derived state, atomic updates</p>

                <h4>Valtio</h4>
                <pre><code class="language-typescript">// Proxy-based state
import { proxy, useSnapshot } from 'valtio';

const state = proxy({ count: 0 });

function Counter() {
  const snap = useSnapshot(state);
  return (
    &lt;div&gt;
      {snap.count}
      &lt;button onClick={() => state.count++}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Developers who prefer mutable syntax, quick prototyping</p>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Bundle Size</th>
                            <th>Learning Curve</th>
                            <th>Best Feature</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Zustand</strong></td>
                            <td>~1KB</td>
                            <td>Very Low</td>
                            <td>Simplicity + power</td>
                        </tr>
                        <tr>
                            <td><strong>Jotai</strong></td>
                            <td>~3KB</td>
                            <td>Low</td>
                            <td>Atomic architecture</td>
                        </tr>
                        <tr>
                            <td><strong>Valtio</strong></td>
                            <td>~3KB</td>
                            <td>Very Low</td>
                            <td>Mutable syntax</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Category 3: Full-Featured State Libraries</h3>

                <h4>Redux Toolkit (RTK)</h4>

                <p>The modern, official way to write Redux code:</p>

                <pre><code class="language-typescript">// Redux Toolkit slice
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1; // Immer allows "mutation"
    },
    incrementByAmount: (state, action: PayloadAction&lt;number&gt;) => {
      state.value += action.payload;
    }
  }
});

export const { increment, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>

                <p><strong>Best for:</strong> Large enterprise apps, teams familiar with Redux, complex state logic</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Mature ecosystem with lots of resources</li>
                    <li>‚úÖ Excellent DevTools (Redux DevTools)</li>
                    <li>‚úÖ Predictable state updates</li>
                    <li>‚úÖ Great for time-travel debugging</li>
                    <li>‚úÖ RTK Query for server state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Steeper learning curve</li>
                    <li>‚ùå More boilerplate than alternatives</li>
                    <li>‚ùå Larger bundle size (~20KB)</li>
                </ul>

                <h4>MobX</h4>

                <p>Observable-based reactive state management:</p>

                <pre><code class="language-typescript">// MobX store
import { makeAutoObservable } from 'mobx';
import { observer } from 'mobx-react-lite';

class TodoStore {
  todos: string[] = [];

  constructor() {
    makeAutoObservable(this);
  }

  addTodo(todo: string) {
    this.todos.push(todo);
  }
}

const todoStore = new TodoStore();

const TodoList = observer(() => {
  return (
    &lt;ul&gt;
      {todoStore.todos.map((todo, i) => (
        &lt;li key={i}&gt;{todo}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
});</code></pre>

                <p><strong>Best for:</strong> Complex domain models, developers familiar with OOP patterns</p>

                <h4>XState</h4>

                <p>State machine-based state management:</p>

                <pre><code class="language-typescript">// XState machine
import { createMachine } from 'xstate';
import { useMachine } from '@xstate/react';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

function Toggle() {
  const [state, send] = useMachine(toggleMachine);
  
  return (
    &lt;button onClick={() => send('TOGGLE')}&gt;
      {state.value === 'active' ? 'ON' : 'OFF'}
    &lt;/button&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Complex workflows, multi-step processes, state machines</p>

                <h3>Category 4: Server State Libraries</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üåü The Game Changer</h4>
                    <p>Server state libraries revolutionized React development by recognizing that <strong>server data is fundamentally different</strong> from client state and should be managed differently.</p>
                </div>

                <h4>React Query (TanStack Query)</h4>

                <pre><code class="language-typescript">// React Query hooks
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function UserProfile({ userId }: { userId: number }) {
  // Automatic loading, error, caching, refetching
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(r => r.json())
  });

  const queryClient = useQueryClient();

  const updateMutation = useMutation({
    mutationFn: (updates: Partial&lt;User&gt;) => 
      fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        body: JSON.stringify(updates)
      }),
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries(['user', userId]);
    }
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error!&lt;/div&gt;;

  return &lt;div&gt;{data.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Features:</strong></p>
                <ul>
                    <li>‚úÖ Automatic caching and background refetching</li>
                    <li>‚úÖ Request deduplication</li>
                    <li>‚úÖ Optimistic updates</li>
                    <li>‚úÖ Pagination and infinite scroll</li>
                    <li>‚úÖ Built-in loading and error states</li>
                    <li>‚úÖ DevTools for debugging</li>
                </ul>

                <h4>SWR (Stale-While-Revalidate)</h4>

                <pre><code class="language-typescript">// SWR - Similar to React Query, Vercel's solution
import useSWR from 'swr';

function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;
  return &lt;div&gt;Hello {data.name}!&lt;/div&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Simpler API needs, Next.js projects</p>

                <h4>Apollo Client (GraphQL)</h4>

                <p>Specialized for GraphQL APIs:</p>

                <pre><code class="language-typescript">// Apollo Client for GraphQL
import { useQuery, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error!&lt;/p&gt;;

  return data.users.map((user: User) => (
    &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
  ));
}</code></pre>

                <p><strong>Best for:</strong> GraphQL APIs, apps with complex data requirements</p>

                <h3>Solution Selection Matrix</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Your Situation</th>
                            <th>Recommended Solution</th>
                            <th>Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Small app, local state</td>
                            <td>useState + Context</td>
                            <td>No dependencies needed</td>
                        </tr>
                        <tr>
                            <td>Medium app, some global state</td>
                            <td>Zustand or Jotai</td>
                            <td>Simple, performant, small bundle</td>
                        </tr>
                        <tr>
                            <td>Large enterprise app</td>
                            <td>Redux Toolkit</td>
                            <td>Mature, predictable, great DevTools</td>
                        </tr>
                        <tr>
                            <td>Lots of API data</td>
                            <td>React Query + Zustand</td>
                            <td>Separate concerns: server vs client state</td>
                        </tr>
                        <tr>
                            <td>Complex workflows</td>
                            <td>XState</td>
                            <td>State machines model workflows naturally</td>
                        </tr>
                        <tr>
                            <td>GraphQL API</td>
                            <td>Apollo Client</td>
                            <td>Purpose-built for GraphQL</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Modern Best Practice</h4>
                    <p><strong>Hybrid approach:</strong> Use React Query (or SWR) for server state + a lightweight library like Zustand for client state. This separation of concerns is becoming the industry standard.</p>
                </div>
            </section>

            <!-- Section 6: Comparing State Management Libraries -->
            <section id="section6" class="lesson-section">
                <h2>‚öñÔ∏è Comparing State Management Libraries</h2>
                
                <p>Let's dive deeper into how these libraries compare across key dimensions that matter for real-world development.</p>

                <h3>Comparison Dimensions</h3>

                <h4>1. Learning Curve</h4>

                <div class="mermaid">
                    graph LR
                    A[Easy] --> B[Moderate] --> C[Challenging]
                    
                    A1[Zustand<br/>Valtio<br/>SWR] -.-> A
                    B1[Jotai<br/>React Query<br/>Context API] -.-> B
                    C1[Redux Toolkit<br/>MobX<br/>XState] -.-> C
                    
                    style A fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <ul>
                    <li><strong>Easy:</strong> Can be productive within hours</li>
                    <li><strong>Moderate:</strong> Takes a day or two to grasp concepts</li>
                    <li><strong>Challenging:</strong> Requires dedicated learning time, often several days</li>
                </ul>

                <h4>2. Bundle Size Impact</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Minified + Gzipped</th>
                            <th>Impact Rating</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>~1KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>~13KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê Small</td>
                        </tr>
                        <tr>
                            <td>SWR</td>
                            <td>~4KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>~20KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>~16KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>~25KB</td>
                            <td>‚≠ê‚≠ê Larger</td>
                        </tr>
                    </tbody>
                </table>

                <h4>3. TypeScript Support</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Type Safety</th>
                            <th>Type Inference</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Written in TS, zero config</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Best-in-class TS support</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Generics work beautifully</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Atom types inferred</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Good</td>
                            <td>Some manual typing</td>
                            <td>Decorators can be tricky</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>Good</td>
                            <td>Complex typing</td>
                            <td>State machine types are verbose</td>
                        </tr>
                    </tbody>
                </table>

                <h4>4. Developer Experience</h4>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Excellent DX</h4>
                    <p><strong>Zustand, React Query, Jotai</strong></p>
                    <ul>
                        <li>Minimal boilerplate</li>
                        <li>Intuitive APIs</li>
                        <li>Great documentation</li>
                        <li>Fast feedback loop</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è More Setup Required</h4>
                    <p><strong>Redux Toolkit, XState</strong></p>
                    <ul>
                        <li>More concepts to learn</li>
                        <li>More configuration needed</li>
                        <li>Steeper initial learning curve</li>
                        <li>But: Very powerful once mastered</li>
                    </ul>
                </div>

                <h4>5. Performance Characteristics</h4>

                <pre><code class="language-typescript">// Example: Zustand's selector optimization
function BearCounter() {
  // Only re-renders when bears count changes
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears}&lt;/h1&gt;;
}

function AddBearButton() {
  // Only re-renders when addBear function changes (never)
  const addBear = useStore(state => state.addBear);
  return &lt;button onClick={addBear}&gt;Add Bear&lt;/button&gt;;
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Re-render Optimization</th>
                            <th>Approach</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Automatic with selectors</td>
                            <td>Fine-grained subscriptions</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Automatic</td>
                            <td>Atomic state updates</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>Automatic</td>
                            <td>Proxy-based tracking</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Manual with reselect</td>
                            <td>Memoized selectors</td>
                        </tr>
                        <tr>
                            <td>Context API</td>
                            <td>Manual with memo</td>
                            <td>Context splitting</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Automatic</td>
                            <td>Observable tracking</td>
                        </tr>
                    </tbody>
                </table>

                <h4>6. DevTools and Debugging</h4>

                <ul>
                    <li><strong>Redux Toolkit:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Industry-leading Redux DevTools with time travel</li>
                    <li><strong>React Query:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent dedicated DevTools for queries</li>
                    <li><strong>Zustand:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê Redux DevTools compatible</li>
                    <li><strong>MobX:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê MobX DevTools available</li>
                    <li><strong>Jotai:</strong> ‚≠ê‚≠ê‚≠ê React DevTools + debug utilities</li>
                    <li><strong>XState:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Visual state machine inspector</li>
                    <li><strong>Context API:</strong> ‚≠ê‚≠ê React DevTools only</li>
                </ul>

                <h3>When to Choose Each Library</h3>

                <h4>Choose Zustand When:</h4>
                <ul>
                    <li>‚úÖ You want something simple and powerful</li>
                    <li>‚úÖ Bundle size matters</li>
                    <li>‚úÖ You like hook-based APIs</li>
                    <li>‚úÖ You want fine-grained performance control</li>
                    <li>‚úÖ You're building a new app</li>
                </ul>

                <h4>Choose Redux Toolkit When:</h4>
                <ul>
                    <li>‚úÖ You have a large, complex application</li>
                    <li>‚úÖ Multiple teams working on the same codebase</li>
                    <li>‚úÖ You need strict state update patterns</li>
                    <li>‚úÖ Time-travel debugging is valuable</li>
                    <li>‚úÖ Your team already knows Redux</li>
                </ul>

                <h4>Choose React Query When:</h4>
                <ul>
                    <li>‚úÖ Your app is heavily data-driven</li>
                    <li>‚úÖ You fetch a lot of data from APIs</li>
                    <li>‚úÖ You need caching and background refetching</li>
                    <li>‚úÖ You want automatic loading/error states</li>
                    <li>‚úÖ Always (as server state solution)!</li>
                </ul>

                <h4>Choose Jotai When:</h4>
                <ul>
                    <li>‚úÖ You like atomic state architecture</li>
                    <li>‚úÖ You need lots of derived state</li>
                    <li>‚úÖ Bottom-up state design appeals to you</li>
                    <li>‚úÖ You want built-in async atom support</li>
                </ul>

                <h4>Choose XState When:</h4>
                <ul>
                    <li>‚úÖ You have complex workflows or processes</li>
                    <li>‚úÖ State machines model your domain well</li>
                    <li>‚úÖ You need to visualize state transitions</li>
                    <li>‚úÖ You want impossible states to be impossible</li>
                </ul>

                <h4>Choose Context API When:</h4>
                <ul>
                    <li>‚úÖ You have 2-5 global values maximum</li>
                    <li>‚úÖ Updates are infrequent</li>
                    <li>‚úÖ You want zero dependencies</li>
                    <li>‚úÖ Values rarely change (theme, locale, auth)</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ The Winner?</h4>
                    <p style="color: white;">There isn't one! Each library excels in different scenarios. The "best" choice depends on your specific needs:</p>
                    <ul style="color: white;">
                        <li><strong>Most versatile:</strong> Zustand (client state) + React Query (server state)</li>
                        <li><strong>Enterprise standard:</strong> Redux Toolkit</li>
                        <li><strong>Simplest:</strong> Context API + useState</li>
                        <li><strong>Most innovative:</strong> Jotai, XState</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Architectural Patterns -->
            <section id="section7" class="lesson-section">
                <h2>üèõÔ∏è Architectural Patterns</h2>
                
                <p>Beyond choosing a library, how you organize your state and structure your application matters immensely. Let's explore proven architectural patterns.</p>

                <h3>Pattern 1: Feature-Based Organization</h3>

                <p>Organize code by feature rather than by file type:</p>

                <pre><code class="language-plaintext">src/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authStore.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ cart/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ store/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îî‚îÄ‚îÄ App.tsx</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits</h4>
                    <ul>
                        <li>Feature code is colocated‚Äîeasy to find everything related</li>
                        <li>Can delete entire feature folder without hunting across directories</li>
                        <li>Clear boundaries between features</li>
                        <li>Teams can work on different features independently</li>
                    </ul>
                </div>

                <h3>Pattern 2: Separation of Client and Server State</h3>

                <div class="mermaid">
                    graph TB
                    A[Application State] --> B[Client State]
                    A --> C[Server State]
                    
                    B --> B1[UI State: Zustand/Redux]
                    B --> B2[Form State: React Hook Form]
                    B --> B3[URL State: Router]
                    
                    C --> C1[API Data: React Query]
                    C --> C2[Real-time: WebSocket + Query]
                    C --> C3[GraphQL: Apollo Client]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <p><strong>Client State:</strong> Managed by Zustand, Redux, Context</p>
                <ul>
                    <li>Theme preference</li>
                    <li>Sidebar open/closed</li>
                    <li>Current tab selection</li>
                    <li>Modal state</li>
                    <li>Filter selections (before applying)</li>
                </ul>

                <p><strong>Server State:</strong> Managed by React Query, SWR, Apollo</p>
                <ul>
                    <li>User profile data</li>
                    <li>Product lists</li>
                    <li>Search results</li>
                    <li>Dashboard metrics</li>
                    <li>Any data fetched from APIs</li>
                </ul>

                <pre><code class="language-typescript">// Example: Hybrid approach
// Client state: Zustand
const useUIStore = create&lt;UIStore&gt;((set) => ({
  sidebarOpen: true,
  theme: 'light',
  toggleSidebar: () => set(state => ({ sidebarOpen: !state.sidebarOpen })),
  setTheme: (theme) => set({ theme })
}));

// Server state: React Query
function ProductList() {
  const { sidebarOpen } = useUIStore(); // Client state
  
  const { data: products } = useQuery({ // Server state
    queryKey: ['products'],
    queryFn: fetchProducts
  });
  
  return (
    &lt;div className={sidebarOpen ? 'with-sidebar' : 'full-width'}&gt;
      {products?.map(p => &lt;ProductCard key={p.id} product={p} /&gt;)}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 3: Custom Hooks for Business Logic</h3>

                <p>Encapsulate complex logic in custom hooks:</p>

                <pre><code class="language-typescript">// Custom hook pattern
function useCart() {
  const { items, addItem, removeItem, clearCart } = useCartStore();
  const queryClient = useQueryClient();
  
  const addToCart = async (product: Product) => {
    // Business logic
    addItem(product);
    
    // Side effects
    toast.success('Added to cart');
    analytics.track('add_to_cart', { productId: product.id });
  };
  
  const checkout = useMutation({
    mutationFn: async () => {
      const response = await fetch('/api/checkout', {
        method: 'POST',
        body: JSON.stringify({ items })
      });
      return response.json();
    },
    onSuccess: () => {
      clearCart();
      queryClient.invalidateQueries(['orders']);
    }
  });
  
  const total = useMemo(() => 
    items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    [items]
  );
  
  return {
    items,
    total,
    addToCart,
    removeItem,
    clearCart,
    checkout
  };
}

// Components stay clean
function ProductCard({ product }: { product: Product }) {
  const { addToCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;button onClick={() => addToCart(product)}&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 4: Domain-Driven Design</h3>

                <p>Structure state around your business domains:</p>

                <pre><code class="language-typescript">// Domain stores
// User domain
const useUserStore = create&lt;UserStore&gt;(/* ... */);

// Product domain
const useProductStore = create&lt;ProductStore&gt;(/* ... */);

// Order domain
const useOrderStore = create&lt;OrderStore&gt;(/* ... */);

// Each domain is independent
// Domains communicate via actions, not shared state</code></pre>

                <h3>Pattern 5: Normalized State</h3>

                <p>Store data in a normalized format to avoid duplication and keep it consistent:</p>

                <pre><code class="language-typescript">// ‚ùå Denormalized - duplication and inconsistency risk
interface DenormalizedState {
  posts: Array&lt;{
    id: string;
    title: string;
    author: {
      id: string;
      name: string;
      email: string;
    };
    comments: Array&lt;{
      id: string;
      text: string;
      author: {
        id: string;
        name: string;
        email: string;
      };
    }&gt;;
  }&gt;;
}

// ‚úÖ Normalized - single source of truth
interface NormalizedState {
  users: {
    byId: Record&lt;string, User&gt;;
    allIds: string[];
  };
  posts: {
    byId: Record&lt;string, Post&gt;; // Just has authorId
    allIds: string[];
  };
  comments: {
    byId: Record&lt;string, Comment&gt;; // Just has authorId, postId
    allIds: string[];
  };
}

// Selectors can reconstruct the full object
const selectPostWithAuthor = (state: State, postId: string) => {
  const post = state.posts.byId[postId];
  const author = state.users.byId[post.authorId];
  return { ...post, author };
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Normalize</h4>
                    <ul>
                        <li><strong>Do normalize:</strong> When data is shared across features, updated frequently, or duplicated</li>
                        <li><strong>Don't normalize:</strong> Server state (React Query handles it), deeply nested read-only data, or simple apps</li>
                    </ul>
                </div>

                <h3>Pattern 6: Middleware and Side Effects</h3>

                <p>Handle side effects systematically:</p>

                <pre><code class="language-typescript">// Zustand middleware example
const useStore = create&lt;Store&gt;()(
  devtools(
    persist(
      immer((set) => ({
        // Store definition
        count: 0,
        increment: () => set(state => { state.count += 1; }),
        
        // Side effect
        incrementWithLog: () => set(state => {
          console.log('Before:', state.count);
          state.count += 1;
          console.log('After:', state.count);
          
          // Analytics
          analytics.track('count_incremented', { value: state.count });
        })
      })),
      {
        name: 'my-store',
        storage: createJSONStorage(() => localStorage)
      }
    )
  )
);</code></pre>

                <h3>Pattern 7: Optimistic Updates</h3>

                <p>Update UI immediately, rollback if server fails:</p>

                <pre><code class="language-typescript">// Optimistic update with React Query
const mutation = useMutation({
  mutationFn: updateTodo,
  onMutate: async (newTodo) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries(['todos']);
    
    // Snapshot previous value
    const previousTodos = queryClient.getQueryData(['todos']);
    
    // Optimistically update
    queryClient.setQueryData(['todos'], (old: Todo[]) => 
      [...old, newTodo]
    );
    
    // Return context with snapshot
    return { previousTodos };
  },
  onError: (err, newTodo, context) => {
    // Rollback on error
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },
  onSettled: () => {
    // Always refetch after error or success
    queryClient.invalidateQueries(['todos']);
  }
});</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Architecture Principles</h4>
                    <ul style="color: white;">
                        <li><strong>Colocation:</strong> Keep related code together</li>
                        <li><strong>Separation:</strong> Separate client and server state</li>
                        <li><strong>Encapsulation:</strong> Hide complexity in custom hooks</li>
                        <li><strong>Single Responsibility:</strong> Each store/slice does one thing</li>
                        <li><strong>Testability:</strong> Make state logic easy to test in isolation</li>
                    </ul>
                </div>
            </section>
            <!-- Section 8: Decision Framework -->
            <section id="section8" class="lesson-section">
                <h2>üéØ Decision Framework</h2>
                
                <p>Choosing the right state management approach can feel overwhelming. Let's break it down into a systematic decision-making process.</p>

                <h3>The State Management Decision Tree</h3>

                <div class="mermaid">
                    graph TD
                    A[Start: Need to manage state] --> B{Is it server data?}
                    B -->|Yes| C[React Query or SWR]
                    B -->|No| D{How many components need it?}
                    
                    D -->|Just one| E[Local useState]
                    D -->|2-3 nearby| F[Lift state up]
                    D -->|Many, far apart| G{How complex?}
                    
                    G -->|Simple| H{How many global values?}
                    G -->|Very complex| I[Redux Toolkit or XState]
                    
                    H -->|1-3 values| J[Context API]
                    H -->|Many values| K[Zustand or Jotai]
                    
                    style A fill:#667eea,color:#fff
                    style C fill:#4CAF50,color:#fff
                    style E fill:#4CAF50,color:#fff
                    style J fill:#FFA726,color:#fff
                    style K fill:#2196F3,color:#fff
                    style I fill:#9C27B0,color:#fff
                </div>

                <h3>Question-Based Decision Guide</h3>

                <h4>Question 1: What type of data is it?</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Data Type</th>
                            <th>Best Solution</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>From API/Server</strong></td>
                            <td>React Query, SWR, Apollo</td>
                            <td>User profile, product list, posts</td>
                        </tr>
                        <tr>
                            <td><strong>UI/Client State</strong></td>
                            <td>useState, Context, Zustand</td>
                            <td>Modal open, sidebar collapsed, theme</td>
                        </tr>
                        <tr>
                            <td><strong>Form Data</strong></td>
                            <td>React Hook Form, Formik</td>
                            <td>Registration form, checkout form</td>
                        </tr>
                        <tr>
                            <td><strong>URL-Based</strong></td>
                            <td>React Router, Next.js router</td>
                            <td>Current page, search filters, sort order</td>
                        </tr>
                    </tbody>
                </table>

                <h4>Question 2: How many components need this data?</h4>

                <pre><code class="language-typescript">// 1 component ‚Üí useState
function Counter() {
  const [count, setCount] = useState(0);
  return &lt;div&gt;{count}&lt;/div&gt;;
}

// 2-3 nearby components ‚Üí Lift state up
function Parent() {
  const [count, setCount] = useState(0);
  return (
    &lt;&gt;
      &lt;Display count={count} /&gt;
      &lt;Controls setCount={setCount} /&gt;
    &lt;/&gt;
  );
}

// Many distant components ‚Üí Global state
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 }))
}));</code></pre>

                <h4>Question 3: How often does it change?</h4>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Rarely Changes</h4>
                    <p><strong>Examples:</strong> Theme, locale, user auth status</p>
                    <p><strong>Solution:</strong> Context API is perfect</p>
                    <pre><code class="language-typescript">const ThemeContext = createContext&lt;Theme&gt;('light');

function App() {
  const [theme, setTheme] = useState&lt;Theme&gt;('light');
  // Changes rarely, Context is fine
  return (
    &lt;ThemeContext.Provider value={theme}&gt;
      &lt;YourApp /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Changes Frequently</h4>
                    <p><strong>Examples:</strong> Mouse position, animation values, real-time data</p>
                    <p><strong>Solution:</strong> Zustand, Jotai (fine-grained updates), or useRef</p>
                    <pre><code class="language-typescript">// Fine-grained updates with Zustand
const useStore = create((set) => ({
  x: 0,
  y: 0,
  setPosition: (x: number, y: number) => set({ x, y })
}));

function MouseTracker() {
  // Only subscribes to what it needs
  const x = useStore(state => state.x);
  return &lt;div&gt;X: {x}&lt;/div&gt;;
}</code></pre>
                </div>

                <h4>Question 4: How complex is the state logic?</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Complexity</th>
                            <th>Indicators</th>
                            <th>Best Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Simple</strong></td>
                            <td>1-3 values, independent updates</td>
                            <td>useState</td>
                        </tr>
                        <tr>
                            <td><strong>Moderate</strong></td>
                            <td>5-10 values, some relationships</td>
                            <td>useReducer, Zustand</td>
                        </tr>
                        <tr>
                            <td><strong>Complex</strong></td>
                            <td>Many values, interdependencies, workflows</td>
                            <td>Redux Toolkit, XState</td>
                        </tr>
                    </tbody>
                </table>

                <pre><code class="language-typescript">// Simple ‚Üí useState
const [isOpen, setIsOpen] = useState(false);

// Moderate ‚Üí useReducer
const [state, dispatch] = useReducer(reducer, initialState);

// Complex ‚Üí Redux Toolkit
const store = configureStore({
  reducer: {
    auth: authReducer,
    products: productsReducer,
    cart: cartReducer,
    orders: ordersReducer
  }
});</code></pre>

                <h4>Question 5: What's your team's experience?</h4>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Team Considerations</h4>
                    <ul>
                        <li><strong>Junior team:</strong> Stick with built-in React features or Zustand (simple API)</li>
                        <li><strong>Mixed experience:</strong> Zustand or Jotai (gradual learning curve)</li>
                        <li><strong>Experienced team:</strong> Any solution, choose based on requirements</li>
                        <li><strong>Redux veterans:</strong> Redux Toolkit is productive and familiar</li>
                    </ul>
                </div>

                <h3>Real-World Scenarios</h3>

                <h4>Scenario 1: Building a Blog</h4>
                <p><strong>Requirements:</strong> Display posts, comments, user authentication</p>
                <p><strong>Recommended Stack:</strong></p>
                <ul>
                    <li><strong>Server state (posts, comments):</strong> React Query</li>
                    <li><strong>Auth state:</strong> Context API (rarely changes)</li>
                    <li><strong>UI state (theme, sidebar):</strong> Context or useState</li>
                </ul>

                <pre><code class="language-typescript">// Blog state architecture
// 1. Auth context (global, changes rarely)
const AuthContext = createContext&lt;AuthContextType | null&gt;(null);

// 2. React Query for posts
function BlogList() {
  const { data: posts } = useQuery({
    queryKey: ['posts'],
    queryFn: fetchPosts
  });
  
  return &lt;div&gt;{posts?.map(post => &lt;PostCard key={post.id} post={post} /&gt;)}&lt;/div&gt;;
}

// 3. Local state for UI
function PostCard({ post }: { post: Post }) {
  const [expanded, setExpanded] = useState(false);
  return &lt;div onClick={() => setExpanded(!expanded)}&gt;...&lt;/div&gt;;
}</code></pre>

                <h4>Scenario 2: E-commerce Application</h4>
                <p><strong>Requirements:</strong> Products, cart, orders, user profile, filters</p>
                <p><strong>Recommended Stack:</strong></p>
                <ul>
                    <li><strong>Server state (products, orders):</strong> React Query</li>
                    <li><strong>Cart state:</strong> Zustand (shared, frequently updated)</li>
                    <li><strong>Filter state:</strong> URL params (shareable, bookmarkable)</li>
                    <li><strong>Auth state:</strong> Context API</li>
                </ul>

                <pre><code class="language-typescript">// E-commerce state architecture
// 1. Cart store (Zustand)
const useCartStore = create&lt;CartStore&gt;((set) => ({
  items: [],
  addItem: (product) => set((state) => ({
    items: [...state.items, { ...product, quantity: 1 }]
  })),
  removeItem: (id) => set((state) => ({
    items: state.items.filter(item => item.id !== id)
  }))
}));

// 2. Products from server (React Query)
function ProductList() {
  const [searchParams] = useSearchParams();
  const category = searchParams.get('category') || 'all';
  
  const { data: products } = useQuery({
    queryKey: ['products', category],
    queryFn: () => fetchProducts(category)
  });
  
  const { addItem } = useCartStore();
  
  return products?.map(p => (
    &lt;ProductCard 
      key={p.id} 
      product={p} 
      onAddToCart={() => addItem(p)} 
    /&gt;
  ));
}</code></pre>

                <h4>Scenario 3: Admin Dashboard</h4>
                <p><strong>Requirements:</strong> Complex forms, tables, charts, real-time updates, multiple user roles</p>
                <p><strong>Recommended Stack:</strong></p>
                <ul>
                    <li><strong>Server state:</strong> React Query with real-time subscriptions</li>
                    <li><strong>Global UI state:</strong> Redux Toolkit (complex, predictable updates needed)</li>
                    <li><strong>Form state:</strong> React Hook Form</li>
                    <li><strong>Auth & permissions:</strong> Context API</li>
                </ul>

                <h4>Scenario 4: Real-Time Chat Application</h4>
                <p><strong>Requirements:</strong> Messages, presence, notifications, typing indicators</p>
                <p><strong>Recommended Stack:</strong></p>
                <ul>
                    <li><strong>Messages:</strong> React Query with WebSocket integration</li>
                    <li><strong>Presence/typing:</strong> Zustand (frequent updates, global)</li>
                    <li><strong>UI state:</strong> Local useState</li>
                </ul>

                <h3>Migration Strategies</h3>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When to Migrate</h4>
                    <p>Signs you might need to refactor your state management:</p>
                    <ul>
                        <li>Prop drilling through 5+ levels consistently</li>
                        <li>Performance issues from Context re-renders</li>
                        <li>Difficulty debugging state changes</li>
                        <li>Team spending too much time on state-related bugs</li>
                        <li>Code duplication in state update logic</li>
                    </ul>
                </div>

                <h4>Migration Path: Context ‚Üí Zustand</h4>

                <pre><code class="language-typescript">// Before: Context (causing re-render issues)
const AppContext = createContext&lt;AppState | null&gt;(null);

function AppProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [theme, setTheme] = useState('light');
  const [cart, setCart] = useState&lt;CartItem[]&gt;([]);
  
  // Every component re-renders when ANY value changes!
  const value = { user, setUser, theme, setTheme, cart, setCart };
  
  return &lt;AppContext.Provider value={value}&gt;{children}&lt;/AppContext.Provider&gt;;
}

// After: Zustand (fine-grained subscriptions)
const useStore = create&lt;AppStore&gt;((set) => ({
  user: null,
  theme: 'light',
  cart: [],
  setUser: (user) => set({ user }),
  setTheme: (theme) => set({ theme }),
  addToCart: (item) => set((state) => ({ cart: [...state.cart, item] }))
}));

// Components only re-render when THEIR data changes
function ThemeToggle() {
  const theme = useStore(state => state.theme); // Only subscribes to theme
  const setTheme = useStore(state => state.setTheme);
  return &lt;button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}&gt;Toggle&lt;/button&gt;;
}</code></pre>

                <h4>Gradual Migration Strategy</h4>

                <ol>
                    <li><strong>Identify pain points:</strong> Which Context is causing the most re-renders?</li>
                    <li><strong>Start small:</strong> Migrate one feature/store at a time</li>
                    <li><strong>Run both systems:</strong> Zustand and Context can coexist during migration</li>
                    <li><strong>Test thoroughly:</strong> Ensure behavior is identical</li>
                    <li><strong>Monitor performance:</strong> Verify improvements with React DevTools Profiler</li>
                    <li><strong>Complete migration:</strong> Remove old Context code once everything is migrated</li>
                </ol>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Decision Framework Summary</h4>
                    <ol style="color: white;">
                        <li><strong>Always start with the simplest solution</strong> (useState)</li>
                        <li><strong>Separate concerns</strong> (server state vs client state)</li>
                        <li><strong>Choose based on actual needs,</strong> not trends</li>
                        <li><strong>Consider team experience</strong> and learning curve</li>
                        <li><strong>Plan for growth,</strong> but don't over-engineer</li>
                        <li><strong>Refactor when you feel pain,</strong> not before</li>
                    </ol>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" class="lesson-section">
                <h2>‚úÖ Best Practices</h2>
                
                <p>Follow these proven practices to build maintainable, performant state management systems.</p>

                <h3>1. Separate Concerns</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Do This</h4>
                    <pre><code class="language-typescript">// Server state - React Query
const { data: user } = useQuery(['user', userId], fetchUser);

// Client state - Zustand
const theme = useStore(state => state.theme);

// Form state - React Hook Form
const { register, handleSubmit } = useForm();

// URL state - React Router
const [searchParams] = useSearchParams();</code></pre>
                </div>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Don't Do This</h4>
                    <pre><code class="language-typescript">// Mixing server state in Redux (now you manage cache yourself!)
dispatch(fetchUser(userId)); // Manual async action
const user = useSelector(state => state.user); // Manual cache management

// Putting everything in Context (performance issues)
const { user, products, cart, theme, locale } = useContext(EverythingContext);</code></pre>
                </div>

                <h3>2. Keep State Close to Where It's Used</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Local state for accordion
function Accordion({ items }: { items: Item[] }) {
  const [openIndex, setOpenIndex] = useState(0);
  // State only matters to this component
  return &lt;div&gt;{/* ... */}&lt;/div&gt;;
}

// ‚ùå Bad: Unnecessary global state
const useStore = create((set) => ({
  accordionOpenIndex: 0, // Why is this global?
  setAccordionOpenIndex: (index: number) => set({ accordionOpenIndex: index })
}));</code></pre>

                <h3>3. Use TypeScript Properly</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Fully typed store
interface UserStore {
  user: User | null;
  setUser: (user: User | null) => void;
  logout: () => void;
}

const useUserStore = create&lt;UserStore&gt;((set) => ({
  user: null,
  setUser: (user) => set({ user }),
  logout: () => set({ user: null })
}));

// ‚ùå Bad: Any types
const useStore = create((set: any) => ({
  user: null as any,
  setUser: (user: any) => set({ user })
}));</code></pre>

                <h3>4. Avoid Derived State</h3>

                <pre><code class="language-typescript">// ‚ùå Bad: Storing derived state
const useStore = create((set) => ({
  items: [],
  total: 0, // Derived from items!
  addItem: (item) => set((state) => ({
    items: [...state.items, item],
    total: state.total + item.price // Easy to get out of sync!
  }))
}));

// ‚úÖ Good: Calculate on the fly
const useStore = create((set) => ({
  items: [],
  addItem: (item) => set((state) => ({
    items: [...state.items, item]
  }))
}));

// Compute when needed
function Cart() {
  const items = useStore(state => state.items);
  const total = items.reduce((sum, item) => sum + item.price, 0);
  return &lt;div&gt;Total: ${total}&lt;/div&gt;;
}

// Or use a selector with memoization
const useTotal = () => useStore(
  state => state.items.reduce((sum, item) => sum + item.price, 0)
);</code></pre>

                <h3>5. Normalize Related Data</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Normalized structure
interface NormalizedState {
  users: {
    byId: Record&lt;string, User&gt;;
    allIds: string[];
  };
  posts: {
    byId: Record&lt;string, Post&gt;;
    allIds: string[];
  };
}

// Easy to update a single user
const updateUser = (userId: string, updates: Partial&lt;User&gt;) => {
  set((state) => ({
    users: {
      ...state.users,
      byId: {
        ...state.users.byId,
        [userId]: { ...state.users.byId[userId], ...updates }
      }
    }
  }));
};</code></pre>

                <h3>6. Use Selectors for Performance</h3>

                <pre><code class="language-typescript">// ‚ùå Bad: Component re-renders when ANY store property changes
function UserName() {
  const store = useStore(); // Subscribes to everything!
  return &lt;div&gt;{store.user?.name}&lt;/div&gt;;
}

// ‚úÖ Good: Only re-renders when user.name changes
function UserName() {
  const userName = useStore(state => state.user?.name);
  return &lt;div&gt;{userName}&lt;/div&gt;;
}

// ‚úÖ Even better: Custom selector hook
const useUserName = () => useStore(state => state.user?.name);

function UserName() {
  const userName = useUserName();
  return &lt;div&gt;{userName}&lt;/div&gt;;
}</code></pre>

                <h3>7. Handle Async Operations Properly</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Proper async handling with React Query
const { data, isLoading, error } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => fetchUser(userId)
});

if (isLoading) return &lt;Spinner /&gt;;
if (error) return &lt;Error error={error} /&gt;;
return &lt;UserProfile user={data} /&gt;;

// ‚úÖ Good: Async actions in Zustand
const useStore = create&lt;Store&gt;((set) => ({
  user: null,
  loading: false,
  error: null,
  fetchUser: async (id: string) => {
    set({ loading: true, error: null });
    try {
      const user = await fetchUser(id);
      set({ user, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  }
}));</code></pre>

                <h3>8. Don't Over-Optimize Prematurely</h3>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Remember</h4>
                    <p>React is fast. Most apps don't need aggressive optimization. Profile first, optimize second.</p>
                    <ul>
                        <li>Don't wrap everything in useMemo/useCallback without reason</li>
                        <li>Don't split Context into 20 tiny contexts prematurely</li>
                        <li>Don't reach for Redux if Context works fine</li>
                        <li>Measure with React DevTools Profiler before optimizing</li>
                    </ul>
                </div>

                <h3>9. Write Testable State Logic</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Testable Zustand store
import { create } from 'zustand';

export const createCounterStore = (initialCount = 0) => {
  return create&lt;CounterStore&gt;((set) => ({
    count: initialCount,
    increment: () => set((state) => ({ count: state.count + 1 })),
    decrement: () => set((state) => ({ count: state.count - 1 }))
  }));
};

// Easy to test!
describe('Counter Store', () => {
  it('increments count', () => {
    const useStore = createCounterStore(0);
    const { increment } = useStore.getState();
    
    increment();
    expect(useStore.getState().count).toBe(1);
  });
});</code></pre>

                <h3>10. Document Your State Architecture</h3>

                <pre><code class="language-typescript">/**
 * Application State Architecture
 * 
 * Server State (React Query):
 * - User data (/api/user)
 * - Products (/api/products)
 * - Orders (/api/orders)
 * 
 * Client State (Zustand):
 * - Cart (useCartStore): Shopping cart items
 * - UI (useUIStore): Theme, sidebar state, modals
 * 
 * Form State (React Hook Form):
 * - Checkout form
 * - Profile edit form
 * 
 * URL State (React Router):
 * - Search filters
 * - Pagination
 * - Selected category
 */</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Best Practices Checklist</h4>
                    <ul style="color: white;">
                        <li>‚úÖ Separate server and client state</li>
                        <li>‚úÖ Keep state as local as possible</li>
                        <li>‚úÖ Use TypeScript for type safety</li>
                        <li>‚úÖ Avoid storing derived state</li>
                        <li>‚úÖ Normalize when needed</li>
                        <li>‚úÖ Use selectors for performance</li>
                        <li>‚úÖ Handle async properly</li>
                        <li>‚úÖ Profile before optimizing</li>
                        <li>‚úÖ Write testable state logic</li>
                        <li>‚úÖ Document your architecture</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéâ What You've Learned</h3>
                    <p style="color: white;">Congratulations! You now have a comprehensive understanding of state management in React applications. Let's review the key concepts:</p>
                </div>

                <h3>Key Takeaways</h3>

                <ol>
                    <li><strong>State Management is About Trade-offs:</strong> There's no perfect solution for all cases. Choose based on your specific needs.</li>
                    
                    <li><strong>Four Types of State:</strong>
                        <ul>
                            <li><strong>Local:</strong> Component-specific (useState)</li>
                            <li><strong>Shared:</strong> Multiple components need it (Context, Zustand, Redux)</li>
                            <li><strong>Server:</strong> From APIs (React Query, SWR)</li>
                            <li><strong>URL:</strong> In the URL (React Router)</li>
                        </ul>
                    </li>
                    
                    <li><strong>Start Simple, Scale When Needed:</strong> Begin with useState and Context, only add complexity when you feel real pain points.</li>
                    
                    <li><strong>Separate Server and Client State:</strong> This is the single biggest improvement you can make to state management.</li>
                    
                    <li><strong>Modern Recommendation:</strong>
                        <ul>
                            <li><strong>Server state:</strong> React Query or SWR</li>
                            <li><strong>Client state:</strong> Zustand for simplicity, Redux Toolkit for complex apps</li>
                            <li><strong>Forms:</strong> React Hook Form</li>
                            <li><strong>URL state:</strong> React Router</li>
                        </ul>
                    </li>
                </ol>

                <h3>Comparison at a Glance</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>Best For</th>
                            <th>Size</th>
                            <th>Learning Curve</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>useState/Context</strong></td>
                            <td>Small to medium apps</td>
                            <td>0KB (built-in)</td>
                            <td>‚≠ê Very Easy</td>
                        </tr>
                        <tr>
                            <td><strong>Zustand</strong></td>
                            <td>Most applications</td>
                            <td>1KB</td>
                            <td>‚≠ê Very Easy</td>
                        </tr>
                        <tr>
                            <td><strong>Jotai</strong></td>
                            <td>Atomic state needs</td>
                            <td>3KB</td>
                            <td>‚≠ê‚≠ê Easy</td>
                        </tr>
                        <tr>
                            <td><strong>Redux Toolkit</strong></td>
                            <td>Large enterprise apps</td>
                            <td>20KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td><strong>React Query</strong></td>
                            <td>Server state (always!)</td>
                            <td>13KB</td>
                            <td>‚≠ê‚≠ê Easy</td>
                        </tr>
                        <tr>
                            <td><strong>XState</strong></td>
                            <td>Complex workflows</td>
                            <td>25KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê Challenging</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Next Steps in Module 8</h3>

                <p>Now that you understand the landscape, here's what's coming:</p>

                <ul>
                    <li><strong>Lesson 8.2:</strong> Hands-on with Zustand - Build real applications with this popular library</li>
                    <li><strong>Lesson 8.3:</strong> Redux Toolkit - Master enterprise-grade state management</li>
                    <li><strong>Lesson 8.4:</strong> React Query - Transform how you handle server state</li>
                    <li><strong>Lesson 8.5:</strong> Architecture Best Practices - Organize your code like a pro</li>
                </ul>

                <h3>Practical Exercise</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üèãÔ∏è Practice: Audit Your Current Project</h4>
                    <p>Take a project you're working on (or one from earlier modules) and answer these questions:</p>
                    <ol>
                        <li>What state do I have? Categorize each piece (local, shared, server, URL)</li>
                        <li>Am I experiencing any pain points? (Prop drilling, performance, complexity)</li>
                        <li>Is my server state separate from client state?</li>
                        <li>What would I change about my current state management?</li>
                        <li>Based on this lesson, what's the best solution for my needs?</li>
                    </ol>
                </div>

                <h3>Additional Resources</h3>

                <ul>
                    <li><a href="https://zustand-demo.pmnd.rs/" target="_blank" rel="noopener noreferrer">Zustand Documentation</a></li>
                    <li><a href="https://tanstack.com/query/latest" target="_blank" rel="noopener noreferrer">TanStack Query (React Query) Docs</a></li>
                    <li><a href="https://redux-toolkit.js.org/" target="_blank" rel="noopener noreferrer">Redux Toolkit Documentation</a></li>
                    <li><a href="https://jotai.org/" target="_blank" rel="noopener noreferrer">Jotai Documentation</a></li>
                    <li><a href="https://xstate.js.org/" target="_blank" rel="noopener noreferrer">XState Documentation</a></li>
                    <li><a href="https://kentcdodds.com/blog/application-state-management-with-react" target="_blank" rel="noopener noreferrer">Kent C. Dodds: Application State Management</a></li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 3rem 2rem;">
                    <h2 style="color: white; font-size: 2.5rem; margin-bottom: 1rem;">üéâ Great Job!</h2>
                    <p style="color: white; font-size: 1.2rem; margin-bottom: 1rem;">You now understand the state management landscape!</p>
                    <p style="color: white; font-size: 1rem;">You're equipped to make informed decisions about which tools to use for your applications. In the next lesson, we'll get hands-on with Zustand and build real state management solutions.</p>
                    <p style="color: white; font-size: 1.1rem; margin-top: 2rem; font-weight: 600;">Ready to start building? Let's go! üöÄ</p>
                </div>
            </section>

            <!-- Quiz Section -->
            <section id="quiz" class="lesson-section">
                <div class="card quiz-container">
                    <h2>üéØ Quick Quiz</h2>
                    <p>Test your understanding of state management concepts!</p>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What type of state is data fetched from an API?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="This is for component-specific UI state">
                                A) Local state
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Server state (data from APIs) is best managed by specialized libraries like React Query or SWR that handle caching, refetching, and synchronization.">
                                B) Server state
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="This is for multiple components sharing data">
                                C) Shared state
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="This is for data in the URL">
                                D) URL state
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> When should you choose Redux Toolkit over Zustand?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Think about scale and complexity">
                                A) Always - Redux is always better
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Bundle size alone shouldn't drive this decision">
                                B) When you need the smallest bundle size
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Excellent! Redux Toolkit shines in large enterprise applications with complex state logic, multiple teams, and when you need strict patterns and excellent DevTools.">
                                C) For large, complex apps needing strict patterns and DevTools
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Learning curve shouldn't be the primary factor">
                                D) When your team is new to React
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> What is the main problem with using Context API for frequently changing values?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Context causes ALL consumers to re-render when ANY value changes, even if a component only uses one value. This is why libraries like Zustand with fine-grained subscriptions are better for frequently changing state.">
                                A) All consumers re-render when any value changes
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Context has good TypeScript support">
                                B) It doesn't support TypeScript
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Context can be used anywhere in React">
                                C) It can't be used with functional components
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Context works with async operations">
                                D) It doesn't work with async operations
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 4:</strong> What is the principle of "colocation" in state management?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="This is about WHERE state lives">
                                A) Putting all state in Redux
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Spot on! Colocation means keeping state as close as possible to where it's used. This improves maintainability, performance, and makes code easier to understand.">
                                B) Keeping state as close as possible to where it's used
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Colocation is about proximity, not format">
                                C) Storing state in localStorage
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="This relates to data normalization">
                                D) Normalizing your data structure
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 5:</strong> Why is React Query considered a game-changer for state management?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="React Query is specifically for server state">
                                A) It handles all types of state in one library
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly right! React Query revolutionized state management by recognizing that server state is fundamentally different and providing automatic caching, refetching, synchronization, and error handling.">
                                B) It separates server state and handles caching automatically
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="React Query is actually lightweight">
                                C) It has the smallest bundle size
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="React Query doesn't replace Redux">
                                D) It replaces Redux completely
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="module_project_7_registration_system.html" class="prev-lesson">‚Üê Previous: Module 7 Project</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_8_2_zustand_basics.html" class="next-lesson">Next: Zustand Basics ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build exceptional applications.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
