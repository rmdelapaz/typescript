<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Understand state management in React applications. Learn when to use local vs global state, explore state management libraries, architectural patterns, and how to select the right tool for your application.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.1: State Management Overview - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.1: State Management Overview</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üèóÔ∏è Lesson 8.1: State Management Overview</h1>
                <p class="lead">Welcome to Module 8! As your React applications grow, managing state becomes increasingly challenging. What starts as simple useState calls can evolve into prop drilling nightmares, performance bottlenecks, and maintenance headaches. In this lesson, you'll learn to recognize different types of state, understand when to use various state management solutions, and make informed architectural decisions that scale with your application.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Distinguish between local state, shared state, server state, and URL state</li>
                        <li>Identify when to keep state local vs. when to lift it up</li>
                        <li>Understand the trade-offs between different state management solutions</li>
                        <li>Recognize the signs that your application needs a state management library</li>
                        <li>Compare popular state management libraries and their use cases</li>
                        <li>Apply architectural patterns for organizing application state</li>
                        <li>Select the right state management tool for your specific needs</li>
                        <li>Plan a scalable state management strategy from the beginning</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Prerequisites:</strong> Modules 1-7, especially Module 5 (Advanced Hooks and Patterns)</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What is State Management?</a></li>
                        <li><a href="#section2" class="toc-link">Types of State in React Applications</a></li>
                        <li><a href="#section3" class="toc-link">Local vs Global State</a></li>
                        <li><a href="#section4" class="toc-link">Common State Management Problems</a></li>
                        <li><a href="#section5" class="toc-link">State Management Solutions Landscape</a></li>
                        <li><a href="#section6" class="toc-link">Comparing State Management Libraries</a></li>
                        <li><a href="#section7" class="toc-link">Architectural Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Decision Framework</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What is State Management? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What is State Management?</h2>
                
                <p>Before diving into different solutions, let's establish what we mean by "state" and why managing it effectively is crucial to building maintainable React applications.</p>

                <h3>Defining State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>State</strong> is any data that changes over time in your application. It represents the current "snapshot" of your application at any given moment‚Äîwhat the user sees, what data has been loaded, what the user has selected, and so on.</p>
                </div>

                <p>Think of state as your application's memory. Just as you remember what you had for breakfast or what tabs you have open in your browser, your application needs to "remember" things like:</p>

                <ul>
                    <li>Is the user logged in?</li>
                    <li>What items are in the shopping cart?</li>
                    <li>Which theme is active (light or dark)?</li>
                    <li>Is a modal currently open?</li>
                    <li>What data did we fetch from the API?</li>
                    <li>What text is the user typing in the search box?</li>
                </ul>

                <h3>Why State Management Matters</h3>

                <p>As applications grow, managing state becomes one of the most challenging aspects of frontend development. Here's why:</p>

                <div class="mermaid">
                    graph TB
                    A[State Management Challenges] --> B[Synchronization]
                    A --> C[Performance]
                    A --> D[Debugging]
                    A --> E[Maintainability]
                    
                    B --> B1[Multiple components need same data]
                    B --> B2[Keeping UI in sync with state]
                    B --> B3[Avoiding stale data]
                    
                    C --> C1[Unnecessary re-renders]
                    C --> C2[Large component trees]
                    C --> C3[Frequent updates]
                    
                    D --> D1[Where did this value come from?]
                    D --> D2[Why did this component re-render?]
                    D --> D3[What changed this state?]
                    
                    E --> E1[Prop drilling]
                    E --> E2[Scattered state logic]
                    E --> E3[Hard to understand data flow]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>The Evolution of an Application's State</h3>

                <p>Let's look at how state management evolves as an application grows:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Application Size</th>
                            <th>State Complexity</th>
                            <th>Typical Solution</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Small</strong><br/>(1-5 components)</td>
                            <td>Simple, contained</td>
                            <td>Local useState</td>
                            <td>Counter, toggle button</td>
                        </tr>
                        <tr>
                            <td><strong>Medium</strong><br/>(5-20 components)</td>
                            <td>Shared between siblings</td>
                            <td>Lifting state up, props</td>
                            <td>Todo list, simple form</td>
                        </tr>
                        <tr>
                            <td><strong>Large</strong><br/>(20-50 components)</td>
                            <td>Many distant components need access</td>
                            <td>Context API, custom hooks</td>
                            <td>E-commerce cart, user auth</td>
                        </tr>
                        <tr>
                            <td><strong>Very Large</strong><br/>(50+ components)</td>
                            <td>Complex interdependencies</td>
                            <td>State management library (Zustand, Redux)</td>
                            <td>Admin dashboard, social media app</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>State management isn't about choosing a fancy library‚Äîit's about making data flow in your application predictable, debuggable, and maintainable. The best state management solution is often the simplest one that solves your specific problems.</p>
                </div>

                <h3>State Management Goals</h3>

                <p>Good state management should achieve these goals:</p>

                <ol>
                    <li><strong>Predictability:</strong> Given the same state and actions, the application behaves the same way</li>
                    <li><strong>Maintainability:</strong> Easy to understand, modify, and extend</li>
                    <li><strong>Debuggability:</strong> Easy to trace state changes and identify bugs</li>
                    <li><strong>Performance:</strong> Efficient updates without unnecessary re-renders</li>
                    <li><strong>Developer Experience:</strong> Pleasant to work with, good TypeScript support</li>
                    <li><strong>Testability:</strong> Easy to test state logic in isolation</li>
                </ol>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Golden Rule</h4>
                    <p><strong>Start simple, scale when needed.</strong> Don't reach for Redux on day one if useState and props work fine. But also don't hesitate to refactor when you feel pain points. The best architecture evolves with your application's needs.</p>
                </div>
            </section>

            <!-- Section 2: Types of State in React Applications -->
            <section id="section2" class="lesson-section">
                <h2>üéØ Types of State in React Applications</h2>
                
                <p>Not all state is created equal. Understanding the different categories of state helps you choose the right management approach for each type.</p>

                <h3>The Four Categories of State</h3>

                <div class="mermaid">
                    graph LR
                    A[Application State] --> B[Local State]
                    A --> C[Shared State]
                    A --> D[Server State]
                    A --> E[URL State]
                    
                    B --> B1[Component-specific]
                    C --> C1[Multiple components]
                    D --> D1[From backend APIs]
                    E --> E1[From URL params]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>1. Local State (UI State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Local state</strong> is data that only a single component (and possibly its children) needs to know about. It's ephemeral, lives only as long as the component is mounted, and doesn't need to be shared globally.</p>
                </div>

                <p><strong>Examples of local state:</strong></p>
                <ul>
                    <li>Form input values (before submission)</li>
                    <li>Is a dropdown menu open?</li>
                    <li>Current tab in a tabbed interface</li>
                    <li>Is a tooltip visible?</li>
                    <li>Hover state of a button</li>
                </ul>

                <p><strong>Best managed with:</strong> <code>useState</code>, <code>useReducer</code></p>

                <pre><code class="language-typescript">// Example: Local state for a dropdown
function Dropdown({ options }: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState&lt;string | null&gt;(null);

  return (
    &lt;div&gt;
      &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
        {selected || 'Select an option'}
      &lt;/button&gt;
      {isOpen && (
        &lt;ul&gt;
          {options.map(option => (
            &lt;li 
              key={option.value}
              onClick={() => {
                setSelected(option.label);
                setIsOpen(false);
              }}
            &gt;
              {option.label}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Local State</h4>
                    <p><strong>Use local state when:</strong> Only one component needs it, it doesn't persist when unmounted, and it doesn't need to be synchronized with other parts of the app.</p>
                </div>

                <h3>2. Shared State (Application State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Shared state</strong> is data that multiple components across your application need access to. It typically persists longer than a single component's lifecycle and needs to stay synchronized.</p>
                </div>

                <p><strong>Examples of shared state:</strong></p>
                <ul>
                    <li>User authentication status</li>
                    <li>Current theme (light/dark mode)</li>
                    <li>Shopping cart items</li>
                    <li>Notification system</li>
                    <li>Active language/locale</li>
                    <li>Sidebar collapsed/expanded state</li>
                </ul>

                <p><strong>Best managed with:</strong> Context API, Zustand, Redux, Jotai</p>

                <pre><code class="language-typescript">// Example: Shared state with Context
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Used anywhere in the app
function Header() {
  const { theme, toggleTheme } = useContext(ThemeContext)!;
  
  return (
    &lt;header className={theme}&gt;
      &lt;button onClick={toggleTheme}&gt;
        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      &lt;/button&gt;
    &lt;/header&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Shared State</h4>
                    <p><strong>Use shared state when:</strong> Multiple components in different parts of the tree need the same data, the data needs to persist across route changes, or you're experiencing "prop drilling" pain.</p>
                </div>

                <h3>3. Server State (Remote State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Server state</strong> is data that originates from a remote server and is cached on the client. It's unique because you don't fully control it‚Äîthe server is the source of truth, and your local copy might be stale.</p>
                </div>

                <p><strong>Examples of server state:</strong></p>
                <ul>
                    <li>User profile data fetched from API</li>
                    <li>List of products in an e-commerce store</li>
                    <li>Blog posts and articles</li>
                    <li>Real-time data (stock prices, chat messages)</li>
                    <li>Search results</li>
                </ul>

                <p><strong>Unique characteristics of server state:</strong></p>
                <ul>
                    <li>Asynchronous by nature</li>
                    <li>Can become stale and need refreshing</li>
                    <li>Multiple components may request the same data</li>
                    <li>Needs error handling and loading states</li>
                    <li>May need caching and invalidation strategies</li>
                    <li>Can have race conditions</li>
                </ul>

                <p><strong>Best managed with:</strong> React Query (TanStack Query), SWR, RTK Query, Apollo Client (for GraphQL)</p>

                <pre><code class="language-typescript">// Example: Server state with React Query
import { useQuery } from '@tanstack/react-query';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile({ userId }: { userId: number }) {
  const { data, isLoading, error } = useQuery&lt;User&gt;({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // Data is fresh for 5 minutes
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h1&gt;{data.name}&lt;/h1&gt;
      &lt;p&gt;{data.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't treat server state the same as client state! Putting API data in Redux/Zustand forces you to manually handle loading states, caching, refetching, and cache invalidation‚Äîall things that specialized libraries do automatically.</p>
                </div>

                <h3>4. URL State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>URL state</strong> is information stored in the URL itself‚Äîincluding the pathname, query parameters, and hash. It's special because it's shareable, bookmarkable, and survives page refreshes.</p>
                </div>

                <p><strong>Examples of URL state:</strong></p>
                <ul>
                    <li>Current page/route</li>
                    <li>Search query</li>
                    <li>Filter and sort parameters</li>
                    <li>Selected tab</li>
                    <li>Pagination state</li>
                    <li>Modal or dialog state (for deep linking)</li>
                </ul>

                <p><strong>Best managed with:</strong> React Router, Next.js router, browser URLSearchParams API</p>

                <pre><code class="language-typescript">// Example: URL state with React Router
import { useSearchParams } from 'react-router-dom';

function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const category = searchParams.get('category') || 'all';
  const sortBy = searchParams.get('sort') || 'name';
  const page = Number(searchParams.get('page')) || 1;

  const updateFilters = (newCategory: string) => {
    setSearchParams({
      category: newCategory,
      sort: sortBy,
      page: '1' // Reset to first page on filter change
    });
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Products - {category}&lt;/h2&gt;
      &lt;select value={category} onChange={e => updateFilters(e.target.value)}&gt;
        &lt;option value="all"&gt;All Products&lt;/option&gt;
        &lt;option value="electronics"&gt;Electronics&lt;/option&gt;
        &lt;option value="clothing"&gt;Clothing&lt;/option&gt;
      &lt;/select&gt;
      {/* Product list here */}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use URL State</h4>
                    <p><strong>Use URL state when:</strong> Users should be able to share or bookmark the current view, state should persist through refreshes, or you want browser back/forward buttons to work naturally.</p>
                </div>

                <h3>State Type Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>State Type</th>
                            <th>Lifespan</th>
                            <th>Scope</th>
                            <th>Persistence</th>
                            <th>Best Tool</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Local</strong></td>
                            <td>Component mount</td>
                            <td>Single component</td>
                            <td>Lost on unmount</td>
                            <td>useState</td>
                        </tr>
                        <tr>
                            <td><strong>Shared</strong></td>
                            <td>App lifecycle</td>
                            <td>Multiple components</td>
                            <td>While app is running</td>
                            <td>Context/Zustand/Redux</td>
                        </tr>
                        <tr>
                            <td><strong>Server</strong></td>
                            <td>Configurable cache</td>
                            <td>Global (cached)</td>
                            <td>Managed by library</td>
                            <td>React Query/SWR</td>
                        </tr>
                        <tr>
                            <td><strong>URL</strong></td>
                            <td>Until navigation</td>
                            <td>Global (in URL)</td>
                            <td>Survives refresh</td>
                            <td>React Router</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip</h4>
                    <p>Many state management problems can be solved by simply using the right type of state. For example, if you're putting search filters in Redux, consider using URL params instead‚Äîthey're more user-friendly and require zero extra code for persistence!</p>
                </div>
            </section>

            <!-- Section 3: Local vs Global State -->
            <section id="section3" class="lesson-section">
                <h2>‚öñÔ∏è Local vs Global State</h2>
                
                <p>One of the most important architectural decisions in React is determining where state should live. Let's explore the principles and patterns for making this decision.</p>

                <h3>The Principle of Colocation</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Colocation Principle</h4>
                    <p style="color: white;"><strong>"State should live as close as possible to where it's used."</strong></p>
                    <p style="color: white;">This means keeping state local by default and only "lifting it up" when multiple components genuinely need to share it.</p>
                </div>

                <h3>Why Colocation Matters</h3>

                <p>Keeping state local has several benefits:</p>

                <ol>
                    <li><strong>Easier to understand:</strong> The state and the components that use it are in the same file</li>
                    <li><strong>Better performance:</strong> State changes only re-render the components that need to update</li>
                    <li><strong>Simpler testing:</strong> Components with local state are self-contained and easier to test</li>
                    <li><strong>Easier refactoring:</strong> Moving or removing components doesn't affect distant parts of the app</li>
                    <li><strong>Less cognitive load:</strong> You don't need to understand the entire app to work on one component</li>
                </ol>

                <h3>When to Keep State Local</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Keep State Local When</h4>
                    <ul>
                        <li>Only one component (and maybe its children) needs the state</li>
                        <li>The state is UI-specific (hover, focus, open/closed)</li>
                        <li>The state doesn't need to persist when the component unmounts</li>
                        <li>The state isn't needed by sibling components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Good: Local state for accordion
function Accordion({ items }: { items: Item[] }) {
  const [openIndex, setOpenIndex] = useState&lt;number | null&gt;(null);

  return (
    &lt;div&gt;
      {items.map((item, index) => (
        &lt;div key={item.id}&gt;
          &lt;button onClick={() => setOpenIndex(index === openIndex ? null : index)}&gt;
            {item.title}
          &lt;/button&gt;
          {openIndex === index && &lt;div&gt;{item.content}&lt;/div&gt;}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>When to Lift State Up</h3>

                <p>Sometimes state needs to be "lifted up" to a common ancestor so multiple components can access it:</p>

                <div class="mermaid">
                    graph TB
                    A[Parent Component<br/>State Lives Here] --> B[Child A<br/>Reads State]
                    A --> C[Child B<br/>Updates State]
                    A --> D[Child C<br/>Reads State]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                    style D fill:#4CAF50,color:#fff
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Lift State Up When</h4>
                    <ul>
                        <li>Multiple sibling components need the same state</li>
                        <li>One component needs to update state that another component displays</li>
                        <li>Parent needs to coordinate behavior between children</li>
                        <li>State needs to be synchronized across components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Example: Lifting state up
function SearchPage() {
  // State lifted to parent so both children can access it
  const [searchQuery, setSearchQuery] = useState('');
  const [results, setResults] = useState&lt;Result[]&gt;([]);

  return (
    &lt;div&gt;
      {/* Child A updates the state */}
      &lt;SearchBar 
        value={searchQuery} 
        onChange={setSearchQuery}
        onSearch={() => fetchResults(searchQuery).then(setResults)}
      /&gt;
      
      {/* Child B reads the state */}
      &lt;SearchResults 
        query={searchQuery} 
        results={results} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>The Prop Drilling Problem</h3>

                <p>When you lift state too high or need to pass it through many layers of components, you encounter "prop drilling":</p>

                <pre><code class="language-typescript">// ‚ùå Prop drilling problem
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return &lt;Layout user={user} setUser={setUser} /&gt;;
}

function Layout({ user, setUser }: LayoutProps) {
  return (
    &lt;div&gt;
      &lt;Sidebar user={user} setUser={setUser} /&gt;
      &lt;Content user={user} /&gt;
    &lt;/div&gt;
  );
}

function Sidebar({ user, setUser }: SidebarProps) {
  return (
    &lt;nav&gt;
      &lt;UserMenu user={user} setUser={setUser} /&gt;
    &lt;/nav&gt;
  );
}

function UserMenu({ user, setUser }: UserMenuProps) {
  // Finally using it here!
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Problems with prop drilling:</strong></p>
                <ul>
                    <li>Intermediate components need props they don't use (Layout, Sidebar)</li>
                    <li>Hard to refactor‚Äîchanging prop names affects many files</li>
                    <li>Makes component trees rigid and brittle</li>
                    <li>TypeScript types become verbose and repetitive</li>
                </ul>

                <h3>Solutions to Prop Drilling</h3>

                <p>When prop drilling becomes painful, consider these solutions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>When to Use</th>
                            <th>Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Component Composition</strong></td>
                            <td>Layout components, wrapper components</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>Context API</strong></td>
                            <td>Theme, auth, 2-5 globally shared values</td>
                            <td>Low-Medium</td>
                        </tr>
                        <tr>
                            <td><strong>Custom Hooks</strong></td>
                            <td>Shared logic with local state</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>State Library</strong></td>
                            <td>Many global values, complex updates</td>
                            <td>Medium-High</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Component Composition Pattern</h3>

                <p>Often overlooked, component composition can eliminate prop drilling without any state management library:</p>

                <pre><code class="language-typescript">// ‚úÖ Better: Component composition
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return (
    &lt;Layout
      sidebar={&lt;Sidebar userMenu={&lt;UserMenu user={user} setUser={setUser} /&gt;} /&gt;}
      content={&lt;Content user={user} /&gt;}
    /&gt;
  );
}

function Layout({ sidebar, content }: LayoutProps) {
  // No user props needed!
  return (
    &lt;div&gt;
      {sidebar}
      {content}
    &lt;/div&gt;
  );
}

function Sidebar({ userMenu }: SidebarProps) {
  // No user props needed!
  return &lt;nav&gt;{userMenu}&lt;/nav&gt;;
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Decision Tree</h4>
                    <ol>
                        <li><strong>Start:</strong> Keep state in the component that needs it</li>
                        <li><strong>If siblings need it:</strong> Lift to common parent</li>
                        <li><strong>If prop drilling 3+ levels:</strong> Try component composition</li>
                        <li><strong>If composition doesn't help:</strong> Use Context or state library</li>
                    </ol>
                </div>
            </section>

            <!-- Section 4: Common State Management Problems -->
            <section id="section4" class="lesson-section">
                <h2>üö® Common State Management Problems</h2>
                
                <p>As applications grow, certain state management patterns emerge. Recognizing these problems helps you know when it's time to refactor or adopt a different approach.</p>

                <h3>Problem 1: Prop Drilling Hell</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>You're passing props through 4+ levels of components that don't use them, just to get data to deeply nested children.</p>
                </div>

                <p><strong>Signs you have this problem:</strong></p>
                <ul>
                    <li>Components have props they don't use, only pass through</li>
                    <li>Changing a prop name requires editing many files</li>
                    <li>Adding a new prop requires touching many components</li>
                    <li>Component function signatures are getting long and unwieldy</li>
                </ul>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use Context API for truly global data (theme, auth)</li>
                    <li>Apply component composition to avoid prop threading</li>
                    <li>Consider a state management library if you have many such cases</li>
                </ul>

                <h3>Problem 2: Scattered State Updates</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>The same piece of state is being updated in many different places, making it hard to track down bugs.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Cart state updated in many places
function ProductCard({ product }: ProductCardProps) {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = () => {
    setCart([...cart, { ...product, quantity: 1 }]);
  };
  
  return &lt;button onClick={addToCart}&gt;Add to Cart&lt;/button&gt;;
}

function CartButton() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const clearCart = () => {
    setCart([]);
  };
  
  return &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;;
}

// Updates also in CartItem, CheckoutForm, etc...</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Create custom hooks that encapsulate update logic</li>
                    <li>Use useReducer to centralize state updates</li>
                    <li>Use a state library with action creators</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Centralized updates via custom hook
function useCart() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = (product: Product) => {
    setCart(prev => [...prev, { ...product, quantity: 1 }]);
  };
  
  const removeFromCart = (productId: string) => {
    setCart(prev => prev.filter(item => item.id !== productId));
  };
  
  const clearCart = () => {
    setCart([]);
  };
  
  return { cart, addToCart, removeFromCart, clearCart };
}

// Now components only call the hook methods
function ProductCard({ product }: ProductCardProps) {
  const { addToCart } = useCart();
  return &lt;button onClick={() => addToCart(product)}&gt;Add&lt;/button&gt;;
}</code></pre>

                <h3>Problem 3: Stale Closures</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Event handlers or effects are using old values of state, causing unexpected behavior.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Stale closure
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Count:', count); // Always logs 0!
      setCount(count + 1); // Always sets to 1!
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Empty deps = stale closure
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use functional updates: <code>setCount(prev => prev + 1)</code></li>
                    <li>Include dependencies in useEffect array</li>
                    <li>Use useRef for values you want to reference but not trigger re-renders</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Functional update
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => {
        console.log('Count:', prev);
        return prev + 1;
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Now safe with empty deps
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <h3>Problem 4: Race Conditions</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Async operations complete out of order, causing the wrong data to be displayed (e.g., search results for an old query showing up after newer results).</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Race condition
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    fetchResults(query).then(data => {
      setResults(data); // Might be stale!
    });
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use cleanup function to ignore stale responses</li>
                    <li>Use AbortController to cancel old requests</li>
                    <li>Use libraries like React Query that handle this automatically</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Cleanup ignores stale results
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    let ignore = false;
    
    fetchResults(query).then(data => {
      if (!ignore) {
        setResults(data);
      }
    });
    
    return () => {
      ignore = true; // Cleanup: ignore stale response
    };
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <h3>Problem 5: Unnecessary Re-renders</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Components re-render even though the data they display hasn't changed, causing performance problems.</p>
                </div>

                <p><strong>Common causes:</strong></p>
                <ul>
                    <li>Creating new objects/arrays on every render</li>
                    <li>Passing inline functions as props</li>
                    <li>Context value changes on every render</li>
                    <li>Not memoizing expensive computations</li>
                </ul>

                <pre><code class="language-typescript">// ‚ùå Problem: Context re-renders everything
function AppProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [theme, setTheme] = useState('light');
  
  // New object on every render!
  const value = { user, setUser, theme, setTheme };
  
  return (
    &lt;AppContext.Provider value={value}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Every component using this context re-renders when ANY value changes!</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>useMemo to memoize context values</li>
                    <li>Split contexts by concern (UserContext, ThemeContext)</li>
                    <li>Use React.memo for expensive components</li>
                    <li>State management libraries with fine-grained reactivity</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Separate contexts
function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  
  return &lt;UserContext.Provider value={value}&gt;{children}&lt;/UserContext.Provider&gt;;
}

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState('light');
  const value = useMemo(() => ({ theme, setTheme }), [theme]);
  
  return &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;;
}

// Now changing theme doesn't re-render components that only use user!</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When Problems Indicate You Need a Library</h4>
                    <p>If you're experiencing <strong>multiple</strong> of these problems simultaneously, and simple refactoring isn't helping, it's probably time to consider a dedicated state management library.</p>
                </div>
            </section>
            <!-- Section 5: State Management Solutions Landscape -->
            <section id="section5" class="lesson-section">
                <h2>üó∫Ô∏è State Management Solutions Landscape</h2>
                
                <p>The React ecosystem offers numerous state management solutions, each designed to solve different problems. Let's explore the landscape and understand where each tool fits.</p>

                <h3>The State Management Spectrum</h3>

                <div class="mermaid">
                    graph LR
                    A[Built-in React] --> B[Context + Hooks]
                    B --> C[Lightweight Libraries]
                    C --> D[Full-Featured Libraries]
                    D --> E[Server State Libraries]
                    
                    A1[useState<br/>useReducer] -.-> A
                    B1[Context API<br/>Custom Hooks] -.-> B
                    C1[Zustand<br/>Jotai<br/>Valtio] -.-> C
                    D1[Redux Toolkit<br/>MobX<br/>XState] -.-> D
                    E1[React Query<br/>SWR<br/>Apollo] -.-> E
                    
                    style A fill:#667eea,color:#fff
                    style E fill:#4CAF50,color:#fff
                </div>

                <h3>Category 1: Built-in React Solutions</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üì¶ What's Included</h4>
                    <ul style="color: white;">
                        <li><strong>useState:</strong> Local state management</li>
                        <li><strong>useReducer:</strong> Complex local state with actions</li>
                        <li><strong>useContext:</strong> Sharing state without prop drilling</li>
                        <li><strong>useRef:</strong> Mutable values that don't trigger re-renders</li>
                    </ul>
                </div>

                <p><strong>Best for:</strong> Small to medium apps, localized state, simple sharing between components</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Zero dependencies‚Äîbuilt into React</li>
                    <li>‚úÖ Simple API, easy to learn</li>
                    <li>‚úÖ Great TypeScript support</li>
                    <li>‚úÖ Perfect for local component state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Context can cause unnecessary re-renders</li>
                    <li>‚ùå No built-in devtools</li>
                    <li>‚ùå Boilerplate increases with app complexity</li>
                    <li>‚ùå No built-in async handling or middleware</li>
                </ul>

                <h3>Category 2: Lightweight State Libraries</h3>

                <p>These libraries provide global state with minimal boilerplate and excellent performance:</p>

                <h4>Zustand</h4>
                <pre><code class="language-typescript">// Simple, hook-based global state
import create from 'zustand';

interface BearStore {
  bears: number;
  addBear: () => void;
  removeAllBears: () => void;
}

const useStore = create&lt;BearStore&gt;((set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 })
}));

function BearCounter() {
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears} bears&lt;/h1&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Most React applications, simple to moderate state complexity</p>

                <h4>Jotai</h4>
                <pre><code class="language-typescript">// Atomic state management
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() => setCount(c => c + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Bottom-up state architecture, derived state, atomic updates</p>

                <h4>Valtio</h4>
                <pre><code class="language-typescript">// Proxy-based state
import { proxy, useSnapshot } from 'valtio';

const state = proxy({ count: 0 });

function Counter() {
  const snap = useSnapshot(state);
  return (
    &lt;div&gt;
      {snap.count}
      &lt;button onClick={() => state.count++}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Developers who prefer mutable syntax, quick prototyping</p>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Bundle Size</th>
                            <th>Learning Curve</th>
                            <th>Best Feature</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Zustand</strong></td>
                            <td>~1KB</td>
                            <td>Very Low</td>
                            <td>Simplicity + power</td>
                        </tr>
                        <tr>
                            <td><strong>Jotai</strong></td>
                            <td>~3KB</td>
                            <td>Low</td>
                            <td>Atomic architecture</td>
                        </tr>
                        <tr>
                            <td><strong>Valtio</strong></td>
                            <td>~3KB</td>
                            <td>Very Low</td>
                            <td>Mutable syntax</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Category 3: Full-Featured State Libraries</h3>

                <h4>Redux Toolkit (RTK)</h4>

                <p>The modern, official way to write Redux code:</p>

                <pre><code class="language-typescript">// Redux Toolkit slice
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1; // Immer allows "mutation"
    },
    incrementByAmount: (state, action: PayloadAction&lt;number&gt;) => {
      state.value += action.payload;
    }
  }
});

export const { increment, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>

                <p><strong>Best for:</strong> Large enterprise apps, teams familiar with Redux, complex state logic</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Mature ecosystem with lots of resources</li>
                    <li>‚úÖ Excellent DevTools (Redux DevTools)</li>
                    <li>‚úÖ Predictable state updates</li>
                    <li>‚úÖ Great for time-travel debugging</li>
                    <li>‚úÖ RTK Query for server state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Steeper learning curve</li>
                    <li>‚ùå More boilerplate than alternatives</li>
                    <li>‚ùå Larger bundle size (~20KB)</li>
                </ul>

                <h4>MobX</h4>

                <p>Observable-based reactive state management:</p>

                <pre><code class="language-typescript">// MobX store
import { makeAutoObservable } from 'mobx';
import { observer } from 'mobx-react-lite';

class TodoStore {
  todos: string[] = [];

  constructor() {
    makeAutoObservable(this);
  }

  addTodo(todo: string) {
    this.todos.push(todo);
  }
}

const todoStore = new TodoStore();

const TodoList = observer(() => {
  return (
    &lt;ul&gt;
      {todoStore.todos.map((todo, i) => (
        &lt;li key={i}&gt;{todo}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
});</code></pre>

                <p><strong>Best for:</strong> Complex domain models, developers familiar with OOP patterns</p>

                <h4>XState</h4>

                <p>State machine-based state management:</p>

                <pre><code class="language-typescript">// XState machine
import { createMachine } from 'xstate';
import { useMachine } from '@xstate/react';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

function Toggle() {
  const [state, send] = useMachine(toggleMachine);
  
  return (
    &lt;button onClick={() => send('TOGGLE')}&gt;
      {state.value === 'active' ? 'ON' : 'OFF'}
    &lt;/button&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Complex workflows, multi-step processes, state machines</p>

                <h3>Category 4: Server State Libraries</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üåü The Game Changer</h4>
                    <p>Server state libraries revolutionized React development by recognizing that <strong>server data is fundamentally different</strong> from client state and should be managed differently.</p>
                </div>

                <h4>React Query (TanStack Query)</h4>

                <pre><code class="language-typescript">// React Query hooks
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function UserProfile({ userId }: { userId: number }) {
  // Automatic loading, error, caching, refetching
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(r => r.json())
  });

  const queryClient = useQueryClient();

  const updateMutation = useMutation({
    mutationFn: (updates: Partial&lt;User&gt;) => 
      fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        body: JSON.stringify(updates)
      }),
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries(['user', userId]);
    }
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error!&lt;/div&gt;;

  return &lt;div&gt;{data.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Features:</strong></p>
                <ul>
                    <li>‚úÖ Automatic caching and background refetching</li>
                    <li>‚úÖ Request deduplication</li>
                    <li>‚úÖ Optimistic updates</li>
                    <li>‚úÖ Pagination and infinite scroll</li>
                    <li>‚úÖ Built-in loading and error states</li>
                    <li>‚úÖ DevTools for debugging</li>
                </ul>

                <h4>SWR (Stale-While-Revalidate)</h4>

                <pre><code class="language-typescript">// SWR - Similar to React Query, Vercel's solution
import useSWR from 'swr';

function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;
  return &lt;div&gt;Hello {data.name}!&lt;/div&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Simpler API needs, Next.js projects</p>

                <h4>Apollo Client (GraphQL)</h4>

                <p>Specialized for GraphQL APIs:</p>

                <pre><code class="language-typescript">// Apollo Client for GraphQL
import { useQuery, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error!&lt;/p&gt;;

  return data.users.map((user: User) => (
    &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
  ));
}</code></pre>

                <p><strong>Best for:</strong> GraphQL APIs, apps with complex data requirements</p>

                <h3>Solution Selection Matrix</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Your Situation</th>
                            <th>Recommended Solution</th>
                            <th>Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Small app, local state</td>
                            <td>useState + Context</td>
                            <td>No dependencies needed</td>
                        </tr>
                        <tr>
                            <td>Medium app, some global state</td>
                            <td>Zustand or Jotai</td>
                            <td>Simple, performant, small bundle</td>
                        </tr>
                        <tr>
                            <td>Large enterprise app</td>
                            <td>Redux Toolkit</td>
                            <td>Mature, predictable, great DevTools</td>
                        </tr>
                        <tr>
                            <td>Lots of API data</td>
                            <td>React Query + Zustand</td>
                            <td>Separate concerns: server vs client state</td>
                        </tr>
                        <tr>
                            <td>Complex workflows</td>
                            <td>XState</td>
                            <td>State machines model workflows naturally</td>
                        </tr>
                        <tr>
                            <td>GraphQL API</td>
                            <td>Apollo Client</td>
                            <td>Purpose-built for GraphQL</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Modern Best Practice</h4>
                    <p><strong>Hybrid approach:</strong> Use React Query (or SWR) for server state + a lightweight library like Zustand for client state. This separation of concerns is becoming the industry standard.</p>
                </div>
            </section>

            <!-- Section 6: Comparing State Management Libraries -->
            <section id="section6" class="lesson-section">
                <h2>‚öñÔ∏è Comparing State Management Libraries</h2>
                
                <p>Let's dive deeper into how these libraries compare across key dimensions that matter for real-world development.</p>

                <h3>Comparison Dimensions</h3>

                <h4>1. Learning Curve</h4>

                <div class="mermaid">
                    graph LR
                    A[Easy] --> B[Moderate] --> C[Challenging]
                    
                    A1[Zustand<br/>Valtio<br/>SWR] -.-> A
                    B1[Jotai<br/>React Query<br/>Context API] -.-> B
                    C1[Redux Toolkit<br/>MobX<br/>XState] -.-> C
                    
                    style A fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <ul>
                    <li><strong>Easy:</strong> Can be productive within hours</li>
                    <li><strong>Moderate:</strong> Takes a day or two to grasp concepts</li>
                    <li><strong>Challenging:</strong> Requires dedicated learning time, often several days</li>
                </ul>

                <h4>2. Bundle Size Impact</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Minified + Gzipped</th>
                            <th>Impact Rating</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>~1KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>~13KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê Small</td>
                        </tr>
                        <tr>
                            <td>SWR</td>
                            <td>~4KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>~20KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>~16KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>~25KB</td>
                            <td>‚≠ê‚≠ê Larger</td>
                        </tr>
                    </tbody>
                </table>

                <h4>3. TypeScript Support</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Type Safety</th>
                            <th>Type Inference</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Written in TS, zero config</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Best-in-class TS support</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Generics work beautifully</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Atom types inferred</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Good</td>
                            <td>Some manual typing</td>
                            <td>Decorators can be tricky</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>Good</td>
                            <td>Complex typing</td>
                            <td>State machine types are verbose</td>
                        </tr>
                    </tbody>
                </table>

                <h4>4. Developer Experience</h4>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Excellent DX</h4>
                    <p><strong>Zustand, React Query, Jotai</strong></p>
                    <ul>
                        <li>Minimal boilerplate</li>
                        <li>Intuitive APIs</li>
                        <li>Great documentation</li>
                        <li>Fast feedback loop</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è More Setup Required</h4>
                    <p><strong>Redux Toolkit, XState</strong></p>
                    <ul>
                        <li>More concepts to learn</li>
                        <li>More configuration needed</li>
                        <li>Steeper initial learning curve</li>
                        <li>But: Very powerful once mastered</li>
                    </ul>
                </div>

                <h4>5. Performance Characteristics</h4>

                <pre><code class="language-typescript">// Example: Zustand's selector optimization
function BearCounter() {
  // Only re-renders when bears count changes
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears}&lt;/h1&gt;;
}

function AddBearButton() {
  // Only re-renders when addBear function changes (never)
  const addBear = useStore(state => state.addBear);
  return &lt;button onClick={addBear}&gt;Add Bear&lt;/button&gt;;
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Re-render Optimization</th>
                            <th>Approach</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Automatic with selectors</td>
                            <td>Fine-grained subscriptions</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Automatic</td>
                            <td>Atomic state updates</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>Automatic</td>
                            <td>Proxy-based tracking</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Manual with reselect</td>
                            <td>Memoized selectors</td>
                        </tr>
                        <tr>
                            <td>Context API</td>
                            <td>Manual with memo</td>
                            <td>Context splitting</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Automatic</td>
                            <td>Observable tracking</td>
                        </tr>
                    </tbody>
                </table>

                <h4>6. DevTools and Debugging</h4>

                <ul>
                    <li><strong>Redux Toolkit:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Industry-leading Redux DevTools with time travel</li>
                    <li><strong>React Query:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent dedicated DevTools for queries</li>
                    <li><strong>Zustand:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê Redux DevTools compatible</li>
                    <li><strong>MobX:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê MobX DevTools available</li>
                    <li><strong>Jotai:</strong> ‚≠ê‚≠ê‚≠ê React DevTools + debug utilities</li>
                    <li><strong>XState:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Visual state machine inspector</li>
                    <li><strong>Context API:</strong> ‚≠ê‚≠ê React DevTools only</li>
                </ul>

                <h3>When to Choose Each Library</h3>

                <h4>Choose Zustand When:</h4>
                <ul>
                    <li>‚úÖ You want something simple and powerful</li>
                    <li>‚úÖ Bundle size matters</li>
                    <li>‚úÖ You like hook-based APIs</li>
                    <li>‚úÖ You want fine-grained performance control</li>
                    <li>‚úÖ You're building a new app</li>
                </ul>

                <h4>Choose Redux Toolkit When:</h4>
                <ul>
                    <li>‚úÖ You have a large, complex application</li>
                    <li>‚úÖ Multiple teams working on the same codebase</li>
                    <li>‚úÖ You need strict state update patterns</li>
                    <li>‚úÖ Time-travel debugging is valuable</li>
                    <li>‚úÖ Your team already knows Redux</li>
                </ul>

                <h4>Choose React Query When:</h4>
                <ul>
                    <li>‚úÖ Your app is heavily data-driven</li>
                    <li>‚úÖ You fetch a lot of data from APIs</li>
                    <li>‚úÖ You need caching and background refetching</li>
                    <li>‚úÖ You want automatic loading/error states</li>
                    <li>‚úÖ Always (as server state solution)!</li>
                </ul>

                <h4>Choose Jotai When:</h4>
                <ul>
                    <li>‚úÖ You like atomic state architecture</li>
                    <li>‚úÖ You need lots of derived state</li>
                    <li>‚úÖ Bottom-up state design appeals to you</li>
                    <li>‚úÖ You want built-in async atom support</li>
                </ul>

                <h4>Choose XState When:</h4>
                <ul>
                    <li>‚úÖ You have complex workflows or processes</li>
                    <li>‚úÖ State machines model your domain well</li>
                    <li>‚úÖ You need to visualize state transitions</li>
                    <li>‚úÖ You want impossible states to be impossible</li>
                </ul>

                <h4>Choose Context API When:</h4>
                <ul>
                    <li>‚úÖ You have 2-5 global values maximum</li>
                    <li>‚úÖ Updates are infrequent</li>
                    <li>‚úÖ You want zero dependencies</li>
                    <li>‚úÖ Values rarely change (theme, locale, auth)</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ The Winner?</h4>
                    <p style="color: white;">There isn't one! Each library excels in different scenarios. The "best" choice depends on your specific needs:</p>
                    <ul style="color: white;">
                        <li><strong>Most versatile:</strong> Zustand (client state) + React Query (server state)</li>
                        <li><strong>Enterprise standard:</strong> Redux Toolkit</li>
                        <li><strong>Simplest:</strong> Context API + useState</li>
                        <li><strong>Most innovative:</strong> Jotai, XState</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Architectural Patterns -->
            <section id="section7" class="lesson-section">
                <h2>üèõÔ∏è Architectural Patterns</h2>
                
                <p>Beyond choosing a library, how you organize your state and structure your application matters immensely. Let's explore proven architectural patterns.</p>

                <h3>Pattern 1: Feature-Based Organization</h3>

                <p>Organize code by feature rather than by file type:</p>

                <pre><code class="language-plaintext">src/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authStore.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ cart/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ store/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îî‚îÄ‚îÄ App.tsx</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits</h4>
                    <ul>
                        <li>Feature code is colocated‚Äîeasy to find everything related</li>
                        <li>Can delete entire feature folder without hunting across directories</li>
                        <li>Clear boundaries between features</li>
                        <li>Teams can work on different features independently</li>
                    </ul>
                </div>

                <h3>Pattern 2: Separation of Client and Server State</h3>

                <div class="mermaid">
                    graph TB
                    A[Application State] --> B[Client State]
                    A --> C[Server State]
                    
                    B --> B1[UI State: Zustand/Redux]
                    B --> B2[Form State: React Hook Form]
                    B --> B3[URL State: Router]
                    
                    C --> C1[API Data: React Query]
                    C --> C2[Real-time: WebSocket + Query]
                    C --> C3[GraphQL: Apollo Client]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <p><strong>Client State:</strong> Managed by Zustand, Redux, Context</p>
                <ul>
                    <li>Theme preference</li>
                    <li>Sidebar open/closed</li>
                    <li>Current tab selection</li>
                    <li>Modal state</li>
                    <li>Filter selections (before applying)</li>
                </ul>

                <p><strong>Server State:</strong> Managed by React Query, SWR, Apollo</p>
                <ul>
                    <li>User profile data</li>
                    <li>Product lists</li>
                    <li>Search results</li>
                    <li>Dashboard metrics</li>
                    <li>Any data fetched from APIs</li>
                </ul>

                <pre><code class="language-typescript">// Example: Hybrid approach
// Client state: Zustand
const useUIStore = create&lt;UIStore&gt;((set) => ({
  sidebarOpen: true,
  theme: 'light',
  toggleSidebar: () => set(state => ({ sidebarOpen: !state.sidebarOpen })),
  setTheme: (theme) => set({ theme })
}));

// Server state: React Query
function ProductList() {
  const { sidebarOpen } = useUIStore(); // Client state
  
  const { data: products } = useQuery({ // Server state
    queryKey: ['products'],
    queryFn: fetchProducts
  });
  
  return (
    &lt;div className={sidebarOpen ? 'with-sidebar' : 'full-width'}&gt;
      {products?.map(p => &lt;ProductCard key={p.id} product={p} /&gt;)}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 3: Custom Hooks for Business Logic</h3>

                <p>Encapsulate complex logic in custom hooks:</p>

                <pre><code class="language-typescript">// Custom hook pattern
function useCart() {
  const { items, addItem, removeItem, clearCart } = useCartStore();
  const queryClient = useQueryClient();
  
  const addToCart = async (product: Product) => {
    // Business logic
    addItem(product);
    
    // Side effects
    toast.success('Added to cart');
    analytics.track('add_to_cart', { productId: product.id });
  };
  
  const checkout = useMutation({
    mutationFn: async () => {
      const response = await fetch('/api/checkout', {
        method: 'POST',
        body: JSON.stringify({ items })
      });
      return response.json();
    },
    onSuccess: () => {
      clearCart();
      queryClient.invalidateQueries(['orders']);
    }
  });
  
  const total = useMemo(() => 
    items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    [items]
  );
  
  return {
    items,
    total,
    addToCart,
    removeItem,
    clearCart,
    checkout
  };
}

// Components stay clean
function ProductCard({ product }: { product: Product }) {
  const { addToCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;button onClick={() => addToCart(product)}&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 4: Domain-Driven Design</h3>

                <p>Structure state around your business domains:</p>

                <pre><code class="language-typescript">// Domain stores
// User domain
const useUserStore = create&lt;UserStore&gt;(/* ... */);

// Product domain
const useProductStore = create&lt;ProductStore&gt;(/* ... */);

// Order domain
const useOrderStore = create&lt;OrderStore&gt;(/* ... */);

// Each domain is independent
// Domains communicate via actions, not shared state</code></pre>

                <h3>Pattern 5: Normalized State</h3>

                <p>Store data in a normalized format to avoid duplication and keep it consistent:</p>

                <pre><code class="language-typescript">// ‚ùå Denormalized - duplication and inconsistency risk
interface DenormalizedState {
  posts: Array&lt;{
    id: string;
    title: string;
    author: {
      id: string;
      name: string;
      email: string;
    };
    comments: Array&lt;{
      id: string;
      text: string;
      author: {
        id: string;
        name: string;
        email: string;
      };
    }&gt;;
  }&gt;;
}

// ‚úÖ Normalized - single source of truth
interface NormalizedState {
  users: {
    byId: Record&lt;string, User&gt;;
    allIds: string[];
  };
  posts: {
    byId: Record&lt;string, Post&gt;; // Just has authorId
    allIds: string[];
  };
  comments: {
    byId: Record&lt;string, Comment&gt;; // Just has authorId, postId
    allIds: string[];
  };
}

// Selectors can reconstruct the full object
const selectPostWithAuthor = (state: State, postId: string) => {
  const post = state.posts.byId[postId];
  const author = state.users.byId[post.authorId];
  return { ...post, author };
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Normalize</h4>
                    <ul>
                        <li><strong>Do normalize:</strong> When data is shared across features, updated frequently, or duplicated</li>
                        <li><strong>Don't normalize:</strong> Server state (React Query handles it), deeply nested read-only data, or simple apps</li>
                    </ul>
                </div>

                <h3>Pattern 6: Middleware and Side Effects</h3>

                <p>Handle side effects systematically:</p>

                <pre><code class="language-typescript">// Zustand middleware example
const useStore = create&lt;Store&gt;()(
  devtools(
    persist(
      immer((set) => ({
        // Store definition
        count: 0,
        increment: () => set(state => { state.count += 1; }),
        
        // Side effect
        incrementWithLog: () => set(state => {
          console.log('Before:', state.count);
          state.count += 1;
          console.log('After:', state.count);
          
          // Analytics
          analytics.track('count_incremented', { value: state.count });
        })
      })),
      {
        name: 'my-store',
        storage: createJSONStorage(() => localStorage)
      }
    )
  )
);</code></pre>

                <h3>Pattern 7: Optimistic Updates</h3>

                <p>Update UI immediately, rollback if server fails:</p>

                <pre><code class="language-typescript">// Optimistic update with React Query
const mutation = useMutation({
  mutationFn: updateTodo,
  onMutate: async (newTodo) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries(['todos']);
    
    // Snapshot previous value
    const previousTodos = queryClient.getQueryData(['todos']);
    
    // Optimistically update
    queryClient.setQueryData(['todos'], (old: Todo[]) => 
      [...old, newTodo]
    );
    
    // Return context with snapshot
    return { previousTodos };
  },
  onError: (err, newTodo, context) => {
    // Rollback on error
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },
  onSettled: () => {
    // Always refetch after error or success
    queryClient.invalidateQueries(['todos']);
  }
});</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Architecture Principles</h4>
                    <ul style="color: white;">
                        <li><strong>Colocation:</strong> Keep related code together</li>
                        <li><strong>Separation:</strong> Separate client and server state</li>
                        <li><strong>Encapsulation:</strong> Hide complexity in custom hooks</li>
                        <li><strong>Single Responsibility:</strong> Each store/slice does one thing</li>
                        <li><strong>Testability:</strong> Make state logic easy to test in isolation</li>
                    </ul>
                </div>
            </section>
