<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master advanced TypeScript patterns in React including generics, discriminated unions, type guards, and utility types for building robust component libraries.">
    <meta name="author" content="Ray">
    <title>Lesson 10.2: TypeScript Advanced Patterns - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 10: Advanced Topics and Deployment</a></li>
            <li aria-current="page">Lesson 10.2: TypeScript Advanced Patterns</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üé® Lesson 10.2: TypeScript Advanced Patterns</h1>
                <p class="lead">Unlock the full power of TypeScript with advanced patterns for building type-safe, reusable React components. Master generics, discriminated unions, and utility types to create robust component libraries.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Use generics to create flexible, reusable React components</li>
                        <li>Implement discriminated unions for type-safe state management</li>
                        <li>Apply type guards to narrow types safely at runtime</li>
                        <li>Leverage utility types to transform component props</li>
                        <li>Create conditional types for advanced type logic</li>
                        <li>Use template literal types for precise string typing</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a type-safe component library</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Introduction to Advanced TypeScript</a></li>
                        <li><a href="#generics-in-react" class="toc-link">Generics in React Components</a></li>
                        <li><a href="#discriminated-unions" class="toc-link">Discriminated Unions</a></li>
                        <li><a href="#type-guards" class="toc-link">Type Guards and Narrowing</a></li>
                        <li><a href="#utility-types" class="toc-link">Utility Types for Components</a></li>
                        <li><a href="#conditional-types" class="toc-link">Conditional Types</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Introduction to Advanced TypeScript</h2>
                
                <p>You've built amazing React applications with TypeScript, mastering the fundamentals along the way. Now it's time to level up your TypeScript skills with <strong>advanced patterns</strong> that professional developers use to build maintainable, scalable codebases.</p>

                <p>These patterns aren't just about writing "clever" code‚Äîthey're about creating components that are impossible to use incorrectly, catching bugs at compile time instead of runtime, and making your codebase easier to understand and maintain.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Why Advanced TypeScript Matters</h4>
                    <p style="color: white;">Advanced TypeScript patterns help you:</p>
                    <ul style="color: white;">
                        <li><strong>Catch bugs earlier:</strong> Move error detection from runtime to compile time</li>
                        <li><strong>Build reusable components:</strong> Create flexible components that work with any data type</li>
                        <li><strong>Improve developer experience:</strong> Better autocomplete and inline documentation</li>
                        <li><strong>Reduce tests:</strong> Types prove correctness, reducing the need for certain tests</li>
                        <li><strong>Refactor confidently:</strong> Type checker ensures changes don't break code</li>
                    </ul>
                </div>

                <h3>üéØ Real-World Scenario</h3>

                <p>Imagine building a data table component. Without advanced types, you might write:</p>

                <pre><code class="language-typescript">// üò± Weak typing - easy to make mistakes
function DataTable({ data, columns }: any) {
  return (
    &lt;table&gt;
      {/* Implementation */}
    &lt;/table&gt;
  );
}

// Usage - NO type safety!
&lt;DataTable 
  data={users} 
  columns={['name', 'emial']} // Typo! Runtime error
/&gt;</code></pre>

                <p>With advanced TypeScript patterns, you can make this completely type-safe:</p>

                <pre><code class="language-typescript">// ‚úÖ Strong typing - catches errors at compile time
function DataTable&lt;T&gt;({ 
  data, 
  columns 
}: { 
  data: T[]; 
  columns: (keyof T)[] 
}) {
  return (
    &lt;table&gt;
      {/* Implementation */}
    &lt;/table&gt;
  );
}

// Usage - Fully type-safe!
&lt;DataTable 
  data={users} 
  columns={['name', 'emial']} // Error: 'emial' doesn't exist!
/&gt;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Advanced TypeScript Mindset</h4>
                    <p>Think of TypeScript's type system as a <em>proof system</em>. You're not just adding annotations‚Äîyou're <strong>proving to the compiler</strong> that your code is correct. The more precise your types, the more bugs you catch before users see them.</p>
                </div>
            </section>

            <section id="generics-in-react" class="lesson-section">
                <h2>üß¨ Generics in React Components</h2>
                
                <p>Generics are TypeScript's most powerful feature for creating reusable components. They allow you to write components that work with <em>any</em> type while maintaining full type safety.</p>

                <h3>üìö Understanding Generics</h3>

                <p>Think of generics as <strong>type parameters</strong>‚Äîvariables for types instead of values:</p>

                <pre><code class="language-typescript">// Generic function - works with any type
function identity&lt;T&gt;(value: T): T {
  return value;
}

const num = identity(42);        // T is number
const str = identity('hello');   // T is string
const obj = identity({ x: 10 }); // T is { x: number }</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Generic Syntax</h4>
                    <p style="color: white;"><code>&lt;T&gt;</code> declares a type parameter named T. You can use any name, but conventions are:</p>
                    <ul style="color: white;">
                        <li><strong>T</strong> - Generic Type</li>
                        <li><strong>K</strong> - Key type</li>
                        <li><strong>V</strong> - Value type</li>
                        <li><strong>E</strong> - Element type</li>
                        <li><strong>P</strong> - Props type</li>
                    </ul>
                </div>

                <h3>üéØ Generic React Components</h3>

                <p>Let's build practical generic components:</p>

                <h4>Example 1: Generic List Component</h4>

                <pre><code class="language-typescript">// Generic List component - works with any data type
interface ListProps&lt;T&gt; {
  items: T[];
  renderItem: (item: T, index: number) =&gt; React.ReactNode;
  keyExtractor: (item: T) =&gt; string | number;
  emptyMessage?: string;
}

function List&lt;T&gt;({ items, renderItem, keyExtractor, emptyMessage }: ListProps&lt;T&gt;) {
  if (items.length === 0) {
    return &lt;div className="empty"&gt;{emptyMessage || 'No items'}&lt;/div&gt;;
  }
  
  return (
    &lt;div className="list"&gt;
      {items.map((item, index) =&gt; (
        &lt;div key={keyExtractor(item)}&gt;
          {renderItem(item, index)}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Usage with different types
interface User {
  id: number;
  name: string;
  email: string;
}

interface Product {
  id: string;
  title: string;
  price: number;
}

function UserList({ users }: { users: User[] }) {
  return (
    &lt;List
      items={users}
      renderItem={(user) =&gt; ( // user is typed as User!
        &lt;div&gt;
          &lt;h3&gt;{user.name}&lt;/h3&gt;
          &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
      )}
      keyExtractor={(user) =&gt; user.id}
    /&gt;
  );
}

function ProductList({ products }: { products: Product[] }) {
  return (
    &lt;List
      items={products}
      renderItem={(product) =&gt; ( // product is typed as Product!
        &lt;div&gt;
          &lt;h3&gt;{product.title}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
        &lt;/div&gt;
      )}
      keyExtractor={(product) =&gt; product.id}
    /&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Type Inference with Generics</h4>
                    <p>Notice we didn't need to write <code>&lt;List&lt;User&gt;&gt;</code>. TypeScript <strong>inferred</strong> the type parameter from the <code>items</code> prop! This makes the API cleaner while maintaining full type safety.</p>
                </div>

                <h4>Example 2: Generic Select Component</h4>

                <pre><code class="language-typescript">interface SelectOption&lt;T&gt; {
  value: T;
  label: string;
  disabled?: boolean;
}

interface SelectProps&lt;T&gt; {
  options: SelectOption&lt;T&gt;[];
  value: T;
  onChange: (value: T) =&gt; void;
  placeholder?: string;
}

function Select&lt;T extends string | number&gt;({
  options,
  value,
  onChange,
  placeholder
}: SelectProps&lt;T&gt;) {
  return (
    &lt;select
      value={value as string | number}
      onChange={(e) =&gt; {
        const newValue = options.find(
          opt =&gt; String(opt.value) === e.target.value
        )?.value;
        if (newValue !== undefined) {
          onChange(newValue);
        }
      }}
    &gt;
      {placeholder &amp;&amp; (
        &lt;option value="" disabled&gt;
          {placeholder}
        &lt;/option&gt;
      )}
      {options.map((option) =&gt; (
        &lt;option
          key={String(option.value)}
          value={option.value as string | number}
          disabled={option.disabled}
        &gt;
          {option.label}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
}

// Usage with string values
type UserRole = 'admin' | 'editor' | 'viewer';

function RoleSelector() {
  const [role, setRole] = useState&lt;UserRole&gt;('viewer');
  
  return (
    &lt;Select
      options={[
        { value: 'admin', label: 'Administrator' },
        { value: 'editor', label: 'Editor' },
        { value: 'viewer', label: 'Viewer' }
      ]}
      value={role}
      onChange={setRole} // Fully typed!
    /&gt;
  );
}

// Usage with number values
function PrioritySelector() {
  const [priority, setPriority] = useState(1);
  
  return (
    &lt;Select
      options={[
        { value: 1, label: 'Low' },
        { value: 2, label: 'Medium' },
        { value: 3, label: 'High' }
      ]}
      value={priority}
      onChange={setPriority} // Also fully typed!
    /&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Generic Constraints</h4>
                    <p>Notice <code>&lt;T extends string | number&gt;</code>? This is a <strong>generic constraint</strong>. It says "T can be any type, but it must be either string or number." This prevents using the Select with invalid types like objects or arrays.</p>
                </div>

                <h4>Example 3: Generic Data Fetching Hook</h4>

                <pre><code class="language-typescript">interface UseDataOptions&lt;T&gt; {
  url: string;
  transform?: (data: unknown) =&gt; T;
}

interface UseDataResult&lt;T&gt; {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () =&gt; Promise&lt;void&gt;;
}

function useData&lt;T&gt;({ url, transform }: UseDataOptions&lt;T&gt;): UseDataResult&lt;T&gt; {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  const fetchData = useCallback(async () =&gt; {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const json = await response.json();
      const transformedData = transform ? transform(json) : json as T;
      
      setData(transformedData);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setLoading(false);
    }
  }, [url, transform]);
  
  useEffect(() =&gt; {
    fetchData();
  }, [fetchData]);
  
  return { data, loading, error, refetch: fetchData };
}

// Usage with different types
interface User {
  id: number;
  name: string;
  email: string;
}

interface Post {
  id: number;
  title: string;
  body: string;
  userId: number;
}

function UserProfile({ userId }: { userId: number }) {
  const { data: user, loading, error } = useData&lt;User&gt;({
    url: `/api/users/${userId}`
  });
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  if (!user) return &lt;div&gt;No user found&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h1&gt;{user.name}&lt;/h1&gt; {/* Fully typed! */}
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function PostList() {
  const { data: posts, loading } = useData&lt;Post[]&gt;({
    url: '/api/posts'
  });
  
  if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!posts) return &lt;div&gt;No posts&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      {posts.map(post =&gt; ( // post is typed as Post!
        &lt;article key={post.id}&gt;
          &lt;h2&gt;{post.title}&lt;/h2&gt;
          &lt;p&gt;{post.body}&lt;/p&gt;
        &lt;/article&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When to Use Generics</h4>
                    <p>Use generics when:</p>
                    <ul>
                        <li>The component works with multiple data types</li>
                        <li>You want to maintain type information through the component</li>
                        <li>You're building reusable library components</li>
                    </ul>
                    <p><strong>Don't use</strong> generics when:</p>
                    <ul>
                        <li>The component only works with one specific type</li>
                        <li>It makes the code harder to understand</li>
                        <li>Simple prop types would suffice</li>
                    </ul>
                </div>

                <h3>üéØ Multiple Type Parameters</h3>

                <p>Sometimes you need more than one type parameter:</p>

                <pre><code class="language-typescript">// Generic Map component with key and value types
interface MapProps&lt;K, V&gt; {
  items: Map&lt;K, V&gt;;
  renderKey: (key: K) =&gt; React.ReactNode;
  renderValue: (value: V) =&gt; React.ReactNode;
}

function MapDisplay&lt;K, V&gt;({ items, renderKey, renderValue }: MapProps&lt;K, V&gt;) {
  return (
    &lt;div&gt;
      {Array.from(items.entries()).map(([key, value]) =&gt; (
        &lt;div key={String(key)} className="map-item"&gt;
          &lt;div className="key"&gt;{renderKey(key)}&lt;/div&gt;
          &lt;div className="value"&gt;{renderValue(value)}&lt;/div&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Usage
function SettingsDisplay() {
  const settings = new Map&lt;string, boolean&gt;([
    ['darkMode', true],
    ['notifications', false],
    ['autoSave', true]
  ]);
  
  return (
    &lt;MapDisplay
      items={settings}
      renderKey={(key) =&gt; &lt;strong&gt;{key}&lt;/strong&gt;}
      renderValue={(value) =&gt; &lt;span&gt;{value ? 'On' : 'Off'}&lt;/span&gt;}
    /&gt;
  );
}</code></pre>

                <div class="mermaid">
graph LR
    A[Component with Generics] --> B[Type Parameter T]
    B --> C[Props use T]
    B --> D[State uses T]
    B --> E[Return type uses T]
    
    C --> F[Full Type Safety]
    D --> F
    E --> F
    
    F --> G[Autocomplete]
    F --> H[Error Detection]
    F --> I[Refactoring Support]
    
    style A fill:#667eea,color:#fff
    style F fill:#c8e6c9
    style G fill:#e8f5e9
    style H fill:#e8f5e9
    style I fill:#e8f5e9
                </div>
            </section>

            <section id="discriminated-unions" class="lesson-section">
                <h2>üîÄ Discriminated Unions</h2>
                
                <p>Discriminated unions (also called tagged unions) are one of TypeScript's most powerful features for modeling data that can be in different states. They're perfect for state machines, API responses, and form states.</p>

                <h3>üìö What Are Discriminated Unions?</h3>

                <p>A discriminated union is a union type where each member has a common property (the "discriminant") with a literal type:</p>

                <pre><code class="language-typescript">// Each type has a 'type' discriminant with a literal value
type Success = {
  type: 'success';
  data: string;
};

type Error = {
  type: 'error';
  message: string;
};

type Loading = {
  type: 'loading';
};

// Union of all possible states
type ApiState = Success | Error | Loading;

// TypeScript can narrow the type based on the discriminant!
function handleState(state: ApiState) {
  switch (state.type) {
    case 'success':
      // TypeScript knows this is Success
      console.log(state.data); // ‚úÖ OK
      break;
    case 'error':
      // TypeScript knows this is Error
      console.log(state.message); // ‚úÖ OK
      break;
    case 'loading':
      // TypeScript knows this is Loading
      console.log('Loading...'); // ‚úÖ OK
      break;
  }
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Why Discriminated Unions?</h4>
                    <p style="color: white;">Discriminated unions provide:</p>
                    <ul style="color: white;">
                        <li><strong>Exhaustive checking:</strong> TypeScript ensures you handle all cases</li>
                        <li><strong>Type narrowing:</strong> Automatic type inference in each branch</li>
                        <li><strong>Impossible states:</strong> Prevent invalid state combinations</li>
                        <li><strong>Self-documenting:</strong> The types show all possible states</li>
                    </ul>
                </div>

                <h3>üéØ Practical Example: Async Data States</h3>

                <pre><code class="language-typescript">// üò± Bad: Multiple booleans = impossible states
interface BadAsyncState&lt;T&gt; {
  data: T | null;
  loading: boolean;
  error: Error | null;
  // Problem: Can be loading AND have error AND have data!
}

// ‚úÖ Good: Discriminated union = impossible to have invalid state
type AsyncState&lt;T&gt; =
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: T }
  | { status: 'error'; error: Error };

// Component using discriminated union
interface DataDisplayProps&lt;T&gt; {
  state: AsyncState&lt;T&gt;;
  renderData: (data: T) =&gt; React.ReactNode;
}

function DataDisplay&lt;T&gt;({ state, renderData }: DataDisplayProps&lt;T&gt;) {
  switch (state.status) {
    case 'idle':
      return &lt;div&gt;Click fetch to load data&lt;/div&gt;;
    
    case 'loading':
      return &lt;div&gt;Loading...&lt;/div&gt;;
    
    case 'success':
      // TypeScript knows state.data exists here!
      return &lt;div&gt;{renderData(state.data)}&lt;/div&gt;;
    
    case 'error':
      // TypeScript knows state.error exists here!
      return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;
    
    default:
      // Exhaustiveness check - TypeScript errors if we miss a case
      const _exhaustive: never = state;
      return _exhaustive;
  }
}

// Usage
function UserProfile() {
  const [state, setState] = useState&lt;AsyncState&lt;User&gt;&gt;({ status: 'idle' });
  
  const fetchUser = async () =&gt; {
    setState({ status: 'loading' });
    
    try {
      const response = await fetch('/api/user');
      const data = await response.json();
      setState({ status: 'success', data });
    } catch (error) {
      setState({ 
        status: 'error', 
        error: error instanceof Error ? error : new Error('Unknown error')
      });
    }
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={fetchUser}&gt;Fetch User&lt;/button&gt;
      &lt;DataDisplay
        state={state}
        renderData={(user) =&gt; (
          &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
          &lt;/div&gt;
        )}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Never Type Trick</h4>
                    <p>The <code>const _exhaustive: never = state;</code> line is a TypeScript trick for exhaustiveness checking. If you forget to handle a case, TypeScript will error because that case can't be assigned to <code>never</code>. This ensures you handle all possible states!</p>
                </div>

                <h3>üéØ Practical Example: Form States</h3>

                <pre><code class="language-typescript">// Model all possible form states
type FormState&lt;T&gt; =
  | { status: 'editing'; values: Partial&lt;T&gt;; errors: Partial&lt;Record&lt;keyof T, string&gt;&gt; }
  | { status: 'submitting'; values: T }
  | { status: 'success'; submittedValues: T }
  | { status: 'failed'; values: T; error: string };

interface LoginForm {
  email: string;
  password: string;
}

function LoginComponent() {
  const [formState, setFormState] = useState&lt;FormState&lt;LoginForm&gt;&gt;({
    status: 'editing',
    values: {},
    errors: {}
  });
  
  const handleSubmit = async (values: LoginForm) =&gt; {
    setFormState({ status: 'submitting', values });
    
    try {
      await loginUser(values);
      setFormState({ status: 'success', submittedValues: values });
    } catch (error) {
      setFormState({
        status: 'failed',
        values,
        error: error instanceof Error ? error.message : 'Login failed'
      });
    }
  };
  
  // Render based on state
  switch (formState.status) {
    case 'editing':
      return (
        &lt;form onSubmit={(e) =&gt; {
          e.preventDefault();
          if (isValid(formState.values)) {
            handleSubmit(formState.values as LoginForm);
          }
        }}&gt;
          {/* Form fields with errors from formState.errors */}
        &lt;/form&gt;
      );
    
    case 'submitting':
      return &lt;div&gt;Logging in...&lt;/div&gt;;
    
    case 'success':
      return &lt;div&gt;Welcome, {formState.submittedValues.email}!&lt;/div&gt;;
    
    case 'failed':
      return (
        &lt;div&gt;
          &lt;div className="error"&gt;{formState.error}&lt;/div&gt;
          &lt;button onClick={() =&gt; setFormState({
            status: 'editing',
            values: formState.values,
            errors: {}
          })}&gt;
            Try Again
          &lt;/button&gt;
        &lt;/div&gt;
      );
  }
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of This Pattern</h4>
                    <ul>
                        <li>Impossible to be "submitting" and "editing" at the same time</li>
                        <li>Can't access <code>error</code> unless status is 'failed'</li>
                        <li>Clear state transitions</li>
                        <li>Easy to add new states without breaking existing code</li>
                    </ul>
                </div>
            </section>

            <section id="type-guards" class="lesson-section">
                <h2>üõ°Ô∏è Type Guards and Narrowing</h2>
                
                <p>Type guards are functions or expressions that perform runtime checks to narrow types. They bridge the gap between compile-time types and runtime values, making your code safer and more expressive.</p>

                <h3>üìö What Are Type Guards?</h3>

                <p>Type guards tell TypeScript to narrow a broad type to a more specific type based on a runtime check:</p>

                <pre><code class="language-typescript">// Without type guard - TypeScript doesn't know the specific type
function processValue(value: string | number) {
  // Error: Property 'toFixed' does not exist on type 'string | number'
  console.log(value.toFixed(2));
}

// With type guard - TypeScript narrows the type
function processValue(value: string | number) {
  if (typeof value === 'number') {
    // TypeScript knows value is number here
    console.log(value.toFixed(2)); // ‚úÖ OK
  } else {
    // TypeScript knows value is string here
    console.log(value.toUpperCase()); // ‚úÖ OK
  }
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Built-in Type Guards</h4>
                    <p style="color: white;">TypeScript has several built-in type guards:</p>
                    <ul style="color: white;">
                        <li><strong>typeof</strong> - For primitive types (string, number, boolean, etc.)</li>
                        <li><strong>instanceof</strong> - For class instances</li>
                        <li><strong>in</strong> - For checking if a property exists</li>
                        <li><strong>Array.isArray()</strong> - For arrays</li>
                    </ul>
                </div>

                <h3>üéØ Using typeof</h3>

                <pre><code class="language-typescript">function formatValue(value: string | number | boolean): string {
  if (typeof value === 'string') {
    return value.toUpperCase();
  } else if (typeof value === 'number') {
    return value.toFixed(2);
  } else {
    return value ? 'Yes' : 'No';
  }
}

// React component example
interface TextOrNumberProps {
  value: string | number;
  prefix?: string;
}

function DisplayValue({ value, prefix }: TextOrNumberProps) {
  return (
    <div>
      {prefix && <span>{prefix}: </span>}
      {typeof value === 'number' ? (
        <strong>{value.toLocaleString()}</strong>
      ) : (
        <span>{value}</span>
      )}
    </div>
  );
}</code></pre>

                <h3>üéØ Using instanceof</h3>

                <pre><code class="language-typescript">class ApiError extends Error {
  constructor(
    message: string,
    public statusCode: number,
    public endpoint: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

class ValidationError extends Error {
  constructor(
    message: string,
    public field: string
  ) {
    super(message);
    this.name = 'ValidationError';
  }
}

// Type guard with instanceof
function ErrorDisplay({ error }: { error: Error }) {
  if (error instanceof ApiError) {
    // TypeScript knows error is ApiError here
    return (
      <div className="api-error">
        <h3>API Error ({error.statusCode})</h3>
        <p>{error.message}</p>
        <small>Endpoint: {error.endpoint}</small>
      </div>
    );
  }
  
  if (error instanceof ValidationError) {
    // TypeScript knows error is ValidationError here
    return (
      <div className="validation-error">
        <h3>Validation Error</h3>
        <p>{error.message}</p>
        <small>Field: {error.field}</small>
      </div>
    );
  }
  
  // Generic error
  return (
    <div className="error">
      <h3>Error</h3>
      <p>{error.message}</p>
    </div>
  );
}</code></pre>

                <h3>üéØ Using the 'in' Operator</h3>

                <pre><code class="language-typescript">interface Bird {
  type: 'bird';
  wingspan: number;
  fly: () => void;
}

interface Fish {
  type: 'fish';
  swimSpeed: number;
  swim: () => void;
}

type Animal = Bird | Fish;

// Type guard using 'in' operator
function moveAnimal(animal: Animal) {
  if ('fly' in animal) {
    // TypeScript knows animal is Bird
    animal.fly();
    console.log(`Wingspan: ${animal.wingspan}m`);
  } else {
    // TypeScript knows animal is Fish
    animal.swim();
    console.log(`Swim speed: ${animal.swimSpeed}km/h`);
  }
}

// React component example
function AnimalCard({ animal }: { animal: Animal }) {
  return (
    <div className="animal-card">
      {'fly' in animal ? (
        <div>
          <h3>üê¶ Bird</h3>
          <p>Wingspan: {animal.wingspan}m</p>
          <button onClick={animal.fly}>Make it fly!</button>
        </div>
      ) : (
        <div>
          <h3>üêü Fish</h3>
          <p>Speed: {animal.swimSpeed}km/h</p>
          <button onClick={animal.swim}>Make it swim!</button>
        </div>
      )}
    </div>
  );
}</code></pre>

                <h3>üéØ Custom Type Guard Functions</h3>

                <p>For complex types, create custom type guard functions using type predicates:</p>

                <pre><code class="language-typescript">interface User {
  type: 'user';
  id: number;
  name: string;
  email: string;
}

interface Guest {
  type: 'guest';
  sessionId: string;
}

type Visitor = User | Guest;

// Custom type guard with type predicate
function isUser(visitor: Visitor): visitor is User {
  return visitor.type === 'user';
}

function isGuest(visitor: Visitor): visitor is Guest {
  return visitor.type === 'guest';
}

// Usage in component
function VisitorGreeting({ visitor }: { visitor: Visitor }) {
  if (isUser(visitor)) {
    // TypeScript knows visitor is User
    return (
      <div>
        <h2>Welcome back, {visitor.name}!</h2>
        <p>Email: {visitor.email}</p>
      </div>
    );
  }
  
  if (isGuest(visitor)) {
    // TypeScript knows visitor is Guest
    return (
      <div>
        <h2>Welcome, Guest!</h2>
        <p>Session: {visitor.sessionId}</p>
        <button>Sign Up</button>
      </div>
    );
  }
  
  // Exhaustiveness check
  const _exhaustive: never = visitor;
  return _exhaustive;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Type Predicate Syntax</h4>
                    <p>The <code>visitor is User</code> syntax is a <strong>type predicate</strong>. It tells TypeScript: "If this function returns true, then the parameter is of type User." This is more powerful than just returning boolean because it affects TypeScript's type narrowing.</p>
                </div>

                <h3>üéØ Advanced: Type Guards with Generics</h3>

                <pre><code class="language-typescript">// Generic type guard for checking if value is defined
function isDefined&lt;T&gt;(value: T | undefined | null): value is T {
  return value !== undefined && value !== null;
}

// Usage
const values = [1, 2, undefined, 4, null, 6];
const definedValues = values.filter(isDefined); // Type: number[]

// Generic type guard for arrays
function isArrayOf&lt;T&gt;(
  value: unknown,
  itemGuard: (item: unknown) => item is T
): value is T[] {
  return Array.isArray(value) && value.every(itemGuard);
}

// Type guard for string
function isString(value: unknown): value is string {
  return typeof value === 'string';
}

// Type guard for number
function isNumber(value: unknown): value is number {
  return typeof value === 'number';
}

// Usage
function processData(data: unknown) {
  if (isArrayOf(data, isString)) {
    // TypeScript knows data is string[]
    data.forEach(str => console.log(str.toUpperCase()));
  } else if (isArrayOf(data, isNumber)) {
    // TypeScript knows data is number[]
    const sum = data.reduce((a, b) => a + b, 0);
    console.log('Sum:', sum);
  }
}</code></pre>

                <h3>üéØ Assertion Functions</h3>

                <p>Assertion functions throw errors if a condition isn't met, and TypeScript narrows types accordingly:</p>

                <pre><code class="language-typescript">// Assertion function
function assertIsUser(visitor: Visitor): asserts visitor is User {
  if (visitor.type !== 'user') {
    throw new Error('Visitor is not a user');
  }
}

function sendEmailToUser(visitor: Visitor) {
  assertIsUser(visitor);
  // After this line, TypeScript knows visitor is User
  sendEmail(visitor.email); // ‚úÖ OK - no type guard needed!
}

// Generic assertion function
function assertIsDefined&lt;T&gt;(value: T | undefined | null): asserts value is T {
  if (value === undefined || value === null) {
    throw new Error('Value is not defined');
  }
}

// Usage in React
function UserProfile({ userId }: { userId: number }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]);
  
  // Instead of optional chaining everywhere...
  try {
    assertIsDefined(user);
    // Now TypeScript knows user is User (not null)
    
    return (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    );
  } catch {
    return <div>Loading...</div>;
  }
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Type Guards Best Practices</h4>
                    <ul>
                        <li>Use built-in type guards (typeof, instanceof, in) when possible</li>
                        <li>Create custom type guards for complex domain types</li>
                        <li>Name type guard functions clearly: <code>isUser</code>, <code>hasProperty</code></li>
                        <li>Combine type guards with discriminated unions for exhaustive checks</li>
                        <li>Use assertion functions when you're certain about the type</li>
                    </ul>
                </div>
            </section>

            <section id="utility-types" class="lesson-section">
                <h2>üîß Utility Types for Components</h2>
                
                <p>TypeScript provides powerful utility types that transform existing types. These are essential for building flexible React components without duplicating type definitions.</p>

                <h3>üìö Built-in Utility Types</h3>

                <div class="mermaid">
graph TD
    A[Utility Types] --> B[Partial&lt;T&gt;]
    A --> C[Required&lt;T&gt;]
    A --> D[Readonly&lt;T&gt;]
    A --> E[Pick&lt;T, K&gt;]
    A --> F[Omit&lt;T, K&gt;]
    A --> G[Record&lt;K, T&gt;]
    A --> H[Extract&lt;T, U&gt;]
    A --> I[Exclude&lt;T, U&gt;]
    
    B --> B1[Makes all properties optional]
    C --> C1[Makes all properties required]
    D --> D1[Makes all properties readonly]
    E --> E1[Picks specific properties]
    F --> F1[Omits specific properties]
    G --> G1[Creates object type with keys]
    H --> H1[Extracts from union]
    I --> I1[Excludes from union]
    
    style A fill:#667eea,color:#fff
    style B fill:#c8e6c9
    style C fill:#c8e6c9
    style D fill:#c8e6c9
    style E fill:#c8e6c9
    style F fill:#c8e6c9
    style G fill:#c8e6c9
    style H fill:#c8e6c9
    style I fill:#c8e6c9
                </div>

                <h3>üéØ Partial&lt;T&gt; - Make All Properties Optional</h3>

                <pre><code class="language-typescript">interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// Partial makes all properties optional
type UserUpdate = Partial&lt;User&gt;;
// Equivalent to:
// {
//   id?: number;
//   name?: string;
//   email?: string;
//   age?: number;
// }

// Practical use: Update functions
function updateUser(id: number, updates: Partial&lt;User&gt;) {
  // Can update any subset of properties
  return fetch(`/api/users/${id}`, {
    method: 'PATCH',
    body: JSON.stringify(updates)
  });
}

// Usage
updateUser(1, { name: 'John' }); // ‚úÖ OK
updateUser(1, { email: 'john@example.com', age: 30 }); // ‚úÖ OK
updateUser(1, { invalid: 'field' }); // ‚ùå Error

// React component with partial props for editing
interface UserFormProps {
  initialValues?: Partial&lt;User&gt;;
  onSubmit: (user: User) =&gt; void;
}

function UserForm({ initialValues = {}, onSubmit }: UserFormProps) {
  const [formData, setFormData] = useState&lt;Partial&lt;User&gt;&gt;(initialValues);
  
  // Form implementation...
  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      if (isValidUser(formData)) {
        onSubmit(formData as User);
      }
    }}>
      {/* Form fields */}
    </form>
  );
}</code></pre>

                <h3>üéØ Required&lt;T&gt; - Make All Properties Required</h3>

                <pre><code class="language-typescript">interface Config {
  apiUrl?: string;
  timeout?: number;
  retries?: number;
}

// Required makes all properties required
type RequiredConfig = Required&lt;Config&gt;;
// Equivalent to:
// {
//   apiUrl: string;
//   timeout: number;
//   retries: number;
// }

// Practical use: Ensure config is complete
function validateConfig(config: Config): config is Required&lt;Config&gt; {
  return config.apiUrl !== undefined 
    && config.timeout !== undefined 
    && config.retries !== undefined;
}

function initializeApp(config: Config) {
  if (!validateConfig(config)) {
    throw new Error('Incomplete configuration');
  }
  
  // TypeScript knows all properties are defined
  console.log(config.apiUrl.toUpperCase()); // ‚úÖ OK
  console.log(config.timeout * 2); // ‚úÖ OK
}</code></pre>

                <h3>üéØ Readonly&lt;T&gt; - Make All Properties Readonly</h3>

                <pre><code class="language-typescript">interface Point {
  x: number;
  y: number;
}

type ImmutablePoint = Readonly&lt;Point&gt;;
// Equivalent to:
// {
//   readonly x: number;
//   readonly y: number;
// }

// Practical use: Immutable props
interface ChartProps {
  data: Readonly&lt;DataPoint[]&gt;;
  config: Readonly&lt;ChartConfig&gt;;
}

function Chart({ data, config }: ChartProps) {
  // Cannot modify props
  // data.push(newPoint); // ‚ùå Error
  // config.title = 'New Title'; // ‚ùå Error
  
  return <div>{/* Chart rendering */}</div>;
}</code></pre>

                <h3>üéØ Pick&lt;T, K&gt; - Select Specific Properties</h3>

                <pre><code class="language-typescript">interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  age: number;
  address: string;
}

// Pick only the properties we want
type UserPublicInfo = Pick&lt;User, 'id' | 'name' | 'email'&gt;;
// Equivalent to:
// {
//   id: number;
//   name: string;
//   email: string;
// }

// Practical use: API responses
function getUserPublicProfile(userId: number): Promise&lt;UserPublicInfo&gt; {
  return fetch(`/api/users/${userId}/public`)
    .then(r => r.json());
}

// Component showing only public info
function UserCard({ user }: { user: UserPublicInfo }) {
  return (
    <div className="user-card">
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      {/* No access to password or address - they don't exist! */}
    </div>
  );
}</code></pre>

                <h3>üéØ Omit&lt;T, K&gt; - Remove Specific Properties</h3>

                <pre><code class="language-typescript">interface User {
  id: number;
  name: string;
  email: string;
  password: string;
}

// Omit sensitive properties
type UserWithoutPassword = Omit&lt;User, 'password'&gt;;
// Equivalent to:
// {
//   id: number;
//   name: string;
//   email: string;
// }

// Practical use: Form inputs (exclude auto-generated fields)
type UserFormData = Omit&lt;User, 'id' | 'createdAt' | 'updatedAt'&gt;;

interface UserFormProps {
  initialValues?: Partial&lt;UserFormData&gt;;
  onSubmit: (data: UserFormData) =&gt; void;
}

// Omit for extending component props
interface ButtonProps {
  variant: 'primary' | 'secondary';
  size: 'small' | 'medium' | 'large';
  onClick: () => void;
}

// Create LinkButton that uses 'href' instead of 'onClick'
type LinkButtonProps = Omit&lt;ButtonProps, 'onClick'&gt; & {
  href: string;
};

function LinkButton({ href, variant, size }: LinkButtonProps) {
  return (
    <a href={href} className={`btn btn-${variant} btn-${size}`}>
      {/* Button content */}
    </a>
  );
}</code></pre>

                <h3>üéØ Record&lt;K, T&gt; - Create Object Type</h3>

                <pre><code class="language-typescript">// Create an object type with specific keys and value type
type UserRole = 'admin' | 'editor' | 'viewer';

type RolePermissions = Record&lt;UserRole, string[]&gt;;
// Equivalent to:
// {
//   admin: string[];
//   editor: string[];
//   viewer: string[];
// }

const permissions: RolePermissions = {
  admin: ['read', 'write', 'delete', 'manage'],
  editor: ['read', 'write'],
  viewer: ['read']
};

// Practical use: State by ID
type EntityById&lt;T&gt; = Record&lt;string, T&gt;;

interface Product {
  id: string;
  name: string;
  price: number;
}

const products: EntityById&lt;Product&gt; = {
  'prod-1': { id: 'prod-1', name: 'Widget', price: 10 },
  'prod-2': { id: 'prod-2', name: 'Gadget', price: 20 }
};

// Component displaying permissions
function PermissionsTable() {
  return (
    <table>
      <thead>
        <tr>
          <th>Role</th>
          <th>Permissions</th>
        </tr>
      </thead>
      <tbody>
        {Object.entries(permissions).map(([role, perms]) => (
          <tr key={role}>
            <td>{role}</td>
            <td>{perms.join(', ')}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
}</code></pre>

                <h3>üéØ Extract&lt;T, U&gt; and Exclude&lt;T, U&gt; - Union Operations</h3>

                <pre><code class="language-typescript">type Status = 'idle' | 'loading' | 'success' | 'error';

// Extract only specific types from union
type SuccessStatus = Extract&lt;Status, 'success'&gt;; // 'success'
type ActiveStatus = Extract&lt;Status, 'loading' | 'success'&gt;; // 'loading' | 'success'

// Exclude specific types from union
type NonErrorStatus = Exclude&lt;Status, 'error'&gt;; // 'idle' | 'loading' | 'success'

// Practical use: Component with restricted props
type ButtonVariant = 'primary' | 'secondary' | 'danger' | 'ghost';

// Only allow safe variants for certain contexts
type SafeButtonVariant = Exclude&lt;ButtonVariant, 'danger'&gt;;

interface SafeButtonProps {
  variant: SafeButtonVariant;
  onClick: () => void;
}

function SafeButton({ variant, onClick }: SafeButtonProps) {
  return (
    <button className={`btn-${variant}`} onClick={onClick}>
      Click me
    </button>
  );
}

// Usage
<SafeButton variant="primary" onClick={handler} /> // ‚úÖ OK
<SafeButton variant="danger" onClick={handler} /> // ‚ùå Error</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Utility Types Best Practices</h4>
                    <ul>
                        <li>Use <code>Partial</code> for optional updates and form data</li>
                        <li>Use <code>Omit</code> when extending component props</li>
                        <li>Use <code>Pick</code> for API response types</li>
                        <li>Use <code>Record</code> for lookup tables and dictionaries</li>
                        <li>Combine utility types: <code>Readonly&lt;Partial&lt;User&gt;&gt;</code></li>
                        <li>Create type aliases for reusable combinations</li>
                    </ul>
                </div>

                <h3>üéØ Combining Utility Types</h3>

                <pre><code class="language-typescript">interface User {
  id: number;
  name: string;
  email: string;
  password: string;
  age: number;
}

// Combine multiple utility types
type UserUpdatePayload = Partial&lt;Omit&lt;User, 'id'&gt;&gt;;
// Allows updating any field except 'id', all fields optional

type ReadonlyUser = Readonly&lt;User&gt;;
// All fields readonly

type PublicUserInfo = Readonly&lt;Pick&lt;User, 'id' | 'name'&gt;&gt;;
// Only id and name, both readonly

// Real-world example
interface ApiResponse&lt;T&gt; {
  data: T;
  status: number;
  timestamp: number;
}

type UserResponse = ApiResponse&lt;Readonly&lt;Omit&lt;User, 'password'&gt;&gt;&gt;;
// User data without password, made readonly</code></pre>
            </section>

            <section id="conditional-types" class="lesson-section">
                <h2>üîÄ Conditional Types</h2>
                
                <p>Conditional types allow you to create types that depend on a condition‚Äîlike an if statement for types. They enable incredibly powerful type transformations and are the foundation of many advanced TypeScript patterns.</p>

                <h3>üìö Conditional Type Syntax</h3>

                <p>The syntax is: <code>T extends U ? X : Y</code></p>

                <pre><code class="language-typescript">// Basic conditional type
type IsString&lt;T&gt; = T extends string ? 'yes' : 'no';

type A = IsString&lt;string&gt;;  // 'yes'
type B = IsString&lt;number&gt;;  // 'no'
type C = IsString&lt;boolean&gt;; // 'no'

// Conditional type that returns different types
type ArrayOrSingle&lt;T&gt; = T extends any[] ? T[number] : T;

type D = ArrayOrSingle&lt;string[]&gt;;  // string
type E = ArrayOrSingle&lt;number&gt;;    // number
type F = ArrayOrSingle&lt;boolean[]&gt;; // boolean</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ How Conditional Types Work</h4>
                    <p style="color: white;">Think of conditional types as:</p>
                    <ul style="color: white;">
                        <li><strong>T extends U</strong> - "Can T be assigned to U?"</li>
                        <li><strong>? X</strong> - "If yes, the type is X"</li>
                        <li><strong>: Y</strong> - "If no, the type is Y"</li>
                    </ul>
                </div>

                <h3>üéØ Practical Example: Function Overload Replacement</h3>

                <pre><code class="language-typescript">// Without conditional types - need overloads
function process(value: string): string;
function process(value: number): number;
function process(value: boolean): string;
function process(value: string | number | boolean): string | number {
  if (typeof value === 'string') return value.toUpperCase();
  if (typeof value === 'number') return value * 2;
  return value ? 'true' : 'false';
}

// ‚úÖ With conditional types - single signature
type ProcessReturnType&lt;T&gt; = 
  T extends string ? string :
  T extends number ? number :
  T extends boolean ? string :
  never;

function processWithConditional&lt;T extends string | number | boolean&gt;(
  value: T
): ProcessReturnType&lt;T&gt; {
  if (typeof value === 'string') {
    return value.toUpperCase() as ProcessReturnType&lt;T&gt;;
  }
  if (typeof value === 'number') {
    return (value * 2) as ProcessReturnType&lt;T&gt;;
  }
  return (value ? 'true' : 'false') as ProcessReturnType&lt;T&gt;;
}

// Usage - return type is inferred correctly!
const str = processWithConditional('hello');  // string
const num = processWithConditional(42);       // number
const bool = processWithConditional(true);    // string</code></pre>

                <h3>üéØ Extracting Types from Promises</h3>

                <pre><code class="language-typescript">// Unwrap Promise type
type Awaited&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;

type A = Awaited&lt;Promise&lt;string&gt;&gt;;  // string
type B = Awaited&lt;Promise&lt;number&gt;&gt;;  // number
type C = Awaited&lt;string&gt;;           // string (not a Promise)

// Practical use: Typing async function results
async function fetchUser(): Promise&lt;User&gt; {
  const response = await fetch('/api/user');
  return response.json();
}

type UserType = Awaited&lt;ReturnType&lt;typeof fetchUser&gt;&gt;; // User

// React hook with conditional return type
type UseAsyncState&lt;T&gt; = {
  data: Awaited&lt;T&gt; | null;
  loading: boolean;
  error: Error | null;
};

function useAsync&lt;T extends Promise&lt;any&gt;&gt;(
  asyncFn: () =&gt; T
): UseAsyncState&lt;T&gt; {
  const [data, setData] = useState&lt;Awaited&lt;T&gt; | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  useEffect(() =&gt; {
    asyncFn()
      .then(setData)
      .catch(setError)
      .finally(() =&gt; setLoading(false));
  }, []);
  
  return { data, loading, error };
}</code></pre>

                <h3>üéØ Inferring Types with 'infer' Keyword</h3>

                <p>The <code>infer</code> keyword lets you extract and name types from within conditional types:</p>

                <pre><code class="language-typescript">// Extract function return type
type ReturnType&lt;T&gt; = T extends (...args: any[]) =&gt; infer R ? R : never;

function getUser() {
  return { id: 1, name: 'John' };
}

type User = ReturnType&lt;typeof getUser&gt;; // { id: number; name: string; }

// Extract function parameters
type Parameters&lt;T&gt; = T extends (...args: infer P) =&gt; any ? P : never;

function createUser(name: string, email: string, age: number) {
  return { name, email, age };
}

type CreateUserParams = Parameters&lt;typeof createUser&gt;; 
// [name: string, email: string, age: number]

// Extract array element type
type ElementType&lt;T&gt; = T extends (infer E)[] ? E : T;

type NumberArray = ElementType&lt;number[]&gt;;  // number
type StringArray = ElementType&lt;string[]&gt;;  // string
type NotArray = ElementType&lt;boolean&gt;;      // boolean

// Practical example: Extract component props
type ComponentProps&lt;T&gt; = T extends React.ComponentType&lt;infer P&gt; ? P : never;

function Button({ label, onClick }: { label: string; onClick: () =&gt; void }) {
  return &lt;button onClick={onClick}&gt;{label}&lt;/button&gt;;
}

type ButtonProps = ComponentProps&lt;typeof Button&gt;;
// { label: string; onClick: () => void; }</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The 'infer' Keyword</h4>
                    <p><code>infer</code> introduces a type variable that TypeScript will infer from the structure. Think of it as "figure out what this type is and call it R (or P, or E, etc.)."</p>
                </div>

                <h3>üéØ Distributive Conditional Types</h3>

                <p>When a conditional type is applied to a union type, it distributes over each member:</p>

                <pre><code class="language-typescript">// Distributive conditional type
type ToArray&lt;T&gt; = T extends any ? T[] : never;

type A = ToArray&lt;string | number&gt;;
// Distributes to: ToArray&lt;string&gt; | ToArray&lt;number&gt;
// Results in: string[] | number[]

// Non-distributive (wrapped in tuple)
type ToArrayNonDist&lt;T&gt; = [T] extends [any] ? T[] : never;

type B = ToArrayNonDist&lt;string | number&gt;;
// Results in: (string | number)[]

// Practical example: Filter nullable types
type NonNullable&lt;T&gt; = T extends null | undefined ? never : T;

type C = NonNullable&lt;string | null | number | undefined&gt;;
// Distributes and filters: string | number

// React component example
type EventHandler&lt;T&gt; = T extends keyof HTMLElementEventMap
  ? (event: HTMLElementEventMap[T]) =&gt; void
  : never;

type ClickHandler = EventHandler&lt;'click'&gt;; 
// (event: MouseEvent) => void

type KeyHandler = EventHandler&lt;'keydown'&gt;; 
// (event: KeyboardEvent) => void</code></pre>

                <h3>üéØ Advanced Pattern: Recursive Conditional Types</h3>

                <pre><code class="language-typescript">// Deep readonly type
type DeepReadonly&lt;T&gt; = {
  readonly [K in keyof T]: T[K] extends object 
    ? DeepReadonly&lt;T[K]&gt; 
    : T[K];
};

interface NestedData {
  user: {
    name: string;
    address: {
      street: string;
      city: string;
    };
  };
}

type ImmutableData = DeepReadonly&lt;NestedData&gt;;
// All nested properties are readonly!

// Deep partial type
type DeepPartial&lt;T&gt; = {
  [K in keyof T]?: T[K] extends object 
    ? DeepPartial&lt;T[K]&gt; 
    : T[K];
};

type PartialUpdate = DeepPartial&lt;NestedData&gt;;
// All nested properties are optional!

// Practical use in React
interface FormState {
  user: {
    name: string;
    email: string;
    profile: {
      bio: string;
      avatar: string;
    };
  };
}

function updateForm(updates: DeepPartial&lt;FormState&gt;) {
  // Can update any nested property
  // updateForm({ user: { profile: { bio: 'New bio' } } })
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Conditional Types Best Practices</h4>
                    <ul>
                        <li>Use conditional types to reduce code duplication</li>
                        <li>Combine with <code>infer</code> to extract nested types</li>
                        <li>Leverage distributive behavior for union types</li>
                        <li>Create reusable utility types for your domain</li>
                        <li>Document complex conditional types with examples</li>
                    </ul>
                </div>
            </section>

            <section id="template-literals" class="lesson-section">
                <h2>üìù Template Literal Types</h2>
                
                <p>Template literal types build on JavaScript's template literal strings to create precise string types. They're perfect for type-safe string manipulation, CSS classes, event names, and more.</p>

                <h3>üìö Basic Template Literal Types</h3>

                <pre><code class="language-typescript">// Basic template literal type
type Greeting = `hello ${string}`;

const g1: Greeting = 'hello world';     // ‚úÖ OK
const g2: Greeting = 'hello there';     // ‚úÖ OK
const g3: Greeting = 'goodbye world';   // ‚ùå Error

// Combining literal types
type Color = 'red' | 'blue' | 'green';
type Size = 'small' | 'medium' | 'large';

type ColoredSize = `${Color}-${Size}`;
// Results in:
// 'red-small' | 'red-medium' | 'red-large' |
// 'blue-small' | 'blue-medium' | 'blue-large' |
// 'green-small' | 'green-medium' | 'green-large'

// React component using template literals
interface ButtonProps {
  variant: ColoredSize;
  onClick: () =&gt; void;
}

function Button({ variant, onClick }: ButtonProps) {
  return (
    &lt;button className={`btn-${variant}`} onClick={onClick}&gt;
      Click me
    &lt;/button&gt;
  );
}

// Usage - fully type-safe!
&lt;Button variant="blue-large" onClick={handler} /&gt; // ‚úÖ OK
&lt;Button variant="purple-huge" onClick={handler} /&gt; // ‚ùå Error</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Template Literal Type Features</h4>
                    <ul style="color: white;">
                        <li>Combine multiple string literal types</li>
                        <li>Create thousands of precise string types automatically</li>
                        <li>Work with mapped types for key transformation</li>
                        <li>Provide autocomplete for string values</li>
                    </ul>
                </div>

                <h3>üéØ CSS Class Names</h3>

                <pre><code class="language-typescript">// Type-safe CSS class generation
type Spacing = 0 | 1 | 2 | 3 | 4 | 5;
type SpacingProperty = 'margin' | 'padding';
type Direction = 'top' | 'right' | 'bottom' | 'left';

type SpacingClass = `${SpacingProperty}-${Direction}-${Spacing}`;
// 'margin-top-0' | 'margin-top-1' | ... | 'padding-left-5'

interface BoxProps {
  className: SpacingClass;
  children: React.ReactNode;
}

function Box({ className, children }: BoxProps) {
  return &lt;div className={className}&gt;{children}&lt;/div&gt;;
}

// Usage
&lt;Box className="margin-top-3"&gt;Content&lt;/Box&gt; // ‚úÖ OK
&lt;Box className="margin-center-3"&gt;Content&lt;/Box&gt; // ‚ùå Error

// Responsive design classes
type Breakpoint = 'sm' | 'md' | 'lg' | 'xl';
type Display = 'block' | 'flex' | 'grid' | 'none';

type ResponsiveDisplay = `${Breakpoint}:${Display}`;
// 'sm:block' | 'sm:flex' | ... | 'xl:none'

type TailwindClass = ResponsiveDisplay | SpacingClass;

interface ResponsiveBoxProps {
  className: TailwindClass;
  children: React.ReactNode;
}

function ResponsiveBox({ className, children }: ResponsiveBoxProps) {
  return &lt;div className={className}&gt;{children}&lt;/div&gt;;
}</code></pre>

                <h3>üéØ Event Handler Type Safety</h3>

                <pre><code class="language-typescript">// Type-safe event handlers
type EventName = 'click' | 'focus' | 'blur' | 'change' | 'submit';
type HandlerName&lt;T extends string&gt; = `on${Capitalize&lt;T&gt;}`;

type ClickHandler = HandlerName&lt;'click'&gt;;   // 'onClick'
type FocusHandler = HandlerName&lt;'focus'&gt;;   // 'onFocus'
type ChangeHandler = HandlerName&lt;'change'&gt;; // 'onChange'

// Generate all handler names
type AllHandlers = HandlerName&lt;EventName&gt;;
// 'onClick' | 'onFocus' | 'onBlur' | 'onChange' | 'onSubmit'

// Generic event emitter with type-safe events
type EventMap = {
  'user:login': { userId: number; timestamp: Date };
  'user:logout': { userId: number };
  'data:update': { id: string; data: unknown };
};

class TypedEventEmitter&lt;T extends Record&lt;string, any&gt;&gt; {
  private listeners: Partial&lt;{
    [K in keyof T]: Array&lt;(data: T[K]) =&gt; void&gt;
  }&gt; = {};

  on&lt;K extends keyof T&gt;(event: K, handler: (data: T[K]) =&gt; void) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event]!.push(handler);
  }

  emit&lt;K extends keyof T&gt;(event: K, data: T[K]) {
    this.listeners[event]?.forEach(handler =&gt; handler(data));
  }
}

// Usage - fully typed!
const emitter = new TypedEventEmitter&lt;EventMap&gt;();

emitter.on('user:login', (data) =&gt; {
  // data is typed as { userId: number; timestamp: Date }
  console.log(`User ${data.userId} logged in`);
});

emitter.emit('user:login', { 
  userId: 123, 
  timestamp: new Date() 
}); // ‚úÖ OK

emitter.emit('user:login', { 
  userId: 123 
}); // ‚ùå Error - missing timestamp</code></pre>

                <h3>üéØ API Route Type Safety</h3>

                <pre><code class="language-typescript">// Type-safe API routes
type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
type ApiVersion = 'v1' | 'v2';

type ApiRoute = `/api/${ApiVersion}/${string}`;

type UserRoute = `/api/${ApiVersion}/users${'' | `/${number}`}`;
// '/api/v1/users' | '/api/v1/users/123' | '/api/v2/users' | ...

interface ApiClient {
  get(url: UserRoute): Promise&lt;User | User[]&gt;;
  post(url: `/api/${ApiVersion}/users`, data: Partial&lt;User&gt;): Promise&lt;User&gt;;
  put(url: `/api/${ApiVersion}/users/${number}`, data: User): Promise&lt;User&gt;;
  delete(url: `/api/${ApiVersion}/users/${number}`): Promise&lt;void&gt;;
}

// Usage
const client: ApiClient = {
  async get(url) { /* implementation */ },
  async post(url, data) { /* implementation */ },
  async put(url, data) { /* implementation */ },
  async delete(url) { /* implementation */ }
};

// Type-safe API calls
await client.get('/api/v1/users');      // ‚úÖ OK
await client.get('/api/v1/users/123');  // ‚úÖ OK
await client.get('/api/v1/products');   // ‚ùå Error
await client.post('/api/v1/users', { name: 'John' }); // ‚úÖ OK</code></pre>

                <h3>üéØ Mapped Types with Template Literals</h3>

                <pre><code class="language-typescript">// Generate getter/setter methods
type Getters&lt;T&gt; = {
  [K in keyof T as `get${Capitalize&lt;string & K&gt;}`]: () =&gt; T[K];
};

type Setters&lt;T&gt; = {
  [K in keyof T as `set${Capitalize&lt;string & K&gt;}`]: (value: T[K]) =&gt; void;
};

interface User {
  name: string;
  age: number;
  email: string;
}

type UserGetters = Getters&lt;User&gt;;
// {
//   getName: () => string;
//   getAge: () => number;
//   getEmail: () => string;
// }

type UserSetters = Setters&lt;User&gt;;
// {
//   setName: (value: string) => void;
//   setAge: (value: number) => void;
//   setEmail: (value: string) => void;
// }

type UserWithAccessors = User & UserGetters & UserSetters;

// Implementation
class UserModel implements UserWithAccessors {
  name: string = '';
  age: number = 0;
  email: string = '';

  getName = () =&gt; this.name;
  getAge = () =&gt; this.age;
  getEmail = () =&gt; this.email;

  setName = (value: string) =&gt; { this.name = value; };
  setAge = (value: number) =&gt; { this.age = value; };
  setEmail = (value: string) =&gt; { this.email = value; };
}

// React hook using template literals
type StateUpdater&lt;T&gt; = {
  [K in keyof T as `set${Capitalize&lt;string & K&gt;}`]: (value: T[K]) =&gt; void;
};

type UseStateReturn&lt;T&gt; = T & StateUpdater&lt;T&gt;;

function useTypedState&lt;T extends Record&lt;string, any&gt;&gt;(
  initialState: T
): UseStateReturn&lt;T&gt; {
  const [state, setState] = useState(initialState);

  const updaters = Object.keys(initialState).reduce((acc, key) =&gt; {
    const setterName = `set${key.charAt(0).toUpperCase() + key.slice(1)}`;
    acc[setterName] = (value: any) =&gt; {
      setState(prev =&gt; ({ ...prev, [key]: value }));
    };
    return acc;
  }, {} as any);

  return { ...state, ...updaters };
}

// Usage
function UserForm() {
  const { name, email, setName, setEmail } = useTypedState({
    name: '',
    email: ''
  });

  return (
    &lt;form&gt;
      &lt;input value={name} onChange={(e) =&gt; setName(e.target.value)} /&gt;
      &lt;input value={email} onChange={(e) =&gt; setEmail(e.target.value)} /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="mermaid">
graph LR
    A[String Literal Types] --> B[Template Literal]
    B --> C[Combine Types]
    C --> D[Generate All Combinations]
    D --> E[Type-Safe Strings]
    
    E --> F[CSS Classes]
    E --> G[Event Names]
    E --> H[API Routes]
    E --> I[Method Names]
    
    style A fill:#667eea,color:#fff
    style E fill:#c8e6c9
    style F fill:#e8f5e9
    style G fill:#e8f5e9
    style H fill:#e8f5e9
    style I fill:#e8f5e9
                </mermaid>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Template Literal Types Best Practices</h4>
                    <ul>
                        <li>Use for type-safe string constants (routes, class names, event names)</li>
                        <li>Combine with mapped types for powerful transformations</li>
                        <li>Keep combinations reasonable (avoid type explosion)</li>
                        <li>Document the pattern when types become complex</li>
                        <li>Consider performance with very large unions</li>
                    </ul>
                </div>
            </section>

            <section id="exercises" class="lesson-section">
                <h2>üèãÔ∏è Practice Exercises</h2>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Generic Data Table</h3>
                    <p><strong>Objective:</strong> Create a fully generic, type-safe data table component</p>
                    
                    <p><strong>Task:</strong> Build a DataTable component that:</p>
                    <ul>
                        <li>Works with any data type</li>
                        <li>Ensures column keys match data properties</li>
                        <li>Provides type-safe sorting and filtering</li>
                        <li>Has customizable cell renderers</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hints</summary>
                        <ul>
                            <li>Use generics for the data type: <code>&lt;T&gt;</code></li>
                            <li>Use <code>keyof T</code> for column keys</li>
                            <li>Use <code>T[K]</code> to get the type of specific properties</li>
                            <li>Consider using <code>Record&lt;keyof T, (value: T[keyof T]) =&gt; React.ReactNode&gt;</code> for custom renderers</li>
                        </ul>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <pre><code class="language-typescript">interface Column&lt;T&gt; {
  key: keyof T;
  label: string;
  render?: (value: T[keyof T], item: T) =&gt; React.ReactNode;
  sortable?: boolean;
}

interface DataTableProps&lt;T&gt; {
  data: T[];
  columns: Column&lt;T&gt;[];
  keyExtractor: (item: T) =&gt; string | number;
  onRowClick?: (item: T) =&gt; void;
}

function DataTable&lt;T&gt;({ 
  data, 
  columns, 
  keyExtractor,
  onRowClick 
}: DataTableProps&lt;T&gt;) {
  const [sortKey, setSortKey] = useState&lt;keyof T | null&gt;(null);
  const [sortDirection, setSortDirection] = useState&lt;'asc' | 'desc'&gt;('asc');
  
  const sortedData = useMemo(() =&gt; {
    if (!sortKey) return data;
    
    return [...data].sort((a, b) =&gt; {
      const aVal = a[sortKey];
      const bVal = b[sortKey];
      
      if (aVal &lt; bVal) return sortDirection === 'asc' ? -1 : 1;
      if (aVal &gt; bVal) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });
  }, [data, sortKey, sortDirection]);
  
  return (
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          {columns.map(col =&gt; (
            &lt;th key={String(col.key)}&gt;
              {col.label}
              {col.sortable &amp;&amp; (
                &lt;button onClick={() =&gt; setSortKey(col.key)}&gt;
                  Sort
                &lt;/button&gt;
              )}
            &lt;/th&gt;
          ))}
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {sortedData.map(item =&gt; (
          &lt;tr 
            key={keyExtractor(item)}
            onClick={() =&gt; onRowClick?.(item)}
          &gt;
            {columns.map(col =&gt; (
              &lt;td key={String(col.key)}&gt;
                {col.render 
                  ? col.render(item[col.key], item)
                  : String(item[col.key])
                }
              &lt;/td&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
}</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Type-Safe State Machine</h3>
                    <p><strong>Objective:</strong> Implement a state machine using discriminated unions</p>
                    
                    <p><strong>Task:</strong> Create a traffic light state machine with:</p>
                    <ul>
                        <li>States: Red, Yellow, Green</li>
                        <li>Type-safe transitions</li>
                        <li>Automatic timing</li>
                        <li>Prevent invalid state transitions</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hints</summary>
                        <ul>
                            <li>Use discriminated unions for states</li>
                            <li>Each state should know its next state</li>
                            <li>Use <code>useReducer</code> for state management</li>
                            <li>Include timing information in state</li>
                        </ul>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <pre><code class="language-typescript">type TrafficLightState =
  | { light: 'red'; duration: 5000 }
  | { light: 'yellow'; duration: 2000 }
  | { light: 'green'; duration: 5000 };

type TrafficLightAction =
  | { type: 'NEXT' }
  | { type: 'RESET' };

function trafficLightReducer(
  state: TrafficLightState,
  action: TrafficLightAction
): TrafficLightState {
  switch (action.type) {
    case 'NEXT':
      switch (state.light) {
        case 'red':
          return { light: 'green', duration: 5000 };
        case 'green':
          return { light: 'yellow', duration: 2000 };
        case 'yellow':
          return { light: 'red', duration: 5000 };
      }
    case 'RESET':
      return { light: 'red', duration: 5000 };
    default:
      const _exhaustive: never = action;
      return state;
  }
}

function TrafficLight() {
  const [state, dispatch] = useReducer(
    trafficLightReducer,
    { light: 'red', duration: 5000 }
  );
  
  useEffect(() =&gt; {
    const timer = setTimeout(() =&gt; {
      dispatch({ type: 'NEXT' });
    }, state.duration);
    
    return () =&gt; clearTimeout(timer);
  }, [state]);
  
  return (
    &lt;div className={`traffic-light ${state.light}`}&gt;
      &lt;div className={state.light === 'red' ? 'active' : ''}&gt;Red&lt;/div&gt;
      &lt;div className={state.light === 'yellow' ? 'active' : ''}&gt;Yellow&lt;/div&gt;
      &lt;div className={state.light === 'green' ? 'active' : ''}&gt;Green&lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Type-Safe Form Builder</h3>
                    <p><strong>Objective:</strong> Create a form builder with full type safety</p>
                    
                    <p><strong>Task:</strong> Build a form system where:</p>
                    <ul>
                        <li>Field names are typed based on schema</li>
                        <li>Validation rules match field types</li>
                        <li>Form values are fully typed</li>
                        <li>Errors are associated with correct fields</li>
                    </ul>
                    
                    <details>
                        <summary>üí° Hints</summary>
                        <ul>
                            <li>Use generics to capture form schema</li>
                            <li>Use <code>Record&lt;keyof T, ...&gt;</code> for field-specific data</li>
                            <li>Use conditional types for validation rules</li>
                            <li>Consider using Partial for optional validation</li>
                        </ul>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution Approach</summary>
                        <pre><code class="language-typescript">type ValidationRule&lt;T&gt; = (value: T) =&gt; string | undefined;

type FormSchema&lt;T&gt; = {
  [K in keyof T]: {
    type: 'text' | 'number' | 'email' | 'password';
    label: string;
    required?: boolean;
    validate?: ValidationRule&lt;T[K]&gt;;
  };
};

type FormValues&lt;T&gt; = {
  [K in keyof T]: T[K];
};

type FormErrors&lt;T&gt; = Partial&lt;Record&lt;keyof T, string&gt;&gt;;

interface UseFormReturn&lt;T&gt; {
  values: Partial&lt;FormValues&lt;T&gt;&gt;;
  errors: FormErrors&lt;T&gt;;
  setValue: &lt;K extends keyof T&gt;(field: K, value: T[K]) =&gt; void;
  handleSubmit: (onSubmit: (values: FormValues&lt;T&gt;) =&gt; void) =&gt; (e: React.FormEvent) =&gt; void;
}

function useForm&lt;T extends Record&lt;string, any&gt;&gt;(
  schema: FormSchema&lt;T&gt;
): UseFormReturn&lt;T&gt; {
  const [values, setValues] = useState&lt;Partial&lt;FormValues&lt;T&gt;&gt;&gt;({});
  const [errors, setErrors] = useState&lt;FormErrors&lt;T&gt;&gt;({});
  
  const setValue = &lt;K extends keyof T&gt;(field: K, value: T[K]) =&gt; {
    setValues(prev =&gt; ({ ...prev, [field]: value }));
    
    // Validate
    const fieldSchema = schema[field];
    if (fieldSchema.validate) {
      const error = fieldSchema.validate(value);
      setErrors(prev =&gt; ({ ...prev, [field]: error }));
    }
  };
  
  const handleSubmit = (onSubmit: (values: FormValues&lt;T&gt;) =&gt; void) =&gt; {
    return (e: React.FormEvent) =&gt; {
      e.preventDefault();
      
      // Validate all fields
      const newErrors: FormErrors&lt;T&gt; = {};
      let hasErrors = false;
      
      for (const key in schema) {
        const field = schema[key];
        const value = values[key];
        
        if (field.required &amp;&amp; !value) {
          newErrors[key] = 'This field is required';
          hasErrors = true;
        } else if (field.validate &amp;&amp; value) {
          const error = field.validate(value);
          if (error) {
            newErrors[key] = error;
            hasErrors = true;
          }
        }
      }
      
      setErrors(newErrors);
      
      if (!hasErrors) {
        onSubmit(values as FormValues&lt;T&gt;);
      }
    };
  };
  
  return { values, errors, setValue, handleSubmit };
}</code></pre>
                    </details>
                </div>
            </section>

            <section id="summary" class="lesson-section">
                <h2>üéØ Lesson Summary</h2>
                
                <p>Congratulations! You've mastered advanced TypeScript patterns that professional developers use to build robust, maintainable React applications. These patterns aren't just academic exercises‚Äîthey're practical tools that will make your code safer and more expressive.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white; margin-top: 0;">üìö Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Generics:</strong> Create flexible, reusable components that work with any type</li>
                        <li><strong>Discriminated Unions:</strong> Model complex state with impossible states ruled out</li>
                        <li><strong>Type Guards:</strong> Safely narrow types at runtime</li>
                        <li><strong>Utility Types:</strong> Transform types without duplication</li>
                        <li><strong>Conditional Types:</strong> Create types that depend on conditions</li>
                        <li><strong>Template Literals:</strong> Build precise string types for type-safe strings</li>
                    </ul>
                </div>

                <h3>üöÄ Next Steps</h3>

                <p>Now that you understand advanced TypeScript patterns, you're ready to:</p>
                
                <ul>
                    <li>Learn accessibility best practices in Lesson 10.3</li>
                    <li>Master build and deployment in Lesson 10.4</li>
                    <li>Explore advanced topics in Lesson 10.5</li>
                    <li>Apply these patterns to build a robust component library</li>
                    <li>Refactor existing code with advanced types</li>
                </ul>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Remember</h4>
                    <p>Advanced TypeScript patterns are powerful, but use them judiciously:</p>
                    <ul>
                        <li>Prioritize readability over cleverness</li>
                        <li>Document complex types with examples</li>
                        <li>Start simple and add complexity only when needed</li>
                        <li>Consider your team's TypeScript experience</li>
                        <li>Balance type safety with development speed</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Mastery Checklist</h4>
                    <p>You've mastered advanced TypeScript when you can:</p>
                    <ul>
                        <li>‚úÖ Create generic components that maintain full type safety</li>
                        <li>‚úÖ Model complex state machines with discriminated unions</li>
                        <li>‚úÖ Write custom type guards for domain types</li>
                        <li>‚úÖ Combine utility types for powerful transformations</li>
                        <li>‚úÖ Use conditional types to reduce code duplication</li>
                        <li>‚úÖ Build type-safe string constants with template literals</li>
                        <li>‚úÖ Explain when and why to use each pattern</li>
                    </ul>
                </div>
            </section>
        </div>
    </main>

    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_10_1_performance_optimization.html" class="prev-lesson">
            <span class="nav-arrow">‚Üê</span>
            <span class="nav-text">
                <span class="nav-label">Previous Lesson</span>
                <span class="nav-title">10.1: Performance Optimization</span>
            </span>
        </a>
        <a href="index.html" class="home-link">
            <span class="nav-text">
                <span class="nav-label">Back to</span>
                <span class="nav-title">Course Home</span>
            </span>
        </a>
        <a href="lesson_10_3_accessibility.html" class="next-lesson">
            <span class="nav-text">
                <span class="nav-label">Next Lesson</span>
                <span class="nav-title">10.3: Accessibility (a11y)</span>
            </span>
            <span class="nav-arrow">‚Üí</span>
        </a>
    </nav>

    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html#about">About</a> |
                <a href="index.html#contact">Contact</a> |
                <a href="index.html#resources">Resources</a>
            </p>
        </div>
    </footer>

    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
