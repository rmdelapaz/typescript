<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React Query (TanStack Query) for powerful data fetching and caching in React applications. Learn queries, mutations, cache management, optimistic updates, and TypeScript integration for seamless server state management.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.4: React Query (TanStack Query) - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.4: React Query (TanStack Query)</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üîÑ Lesson 8.4: React Query (TanStack Query)</h1>
                <p class="lead">Welcome to the data fetching revolution! React Query (now TanStack Query) has fundamentally changed how we think about server state in React applications. If you've ever struggled with loading states, caching, background refetching, or synchronizing server data, React Query is the solution you've been looking for. In this comprehensive lesson, you'll learn how to use React Query to build applications with seamless data fetching, automatic caching, and incredible developer experience.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the difference between server state and client state</li>
                        <li>Install and configure React Query in a TypeScript project</li>
                        <li>Use queries to fetch and cache data automatically</li>
                        <li>Implement mutations for creating, updating, and deleting data</li>
                        <li>Handle loading, error, and success states elegantly</li>
                        <li>Configure automatic refetching and cache invalidation</li>
                        <li>Implement optimistic updates for instant UI feedback</li>
                        <li>Type queries and mutations properly with TypeScript</li>
                        <li>Use React Query DevTools for debugging</li>
                        <li>Apply React Query best practices and patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 70-85 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 8.1-8.3 (State Management, Zustand, Redux Toolkit), Modules 1-4</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding Server State vs Client State</a></li>
                        <li><a href="#section2" class="toc-link">Installation and Setup</a></li>
                        <li><a href="#section3" class="toc-link">Queries: Fetching Data</a></li>
                        <li><a href="#section4" class="toc-link">Query Keys and Caching</a></li>
                        <li><a href="#section5" class="toc-link">Mutations: Updating Data</a></li>
                        <li><a href="#section6" class="toc-link">Cache Invalidation and Refetching</a></li>
                        <li><a href="#section7" class="toc-link">Optimistic Updates</a></li>
                        <li><a href="#section8" class="toc-link">Best Practices</a></li>
                        <li><a href="#section9" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Server State vs Client State -->
            <section id="section1" class="lesson-section">
                <h2>ü§î Understanding Server State vs Client State</h2>
                
                <p>React Query solves a fundamental problem: managing server state is fundamentally different from managing client state, yet we often treat them the same way.</p>

                <h3>What is Server State?</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Server state</strong> is data that lives on a remote server and is fetched over the network. It's data you don't own - it can change without your knowledge, be updated by other users, and requires synchronization between the server and your UI. <strong>React Query</strong> (now TanStack Query) is a powerful data fetching library that manages server state automatically with caching, background updates, and optimistic updates.</p>
                </div>

                <h3>Server State vs Client State</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Server State</th>
                            <th>Client State</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fetched from API/server</td>
                            <td>Created and managed locally</td>
                        </tr>
                        <tr>
                            <td>Shared across users</td>
                            <td>Unique to one user/session</td>
                        </tr>
                        <tr>
                            <td>Can become stale</td>
                            <td>Always current</td>
                        </tr>
                        <tr>
                            <td>Needs caching strategy</td>
                            <td>Direct state management</td>
                        </tr>
                        <tr>
                            <td>Requires synchronization</td>
                            <td>No synchronization needed</td>
                        </tr>
                        <tr>
                            <td>Examples: User data, posts, products</td>
                            <td>Examples: Modal open, theme, form inputs</td>
                        </tr>
                    </tbody>
                </table>

                <h3>The Problem with Traditional Approaches</h3>

                <p>Before React Query, managing server state typically looked like this:</p>

                <pre><code class="language-typescript">// ‚ùå The old way - so much boilerplate!
function UserList() {
  const [users, setUsers] = useState&lt;User[]&gt;([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() => {
    setIsLoading(true);
    setError(null);
    
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setIsLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setIsLoading(false);
      });
  }, []); // When should we refetch?
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with Manual Fetching</h4>
                    <ul>
                        <li><strong>Boilerplate:</strong> Loading states, error states, success states</li>
                        <li><strong>No Caching:</strong> Same data fetched multiple times</li>
                        <li><strong>No Background Updates:</strong> Data goes stale</li>
                        <li><strong>Race Conditions:</strong> Multiple requests can conflict</li>
                        <li><strong>No Deduplication:</strong> Multiple components = multiple requests</li>
                        <li><strong>Manual Refetching:</strong> When should we refetch? On focus? On interval?</li>
                        <li><strong>Memory Leaks:</strong> Updating state after unmount</li>
                    </ul>
                </div>

                <h3>How React Query Solves These Problems</h3>

                <p>With React Query, the same component becomes:</p>

                <pre><code class="language-typescript">// ‚úÖ The React Query way - simple and powerful!
import { useQuery } from '@tanstack/react-query';

function UserList() {
  const { data: users, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: () => fetch('/api/users').then(res => res.json())
  });
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ React Query Benefits</h4>
                    <p>Out of the box, React Query provides:</p>
                    <ul>
                        <li><strong>Automatic Caching:</strong> Data is cached and shared across components</li>
                        <li><strong>Background Refetching:</strong> Keeps data fresh automatically</li>
                        <li><strong>Window Focus Refetching:</strong> Updates when user returns to tab</li>
                        <li><strong>Request Deduplication:</strong> Multiple requests = one network call</li>
                        <li><strong>Automatic Retries:</strong> Failed requests retry automatically</li>
                        <li><strong>Garbage Collection:</strong> Old data is cleaned up automatically</li>
                        <li><strong>Optimistic Updates:</strong> Update UI before server responds</li>
                        <li><strong>Pagination & Infinite Scroll:</strong> Built-in support</li>
                        <li><strong>DevTools:</strong> Visualize queries and cache</li>
                    </ul>
                </div>

                <h3>When to Use React Query</h3>

                <div class="mermaid">
graph TB
    A[Need Data?] --> B{Where's it from?}
    B -->|Server/API| C[Use React Query]
    B -->|Local/Browser| D[Use useState/Context/Zustand]
    
    C --> E[Automatic caching]
    C --> F[Background updates]
    C --> G[Loading states]
    
    D --> H[Direct state control]
    D --> I[No network overhead]
    
    style C fill:#c8e6c9
    style D fill:#e3f2fd
    style A fill:#f0f0f0
</div>

                <p>Use React Query for:</p>
                <ul>
                    <li>‚úÖ Fetching data from REST APIs</li>
                    <li>‚úÖ GraphQL queries (with plugins)</li>
                    <li>‚úÖ Data that can become stale</li>
                    <li>‚úÖ Data shared across components</li>
                    <li>‚úÖ CRUD operations</li>
                    <li>‚úÖ Pagination and infinite scroll</li>
                </ul>

                <p>Don't use React Query for:</p>
                <ul>
                    <li>‚ùå Local UI state (modals, themes, forms)</li>
                    <li>‚ùå One-time configuration fetches</li>
                    <li>‚ùå Data you don't need to cache</li>
                    <li>‚ùå Simple, infrequent API calls</li>
                </ul>
            </section>

            <!-- Section 2: Installation and Setup -->
            <section id="section2" class="lesson-section">
                <h2>‚öôÔ∏è Installation and Setup</h2>
                
                <p>Let's get React Query set up in your React TypeScript project.</p>

                <h3>Installing React Query</h3>

                <pre><code class="language-bash"># Install React Query v5 (TanStack Query)
npm install @tanstack/react-query

# Optional: Install DevTools for debugging
npm install @tanstack/react-query-devtools</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Version Note</h4>
                    <p>React Query was rebranded as <strong>TanStack Query</strong> starting with v4. The package is now <code>@tanstack/react-query</code>. All functionality works the same, just with a new namespace. We'll use the latest v5 in this lesson.</p>
                </div>

                <h3>Setting Up QueryClient</h3>

                <p>Create and configure a QueryClient with default options:</p>

                <pre><code class="language-typescript">// src/lib/queryClient.ts

import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 10, // 10 minutes
      refetchOnWindowFocus: true,
      refetchOnReconnect: true,
      retry: 1,
    },
  },
});

// Explanation:
// - staleTime: How long until data is considered stale
// - cacheTime: How long to keep unused data in cache
// - refetchOnWindowFocus: Refetch when user returns to window
// - refetchOnReconnect: Refetch when internet reconnects
// - retry: Number of retry attempts on failure</code></pre>

                <h3>Wrapping Your App</h3>

                <p>Provide the QueryClient to your entire application:</p>

                <pre><code class="language-typescript">// src/main.tsx (or App.tsx)

import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import App from './App';

// Create a client
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      retry: 1,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;QueryClientProvider client={queryClient}&gt;
      &lt;App /&gt;
      
      {/* DevTools - only appears in development */}
      &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
    &lt;/QueryClientProvider&gt;
  &lt;/React.StrictMode&gt;
);</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ React Query DevTools</h4>
                    <p>The DevTools provide an amazing debugging experience:</p>
                    <ul>
                        <li>See all queries and their current state</li>
                        <li>Visualize query cache</li>
                        <li>Manually trigger refetches</li>
                        <li>Inspect query data and errors</li>
                        <li>View query timelines</li>
                        <li>Automatically tree-shaken from production builds</li>
                    </ul>
                </div>

                <h3>Project Structure</h3>

                <p>Organize your React Query code:</p>

                <pre><code class="language-typescript">src/
  lib/
    queryClient.ts          // QueryClient configuration
    
  api/
    users.ts               // User-related API functions
    posts.ts               // Post-related API functions
    
  hooks/
    queries/
      useUsers.ts          // User query hooks
      usePosts.ts          // Post query hooks
    mutations/
      useCreateUser.ts     // User mutation hooks
      useUpdatePost.ts     // Post mutation hooks
      
  components/
    users/
      UserList.tsx         // Uses user queries
      CreateUserForm.tsx   // Uses user mutations</code></pre>

                <h3>Creating API Functions</h3>

                <p>Separate your API logic from components:</p>

                <pre><code class="language-typescript">// src/api/users.ts

export interface User {
  id: string;
  name: string;
  email: string;
}

// GET all users
export async function getUsers(): Promise&lt;User[]&gt; {
  const response = await fetch('https://api.example.com/users');
  
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  
  return response.json();
}

// GET single user
export async function getUser(id: string): Promise&lt;User&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch user');
  }
  
  return response.json();
}

// POST create user
export async function createUser(userData: Omit&lt;User, 'id'&gt;): Promise&lt;User&gt; {
  const response = await fetch('https://api.example.com/users', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(userData),
  });
  
  if (!response.ok) {
    throw new Error('Failed to create user');
  }
  
  return response.json();
}

// PATCH update user
export async function updateUser(
  id: string, 
  updates: Partial&lt;User&gt;
): Promise&lt;User&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(updates),
  });
  
  if (!response.ok) {
    throw new Error('Failed to update user');
  }
  
  return response.json();
}

// DELETE user
export async function deleteUser(id: string): Promise&lt;void&gt; {
  const response = await fetch(`https://api.example.com/users/${id}`, {
    method: 'DELETE',
  });
  
  if (!response.ok) {
    throw new Error('Failed to delete user');
  }
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Error Handling</h4>
                    <p>Always check <code>response.ok</code> and throw errors for failed requests. React Query will catch these errors and expose them through the <code>error</code> property in your hooks.</p>
                </div>
            </section>

            <!-- Section 3: Queries - Fetching Data -->
            <section id="section3" class="lesson-section">
                <h2>üì• Queries: Fetching Data</h2>
                
                <p>Queries are the core of React Query. They fetch data, cache it, and keep it synchronized with the server.</p>

                <h3>Basic useQuery</h3>

                <pre><code class="language-typescript">// src/components/UserList.tsx

import { useQuery } from '@tanstack/react-query';
import { getUsers } from '../api/users';

function UserList() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['users'],
    queryFn: getUsers
  });
  
  if (isLoading) {
    return &lt;div&gt;Loading users...&lt;/div&gt;;
  }
  
  if (error) {
    return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  }
  
  return (
    &lt;ul&gt;
      {data?.map(user => (
        &lt;li key={user.id}&gt;
          {user.name} - {user.email}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>Understanding Query States</h3>

                <p>React Query provides detailed state information:</p>

                <pre><code class="language-typescript">function UserList() {
  const { 
    data,              // The data returned from queryFn
    error,             // Error object if query failed
    isLoading,         // true on first load (no cached data)
    isFetching,        // true whenever fetching (even if cached data exists)
    isError,           // true if query errored
    isSuccess,         // true if query succeeded
    status,            // 'pending' | 'error' | 'success'
    fetchStatus,       // 'fetching' | 'paused' | 'idle'
    refetch,           // Function to manually refetch
  } = useQuery({
    queryKey: ['users'],
    queryFn: getUsers
  });
  
  // Different ways to check loading
  if (isLoading) {
    return &lt;div&gt;Loading for the first time...&lt;/div&gt;;
  }
  
  return (
    &lt;div&gt;
      {isFetching && &lt;div&gt;Updating...&lt;/div&gt;}
      {/* Render data */}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="mermaid">
stateDiagram-v2
    [*] --> Pending: Query starts
    Pending --> Success: Data received
    Pending --> Error: Request failed
    Success --> Fetching: Refetching
    Error --> Fetching: Retrying
    Fetching --> Success: Data received
    Fetching --> Error: Request failed
    
    Success --> [*]
    Error --> [*]
</div>

                <h3>Query with Parameters</h3>

                <pre><code class="language-typescript">// src/components/UserProfile.tsx

import { useQuery } from '@tanstack/react-query';
import { getUser } from '../api/users';

function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useQuery({
    queryKey: ['user', userId], // Include params in key!
    queryFn: () => getUser(userId),
    enabled: !!userId, // Only run if userId exists
  });
  
  if (isLoading) return &lt;div&gt;Loading user...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The enabled Option</h4>
                    <p>Use <code>enabled</code> to conditionally execute queries:</p>
                    <ul>
                        <li>Wait for required data before fetching</li>
                        <li>Disable queries based on user permissions</li>
                        <li>Implement dependent queries</li>
                        <li>Prevent unnecessary requests</li>
                    </ul>
                    <pre><code class="language-typescript">const { data: user } = useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId),
  enabled: !!userId && hasPermission
});</code></pre>
                </div>

                <h3>TypeScript Integration</h3>

                <pre><code class="language-typescript">// Strongly typed query
const { data } = useQuery&lt;User[], Error&gt;({
  queryKey: ['users'],
  queryFn: getUsers
});
// data is typed as User[] | undefined
// error is typed as Error | null

// With type inference (recommended)
const { data, error } = useQuery({
  queryKey: ['users'],
  queryFn: getUsers // Return type inferred as User[]
});
// TypeScript infers types from getUsers function</code></pre>

                <h3>Query Options</h3>

                <pre><code class="language-typescript">const { data } = useQuery({
  queryKey: ['users'],
  queryFn: getUsers,
  
  // Caching
  staleTime: 1000 * 60 * 5,        // 5 minutes until stale
  cacheTime: 1000 * 60 * 10,       // 10 minutes in cache (deprecated in v5, use gcTime)
  gcTime: 1000 * 60 * 10,          // Garbage collection time (v5+)
  
  // Refetching
  refetchOnMount: true,             // Refetch on component mount if stale
  refetchOnWindowFocus: true,       // Refetch when window regains focus
  refetchOnReconnect: true,         // Refetch when internet reconnects
  refetchInterval: false,           // Refetch every X ms (or false to disable)
  refetchIntervalInBackground: false, // Refetch even when window not focused
  
  // Retry
  retry: 3,                         // Retry failed requests 3 times
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  
  // Other
  enabled: true,                    // Enable/disable query
  placeholderData: [],              // Show while loading (doesn't go to cache)
  initialData: [],                  // Initial data (goes to cache)
  
  // Callbacks
  onSuccess: (data) => {
    console.log('Query succeeded:', data);
  },
  onError: (error) => {
    console.error('Query failed:', error);
  },
  onSettled: (data, error) => {
    console.log('Query completed');
  }
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Query Best Practices</h4>
                    <ul>
                        <li>Always include all dependencies in <code>queryKey</code></li>
                        <li>Keep query functions pure and predictable</li>
                        <li>Use <code>enabled</code> for conditional fetching</li>
                        <li>Set appropriate <code>staleTime</code> based on data volatility</li>
                        <li>Extract query logic into custom hooks for reusability</li>
                        <li>Let TypeScript infer types from your API functions</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Query Keys and Caching -->
            <section id="section4" class="lesson-section">
                <h2>üîë Query Keys and Caching</h2>
                
                <p>Query keys are the backbone of React Query's caching system. Understanding them is crucial for effective data management.</p>

                <h3>How Query Keys Work</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Query Keys</h4>
                    <p style="color: white;">Query keys uniquely identify queries in the cache. They can be strings or arrays, and React Query compares them deeply. If two queries have the same key, they share the same cached data.</p>
                </div>

                <pre><code class="language-typescript">// Simple string key
useQuery({
  queryKey: ['users'],
  queryFn: getUsers
});

// Array with parameters
useQuery({
  queryKey: ['user', userId],
  queryFn: () => getUser(userId)
});

// Complex keys with multiple parameters
useQuery({
  queryKey: ['users', { status: 'active', page: 1 }],
  queryFn: () => getUsers({ status: 'active', page: 1 })
});

// Keys are compared deeply
['users', { page: 1, status: 'active' }] 
  === 
['users', { status: 'active', page: 1 }]  // true!
</code></pre>

                <h3>Query Key Patterns</h3>

                <pre><code class="language-typescript">// ‚úÖ Good: Hierarchical structure
['users']                          // All users
['users', userId]                  // Specific user
['users', userId, 'posts']         // User's posts
['users', userId, 'posts', postId] // Specific post

// ‚úÖ Good: With filters/params
['users', { status: 'active' }]
['posts', { page: 1, limit: 10 }]
['products', { category: 'electronics', sort: 'price' }]

// ‚ùå Bad: Inconsistent structure
['users']
['userById', userId]  // Should be ['users', userId]
['getUserPosts', userId]  // Should be ['users', userId, 'posts']</code></pre>

                <h3>Query Key Factory</h3>

                <p>Create a centralized key factory for consistency:</p>

                <pre><code class="language-typescript">// src/lib/queryKeys.ts

export const queryKeys = {
  // Users
  users: {
    all: ['users'] as const,
    lists: () => [...queryKeys.users.all, 'list'] as const,
    list: (filters: string) => 
      [...queryKeys.users.lists(), { filters }] as const,
    details: () => [...queryKeys.users.all, 'detail'] as const,
    detail: (id: string) => 
      [...queryKeys.users.details(), id] as const,
  },
  
  // Posts
  posts: {
    all: ['posts'] as const,
    lists: () => [...queryKeys.posts.all, 'list'] as const,
    list: (filters: string) => 
      [...queryKeys.posts.lists(), { filters }] as const,
    details: () => [...queryKeys.posts.all, 'detail'] as const,
    detail: (id: string) => 
      [...queryKeys.posts.details(), id] as const,
  },
};

// Usage
useQuery({
  queryKey: queryKeys.users.detail(userId),
  queryFn: () => getUser(userId)
});

useQuery({
  queryKey: queryKeys.posts.list('published'),
  queryFn: () => getPosts({ status: 'published' })
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Query Key Factory</h4>
                    <ul>
                        <li><strong>Consistency:</strong> Same structure everywhere</li>
                        <li><strong>Type Safety:</strong> TypeScript autocomplete</li>
                        <li><strong>Maintainability:</strong> Change keys in one place</li>
                        <li><strong>Invalidation:</strong> Easy to target specific queries</li>
                        <li><strong>Documentation:</strong> Self-documenting API</li>
                    </ul>
                </div>

                <h3>Understanding the Cache</h3>

                <div class="mermaid">
graph TB
    A[Component 1 requests 'users'] --> B{In cache?}
    B -->|No| C[Fetch from server]
    B -->|Yes - Fresh| D[Return cached data]
    B -->|Yes - Stale| E[Return cached + refetch]
    
    C --> F[Store in cache]
    E --> F
    F --> G[Update components]
    
    H[Component 2 requests 'users'] --> B
    
    style D fill:#c8e6c9
    style E fill:#fff3cd
    style C fill:#e3f2fd
</div>

                <h3>Stale Time vs Cache Time</h3>

                <pre><code class="language-typescript">useQuery({
  queryKey: ['users'],
  queryFn: getUsers,
  staleTime: 1000 * 60 * 5,  // 5 minutes
  gcTime: 1000 * 60 * 10      // 10 minutes (was cacheTime in v4)
});

// Timeline:
// t=0:  Fetch data, cache it as "fresh"
// t=5m: Data becomes "stale" but still in cache
//       - On mount, return stale data + refetch in background
// t=10m: Data removed from cache (garbage collected)
//       - On mount, show loading + fetch fresh data</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>staleTime</th>
                            <th>gcTime (cacheTime)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>How long data is considered "fresh"</td>
                            <td>How long inactive data stays in cache</td>
                        </tr>
                        <tr>
                            <td>Fresh data won't refetch</td>
                            <td>After gcTime, data is removed</td>
                        </tr>
                        <tr>
                            <td>Default: 0 (immediately stale)</td>
                            <td>Default: 5 minutes</td>
                        </tr>
                        <tr>
                            <td>Use for data that changes slowly</td>
                            <td>Use to control memory usage</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Choosing staleTime</h4>
                    <p>Set <code>staleTime</code> based on how often your data changes:</p>
                    <ul>
                        <li><strong>0ms (default):</strong> Real-time data, social feeds</li>
                        <li><strong>30s - 1min:</strong> Live dashboards, scores</li>
                        <li><strong>5-10min:</strong> User profiles, settings</li>
                        <li><strong>1hour+:</strong> Rarely changing data (countries, categories)</li>
                        <li><strong>Infinity:</strong> Static data (won't refetch until invalidated)</li>
                    </ul>
                </div>

                <!-- Interactive Cache Timeline Visualization -->
                <div class="card" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0; display: flex; align-items: center; gap: 0.5rem;">
                            <span style="font-size: 1.5rem;">‚è±Ô∏è</span> Interactive: Cache Lifecycle Timeline
                        </h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Watch how data transitions from fresh ‚Üí stale ‚Üí garbage collected. Adjust the timing settings!</p>
                    </div>
                    <div id="cache-timeline-viz" style="padding: 1.5rem; background: #1a1a2e;">
                        <!-- Controls -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div>
                                <label style="color: #9ca3af; font-size: 0.85rem; display: block; margin-bottom: 0.5rem;">staleTime: <span id="stale-time-value" style="color: #4ade80; font-weight: bold;">3 min</span></label>
                                <input type="range" id="stale-time-slider" min="0" max="10" value="3" 
                                    style="width: 100%; accent-color: #4ade80;">
                            </div>
                            <div>
                                <label style="color: #9ca3af; font-size: 0.85rem; display: block; margin-bottom: 0.5rem;">gcTime: <span id="gc-time-value" style="color: #f87171; font-weight: bold;">6 min</span></label>
                                <input type="range" id="gc-time-slider" min="1" max="15" value="6" 
                                    style="width: 100%; accent-color: #f87171;">
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: flex-end;">
                                <button id="cache-play-btn" style="flex: 1; background: #4ade80; color: #1a1a2e; border: none; padding: 0.6rem 1rem; border-radius: 6px; font-weight: bold; cursor: pointer;">‚ñ∂ Start</button>
                                <button id="cache-reset-btn" style="background: #374151; color: white; border: none; padding: 0.6rem 1rem; border-radius: 6px; cursor: pointer;">‚Ü∫ Reset</button>
                            </div>
                        </div>

                        <!-- Timeline visualization -->
                        <div style="background: #0f172a; border-radius: 8px; padding: 1rem; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; color: #6b7280; font-size: 0.75rem; margin-bottom: 0.5rem;">
                                <span>0 min</span>
                                <span>5 min</span>
                                <span>10 min</span>
                                <span>15 min</span>
                            </div>
                            <div style="position: relative; height: 60px; background: linear-gradient(to right, #22c55e 0%, #22c55e var(--stale-pct, 20%), #f59e0b var(--stale-pct, 20%), #f59e0b var(--gc-pct, 40%), #374151 var(--gc-pct, 40%)); border-radius: 8px; overflow: hidden;" id="timeline-bar">
                                <!-- Current time marker -->
                                <div id="time-marker" style="position: absolute; top: 0; left: 0; width: 3px; height: 100%; background: white; box-shadow: 0 0 10px rgba(255,255,255,0.8); transition: left 0.1s linear;"></div>
                                <!-- Stale boundary -->
                                <div id="stale-marker" style="position: absolute; top: 0; left: 20%; width: 2px; height: 100%; background: #fbbf24; border-left: 2px dashed #fbbf24;"></div>
                                <!-- GC boundary -->
                                <div id="gc-marker" style="position: absolute; top: 0; left: 40%; width: 2px; height: 100%; background: #ef4444; border-left: 2px dashed #ef4444;"></div>
                            </div>
                            <div style="display: flex; justify-content: flex-start; gap: 1.5rem; margin-top: 0.75rem;">
                                <span style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.8rem; color: #9ca3af;">
                                    <span style="width: 12px; height: 12px; background: #22c55e; border-radius: 2px;"></span> Fresh
                                </span>
                                <span style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.8rem; color: #9ca3af;">
                                    <span style="width: 12px; height: 12px; background: #f59e0b; border-radius: 2px;"></span> Stale
                                </span>
                                <span style="display: flex; align-items: center; gap: 0.25rem; font-size: 0.8rem; color: #9ca3af;">
                                    <span style="width: 12px; height: 12px; background: #374151; border-radius: 2px;"></span> Garbage Collected
                                </span>
                            </div>
                        </div>

                        <!-- Current state display -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                            <div id="cache-status-box" style="background: #22c55e; border-radius: 8px; padding: 1rem; text-align: center; transition: background 0.3s;">
                                <div style="font-size: 1.5rem;">üì¶</div>
                                <div style="font-size: 0.9rem; font-weight: bold; color: #1a1a2e;">FRESH</div>
                            </div>
                            <div style="background: #1e293b; border-radius: 8px; padding: 1rem; text-align: center;">
                                <div id="current-time-display" style="font-size: 1.5rem; font-weight: bold; color: white;">0:00</div>
                                <div style="font-size: 0.75rem; color: #9ca3af;">Elapsed Time</div>
                            </div>
                            <div style="background: #1e293b; border-radius: 8px; padding: 1rem; text-align: center;">
                                <div id="refetch-count" style="font-size: 1.5rem; font-weight: bold; color: #60a5fa;">0</div>
                                <div style="font-size: 0.75rem; color: #9ca3af;">Background Refetches</div>
                            </div>
                        </div>

                        <!-- Event log -->
                        <div style="background: #0f172a; border-radius: 8px; padding: 1rem; max-height: 150px; overflow-y: auto;">
                            <div style="color: #6b7280; font-size: 0.75rem; margin-bottom: 0.5rem;">EVENT LOG</div>
                            <div id="cache-event-log" style="font-family: monospace; font-size: 0.8rem; color: #e5e7eb;">
                                <div style="color: #4ade80;">‚û° t=0:00 - Data fetched and cached as FRESH</div>
                            </div>
                        </div>

                        <!-- Scenario buttons -->
                        <div style="margin-top: 1rem;">
                            <div style="color: #6b7280; font-size: 0.75rem; margin-bottom: 0.5rem;">TRIGGER SCENARIOS</div>
                            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                <button id="scenario-mount" style="background: #3b82f6; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer;">üì± Component Mounts</button>
                                <button id="scenario-focus" style="background: #8b5cf6; color: white; border: none; padding: 0.5rem 0.75rem; border-radius: 6px; font-size: 0.8rem; cursor: pointer;">üëÅ Window Focus</button>
                            </div>
                        </div>
                    </div>
                </div>

                <script>
                (function() {
                    const staleSlider = document.getElementById('stale-time-slider');
                    const gcSlider = document.getElementById('gc-time-slider');
                    const staleValue = document.getElementById('stale-time-value');
                    const gcValue = document.getElementById('gc-time-value');
                    const playBtn = document.getElementById('cache-play-btn');
                    const resetBtn = document.getElementById('cache-reset-btn');
                    const timeMarker = document.getElementById('time-marker');
                    const staleMarker = document.getElementById('stale-marker');
                    const gcMarker = document.getElementById('gc-marker');
                    const timelineBar = document.getElementById('timeline-bar');
                    const statusBox = document.getElementById('cache-status-box');
                    const currentTimeDisplay = document.getElementById('current-time-display');
                    const refetchCount = document.getElementById('refetch-count');
                    const eventLog = document.getElementById('cache-event-log');
                    const mountBtn = document.getElementById('scenario-mount');
                    const focusBtn = document.getElementById('scenario-focus');

                    let currentTime = 0;
                    let isPlaying = false;
                    let interval = null;
                    let refetches = 0;

                    function getStaleTime() {
                        return parseInt(staleSlider.value);
                    }

                    function getGcTime() {
                        return parseInt(gcSlider.value);
                    }

                    function updateMarkers() {
                        const staleT = getStaleTime();
                        const gcT = getGcTime();
                        const maxTime = 15;
                        
                        const stalePct = (staleT / maxTime) * 100;
                        const gcPct = (gcT / maxTime) * 100;
                        
                        staleMarker.style.left = stalePct + '%';
                        gcMarker.style.left = gcPct + '%';
                        
                        timelineBar.style.setProperty('--stale-pct', stalePct + '%');
                        timelineBar.style.setProperty('--gc-pct', gcPct + '%');
                        
                        staleValue.textContent = staleT === 0 ? '0 (instant)' : staleT + ' min';
                        gcValue.textContent = gcT + ' min';
                    }

                    function getStatus() {
                        const staleT = getStaleTime();
                        const gcT = getGcTime();
                        if (currentTime < staleT) return 'fresh';
                        if (currentTime < gcT) return 'stale';
                        return 'gc';
                    }

                    function updateStatus() {
                        const status = getStatus();
                        const maxTime = 15;
                        const pct = (currentTime / maxTime) * 100;
                        
                        timeMarker.style.left = pct + '%';
                        
                        const mins = Math.floor(currentTime);
                        const secs = Math.round((currentTime % 1) * 60);
                        currentTimeDisplay.textContent = mins + ':' + secs.toString().padStart(2, '0');
                        
                        if (status === 'fresh') {
                            statusBox.style.background = '#22c55e';
                            statusBox.innerHTML = '<div style="font-size: 1.5rem;">üì¶</div><div style="font-size: 0.9rem; font-weight: bold; color: #1a1a2e;">FRESH</div>';
                        } else if (status === 'stale') {
                            statusBox.style.background = '#f59e0b';
                            statusBox.innerHTML = '<div style="font-size: 1.5rem;">‚è≥</div><div style="font-size: 0.9rem; font-weight: bold; color: #1a1a2e;">STALE</div>';
                        } else {
                            statusBox.style.background = '#6b7280';
                            statusBox.innerHTML = '<div style="font-size: 1.5rem;">üóëÔ∏è</div><div style="font-size: 0.9rem; font-weight: bold; color: white;">GARBAGE COLLECTED</div>';
                        }
                    }

                    function addEvent(message, color) {
                        const mins = Math.floor(currentTime);
                        const secs = Math.round((currentTime % 1) * 60);
                        const timeStr = mins + ':' + secs.toString().padStart(2, '0');
                        const div = document.createElement('div');
                        div.style.color = color || '#e5e7eb';
                        div.textContent = '‚û° t=' + timeStr + ' - ' + message;
                        eventLog.appendChild(div);
                        eventLog.scrollTop = eventLog.scrollHeight;
                    }

                    function tick() {
                        const prevStatus = getStatus();
                        currentTime += 0.05;
                        const newStatus = getStatus();
                        
                        if (prevStatus === 'fresh' && newStatus === 'stale') {
                            addEvent('Data became STALE', '#fbbf24');
                        } else if (prevStatus === 'stale' && newStatus === 'gc') {
                            addEvent('Data GARBAGE COLLECTED from cache', '#ef4444');
                        }
                        
                        updateStatus();
                        
                        if (currentTime >= 15) {
                            stopPlayback();
                        }
                    }

                    function startPlayback() {
                        if (!isPlaying) {
                            isPlaying = true;
                            playBtn.textContent = '‚è∏ Pause';
                            playBtn.style.background = '#f59e0b';
                            interval = setInterval(tick, 50);
                        } else {
                            stopPlayback();
                        }
                    }

                    function stopPlayback() {
                        isPlaying = false;
                        playBtn.textContent = '‚ñ∂ Start';
                        playBtn.style.background = '#4ade80';
                        if (interval) {
                            clearInterval(interval);
                            interval = null;
                        }
                    }

                    function resetSimulation() {
                        stopPlayback();
                        currentTime = 0;
                        refetches = 0;
                        refetchCount.textContent = '0';
                        eventLog.innerHTML = '<div style="color: #4ade80;">‚û° t=0:00 - Data fetched and cached as FRESH</div>';
                        updateStatus();
                    }

                    function handleScenario(type) {
                        const status = getStatus();
                        if (type === 'mount') {
                            if (status === 'fresh') {
                                addEvent('Component mounted ‚Üí Using cached FRESH data (no refetch)', '#4ade80');
                            } else if (status === 'stale') {
                                addEvent('Component mounted ‚Üí Returning STALE data + REFETCHING in background', '#fbbf24');
                                refetches++;
                                refetchCount.textContent = refetches;
                            } else {
                                addEvent('Component mounted ‚Üí No cache! Showing loading + FETCHING fresh data', '#60a5fa');
                                refetches++;
                                refetchCount.textContent = refetches;
                            }
                        } else if (type === 'focus') {
                            if (status === 'fresh') {
                                addEvent('Window focused ‚Üí Data still FRESH (no refetch)', '#4ade80');
                            } else if (status === 'stale') {
                                addEvent('Window focused ‚Üí Data is STALE, REFETCHING in background', '#fbbf24');
                                refetches++;
                                refetchCount.textContent = refetches;
                            } else {
                                addEvent('Window focused ‚Üí No cached data (nothing to refetch)', '#6b7280');
                            }
                        }
                    }

                    // Event listeners
                    staleSlider.addEventListener('input', () => {
                        // Ensure staleTime <= gcTime
                        if (parseInt(staleSlider.value) > parseInt(gcSlider.value)) {
                            gcSlider.value = staleSlider.value;
                        }
                        updateMarkers();
                        updateStatus();
                    });

                    gcSlider.addEventListener('input', () => {
                        // Ensure gcTime >= staleTime
                        if (parseInt(gcSlider.value) < parseInt(staleSlider.value)) {
                            staleSlider.value = gcSlider.value;
                        }
                        updateMarkers();
                        updateStatus();
                    });

                    playBtn.addEventListener('click', startPlayback);
                    resetBtn.addEventListener('click', resetSimulation);
                    mountBtn.addEventListener('click', () => handleScenario('mount'));
                    focusBtn.addEventListener('click', () => handleScenario('focus'));

                    // Initialize
                    updateMarkers();
                    updateStatus();
                })();
                </script>
