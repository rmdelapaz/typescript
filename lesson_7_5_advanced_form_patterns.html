<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master advanced form patterns in React with TypeScript. Learn multi-step forms, conditional fields, form wizards, auto-save, and field dependencies.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 7.5: Advanced Form Patterns - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module7">Module 7: Forms and Validation</a></li>
            <li aria-current="page">Lesson 7.5: Advanced Form Patterns</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üé® Lesson 7.5: Advanced Form Patterns</h1>
                <p class="lead">You've mastered the fundamentals of forms, validation, and file uploads. Now it's time to level up with advanced patterns that you'll encounter in real-world applications. Think about complex forms you've filled out online‚Äîmulti-step checkout processes, conditional questions that appear based on your answers, forms that save your progress automatically, or wizards that guide you through complex data entry. These aren't just nice-to-have features; they're essential for creating professional, user-friendly applications. In this lesson, you'll learn to build all of these patterns with React, TypeScript, and React Hook Form.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Build multi-step forms with proper state management and navigation</li>
                        <li>Implement conditional fields that show/hide based on user input</li>
                        <li>Create form wizards with progress tracking and validation per step</li>
                        <li>Implement auto-save functionality with debouncing</li>
                        <li>Handle field dependencies and computed values</li>
                        <li>Make forms accessible with proper ARIA attributes and keyboard navigation</li>
                        <li>Persist form data to localStorage for better UX</li>
                        <li>Implement review/summary steps before submission</li>
                        <li>Handle complex form navigation patterns (back, next, skip, cancel)</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a complete multi-step checkout form with conditional fields and auto-save</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Introduction to Advanced Form Patterns</a></li>
                        <li><a href="#section2" class="toc-link">Multi-Step Forms: The Basics</a></li>
                        <li><a href="#section3" class="toc-link">Building Your First Multi-Step Form</a></li>
                        <li><a href="#section4" class="toc-link">Step Navigation and Validation</a></li>
                        <li><a href="#section5" class="toc-link">Progress Indicators</a></li>
                        <li><a href="#section6" class="toc-link">Conditional Fields</a></li>
                        <li><a href="#section7" class="toc-link">Advanced Conditional Logic</a></li>
                        <li><a href="#section8" class="toc-link">Field Dependencies</a></li>
                        <li><a href="#section9" class="toc-link">Auto-Save Implementation</a></li>
                        <li><a href="#section10" class="toc-link">Form Wizards</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="section1" class="lesson-section">
                <h2>üåü Introduction to Advanced Form Patterns</h2>
                
                <p>Forms are the primary way users interact with web applications, and as applications grow more complex, so do their forms. Let's look at some real-world scenarios where advanced form patterns are essential:</p>

                <h3>Common Advanced Form Scenarios</h3>

                <ul>
                    <li><strong>E-commerce Checkout:</strong> Multi-step process (shipping ‚Üí payment ‚Üí review ‚Üí confirmation)</li>
                    <li><strong>User Onboarding:</strong> Wizard-style forms that guide new users through setup</li>
                    <li><strong>Insurance Applications:</strong> Conditional questions based on coverage type, age, health status</li>
                    <li><strong>Job Applications:</strong> Different fields for different job types, auto-save drafts</li>
                    <li><strong>Tax Filing Software:</strong> Complex conditional logic, field dependencies, calculations</li>
                    <li><strong>Survey Forms:</strong> Skip logic, branching questions, progress tracking</li>
                    <li><strong>Account Settings:</strong> Auto-save changes, show/hide sections, field validation</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What Makes a Form "Advanced"?</h4>
                    <p style="color: white;"><strong>Advanced Form Patterns:</strong> Techniques that go beyond basic single-page forms with simple validation. These include multi-step navigation, conditional field visibility, field dependencies, auto-save functionality, complex validation rules, and sophisticated user guidance patterns like wizards. They're "advanced" because they require careful state management, user experience consideration, and often integration with multiple systems.</p>
                </div>

                <h3>Why These Patterns Matter</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>User Benefit</th>
                            <th>Business Benefit</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Multi-Step Forms</strong></td>
                            <td>Less overwhelming, focused attention</td>
                            <td>Higher completion rates</td>
                        </tr>
                        <tr>
                            <td><strong>Conditional Fields</strong></td>
                            <td>Only see relevant questions</td>
                            <td>Cleaner data, faster completion</td>
                        </tr>
                        <tr>
                            <td><strong>Auto-Save</strong></td>
                            <td>No lost work, peace of mind</td>
                            <td>Reduced abandonment</td>
                        </tr>
                        <tr>
                            <td><strong>Progress Indicators</strong></td>
                            <td>Know how far they've come</td>
                            <td>Increased completion motivation</td>
                        </tr>
                        <tr>
                            <td><strong>Field Dependencies</strong></td>
                            <td>Intelligent defaults, less typing</td>
                            <td>Better data quality</td>
                        </tr>
                        <tr>
                            <td><strong>Form Wizards</strong></td>
                            <td>Guided experience, clear path</td>
                            <td>Consistent onboarding</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Psychology of Form Design</h4>
                    <p>Research shows that:</p>
                    <ul>
                        <li><strong>Multi-step forms can increase conversions by up to 300%</strong> compared to long single-page forms</li>
                        <li><strong>Progress bars increase completion rates</strong> by giving users a sense of accomplishment</li>
                        <li><strong>Auto-save reduces anxiety</strong> and makes users more likely to complete longer forms</li>
                        <li><strong>Conditional fields reduce cognitive load</strong> by showing only relevant questions</li>
                    </ul>
                    <p>Good form design isn't just about code‚Äîit's about understanding human behavior!</p>
                </div>

                <h3>What We'll Build Together</h3>

                <p>Throughout this lesson, we'll progressively build a complete multi-step checkout form that demonstrates all these patterns:</p>

                <div class="mermaid">
                    graph LR
                    A[Account Info] --> B[Shipping Address]
                    B --> C{Shipping = Billing?}
                    C -->|No| D[Billing Address]
                    C -->|Yes| E[Payment Method]
                    D --> E
                    E --> F[Review & Submit]
                    F --> G[Confirmation]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style C fill:#FFA726,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <p>This form will include:</p>
                <ul>
                    <li>‚úÖ Multiple steps with navigation</li>
                    <li>‚úÖ Conditional billing address step</li>
                    <li>‚úÖ Field dependencies (state ‚Üí cities)</li>
                    <li>‚úÖ Auto-save to localStorage</li>
                    <li>‚úÖ Per-step validation</li>
                    <li>‚úÖ Progress indicator</li>
                    <li>‚úÖ Review/summary step</li>
                    <li>‚úÖ Full accessibility support</li>
                </ul>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Tools We'll Use</h4>
                    <p>We'll leverage everything you've learned so far:</p>
                    <ul>
                        <li><strong>React Hook Form:</strong> For efficient form state management</li>
                        <li><strong>Zod:</strong> For schema validation</li>
                        <li><strong>TypeScript:</strong> For type safety across complex form state</li>
                        <li><strong>localStorage:</strong> For persisting form data</li>
                        <li><strong>Custom Hooks:</strong> For reusable form logic</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Multi-Step Forms Basics -->
            <section id="section2" class="lesson-section">
                <h2>üìä Multi-Step Forms: The Basics</h2>
                
                <p>Multi-step forms break a long form into smaller, more manageable pieces. Instead of overwhelming users with 50 fields at once, you present them with 5-10 fields per step. This improves both the user experience and completion rates.</p>

                <h3>Key Concepts</h3>

                <h4>1. State Management</h4>

                <p>In a multi-step form, you need to track:</p>

                <ul>
                    <li><strong>Current Step:</strong> Which step the user is on (e.g., step 1 of 4)</li>
                    <li><strong>Form Data:</strong> All data from all steps, even those not currently visible</li>
                    <li><strong>Validation State:</strong> Which steps have been completed/validated</li>
                    <li><strong>Step History:</strong> Where the user has been (for back button)</li>
                </ul>

                <pre><code class="language-typescript">interface MultiStepFormState {
  currentStep: number;
  completedSteps: Set&lt;number&gt;;
  formData: {
    step1: Step1Data;
    step2: Step2Data;
    step3: Step3Data;
  };
}</code></pre>

                <h4>2. Step Components</h4>

                <p>Each step is typically its own component with its own validation schema:</p>

                <pre><code class="language-typescript">// Step 1: Account Information
const AccountInfoStep = ({ onNext, defaultValues }) => {
  // Form logic for this step only
  // Validate and call onNext with data
};

// Step 2: Shipping Address
const ShippingStep = ({ onNext, onBack, defaultValues }) => {
  // Form logic for shipping
};

// And so on...</code></pre>

                <h4>3. Navigation Patterns</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Action</th>
                            <th>Behavior</th>
                            <th>Validation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Next</strong></td>
                            <td>Move to next step</td>
                            <td>Validate current step before proceeding</td>
                        </tr>
                        <tr>
                            <td><strong>Back</strong></td>
                            <td>Return to previous step</td>
                            <td>No validation required (data preserved)</td>
                        </tr>
                        <tr>
                            <td><strong>Skip</strong></td>
                            <td>Jump to next step (if allowed)</td>
                            <td>Optional step, no validation</td>
                        </tr>
                        <tr>
                            <td><strong>Jump to Step</strong></td>
                            <td>Navigate to specific step</td>
                            <td>Only allow if step is completed or next in sequence</td>
                        </tr>
                        <tr>
                            <td><strong>Submit</strong></td>
                            <td>Final submission (last step)</td>
                            <td>Validate all steps, then submit</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Pitfalls</h4>
                    <ul>
                        <li><strong>Losing Data:</strong> When navigating between steps, preserve all form data</li>
                        <li><strong>Over-Validation:</strong> Don't validate steps the user hasn't reached yet</li>
                        <li><strong>Unclear Progress:</strong> Always show where users are in the process</li>
                        <li><strong>Disabled Back Button:</strong> Users should always be able to go back and change answers</li>
                        <li><strong>Too Many Steps:</strong> More than 5-6 steps feels tedious. Group related fields.</li>
                    </ul>
                </div>

                <h3>Architectural Approaches</h3>

                <p>There are two main ways to structure multi-step forms:</p>

                <h4>Approach 1: Single Form with Conditional Rendering</h4>

                <pre><code class="language-typescript">const MultiStepForm = () => {
  const [step, setStep] = useState(1);
  const methods = useForm(); // Single form instance

  return (
    &lt;FormProvider {...methods}&gt;
      {step === 1 && &lt;Step1 /&gt;}
      {step === 2 && &lt;Step2 /&gt;}
      {step === 3 && &lt;Step3 /&gt;}
    &lt;/FormProvider&gt;
  );
};</code></pre>

                <p><strong>Pros:</strong> All data in one form, simple state management<br>
                <strong>Cons:</strong> All validation schemas load upfront, harder to code-split</p>

                <h4>Approach 2: Separate Forms with Shared State</h4>

                <pre><code class="language-typescript">const MultiStepForm = () => {
  const [step, setStep] = useState(1);
  const [formData, setFormData] = useState({});

  const handleStepComplete = (stepData) => {
    setFormData(prev => ({ ...prev, ...stepData }));
    setStep(prev => prev + 1);
  };

  return (
    &lt;&gt;
      {step === 1 && &lt;Step1Form onComplete={handleStepComplete} /&gt;}
      {step === 2 && &lt;Step2Form onComplete={handleStepComplete} /&gt;}
      {step === 3 && &lt;Step3Form onComplete={handleStepComplete} /&gt;}
    &lt;/&gt;
  );
};</code></pre>

                <p><strong>Pros:</strong> Better code splitting, isolated validation<br>
                <strong>Cons:</strong> More complex state management, need to pass data between steps</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Recommendation</h4>
                    <p>For most applications, <strong>Approach 2 (separate forms with shared state)</strong> is better because:</p>
                    <ul>
                        <li>Better performance (lazy load steps)</li>
                        <li>Easier to test individual steps</li>
                        <li>More flexible validation rules per step</li>
                        <li>Cleaner separation of concerns</li>
                    </ul>
                    <p>We'll use this approach in our examples.</p>
                </div>

                <h3>Data Flow in Multi-Step Forms</h3>

                <div class="mermaid">
                    sequenceDiagram
                    participant User
                    participant Step1
                    participant State
                    participant Step2
                    participant API

                    User->>Step1: Fill form fields
                    User->>Step1: Click "Next"
                    Step1->>Step1: Validate data
                    Step1->>State: Save step1 data
                    State->>Step2: Provide default values
                    Step2->>User: Show step 2
                    User->>Step2: Fill form fields
                    User->>Step2: Click "Back"
                    Step2->>State: Save step2 data (draft)
                    State->>Step1: Restore with saved data
                    Step1->>User: Show step 1
                    User->>Step1: Click "Next" again
                    Step1->>State: Confirm step1 data
                    State->>Step2: Show step 2 with saved data
                    User->>Step2: Click "Submit"
                    Step2->>Step2: Validate final data
                    Step2->>State: Combine all data
                    State->>API: Submit complete form
                    API->>User: Show success
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Principle: Progressive Enhancement</h4>
                    <p>Think of multi-step forms as progressive enhancement:</p>
                    <ul>
                        <li><strong>Step 1:</strong> Get the minimum required information</li>
                        <li><strong>Step 2:</strong> Enhance with additional details</li>
                        <li><strong>Step 3:</strong> Optional customization</li>
                        <li><strong>Final Step:</strong> Review and confirm</li>
                    </ul>
                    <p>Each step should feel like a natural progression, not an arbitrary division.</p>
                </div>
            </section>

            <!-- Section 3: Building First Multi-Step Form -->
            <section id="section3" class="lesson-section">
                <h2>üî® Building Your First Multi-Step Form</h2>
                
                <p>Let's build a practical multi-step form from scratch. We'll create a user registration form with three steps: Account Info, Personal Details, and Preferences.</p>

                <h3>Step 1: Define Types and Schemas</h3>

                <p>First, let's define our TypeScript types and Zod schemas for each step:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Step 1: Account Information
const accountInfoSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z
    .string()
    .min(8, 'Password must be at least 8 characters')
    .regex(/[A-Z]/, 'Password must contain uppercase letter')
    .regex(/[0-9]/, 'Password must contain number'),
  confirmPassword: z.string()
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ['confirmPassword']
});

type AccountInfo = z.infer&lt;typeof accountInfoSchema&gt;;

// Step 2: Personal Details
const personalDetailsSchema = z.object({
  firstName: z.string().min(2, 'First name is required'),
  lastName: z.string().min(2, 'Last name is required'),
  dateOfBirth: z.string().regex(
    /^\d{4}-\d{2}-\d{2}$/,
    'Date must be in YYYY-MM-DD format'
  ),
  phone: z.string().regex(
    /^\d{10}$/,
    'Phone must be 10 digits'
  ).optional()
});

type PersonalDetails = z.infer&lt;typeof personalDetailsSchema&gt;;

// Step 3: Preferences
const preferencesSchema = z.object({
  newsletter: z.boolean(),
  notifications: z.enum(['all', 'important', 'none']),
  interests: z.array(z.string()).min(1, 'Select at least one interest')
});

type Preferences = z.infer&lt;typeof preferencesSchema&gt;;

// Combined form data
interface RegistrationFormData {
  accountInfo?: AccountInfo;
  personalDetails?: PersonalDetails;
  preferences?: Preferences;
}</code></pre>

                <h3>Step 2: Create the Main Form Container</h3>

                <pre><code class="language-typescript">import React, { useState } from 'react';

const RegistrationForm: React.FC = () => {
  const [currentStep, setCurrentStep] = useState(1);
  const [formData, setFormData] = useState&lt;RegistrationFormData&gt;({});

  const totalSteps = 3;

  const handleStepComplete = (stepName: keyof RegistrationFormData, data: any) => {
    // Save step data
    setFormData(prev => ({
      ...prev,
      [stepName]: data
    }));

    // Move to next step
    if (currentStep < totalSteps) {
      setCurrentStep(prev => prev + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 1) {
      setCurrentStep(prev => prev - 1);
    }
  };

  const handleSubmit = async () => {
    console.log('Submitting complete form:', formData);
    
    try {
      const response = await fetch('/api/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      });

      if (response.ok) {
        alert('Registration successful!');
        // Redirect to login or dashboard
      }
    } catch (error) {
      console.error('Registration failed:', error);
      alert('Registration failed. Please try again.');
    }
  };

  return (
    &lt;div className="registration-form"&gt;
      &lt;h1&gt;Create Your Account&lt;/h1&gt;
      
      {/* Progress indicator */}
      &lt;div className="progress-steps"&gt;
        {[1, 2, 3].map(step => (
          &lt;div
            key={step}
            className={`step ${step === currentStep ? 'active' : ''} ${
              step < currentStep ? 'completed' : ''
            }`}
          &gt;
            {step}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;

      {/* Render current step */}
      {currentStep === 1 && (
        &lt;AccountInfoStep
          onNext={(data) => handleStepComplete('accountInfo', data)}
          defaultValues={formData.accountInfo}
        /&gt;
      )}

      {currentStep === 2 && (
        &lt;PersonalDetailsStep
          onNext={(data) => handleStepComplete('personalDetails', data)}
          onBack={handleBack}
          defaultValues={formData.personalDetails}
        /&gt;
      )}

      {currentStep === 3 && (
        &lt;PreferencesStep
          onSubmit={(data) => {
            handleStepComplete('preferences', data);
            handleSubmit();
          }}
          onBack={handleBack}
          defaultValues={formData.preferences}
        /&gt;
      )}
    &lt;/div&gt;
  );
};

export default RegistrationForm;</code></pre>

                <h3>Step 3: Create Individual Step Components</h3>

                <p>Now let's create each step component. Here's the first step:</p>

                <pre><code class="language-typescript">import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';

interface AccountInfoStepProps {
  onNext: (data: AccountInfo) => void;
  defaultValues?: AccountInfo;
}

const AccountInfoStep: React.FC&lt;AccountInfoStepProps&gt; = ({
  onNext,
  defaultValues
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;AccountInfo&gt;({
    resolver: zodResolver(accountInfoSchema),
    defaultValues
  });

  const onSubmit = (data: AccountInfo) => {
    onNext(data);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;h2&gt;Step 1: Account Information&lt;/h2&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="email"&gt;Email Address *&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          {...register('email')}
          aria-invalid={errors.email ? 'true' : 'false'}
          aria-describedby={errors.email ? 'email-error' : undefined}
        /&gt;
        {errors.email && (
          &lt;span id="email-error" className="error" role="alert"&gt;
            {errors.email.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="password"&gt;Password *&lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          {...register('password')}
          aria-invalid={errors.password ? 'true' : 'false'}
          aria-describedby={errors.password ? 'password-error' : undefined}
        /&gt;
        {errors.password && (
          &lt;span id="password-error" className="error" role="alert"&gt;
            {errors.password.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password *&lt;/label&gt;
        &lt;input
          id="confirmPassword"
          type="password"
          {...register('confirmPassword')}
          aria-invalid={errors.confirmPassword ? 'true' : 'false'}
          aria-describedby={
            errors.confirmPassword ? 'confirm-password-error' : undefined
          }
        /&gt;
        {errors.confirmPassword && (
          &lt;span id="confirm-password-error" className="error" role="alert"&gt;
            {errors.confirmPassword.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-actions"&gt;
        &lt;button type="submit" className="btn-primary"&gt;
          Next ‚Üí
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Patterns in This Implementation</h4>
                    <ul>
                        <li><strong>Default Values:</strong> Each step receives previous data via <code>defaultValues</code></li>
                        <li><strong>Independent Validation:</strong> Each step has its own schema and validates independently</li>
                        <li><strong>Callback Pattern:</strong> Steps call <code>onNext</code> with validated data</li>
                        <li><strong>Type Safety:</strong> TypeScript ensures data structure is correct across steps</li>
                        <li><strong>Accessibility:</strong> Proper ARIA attributes for errors and form controls</li>
                    </ul>
                </div>

                <h3>Step 4: Second and Third Step Components</h3>

                <p>The other steps follow the same pattern, but with <code>onBack</code> support:</p>

                <pre><code class="language-typescript">interface PersonalDetailsStepProps {
  onNext: (data: PersonalDetails) => void;
  onBack: () => void;
  defaultValues?: PersonalDetails;
}

const PersonalDetailsStep: React.FC&lt;PersonalDetailsStepProps&gt; = ({
  onNext,
  onBack,
  defaultValues
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;PersonalDetails&gt;({
    resolver: zodResolver(personalDetailsSchema),
    defaultValues
  });

  return (
    &lt;form onSubmit={handleSubmit(onNext)}&gt;
      &lt;h2&gt;Step 2: Personal Details&lt;/h2&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="firstName"&gt;First Name *&lt;/label&gt;
        &lt;input
          id="firstName"
          {...register('firstName')}
          aria-invalid={errors.firstName ? 'true' : 'false'}
        /&gt;
        {errors.firstName && (
          &lt;span className="error" role="alert"&gt;
            {errors.firstName.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="lastName"&gt;Last Name *&lt;/label&gt;
        &lt;input
          id="lastName"
          {...register('lastName')}
          aria-invalid={errors.lastName ? 'true' : 'false'}
        /&gt;
        {errors.lastName && (
          &lt;span className="error" role="alert"&gt;
            {errors.lastName.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="dateOfBirth"&gt;Date of Birth *&lt;/label&gt;
        &lt;input
          id="dateOfBirth"
          type="date"
          {...register('dateOfBirth')}
          aria-invalid={errors.dateOfBirth ? 'true' : 'false'}
        /&gt;
        {errors.dateOfBirth && (
          &lt;span className="error" role="alert"&gt;
            {errors.dateOfBirth.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="phone"&gt;Phone (Optional)&lt;/label&gt;
        &lt;input
          id="phone"
          type="tel"
          {...register('phone')}
          placeholder="1234567890"
        /&gt;
        {errors.phone && (
          &lt;span className="error" role="alert"&gt;
            {errors.phone.message}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div className="form-actions"&gt;
        &lt;button type="button" onClick={onBack} className="btn-secondary"&gt;
          ‚Üê Back
        &lt;/button&gt;
        &lt;button type="submit" className="btn-primary"&gt;
          Next ‚Üí
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Notice the Pattern</h4>
                    <p>Each step component is remarkably similar:</p>
                    <ol>
                        <li>Receives <code>onNext</code>, <code>onBack</code> (except first step), and <code>defaultValues</code></li>
                        <li>Uses <code>useForm</code> with its own schema and default values</li>
                        <li>Renders form fields with error handling</li>
                        <li>Provides navigation buttons (Back + Next or Submit)</li>
                    </ol>
                    <p>This consistency makes the code easy to understand and maintain!</p>
                </div>
            <!-- Section 4: Step Navigation and Validation -->
            <section id="section4" class="lesson-section">
                <h2>üß≠ Step Navigation and Validation</h2>
                
                <p>Navigation in multi-step forms needs to be intelligent. You can't just move between steps freely‚Äîyou need to validate data, handle edge cases, and provide a smooth user experience. Let's explore advanced navigation patterns.</p>

                <h3>Validation Strategies</h3>

                <p>There are several approaches to validation in multi-step forms:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Strategy</th>
                            <th>When to Validate</th>
                            <th>Pros</th>
                            <th>Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Validate on Next</strong></td>
                            <td>When clicking "Next" button</td>
                            <td>Users can freely edit, no premature errors</td>
                            <td>Errors only shown when trying to proceed</td>
                        </tr>
                        <tr>
                            <td><strong>Validate on Blur</strong></td>
                            <td>When leaving each field</td>
                            <td>Immediate feedback per field</td>
                            <td>Can feel aggressive/annoying</td>
                        </tr>
                        <tr>
                            <td><strong>Validate on Change</strong></td>
                            <td>As user types</td>
                            <td>Real-time feedback</td>
                            <td>Very aggressive, can be distracting</td>
                        </tr>
                        <tr>
                            <td><strong>Hybrid Approach</strong></td>
                            <td>On Next initially, then on Change for errors</td>
                            <td>Best UX‚Äîforgiving at first, helpful after</td>
                            <td>More complex to implement</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Recommended: Hybrid Approach</h4>
                    <p>The best user experience comes from:</p>
                    <ol>
                        <li><strong>First attempt:</strong> Validate only when user clicks "Next"</li>
                        <li><strong>After errors:</strong> Show real-time validation for fields that had errors</li>
                        <li><strong>Going back:</strong> Don't validate when going back (preserve data as-is)</li>
                    </ol>
                    <p>React Hook Form supports this pattern natively with its <code>mode</code> option!</p>
                </div>

                <h3>Implementing Smart Validation</h3>

                <pre><code class="language-typescript">const SmartValidationStep: React.FC&lt;StepProps&gt; = ({
  onNext,
  onBack,
  defaultValues
}) => {
  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitted }
  } = useForm&lt;FormData&gt;({
    resolver: zodResolver(schema),
    defaultValues,
    mode: 'onSubmit', // Validate on first submit
    reValidateMode: 'onChange' // Then validate on change
  });

  return (
    &lt;form onSubmit={handleSubmit(onNext)}&gt;
      {/* Form fields */}
      
      &lt;div className="form-actions"&gt;
        &lt;button 
          type="button" 
          onClick={onBack}
          className="btn-secondary"
        &gt;
          ‚Üê Back
        &lt;/button&gt;
        &lt;button type="submit" className="btn-primary"&gt;
          Next ‚Üí
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <h3>Preventing Navigation with Unsaved Changes</h3>

                <p>When users try to navigate away or close the browser with unsaved changes, warn them:</p>

                <pre><code class="language-typescript">import { useEffect } from 'react';
import { useFormState } from 'react-hook-form';

const useWarnOnUnsavedChanges = (isDirty: boolean) => {
  useEffect(() => {
    const handleBeforeUnload = (e: BeforeUnloadEvent) => {
      if (isDirty) {
        e.preventDefault();
        e.returnValue = ''; // Required for Chrome
      }
    };

    window.addEventListener('beforeunload', handleBeforeUnload);

    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [isDirty]);
};

// Usage in step component
const StepWithWarning: React.FC&lt;StepProps&gt; = ({ onNext, onBack }) => {
  const { control, handleSubmit } = useForm();
  const { isDirty } = useFormState({ control });

  // Warn if user tries to leave with unsaved changes
  useWarnOnUnsavedChanges(isDirty);

  return (
    &lt;form onSubmit={handleSubmit(onNext)}&gt;
      {/* Form fields */}
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Browser Limitations</h4>
                    <p>The <code>beforeunload</code> event has limitations:</p>
                    <ul>
                        <li>You can't customize the warning message (browser shows generic message)</li>
                        <li>It only works for browser navigation, not React Router navigation</li>
                        <li>Some browsers ignore it in certain contexts</li>
                    </ul>
                    <p>For in-app navigation, use React Router's navigation guards or a confirmation dialog.</p>
                </div>

                <h3>Step Completion Tracking</h3>

                <p>Track which steps have been completed so users can jump back to any completed step:</p>

                <pre><code class="language-typescript">interface MultiStepFormState {
  currentStep: number;
  completedSteps: Set&lt;number&gt;;
  formData: any;
}

const MultiStepFormWithTracking: React.FC = () => {
  const [state, setState] = useState&lt;MultiStepFormState&gt;({
    currentStep: 1,
    completedSteps: new Set(),
    formData: {}
  });

  const handleStepComplete = (stepData: any) => {
    setState(prev => ({
      ...prev,
      completedSteps: new Set([...prev.completedSteps, prev.currentStep]),
      formData: { ...prev.formData, ...stepData },
      currentStep: prev.currentStep + 1
    }));
  };

  const canNavigateToStep = (step: number): boolean => {
    // Can navigate to current step or any completed step
    return step === state.currentStep || state.completedSteps.has(step);
  };

  const goToStep = (step: number) => {
    if (canNavigateToStep(step)) {
      setState(prev => ({ ...prev, currentStep: step }));
    }
  };

  return (
    &lt;div&gt;
      {/* Progress indicator with clickable steps */}
      &lt;div className="progress-steps"&gt;
        {[1, 2, 3, 4].map(step => (
          &lt;button
            key={step}
            onClick={() => goToStep(step)}
            disabled={!canNavigateToStep(step)}
            className={`
              step 
              ${step === state.currentStep ? 'active' : ''} 
              ${state.completedSteps.has(step) ? 'completed' : ''}
            `}
            aria-label={`Step ${step}${
              state.completedSteps.has(step) ? ' (completed)' : ''
            }${step === state.currentStep ? ' (current)' : ''}`}
          &gt;
            {state.completedSteps.has(step) ? '‚úì' : step}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;

      {/* Render current step */}
      {/* ... */}
    &lt;/div&gt;
  );
};</code></pre>

                <h3>Scroll to Top on Step Change</h3>

                <p>When navigating between steps, scroll to the top of the form:</p>

                <pre><code class="language-typescript">import { useEffect, useRef } from 'react';

const MultiStepFormWithScroll: React.FC = () => {
  const [currentStep, setCurrentStep] = useState(1);
  const formRef = useRef&lt;HTMLDivElement&gt;(null);

  // Scroll to top when step changes
  useEffect(() => {
    formRef.current?.scrollIntoView({ 
      behavior: 'smooth', 
      block: 'start' 
    });
  }, [currentStep]);

  return (
    &lt;div ref={formRef}&gt;
      {/* Form content */}
    &lt;/div&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Keyboard Navigation</h4>
                    <p>Make your multi-step forms keyboard-friendly:</p>
                    <ul>
                        <li><strong>Tab order:</strong> Ensure logical tab order through form fields</li>
                        <li><strong>Enter key:</strong> Pressing Enter should submit the current step (if valid)</li>
                        <li><strong>Escape key:</strong> Could cancel or go back (optional)</li>
                        <li><strong>Arrow keys:</strong> Navigate between steps in progress indicator (optional)</li>
                    </ul>
                    <pre><code class="language-typescript">const handleKeyDown = (e: React.KeyboardEvent) => {
  if (e.key === 'Escape' && currentStep > 1) {
    handleBack();
  }
};</code></pre>
                </div>
            </section>

            <!-- Section 5: Progress Indicators -->
            <section id="section5" class="lesson-section">
                <h2>üìà Progress Indicators</h2>
                
                <p>Progress indicators are crucial for multi-step forms. They show users where they are, how far they've come, and how much is left. Let's explore different progress indicator patterns and implement them properly.</p>

                <h3>Types of Progress Indicators</h3>

                <h4>1. Numbered Steps</h4>

                <pre><code class="language-typescript">const NumberedProgress: React.FC&lt;{
  currentStep: number;
  totalSteps: number;
  completedSteps: Set&lt;number&gt;;
  onStepClick?: (step: number) => void;
}&gt; = ({ currentStep, totalSteps, completedSteps, onStepClick }) => {
  return (
    &lt;div className="numbered-progress"&gt;
      {Array.from({ length: totalSteps }, (_, i) => i + 1).map(step => {
        const isCompleted = completedSteps.has(step);
        const isCurrent = step === currentStep;
        const isClickable = isCompleted || isCurrent;

        return (
          &lt;div key={step} className="progress-step-container"&gt;
            &lt;button
              onClick={() => isClickable && onStepClick?.(step)}
              disabled={!isClickable}
              className={`
                progress-step
                ${isCurrent ? 'current' : ''}
                ${isCompleted ? 'completed' : ''}
              `}
              aria-current={isCurrent ? 'step' : undefined}
            &gt;
              {isCompleted ? '‚úì' : step}
            &lt;/button&gt;
            {step < totalSteps && (
              &lt;div 
                className={`progress-line ${
                  isCompleted ? 'completed' : ''
                }`}
              /&gt;
            )}
          &lt;/div&gt;
        );
      })}
    &lt;/div&gt;
  );
};</code></pre>

                <h4>2. Progress Bar</h4>

                <pre><code class="language-typescript">const ProgressBar: React.FC&lt;{
  currentStep: number;
  totalSteps: number;
}&gt; = ({ currentStep, totalSteps }) => {
  const progress = ((currentStep - 1) / (totalSteps - 1)) * 100;

  return (
    &lt;div className="progress-bar-container"&gt;
      &lt;div className="progress-info"&gt;
        &lt;span&gt;Step {currentStep} of {totalSteps}&lt;/span&gt;
        &lt;span&gt;{Math.round(progress)}% Complete&lt;/span&gt;
      &lt;/div&gt;
      &lt;div 
        className="progress-bar-track"
        role="progressbar"
        aria-valuenow={progress}
        aria-valuemin={0}
        aria-valuemax={100}
        aria-label={`Step ${currentStep} of ${totalSteps}`}
      &gt;
        &lt;div 
          className="progress-bar-fill"
          style={{ width: `${progress}%` }}
        /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></pre>

                <h4>3. Step Labels</h4>

                <pre><code class="language-typescript">interface StepInfo {
  number: number;
  label: string;
  description?: string;
}

const LabeledProgress: React.FC&lt;{
  steps: StepInfo[];
  currentStep: number;
  completedSteps: Set&lt;number&gt;;
}&gt; = ({ steps, currentStep, completedSteps }) => {
  return (
    &lt;div className="labeled-progress"&gt;
      {steps.map(step => {
        const isCompleted = completedSteps.has(step.number);
        const isCurrent = step.number === currentStep;

        return (
          &lt;div
            key={step.number}
            className={`
              labeled-step
              ${isCurrent ? 'current' : ''}
              ${isCompleted ? 'completed' : ''}
            `}
          &gt;
            &lt;div className="step-indicator"&gt;
              {isCompleted ? '‚úì' : step.number}
            &lt;/div&gt;
            &lt;div className="step-content"&gt;
              &lt;div className="step-label"&gt;{step.label}&lt;/div&gt;
              {step.description && (
                &lt;div className="step-description"&gt;
                  {step.description}
                &lt;/div&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        );
      })}
    &lt;/div&gt;
  );
};

// Usage
const steps: StepInfo[] = [
  { number: 1, label: 'Account', description: 'Create your account' },
  { number: 2, label: 'Profile', description: 'Tell us about yourself' },
  { number: 3, label: 'Preferences', description: 'Customize your experience' },
  { number: 4, label: 'Review', description: 'Confirm your information' }
];</code></pre>

                <h3>Responsive Progress Indicators</h3>

                <p>On mobile devices, full step labels might not fit. Here's a responsive approach:</p>

                <pre><code class="language-typescript">const ResponsiveProgress: React.FC&lt;ProgressProps&gt; = (props) => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkMobile = () => {
      setIsMobile(window.innerWidth < 768);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  if (isMobile) {
    return &lt;ProgressBar {...props} /&gt;;
  }

  return &lt;LabeledProgress {...props} /&gt;;
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Progress Indicator Best Practices</h4>
                    <ul>
                        <li><strong>Always visible:</strong> Keep the progress indicator in view (sticky or fixed)</li>
                        <li><strong>Clear current step:</strong> Make it obvious which step the user is on</li>
                        <li><strong>Show completion:</strong> Visually distinguish completed steps</li>
                        <li><strong>Clickable when allowed:</strong> Let users return to completed steps</li>
                        <li><strong>Accessible:</strong> Use proper ARIA attributes for screen readers</li>
                        <li><strong>Mobile-friendly:</strong> Adapt to smaller screens</li>
                    </ul>
                </div>

                <h3>CSS for Progress Indicators</h3>

                <pre><code class="language-css">/* Numbered Progress Styles */
.numbered-progress {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 2rem 0;
  position: sticky;
  top: 0;
  background: white;
  z-index: 100;
}

.progress-step-container {
  display: flex;
  align-items: center;
  flex: 1;
}

.progress-step {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid #ccc;
  background: white;
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
}

.progress-step.current {
  border-color: #667eea;
  background: #667eea;
  color: white;
  box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.2);
}

.progress-step.completed {
  border-color: #4CAF50;
  background: #4CAF50;
  color: white;
}

.progress-step:disabled {
  cursor: not-allowed;
  opacity: 0.5;
}

.progress-line {
  flex: 1;
  height: 2px;
  background: #e0e0e0;
  margin: 0 0.5rem;
  transition: background 0.3s ease;
}

.progress-line.completed {
  background: #4CAF50;
}

/* Progress Bar Styles */
.progress-bar-container {
  padding: 1rem 0;
  position: sticky;
  top: 0;
  background: white;
  z-index: 100;
}

.progress-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
  font-size: 0.875rem;
  color: #666;
}

.progress-bar-track {
  height: 8px;
  background: #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
}

.progress-bar-fill {
  height: 100%;
  background: linear-gradient(90deg, #667eea, #764ba2);
  transition: width 0.3s ease;
  border-radius: 4px;
}

/* Labeled Progress Styles */
.labeled-progress {
  display: flex;
  gap: 2rem;
  padding: 2rem 0;
}

.labeled-step {
  flex: 1;
  display: flex;
  gap: 1rem;
  opacity: 0.5;
  transition: opacity 0.3s ease;
}

.labeled-step.current,
.labeled-step.completed {
  opacity: 1;
}

.step-indicator {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid #ccc;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  flex-shrink: 0;
}

.labeled-step.current .step-indicator {
  border-color: #667eea;
  background: #667eea;
  color: white;
}

.labeled-step.completed .step-indicator {
  border-color: #4CAF50;
  background: #4CAF50;
  color: white;
}

.step-content {
  flex: 1;
}

.step-label {
  font-weight: 600;
  margin-bottom: 0.25rem;
}

.step-description {
  font-size: 0.875rem;
  color: #666;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .labeled-progress {
    flex-direction: column;
    gap: 1rem;
  }
  
  .numbered-progress {
    padding: 1rem 0;
  }
  
  .progress-step {
    width: 32px;
    height: 32px;
    font-size: 0.875rem;
  }
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Animation Tips</h4>
                    <p>Smooth transitions make progress indicators feel polished:</p>
                    <ul>
                        <li>Animate the progress bar fill with CSS transitions</li>
                        <li>Add a subtle scale animation when completing a step</li>
                        <li>Use color transitions when changing step states</li>
                        <li>Consider a celebratory animation when reaching 100%</li>
                    </ul>
                    <pre><code class="language-css">.progress-step.completed {
  animation: completePulse 0.6s ease;
}

@keyframes completePulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}</code></pre>
                </div>
            </section>

            <!-- Section 6: Conditional Fields -->
            <section id="section6" class="lesson-section">
                <h2>üîÄ Conditional Fields</h2>
                
                <p>Conditional fields show or hide based on the user's previous answers. This creates a dynamic, personalized form experience that only asks relevant questions. Think about forms that ask "Do you have pets?" and only show pet-related questions if you answer "Yes".</p>

                <h3>Basic Conditional Field Pattern</h3>

                <p>The simplest approach uses <code>watch</code> from React Hook Form to monitor field values:</p>

                <pre><code class="language-typescript">import { useForm } from 'react-hook-form';

interface FormData {
  hasPets: boolean;
  petType?: string;
  petName?: string;
}

const ConditionalFieldsBasic: React.FC = () => {
  const { register, watch, handleSubmit } = useForm&lt;FormData&gt;({
    defaultValues: {
      hasPets: false
    }
  });

  // Watch the hasPets field
  const hasPets = watch('hasPets');

  const onSubmit = (data: FormData) => {
    console.log('Form data:', data);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;div className="form-group"&gt;
        &lt;label&gt;
          &lt;input type="checkbox" {...register('hasPets')} /&gt;
          Do you have pets?
        &lt;/label&gt;
      &lt;/div&gt;

      {/* Conditional fields - only show if hasPets is true */}
      {hasPets && (
        &lt;&gt;
          &lt;div className="form-group"&gt;
            &lt;label htmlFor="petType"&gt;Type of Pet&lt;/label&gt;
            &lt;select id="petType" {...register('petType')}&gt;
              &lt;option value=""&gt;Select...&lt;/option&gt;
              &lt;option value="dog"&gt;Dog&lt;/option&gt;
              &lt;option value="cat"&gt;Cat&lt;/option&gt;
              &lt;option value="bird"&gt;Bird&lt;/option&gt;
              &lt;option value="other"&gt;Other&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;

          &lt;div className="form-group"&gt;
            &lt;label htmlFor="petName"&gt;Pet's Name&lt;/label&gt;
            &lt;input id="petName" {...register('petName')} /&gt;
          &lt;/div&gt;
        &lt;/&gt;
      )}

      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ How watch() Works</h4>
                    <p>The <code>watch()</code> function from React Hook Form:</p>
                    <ul>
                        <li>Returns the current value of a field (or all fields if no name provided)</li>
                        <li>Re-renders the component when the watched field changes</li>
                        <li>Is more efficient than subscribing to form state manually</li>
                        <li>Can watch multiple fields: <code>const [field1, field2] = watch(['field1', 'field2'])</code></li>
                    </ul>
                </div>

                <h3>Conditional Validation</h3>

                <p>When fields are conditional, their validation should be conditional too. Use Zod's <code>refine</code> or conditional schemas:</p>

                <pre><code class="language-typescript">import { z } from 'zod';

// Approach 1: Using refine
const conditionalSchema = z.object({
  hasPets: z.boolean(),
  petType: z.string().optional(),
  petName: z.string().optional()
}).refine(
  (data) => {
    // If hasPets is true, petType and petName are required
    if (data.hasPets) {
      return data.petType && data.petName;
    }
    return true;
  },
  {
    message: 'Pet type and name are required when you have pets',
    path: ['petType'] // Which field to attach error to
  }
);

// Approach 2: Conditional schema with discriminated union
const schemaWithPets = z.object({
  hasPets: z.literal(true),
  petType: z.enum(['dog', 'cat', 'bird', 'other']),
  petName: z.string().min(1, 'Pet name is required')
});

const schemaWithoutPets = z.object({
  hasPets: z.literal(false)
});

const betterConditionalSchema = z.discriminatedUnion('hasPets', [
  schemaWithPets,
  schemaWithoutPets
]);

// Usage
const ConditionalValidation: React.FC = () => {
  const {
    register,
    watch,
    handleSubmit,
    formState: { errors }
  } = useForm&lt;FormData&gt;({
    resolver: zodResolver(conditionalSchema)
  });

  const hasPets = watch('hasPets');

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      {/* Form fields */}
      {hasPets && (
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="petType"&gt;Type of Pet *&lt;/label&gt;
          &lt;select id="petType" {...register('petType')}&gt;
            &lt;option value=""&gt;Select...&lt;/option&gt;
            &lt;option value="dog"&gt;Dog&lt;/option&gt;
            &lt;option value="cat"&gt;Cat&lt;/option&gt;
          &lt;/select&gt;
          {errors.petType && (
            &lt;span className="error"&gt;{errors.petType.message}&lt;/span&gt;
          )}
        &lt;/div&gt;
      )}
    &lt;/form&gt;
  );
};</code></pre>

                <h3>Multiple Conditional Levels</h3>

                <p>Sometimes conditionals are nested‚Äîfield B appears if field A is true, and field C appears if field B has a certain value:</p>

                <pre><code class="language-typescript">interface ShippingFormData {
  shippingMethod: 'standard' | 'express' | 'pickup';
  address?: string;
  expressDate?: string;
  pickupLocation?: string;
}

const NestedConditionals: React.FC = () => {
  const { register, watch } = useForm&lt;ShippingFormData&gt;();

  const shippingMethod = watch('shippingMethod');

  return (
    &lt;form&gt;
      &lt;div className="form-group"&gt;
        &lt;label&gt;Shipping Method&lt;/label&gt;
        &lt;select {...register('shippingMethod')}&gt;
          &lt;option value="standard"&gt;Standard Shipping&lt;/option&gt;
          &lt;option value="express"&gt;Express Shipping&lt;/option&gt;
          &lt;option value="pickup"&gt;Store Pickup&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      {/* Show address for standard or express */}
      {(shippingMethod === 'standard' || shippingMethod === 'express') && (
        &lt;div className="form-group"&gt;
          &lt;label&gt;Shipping Address&lt;/label&gt;
          &lt;input {...register('address')} /&gt;
        &lt;/div&gt;
      )}

      {/* Show date picker only for express */}
      {shippingMethod === 'express' && (
        &lt;div className="form-group"&gt;
          &lt;label&gt;Preferred Delivery Date&lt;/label&gt;
          &lt;input type="date" {...register('expressDate')} /&gt;
        &lt;/div&gt;
      )}

      {/* Show pickup location only for pickup */}
      {shippingMethod === 'pickup' && (
        &lt;div className="form-group"&gt;
          &lt;label&gt;Pickup Location&lt;/label&gt;
          &lt;select {...register('pickupLocation')}&gt;
            &lt;option&gt;Downtown Store&lt;/option&gt;
            &lt;option&gt;Mall Location&lt;/option&gt;
            &lt;option&gt;Airport Store&lt;/option&gt;
          &lt;/select&gt;
        &lt;/div&gt;
      )}
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Performance Consideration</h4>
                    <p>Each <code>watch()</code> call causes a re-render when the watched field changes. For forms with many conditional fields:</p>
                    <ul>
                        <li>Watch only the fields you need</li>
                        <li>Consider watching all fields once: <code>const values = watch()</code></li>
                        <li>Use <code>useWatch</code> hook for better performance in complex scenarios</li>
                        <li>Memoize expensive conditional calculations</li>
                    </ul>
                </div>

                <h3>Animated Conditional Fields</h3>

                <p>Make conditional fields appear smoothly with CSS transitions:</p>

                <pre><code class="language-typescript">import { useState, useEffect } from 'react';

const AnimatedConditionalField: React.FC&lt;{
  show: boolean;
  children: React.ReactNode;
}&gt; = ({ show, children }) => {
  const [shouldRender, setShouldRender] = useState(show);

  useEffect(() => {
    if (show) setShouldRender(true);
  }, [show]);

  const handleAnimationEnd = () => {
    if (!show) setShouldRender(false);
  };

  if (!shouldRender) return null;

  return (
    &lt;div
      className={`conditional-field ${show ? 'show' : 'hide'}`}
      onAnimationEnd={handleAnimationEnd}
    &gt;
      {children}
    &lt;/div&gt;
  );
};

// CSS
/*
.conditional-field {
  animation: slideDown 0.3s ease;
  overflow: hidden;
}

.conditional-field.hide {
  animation: slideUp 0.3s ease;
}

@keyframes slideDown {
  from {
    opacity: 0;
    max-height: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    max-height: 500px;
    transform: translateY(0);
  }
}

@keyframes slideUp {
  from {
    opacity: 1;
    max-height: 500px;
    transform: translateY(0);
  }
  to {
    opacity: 0;
    max-height: 0;
    transform: translateY(-10px);
  }
}
*/</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° UX Best Practices for Conditional Fields</h4>
                    <ul>
                        <li><strong>Clear Cause-and-Effect:</strong> Make it obvious why fields appear/disappear</li>
                        <li><strong>Smooth Transitions:</strong> Don't just show/hide‚Äîanimate the change</li>
                        <li><strong>Preserve Scroll Position:</strong> Don't jump the page when fields appear</li>
                        <li><strong>Don't Lose Data:</strong> If user fills conditional field, changes trigger, then changes back‚Äîrestore their data</li>
                        <li><strong>Visual Grouping:</strong> Group conditional fields visually (border, background, indentation)</li>
                        <li><strong>Accessibility:</strong> Announce changes to screen readers with ARIA live regions</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Advanced Conditional Logic -->
            <section id="section7" class="lesson-section">
                <h2>üß© Advanced Conditional Logic</h2>
                
                <p>Real-world forms often have complex conditional logic involving multiple fields, calculations, and business rules. Let's explore patterns for handling sophisticated conditional scenarios.</p>

                <h3>Boolean Logic Combinations</h3>

                <p>Sometimes fields should appear based on complex AND/OR conditions:</p>

                <pre><code class="language-typescript">interface ApplicationFormData {
  applicationType: 'individual' | 'business' | 'nonprofit';
  annualRevenue: number;
  employeeCount: number;
  isInternational: boolean;
}

const ComplexConditionalForm: React.FC = () => {
  const { register, watch } = useForm&lt;ApplicationFormData&gt;();

  const applicationType = watch('applicationType');
  const annualRevenue = watch('annualRevenue');
  const employeeCount = watch('employeeCount');
  const isInternational = watch('isInternational');

  // Complex condition: Show tax ID field if...
  const shouldShowTaxId = 
    applicationType === 'business' || 
    applicationType === 'nonprofit' ||
    (applicationType === 'individual' && annualRevenue > 50000);

  // Show international fields if applicable
  const shouldShowInternationalFields =
    isInternational && (
      applicationType === 'business' || 
      employeeCount > 10
    );

  // Show certification field for large nonprofits
  const shouldShowCertification =
    applicationType === 'nonprofit' && 
    annualRevenue > 100000;

  return (
    &lt;form&gt;
      &lt;div className="form-group"&gt;
        &lt;label&gt;Application Type&lt;/label&gt;
        &lt;select {...register('applicationType')}&gt;
          &lt;option value="individual"&gt;Individual&lt;/option&gt;
          &lt;option value="business"&gt;Business&lt;/option&gt;
          &lt;option value="nonprofit"&gt;Non-Profit&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label&gt;Annual Revenue&lt;/label&gt;
        &lt;input 
          type="number" 
          {...register('annualRevenue', { valueAsNumber: true })} 
        /&gt;
      &lt;/div&gt;

      {shouldShowTaxId && (
        &lt;div className="form-group conditional-section"&gt;
          &lt;label&gt;Tax ID Number *&lt;/label&gt;
          &lt;input {...register('taxId')} /&gt;
          &lt;small&gt;Required for businesses and high-revenue individuals&lt;/small&gt;
        &lt;/div&gt;
      )}

      &lt;div className="form-group"&gt;
        &lt;label&gt;
          &lt;input type="checkbox" {...register('isInternational')} /&gt;
          International Operations
        &lt;/label&gt;
      &lt;/div&gt;

      {shouldShowInternationalFields && (
        &lt;div className="conditional-section"&gt;
          &lt;h3&gt;International Information&lt;/h3&gt;
          &lt;div className="form-group"&gt;
            &lt;label&gt;Primary Country of Operation&lt;/label&gt;
            &lt;input {...register('primaryCountry')} /&gt;
          &lt;/div&gt;
          &lt;div className="form-group"&gt;
            &lt;label&gt;International Tax ID&lt;/label&gt;
            &lt;input {...register('internationalTaxId')} /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {shouldShowCertification && (
        &lt;div className="form-group conditional-section"&gt;
          &lt;label&gt;Non-Profit Certification Number *&lt;/label&gt;
          &lt;input {...register('certificationNumber')} /&gt;
          &lt;small&gt;Required for non-profits with revenue over $100,000&lt;/small&gt;
        &lt;/div&gt;
      )}
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Clean Conditional Logic</h4>
                    <p>Keep your conditional logic maintainable:</p>
                    <ul>
                        <li><strong>Extract to Variables:</strong> Give complex conditions descriptive names</li>
                        <li><strong>Document Business Rules:</strong> Comment why conditions exist</li>
                        <li><strong>Centralize Logic:</strong> Consider a custom hook for complex form rules</li>
                        <li><strong>Test Thoroughly:</strong> Complex conditionals need thorough testing</li>
                    </ul>
                </div>

                <h3>Custom Hook for Conditional Logic</h3>

                <p>For very complex forms, extract conditional logic into a custom hook:</p>

                <pre><code class="language-typescript">interface FormRules {
  shouldShowTaxId: boolean;
  shouldShowInternational: boolean;
  shouldShowCertification: boolean;
  shouldShowPaymentPlan: boolean;
}

const useFormConditionalRules = (
  formValues: ApplicationFormData
): FormRules => {
  const {
    applicationType,
    annualRevenue,
    employeeCount,
    isInternational
  } = formValues;

  // Calculate all conditional rules
  const rules: FormRules = useMemo(() => ({
    shouldShowTaxId:
      applicationType === 'business' || 
      applicationType === 'nonprofit' ||
      (applicationType === 'individual' && annualRevenue > 50000),

    shouldShowInternational:
      isInternational && (
        applicationType === 'business' || 
        employeeCount > 10
      ),

    shouldShowCertification:
      applicationType === 'nonprofit' && 
      annualRevenue > 100000,

    shouldShowPaymentPlan:
      annualRevenue > 0 && annualRevenue < 25000

  }), [applicationType, annualRevenue, employeeCount, isInternational]);

  return rules;
};

// Usage in component
const FormWithRulesHook: React.FC = () => {
  const { register, watch } = useForm&lt;ApplicationFormData&gt;();
  const formValues = watch();
  
  // Get all conditional rules from custom hook
  const rules = useFormConditionalRules(formValues);

  return (
    &lt;form&gt;
      {/* Base fields */}
      
      {rules.shouldShowTaxId && (
        &lt;div&gt;{/* Tax ID field */}&lt;/div&gt;
      )}
      
      {rules.shouldShowInternational && (
        &lt;div&gt;{/* International fields */}&lt;/div&gt;
      )}
      
      {rules.shouldShowCertification && (
        &lt;div&gt;{/* Certification field */}&lt;/div&gt;
      )}
      
      {rules.shouldShowPaymentPlan && (
        &lt;div&gt;{/* Payment plan options */}&lt;/div&gt;
      )}
    &lt;/form&gt;
  );
};</code></pre>

                <h3>Conditional Entire Steps</h3>

                <p>In multi-step forms, entire steps might be conditional:</p>

                <pre><code class="language-typescript">const MultiStepWithConditionalSteps: React.FC = () => {
  const [currentStep, setCurrentStep] = useState(1);
  const [formData, setFormData] = useState&lt;any&gt;({});

  // Determine which steps to show based on data
  const getSteps = () => {
    const baseSteps = [
      { number: 1, component: AccountInfoStep, label: 'Account' },
      { number: 2, component: ShippingStep, label: 'Shipping' }
    ];

    // Add billing step only if shipping !== billing
    if (!formData.sameAsBilling) {
      baseSteps.push({
        number: 3,
        component: BillingStep,
        label: 'Billing'
      });
    }

    // Payment step (number depends on whether billing was shown)
    const paymentStepNumber = formData.sameAsBilling ? 3 : 4;
    baseSteps.push({
      number: paymentStepNumber,
      component: PaymentStep,
      label: 'Payment'
    });

    // Review is always last
    baseSteps.push({
      number: paymentStepNumber + 1,
      component: ReviewStep,
      label: 'Review'
    });

    return baseSteps;
  };

  const steps = getSteps();
  const totalSteps = steps.length;
  const currentStepData = steps.find(s => s.number === currentStep);

  const handleNext = (stepData: any) => {
    setFormData(prev => ({ ...prev, ...stepData }));
    
    if (currentStep < totalSteps) {
      setCurrentStep(prev => prev + 1);
    }
  };

  return (
    &lt;div&gt;
      &lt;ProgressBar currentStep={currentStep} totalSteps={totalSteps} /&gt;
      
      {currentStepData && (
        &lt;currentStepData.component
          onNext={handleNext}
          onBack={() => setCurrentStep(prev => prev - 1)}
          defaultValues={formData}
        /&gt;
      )}
    &lt;/div&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Dynamic Step Numbers</h4>
                    <p>When steps are conditional, step numbers change dynamically. Consider:</p>
                    <ul>
                        <li><strong>Recalculate step numbers</strong> when formData changes</li>
                        <li><strong>Update progress indicators</strong> to reflect actual total steps</li>
                        <li><strong>Adjust navigation logic</strong> to skip over hidden steps</li>
                        <li><strong>Clear data from skipped steps</strong> if those fields are no longer relevant</li>
                    </ul>
                </div>
             <!-- Section 8: Field Dependencies -->
            <section id="section8" class="lesson-section">
                <h2>üîó Field Dependencies</h2>
                
                <p>Field dependencies occur when one field's value affects or determines another field's options, validation, or value. Common examples include country ‚Üí state ‚Üí city cascading dropdowns, or automatic calculations based on other fields.</p>

                <h3>Cascading Dropdowns</h3>

                <p>The classic example: selecting a country determines which states are available, and selecting a state determines which cities appear:</p>

                <pre><code class="language-typescript">import { useEffect } from 'react';
import { useForm, useWatch } from 'react-hook-form';

interface LocationData {
  country: string;
  state: string;
  city: string;
}

// Mock data - in real app, this would come from an API
const locationData = {
  USA: {
    California: ['Los Angeles', 'San Francisco', 'San Diego'],
    Texas: ['Houston', 'Dallas', 'Austin'],
    NewYork: ['New York City', 'Buffalo', 'Rochester']
  },
  Canada: {
    Ontario: ['Toronto', 'Ottawa', 'Mississauga'],
    Quebec: ['Montreal', 'Quebec City', 'Laval'],
    BritishColumbia: ['Vancouver', 'Victoria', 'Surrey']
  }
};

const CascadingDropdowns: React.FC = () => {
  const { register, watch, setValue, resetField } = useForm&lt;LocationData&gt;({
    defaultValues: {
      country: '',
      state: '',
      city: ''
    }
  });

  const selectedCountry = watch('country');
  const selectedState = watch('state');

  // Get available states based on selected country
  const availableStates = selectedCountry 
    ? Object.keys(locationData[selectedCountry as keyof typeof locationData] || {})
    : [];

  // Get available cities based on selected state
  const availableCities = selectedCountry && selectedState
    ? locationData[selectedCountry as keyof typeof locationData]?.[selectedState] || []
    : [];

  // Reset dependent fields when parent changes
  useEffect(() => {
    if (selectedCountry) {
      // Country changed - reset state and city
      resetField('state');
      resetField('city');
    }
  }, [selectedCountry, resetField]);

  useEffect(() => {
    if (selectedState) {
      // State changed - reset city
      resetField('city');
    }
  }, [selectedState, resetField]);

  return (
    &lt;form&gt;
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="country"&gt;Country *&lt;/label&gt;
        &lt;select id="country" {...register('country', { required: true })}&gt;
          &lt;option value=""&gt;Select a country&lt;/option&gt;
          &lt;option value="USA"&gt;United States&lt;/option&gt;
          &lt;option value="Canada"&gt;Canada&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="state"&gt;State/Province *&lt;/label&gt;
        &lt;select 
          id="state" 
          {...register('state', { required: true })}
          disabled={!selectedCountry}
        &gt;
          &lt;option value=""&gt;
            {selectedCountry ? 'Select a state' : 'Select a country first'}
          &lt;/option&gt;
          {availableStates.map(state => (
            &lt;option key={state} value={state}&gt;
              {state}
            &lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="city"&gt;City *&lt;/label&gt;
        &lt;select 
          id="city" 
          {...register('city', { required: true })}
          disabled={!selectedState}
        &gt;
          &lt;option value=""&gt;
            {selectedState ? 'Select a city' : 'Select a state first'}
          &lt;/option&gt;
          {availableCities.map(city => (
            &lt;option key={city} value={city}&gt;
              {city}
            &lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Patterns for Cascading Dropdowns</h4>
                    <ul>
                        <li><strong>Reset Dependent Fields:</strong> Use <code>resetField()</code> when parent changes</li>
                        <li><strong>Disable Children:</strong> Disable dependent fields until parent is selected</li>
                        <li><strong>Clear Messages:</strong> Tell users why a field is disabled</li>
                        <li><strong>Preserve Valid Selections:</strong> Only reset if the selected value is no longer valid</li>
                    </ul>
                </div>

                <h3>Loading Dependent Data from API</h3>

                <p>In real applications, dependent data often comes from an API:</p>

                <pre><code class="language-typescript">const DynamicCascadingDropdowns: React.FC = () => {
  const { register, watch, resetField } = useForm&lt;LocationData&gt;();
  const [states, setStates] = useState&lt;string[]&gt;([]);
  const [cities, setCities] = useState&lt;string[]&gt;([]);
  const [loadingStates, setLoadingStates] = useState(false);
  const [loadingCities, setLoadingCities] = useState(false);

  const selectedCountry = watch('country');
  const selectedState = watch('state');

  // Load states when country changes
  useEffect(() => {
    if (!selectedCountry) {
      setStates([]);
      return;
    }

    const loadStates = async () => {
      setLoadingStates(true);
      try {
        const response = await fetch(`/api/states?country=${selectedCountry}`);
        const data = await response.json();
        setStates(data);
      } catch (error) {
        console.error('Failed to load states:', error);
        setStates([]);
      } finally {
        setLoadingStates(false);
      }
    };

    loadStates();
    resetField('state');
    setCities([]);
    resetField('city');
  }, [selectedCountry, resetField]);

  // Load cities when state changes
  useEffect(() => {
    if (!selectedState) {
      setCities([]);
      return;
    }

    const loadCities = async () => {
      setLoadingCities(true);
      try {
        const response = await fetch(
          `/api/cities?country=${selectedCountry}&state=${selectedState}`
        );
        const data = await response.json();
        setCities(data);
      } catch (error) {
        console.error('Failed to load cities:', error);
        setCities([]);
      } finally {
        setLoadingCities(false);
      }
    };

    loadCities();
    resetField('city');
  }, [selectedState, selectedCountry, resetField]);

  return (
    &lt;form&gt;
      &lt;div className="form-group"&gt;
        &lt;label htmlFor="country"&gt;Country *&lt;/label&gt;
        &lt;select id="country" {...register('country')}&gt;
          &lt;option value=""&gt;Select a country&lt;/option&gt;
          &lt;option value="USA"&gt;United States&lt;/option&gt;
          &lt;option value="Canada"&gt;Canada&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="state"&gt;State/Province *&lt;/label&gt;
        &lt;select 
          id="state" 
          {...register('state')}
          disabled={!selectedCountry || loadingStates}
        &gt;
          &lt;option value=""&gt;
            {loadingStates ? 'Loading...' : 'Select a state'}
          &lt;/option&gt;
          {states.map(state => (
            &lt;option key={state} value={state}&gt;{state}&lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="city"&gt;City *&lt;/label&gt;
        &lt;select 
          id="city" 
          {...register('city')}
          disabled={!selectedState || loadingCities}
        &gt;
          &lt;option value=""&gt;
            {loadingCities ? 'Loading...' : 'Select a city'}
          &lt;/option&gt;
          {cities.map(city => (
            &lt;option key={city} value={city}&gt;{city}&lt;/option&gt;
          ))}
        &lt;/select&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <h3>Calculated Fields</h3>

                <p>Some fields automatically calculate based on other fields:</p>

                <pre><code class="language-typescript">interface InvoiceData {
  quantity: number;
  unitPrice: number;
  subtotal: number;
  taxRate: number;
  taxAmount: number;
  total: number;
  discount: number;
}

const CalculatedFieldsForm: React.FC = () => {
  const { register, watch, setValue } = useForm&lt;InvoiceData&gt;({
    defaultValues: {
      quantity: 1,
      unitPrice: 0,
      taxRate: 10, // 10%
      discount: 0
    }
  });

  const quantity = watch('quantity');
  const unitPrice = watch('unitPrice');
  const taxRate = watch('taxRate');
  const discount = watch('discount');

  // Calculate derived values
  useEffect(() => {
    const subtotal = quantity * unitPrice;
    const discountAmount = (subtotal * discount) / 100;
    const subtotalAfterDiscount = subtotal - discountAmount;
    const taxAmount = (subtotalAfterDiscount * taxRate) / 100;
    const total = subtotalAfterDiscount + taxAmount;

    setValue('subtotal', subtotal);
    setValue('taxAmount', taxAmount);
    setValue('total', total);
  }, [quantity, unitPrice, taxRate, discount, setValue]);

  return (
    &lt;form&gt;
      &lt;div className="form-row"&gt;
        &lt;div className="form-group"&gt;
          &lt;label htmlFor="quantity"&gt;Quantity&lt;/label&gt;
          &lt;input
            id="quantity"
            type="number"
            min="1"
            {...register('quantity', { valueAsNumber: true })}
          /&gt;
        &lt;/div&gt;

        &lt;div className="form-group"&gt;
          &lt;label htmlFor="unitPrice"&gt;Unit Price&lt;/label&gt;
          &lt;input
            id="unitPrice"
            type="number"
            min="0"
            step="0.01"
            {...register('unitPrice', { valueAsNumber: true })}
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="discount"&gt;Discount (%)&lt;/label&gt;
        &lt;input
          id="discount"
          type="number"
          min="0"
          max="100"
          {...register('discount', { valueAsNumber: true })}
        /&gt;
      &lt;/div&gt;

      &lt;div className="form-group"&gt;
        &lt;label htmlFor="taxRate"&gt;Tax Rate (%)&lt;/label&gt;
        &lt;input
          id="taxRate"
          type="number"
          min="0"
          max="100"
          step="0.1"
          {...register('taxRate', { valueAsNumber: true })}
        /&gt;
      &lt;/div&gt;

      {/* Read-only calculated fields */}
      &lt;div className="calculated-fields"&gt;
        &lt;div className="form-group"&gt;
          &lt;label&gt;Subtotal&lt;/label&gt;
          &lt;input
            {...register('subtotal')}
            readOnly
            className="calculated"
          /&gt;
        &lt;/div&gt;

        &lt;div className="form-group"&gt;
          &lt;label&gt;Tax Amount&lt;/label&gt;
          &lt;input
            {...register('taxAmount')}
            readOnly
            className="calculated"
          /&gt;
        &lt;/div&gt;

        &lt;div className="form-group"&gt;
          &lt;label&gt;Total&lt;/label&gt;
          &lt;input
            {...register('total')}
            readOnly
            className="calculated total"
          /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Formatting Calculated Values</h4>
                    <p>Display calculated values in user-friendly formats:</p>
                    <pre><code class="language-typescript">const formatCurrency = (value: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(value);
};

// Display formatted value
&lt;div className="calculated-display"&gt;
  &lt;span&gt;Total: &lt;/span&gt;
  &lt;strong&gt;{formatCurrency(watch('total'))}&lt;/strong&gt;
&lt;/div&gt;</code></pre>
                </div>

                <h3>Field Dependency Hook</h3>

                <p>Extract complex field dependency logic into a reusable hook:</p>

                <pre><code class="language-typescript">interface DependencyConfig&lt;T&gt; {
  sourceField: keyof T;
  targetField: keyof T;
  calculate: (sourceValue: any) => any;
}

const useFieldDependency = &lt;T extends Record&lt;string, any&gt;&gt;(
  control: Control&lt;T&gt;,
  dependencies: DependencyConfig&lt;T&gt;[]
) => {
  const { setValue } = useFormContext&lt;T&gt;();

  dependencies.forEach(({ sourceField, targetField, calculate }) => {
    const sourceValue = useWatch({
      control,
      name: sourceField as string
    });

    useEffect(() => {
      if (sourceValue !== undefined) {
        const calculatedValue = calculate(sourceValue);
        setValue(targetField as string, calculatedValue);
      }
    }, [sourceValue, targetField, calculate, setValue]);
  });
};

// Usage
const FormWithDependencies: React.FC = () => {
  const { control } = useForm&lt;InvoiceData&gt;();

  useFieldDependency(control, [
    {
      sourceField: 'quantity',
      targetField: 'subtotal',
      calculate: (qty) => qty * watch('unitPrice')
    },
    // More dependencies...
  ]);

  return &lt;form&gt;{/* ... */}&lt;/form&gt;;
};</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Performance with Dependencies</h4>
                    <p>Be mindful of performance when dealing with field dependencies:</p>
                    <ul>
                        <li><strong>Avoid Circular Dependencies:</strong> Field A ‚Üí Field B ‚Üí Field A creates infinite loops</li>
                        <li><strong>Debounce Expensive Calculations:</strong> Don't recalculate on every keystroke</li>
                        <li><strong>Memoize Complex Calculations:</strong> Use <code>useMemo</code> for expensive operations</li>
                        <li><strong>Batch Updates:</strong> Update multiple dependent fields together</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Auto-Save Implementation -->
            <section id="section9" class="lesson-section">
                <h2>üíæ Auto-Save Implementation</h2>
                
                <p>Auto-save is a critical feature for long forms. It prevents data loss if users accidentally close the browser, lose connection, or navigate away. Let's implement robust auto-save functionality.</p>

                <h3>Basic Auto-Save to localStorage</h3>

                <pre><code class="language-typescript">import { useEffect } from 'react';
import { useForm } from 'react-hook-form';

const STORAGE_KEY = 'form-draft';
const AUTO_SAVE_DELAY = 2000; // 2 seconds

const AutoSaveForm: React.FC = () => {
  const { register, watch, reset } = useForm({
    defaultValues: () => {
      // Load saved data on mount
      const saved = localStorage.getItem(STORAGE_KEY);
      return saved ? JSON.parse(saved) : {};
    }
  });

  const formData = watch();

  // Auto-save to localStorage
  useEffect(() => {
    const timer = setTimeout(() => {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(formData));
      console.log('Form auto-saved');
    }, AUTO_SAVE_DELAY);

    return () => clearTimeout(timer);
  }, [formData]);

  const handleSubmit = (data: any) => {
    console.log('Submitting:', data);
    // Clear saved draft on successful submit
    localStorage.removeItem(STORAGE_KEY);
  };

  const clearDraft = () => {
    localStorage.removeItem(STORAGE_KEY);
    reset({});
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      {/* Form fields */}
      
      &lt;div className="form-actions"&gt;
        &lt;button type="button" onClick={clearDraft}&gt;
          Clear Draft
        &lt;/button&gt;
        &lt;button type="submit"&gt;
          Submit
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ How This Auto-Save Works</h4>
                    <ol>
                        <li><strong>Load on Mount:</strong> Check localStorage for saved draft when component mounts</li>
                        <li><strong>Watch All Fields:</strong> <code>watch()</code> without arguments watches all form fields</li>
                        <li><strong>Debounced Save:</strong> Use <code>setTimeout</code> to save after user stops typing</li>
                        <li><strong>Clear on Submit:</strong> Remove draft after successful submission</li>
                    </ol>
                </div>

                <h3>Auto-Save with Visual Feedback</h3>

                <p>Show users when their work is being saved:</p>

                <pre><code class="language-typescript">type SaveStatus = 'idle' | 'saving' | 'saved' | 'error';

const AutoSaveWithFeedback: React.FC = () => {
  const { register, watch, formState } = useForm();
  const [saveStatus, setSaveStatus] = useState&lt;SaveStatus&gt;('idle');
  const [lastSaved, setLastSaved] = useState&lt;Date | null&gt;(null);

  const formData = watch();

  useEffect(() => {
    if (formState.isDirty) {
      setSaveStatus('saving');

      const timer = setTimeout(() => {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(formData));
          setSaveStatus('saved');
          setLastSaved(new Date());
          
          // Reset to idle after 2 seconds
          setTimeout(() => setSaveStatus('idle'), 2000);
        } catch (error) {
          console.error('Auto-save failed:', error);
          setSaveStatus('error');
        }
      }, AUTO_SAVE_DELAY);

      return () => clearTimeout(timer);
    }
  }, [formData, formState.isDirty]);

  const formatLastSaved = () => {
    if (!lastSaved) return '';
    const seconds = Math.floor((Date.now() - lastSaved.getTime()) / 1000);
    if (seconds < 60) return 'just now';
    if (seconds < 3600) return `${Math.floor(seconds / 60)} minutes ago`;
    return lastSaved.toLocaleTimeString();
  };

  return (
    &lt;div&gt;
      {/* Save status indicator */}
      &lt;div className={`save-status ${saveStatus}`}&gt;
        {saveStatus === 'saving' && (
          &lt;span&gt;üíæ Saving...&lt;/span&gt;
        )}
        {saveStatus === 'saved' && (
          &lt;span&gt;‚úì Saved {formatLastSaved()}&lt;/span&gt;
        )}
        {saveStatus === 'error' && (
          &lt;span&gt;‚ö†Ô∏è Failed to save&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;form&gt;
        {/* Form fields */}
      &lt;/form&gt;
    &lt;/div&gt;
  );
};</code></pre>

                <h3>Auto-Save Hook</h3>

                <p>Create a reusable auto-save hook:</p>

                <pre><code class="language-typescript">interface UseAutoSaveOptions {
  key: string;
  delay?: number;
  onSave?: (data: any) => void | Promise&lt;void&gt;;
  onError?: (error: Error) => void;
}

const useAutoSave = &lt;T extends Record&lt;string, any&gt;&gt;(
  formData: T,
  options: UseAutoSaveOptions
) => {
  const { key, delay = 2000, onSave, onError } = options;
  const [status, setStatus] = useState&lt;SaveStatus&gt;('idle');
  const [lastSaved, setLastSaved] = useState&lt;Date | null&gt;(null);

  useEffect(() => {
    setStatus('saving');

    const timer = setTimeout(async () => {
      try {
        // Save to localStorage
        localStorage.setItem(key, JSON.stringify(formData));

        // Call custom save function if provided
        if (onSave) {
          await onSave(formData);
        }

        setStatus('saved');
        setLastSaved(new Date());

        // Reset to idle after showing "saved" message
        setTimeout(() => setStatus('idle'), 2000);
      } catch (error) {
        console.error('Auto-save failed:', error);
        setStatus('error');
        if (onError && error instanceof Error) {
          onError(error);
        }
      }
    }, delay);

    return () => clearTimeout(timer);
  }, [formData, key, delay, onSave, onError]);

  const clearSaved = () => {
    localStorage.removeItem(key);
    setStatus('idle');
    setLastSaved(null);
  };

  return { status, lastSaved, clearSaved };
};

// Usage
const FormWithAutoSaveHook: React.FC = () => {
  const { register, watch } = useForm();
  const formData = watch();

  const { status, lastSaved } = useAutoSave(formData, {
    key: 'my-form-draft',
    delay: 2000,
    onSave: async (data) => {
      // Optional: save to server
      await fetch('/api/drafts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });
    },
    onError: (error) => {
      console.error('Save failed:', error);
      alert('Failed to save draft');
    }
  });

  return (
    &lt;div&gt;
      &lt;SaveStatusIndicator status={status} lastSaved={lastSaved} /&gt;
      &lt;form&gt;{/* Form fields */}&lt;/form&gt;
    &lt;/div&gt;
  );
};</code></pre>

                <h3>Auto-Save to Server</h3>

                <p>For critical data, save to your server instead of (or in addition to) localStorage:</p>

                <pre><code class="language-typescript">const useServerAutoSave = &lt;T,&gt;(
  formData: T,
  draftId: string | null,
  options: {
    delay?: number;
    endpoint?: string;
  } = {}
) => {
  const { delay = 3000, endpoint = '/api/drafts' } = options;
  const [status, setStatus] = useState&lt;SaveStatus&gt;('idle');
  const [savedDraftId, setSavedDraftId] = useState&lt;string | null&gt;(draftId);

  useEffect(() => {
    setStatus('saving');

    const timer = setTimeout(async () => {
      try {
        const url = savedDraftId 
          ? `${endpoint}/${savedDraftId}` 
          : endpoint;
        
        const method = savedDraftId ? 'PUT' : 'POST';

        const response = await fetch(url, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });

        if (!response.ok) {
          throw new Error('Server save failed');
        }

        const result = await response.json();
        
        // Save draft ID for future updates
        if (!savedDraftId && result.id) {
          setSavedDraftId(result.id);
        }

        setStatus('saved');
        setTimeout(() => setStatus('idle'), 2000);
      } catch (error) {
        console.error('Server auto-save failed:', error);
        setStatus('error');
      }
    }, delay);

    return () => clearTimeout(timer);
  }, [formData, savedDraftId, endpoint, delay]);

  return { status, draftId: savedDraftId };
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Auto-Save Best Practices</h4>
                    <ul>
                        <li><strong>Debounce:</strong> Don't save on every keystroke‚Äîwait for user to pause</li>
                        <li><strong>Show Status:</strong> Always indicate saving/saved/error state</li>
                        <li><strong>Handle Errors:</strong> Gracefully handle save failures, offer retry</li>
                        <li><strong>Clear on Submit:</strong> Remove drafts after successful submission</li>
                        <li><strong>Offline Support:</strong> Use localStorage as fallback when server is unavailable</li>
                        <li><strong>Version Conflicts:</strong> Handle cases where same form is open in multiple tabs</li>
                        <li><strong>Privacy:</strong> Clear sensitive data from localStorage after session ends</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è localStorage Limitations</h4>
                    <ul>
                        <li><strong>Size Limit:</strong> Usually 5-10MB per domain</li>
                        <li><strong>Security:</strong> Data is not encrypted, accessible via JavaScript</li>
                        <li><strong>Synchronous:</strong> Can block the main thread with large data</li>
                        <li><strong>Browser-Specific:</strong> Not shared across browsers or devices</li>
                        <li><strong>Incognito Mode:</strong> Cleared when closing incognito window</li>
                    </ul>
                    <p>For large or sensitive data, prefer server-side saving!</p>
                </div>
            </section>

            <!-- Section 10: Form Wizards -->
            <section id="section10" class="lesson-section">
                <h2>üßô Form Wizards</h2>
                
                <p>A form wizard is a specialized multi-step form that guides users through a specific process with clear instructions at each step. Wizards are great for complex workflows like product configuration, account setup, or onboarding.</p>

                <h3>Wizard vs. Regular Multi-Step Form</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Multi-Step Form</th>
                            <th>Form Wizard</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Purpose</strong></td>
                            <td>Data collection</td>
                            <td>Guided process</td>
                        </tr>
                        <tr>
                            <td><strong>Navigation</strong></td>
                            <td>Linear, can go back</td>
                            <td>Linear, sometimes can't skip ahead</td>
                        </tr>
                        <tr>
                            <td><strong>Instructions</strong></td>
                            <td>Minimal</td>
                            <td>Rich guidance at each step</td>
                        </tr>
                        <tr>
                            <td><strong>Steps</strong></td>
                            <td>Usually 2-5 steps</td>
                            <td>Can be 5-10+ steps</td>
                        </tr>
                        <tr>
                            <td><strong>Complexity</strong></td>
                            <td>Simple to moderate</td>
                            <td>Moderate to high</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Complete Wizard Implementation</h3>

                <pre><code class="language-typescript">interface WizardStep {
  id: string;
  title: string;
  description: string;
  component: React.ComponentType&lt;StepComponentProps&gt;;
  canSkip?: boolean;
  icon?: string;
}

interface WizardContextValue {
  currentStepIndex: number;
  steps: WizardStep[];
  formData: any;
  goToStep: (index: number) => void;
  nextStep: (data: any) => void;
  previousStep: () => void;
  canGoToStep: (index: number) => boolean;
  isFirstStep: boolean;
  isLastStep: boolean;
  completedSteps: Set&lt;number&gt;;
}

const WizardContext = createContext&lt;WizardContextValue | null&gt;(null);

export const useWizard = () => {
  const context = useContext(WizardContext);
  if (!context) {
    throw new Error('useWizard must be used within WizardProvider');
  }
  return context;
};

const WizardProvider: React.FC&lt;{
  steps: WizardStep[];
  onComplete: (data: any) => void;
  children: React.ReactNode;
}&gt; = ({ steps, onComplete, children }) => {
  const [currentStepIndex, setCurrentStepIndex] = useState(0);
  const [formData, setFormData] = useState&lt;any&gt;({});
  const [completedSteps, setCompletedSteps] = useState&lt;Set&lt;number&gt;&gt;(
    new Set()
  );

  const isFirstStep = currentStepIndex === 0;
  const isLastStep = currentStepIndex === steps.length - 1;

  const canGoToStep = (index: number): boolean => {
    // Can go to current step or any completed step
    if (index === currentStepIndex) return true;
    if (completedSteps.has(index)) return true;
    
    // Can go to next step if current is completed
    if (index === currentStepIndex + 1 && completedSteps.has(currentStepIndex)) {
      return true;
    }
    
    return false;
  };

  const goToStep = (index: number) => {
    if (canGoToStep(index)) {
      setCurrentStepIndex(index);
    }
  };

  const nextStep = (stepData: any) => {
    // Save step data
    const updatedFormData = { ...formData, ...stepData };
    setFormData(updatedFormData);

    // Mark current step as completed
    setCompletedSteps(prev => new Set([...prev, currentStepIndex]));

    if (isLastStep) {
      // Submit complete form
      onComplete(updatedFormData);
    } else {
      // Move to next step
      setCurrentStepIndex(prev => prev + 1);
    }
  };

  const previousStep = () => {
    if (!isFirstStep) {
      setCurrentStepIndex(prev => prev - 1);
    }
  };

  const value: WizardContextValue = {
    currentStepIndex,
    steps,
    formData,
    goToStep,
    nextStep,
    previousStep,
    canGoToStep,
    isFirstStep,
    isLastStep,
    completedSteps
  };

  return (
    &lt;WizardContext.Provider value={value}&gt;
      {children}
    &lt;/WizardContext.Provider&gt;
  );
};

// Main Wizard Component
const Wizard: React.FC&lt;{
  steps: WizardStep[];
  onComplete: (data: any) => void;
}&gt; = ({ steps, onComplete }) => {
  return (
    &lt;WizardProvider steps={steps} onComplete={onComplete}&gt;
      &lt;WizardContainer /&gt;
    &lt;/WizardProvider&gt;
  );
};

const WizardContainer: React.FC = () => {
  const {
    currentStepIndex,
    steps,
    formData,
    completedSteps,
    goToStep,
    canGoToStep
  } = useWizard();

  const currentStep = steps[currentStepIndex];
  const StepComponent = currentStep.component;

  return (
    &lt;div className="wizard-container"&gt;
      {/* Wizard Header */}
      &lt;div className="wizard-header"&gt;
        &lt;h1&gt;Setup Wizard&lt;/h1&gt;
        &lt;p&gt;Complete the steps below to finish setup&lt;/p&gt;
      &lt;/div&gt;

      {/* Step Progress */}
      &lt;div className="wizard-progress"&gt;
        {steps.map((step, index) => (
          &lt;button
            key={step.id}
            onClick={() => goToStep(index)}
            disabled={!canGoToStep(index)}
            className={`
              wizard-step
              ${index === currentStepIndex ? 'active' : ''}
              ${completedSteps.has(index) ? 'completed' : ''}
            `}
          &gt;
            &lt;div className="step-number"&gt;
              {completedSteps.has(index) ? '‚úì' : index + 1}
            &lt;/div&gt;
            &lt;div className="step-info"&gt;
              &lt;div className="step-title"&gt;{step.title}&lt;/div&gt;
              &lt;div className="step-description"&gt;{step.description}&lt;/div&gt;
            &lt;/div&gt;
          &lt;/button&gt;
        ))}
      &lt;/div&gt;

      {/* Current Step Content */}
      &lt;div className="wizard-content"&gt;
        &lt;div className="step-header"&gt;
          {currentStep.icon && (
            &lt;span className="step-icon"&gt;{currentStep.icon}&lt;/span&gt;
          )}
          &lt;h2&gt;{currentStep.title}&lt;/h2&gt;
          &lt;p&gt;{currentStep.description}&lt;/p&gt;
        &lt;/div&gt;

        &lt;StepComponent defaultValues={formData} /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};</code></pre>

                <h3>Step Component Interface</h3>

                <pre><code class="language-typescript">interface StepComponentProps {
  defaultValues?: any;
}

// Example step component
const AccountSetupStep: React.FC&lt;StepComponentProps&gt; = ({ defaultValues }) => {
  const { nextStep, previousStep, isFirstStep } = useWizard();
  
  const {
    register,
    handleSubmit,
    formState: { errors }
  } = useForm({
    defaultValues
  });

  const onSubmit = (data: any) => {
    nextStep(data);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      {/* Form fields */}
      
      &lt;div className="wizard-actions"&gt;
        {!isFirstStep && (
          &lt;button type="button" onClick={previousStep}&gt;
            ‚Üê Back
          &lt;/button&gt;
        )}
        &lt;button type="submit"&gt;
          Continue ‚Üí
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Wizard Best Practices</h4>
                    <ul>
                        <li><strong>Clear Progress:</strong> Show exactly where users are in the process</li>
                        <li><strong>Skip Options:</strong> Allow skipping optional steps</li>
                        <li><strong>Save Progress:</strong> Auto-save so users can return later</li>
                        <li><strong>Review Step:</strong> Include a final review before submission</li>
                        <li><strong>Help Text:</strong> Provide guidance at each step</li>
                        <li><strong>Validation:</strong> Validate each step before proceeding</li>
                        <li><strong>Exit Warning:</strong> Warn users if they try to leave incomplete wizard</li>
                    </ul>
                </div>

                <h3>Wizard with Review Step</h3>

                <pre><code class="language-typescript">const ReviewStep: React.FC&lt;StepComponentProps&gt; = () => {
  const { formData, previousStep, nextStep, goToStep, steps } = useWizard();

  const handleSubmit = () => {
    nextStep({}); // Triggers onComplete in WizardProvider
  };

  return (
    &lt;div className="review-step"&gt;
      &lt;h2&gt;Review Your Information&lt;/h2&gt;
      &lt;p&gt;Please review your information before submitting.&lt;/p&gt;

      {/* Display all collected data */}
      {steps.slice(0, -1).map((step, index) => {
        const stepData = formData[step.id] || {};
        const hasData = Object.keys(stepData).length > 0;

        if (!hasData) return null;

        return (
          &lt;div key={step.id} className="review-section"&gt;
            &lt;div className="review-section-header"&gt;
              &lt;h3&gt;{step.title}&lt;/h3&gt;
              &lt;button
                type="button"
                onClick={() => goToStep(index)}
                className="edit-button"
              &gt;
                Edit
              &lt;/button&gt;
            &lt;/div&gt;

            &lt;dl className="review-data"&gt;
              {Object.entries(stepData).map(([key, value]) => (
                &lt;div key={key} className="review-item"&gt;
                  &lt;dt&gt;{formatFieldName(key)}&lt;/dt&gt;
                  &lt;dd&gt;{String(value)}&lt;/dd&gt;
                &lt;/div&gt;
              ))}
            &lt;/dl&gt;
          &lt;/div&gt;
        );
      })}

      &lt;div className="wizard-actions"&gt;
        &lt;button type="button" onClick={previousStep}&gt;
          ‚Üê Back
        &lt;/button&gt;
        &lt;button
          type="button"
          onClick={handleSubmit}
          className="btn-primary"
        &gt;
          Submit
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

// Helper function
const formatFieldName = (key: string): string => {
  return key
    .replace(/([A-Z])/g, ' $1')
    .replace(/^./, (str) => str.toUpperCase())
    .trim();
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Wizard CSS Tips</h4>
                    <pre><code class="language-css">/* Wizard container */
.wizard-container {
  max-width: 900px;
  margin: 0 auto;
  padding: 2rem;
}

/* Progress steps */
.wizard-progress {
  display: flex;
  gap: 1rem;
  margin: 2rem 0;
  overflow-x: auto;
}

.wizard-step {
  flex: 1;
  min-width: 200px;
  padding: 1rem;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  background: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

.wizard-step.active {
  border-color: #667eea;
  background: #f0f4ff;
}

.wizard-step.completed {
  border-color: #4CAF50;
}

.wizard-step:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Review step */
.review-section {
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  padding: 1.5rem;
  margin-bottom: 1.5rem;
}

.review-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.review-data {
  display: grid;
  grid-template-columns: 150px 1fr;
  gap: 0.75rem;
}

.review-item dt {
  font-weight: 600;
  color: #666;
}

.review-item dd {
  margin: 0;
}</code></pre>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_7_4_file_uploads_c.html" class="prev-lesson">‚Üê Previous: Lesson 7.4 File Uploads</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="module_project_7_registration_system.html" class="next-lesson">Next: Module 7 Project ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals through comprehensive React and TypeScript education.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
