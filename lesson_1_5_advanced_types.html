<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master TypeScript's advanced type system - union types, intersection types, type guards, generics, utility types, conditional types, and template literal types for building robust React applications.">
    <meta name="author" content="PracticalAce">
    <title>Advanced Types - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module1">Module 1: TypeScript Fundamentals</a></li>
            <li aria-current="page">Lesson 1.5: Advanced Types</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üéØ Advanced Types</h1>
                <p class="lead">Welcome to the grand finale of TypeScript Fundamentals! You've built a solid foundation - now it's time to unlock TypeScript's true superpowers. Advanced types are where TypeScript transforms from "helpful" to "indispensable." These tools will let you express complex ideas with precision, catch bugs before they happen, and write code that practically documents itself. Get ready to level up! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Use union and intersection types to model complex data structures</li>
                        <li>Implement type guards for runtime type safety</li>
                        <li>Create generic functions and components for maximum reusability</li>
                        <li>Master utility types to transform existing types</li>
                        <li>Write conditional types for advanced type logic</li>
                        <li>Use template literal types for type-safe string manipulation</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a type-safe data processor showcasing all advanced type features</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Union Types</a></li>
                        <li><a href="#section2" class="toc-link">Intersection Types</a></li>
                        <li><a href="#section3" class="toc-link">Type Guards & Narrowing</a></li>
                        <li><a href="#section4" class="toc-link">Generics</a></li>
                        <li><a href="#section5" class="toc-link">Utility Types</a></li>
                        <li><a href="#section6" class="toc-link">Conditional Types</a></li>
                        <li><a href="#section7" class="toc-link">Template Literal Types</a></li>
                        <li><a href="#section8" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Union Types -->
            <section id="section1" class="lesson-section">
                <h2>üîÄ Union Types</h2>
                <p>Union types let a value be one of several types. Think of it like a restaurant menu where you choose "soup OR salad" - the value must be one option, but you get to choose which. This is incredibly useful when a value can legitimately have different shapes in different contexts.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Union Type:</strong> A type formed from two or more types, representing values that may be any one of those types. We use the pipe symbol <code style="color: white;">|</code> to create unions.</p>
                </div>

                <h3>Basic Union Types</h3>
                <p>Let's start with simple examples:</p>

                <pre><code class="language-typescript">// A value that can be a string OR a number
let id: string | number;

id = "abc123";      // ‚úÖ Valid
id = 42;            // ‚úÖ Valid
id = true;          // ‚ùå Error: Type 'boolean' is not assignable

// Union with literal types - perfect for status values
type Status = "pending" | "approved" | "rejected";

let orderStatus: Status;
orderStatus = "pending";    // ‚úÖ Valid
orderStatus = "shipped";    // ‚ùå Error: not in union

// Function accepting union type
function formatId(id: string | number): string {
    return `ID: ${id}`;
}

console.log(formatId("ABC"));  // "ID: ABC"
console.log(formatId(123));    // "ID: 123"</code></pre>

                <h3>Working with Union Types</h3>
                <p>When you have a union type, TypeScript only lets you access properties that exist on <strong>all</strong> types in the union:</p>

                <pre><code class="language-typescript">interface Bird {
    fly(): void;
    layEggs(): void;
}

interface Fish {
    swim(): void;
    layEggs(): void;
}

function getPet(): Bird | Fish {
    // ... returns either a Bird or Fish
    return { layEggs: () => console.log("Laying eggs") } as Bird;
}

let pet = getPet();
pet.layEggs();  // ‚úÖ OK - both Bird and Fish have layEggs()
// pet.fly();   // ‚ùå Error - Fish doesn't have fly()
// pet.swim();  // ‚ùå Error - Bird doesn't have swim()</code></pre>

                <h3>Discriminated Unions (Tagged Unions)</h3>
                <p>One of the most powerful patterns in TypeScript! Add a common property to distinguish between union members:</p>

                <pre><code class="language-typescript">// Discriminated union for payment methods
type PaymentMethod = 
    | { type: "credit_card"; cardNumber: string; cvv: string }
    | { type: "paypal"; email: string }
    | { type: "bank_transfer"; accountNumber: string; routingNumber: string };

function processPayment(payment: PaymentMethod): string {
    // TypeScript knows which properties are available based on 'type'
    switch (payment.type) {
        case "credit_card":
            return `Processing credit card ending in ${payment.cardNumber.slice(-4)}`;
        case "paypal":
            return `Processing PayPal payment for ${payment.email}`;
        case "bank_transfer":
            return `Processing bank transfer from account ${payment.accountNumber}`;
    }
}

// Usage with full type safety
const payment: PaymentMethod = {
    type: "credit_card",
    cardNumber: "1234-5678-9012-3456",
    cvv: "123"
};

console.log(processPayment(payment));</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Discriminated Unions in React</h4>
                    <p>Discriminated unions are <em>perfect</em> for React component props! They let you create components with different "modes" that have different required props. For example, a Button component that's either a regular button, a link, or a submit button - each with its own specific props.</p>
                </div>

                <div class="mermaid">
                    graph LR
                    A[Union Type] --> B[Option 1: string]
                    A --> C[Option 2: number]
                    A --> D[Option 3: boolean]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style B fill:#f0f0f0
                    style C fill:#f0f0f0
                    style D fill:#f0f0f0
                </div>
            </section>

            <!-- Section 2: Intersection Types -->
            <section id="section2" class="lesson-section">
                <h2>üîó Intersection Types</h2>
                <p>While union types represent "OR" logic, intersection types represent "AND" logic. An intersection combines multiple types into one. Think of it like creating a superhero with multiple powers - they need ALL the abilities! ü¶∏‚Äç‚ôÇÔ∏è</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Intersection Type:</strong> A type that combines multiple types. A value must satisfy ALL the combined types. We use the ampersand symbol <code style="color: white;">&</code> to create intersections.</p>
                </div>

                <h3>Basic Intersection Types</h3>

                <pre><code class="language-typescript">interface Person {
    name: string;
    age: number;
}

interface Employee {
    employeeId: string;
    department: string;
}

// Intersection type - must have ALL properties from both types
type StaffMember = Person & Employee;

const john: StaffMember = {
    name: "John Doe",
    age: 30,
    employeeId: "EMP001",
    department: "Engineering"
};

// Missing any property would be an error
const jane: StaffMember = {
    name: "Jane Smith",
    age: 28
    // ‚ùå Error: Missing employeeId and department
};</code></pre>

                <h3>Combining Multiple Types</h3>
                <p>Intersection types really shine when combining multiple behaviors:</p>

                <pre><code class="language-typescript">// Base props for all components
interface BaseProps {
    id: string;
    className?: string;
}

// Props specific to clickable elements
interface Clickable {
    onClick: () => void;
    disabled?: boolean;
}

// Props specific to form inputs
interface FormField {
    name: string;
    value: string;
    onChange: (value: string) => void;
}

// Combine them for a clickable form input!
type ClickableInput = BaseProps & Clickable & FormField;

// Must provide ALL required properties
const inputProps: ClickableInput = {
    id: "user-input",
    className: "fancy-input",
    name: "username",
    value: "John",
    onChange: (val) => console.log(val),
    onClick: () => console.log("Clicked!"),
    disabled: false
};</code></pre>

                <h3>Union + Intersection = Power! üí™</h3>
                <p>Combine both concepts for sophisticated type definitions:</p>

                <pre><code class="language-typescript">type Admin = {
    role: "admin";
    permissions: string[];
};

type User = {
    role: "user";
    lastLogin: Date;
};

type Guest = {
    role: "guest";
};

// Union of all account types
type Account = Admin | User | Guest;

// Add common properties to all accounts
type TrackedAccount = Account & {
    id: string;
    email: string;
    createdAt: Date;
};

// Now every account must have id, email, createdAt
// PLUS the properties from their specific role type
const adminAccount: TrackedAccount = {
    id: "001",
    email: "admin@example.com",
    createdAt: new Date(),
    role: "admin",
    permissions: ["read", "write", "delete"]
};</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Union Types (|)</th>
                            <th>Intersection Types (&)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Logic</strong></td>
                            <td>OR - can be one of several types</td>
                            <td>AND - must have all properties</td>
                        </tr>
                        <tr>
                            <td><strong>Properties</strong></td>
                            <td>Only common properties accessible</td>
                            <td>All properties from all types</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>Multiple possible shapes</td>
                            <td>Combining multiple behaviors</td>
                        </tr>
                        <tr>
                            <td><strong>Example</strong></td>
                            <td>string | number</td>
                            <td>Person & Employee</td>
                        </tr>
                        <tr>
                            <td><strong>React Use</strong></td>
                            <td>Component variants/modes</td>
                            <td>Extending component props</td>
                        </tr>
                    </tbody>
                </table>

                <div class="mermaid">
                    graph TD
                    A[Intersection Type] --> B[Type 1 Properties]
                    A --> C[Type 2 Properties]
                    A --> D[Type 3 Properties]
                    E[Result] --> B
                    E --> C
                    E --> D
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>
                        <!-- Section 3: Type Guards & Narrowing -->
            <section id="section3" class="lesson-section">
                <h2>üõ°Ô∏è Type Guards and Type Narrowing</h2>
                <p>Type guards are like security checkpoints for your code. They help TypeScript understand what type a value is at runtime, allowing you to safely access type-specific properties. This process is called "type narrowing" - taking a broader type and narrowing it down to something more specific. üîç</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Type Guard:</strong> A runtime check that narrows the type of a variable within a conditional block. Type guards help TypeScript understand what type you're working with at any given moment.</p>
                </div>

                <h3>Built-in Type Guards</h3>
                <p>TypeScript recognizes several built-in type guards automatically:</p>

                <h4>typeof Type Guard</h4>
                <p>Perfect for primitive types:</p>

                <pre><code class="language-typescript">function processValue(value: string | number) {
    if (typeof value === "string") {
        // TypeScript knows value is a string here
        console.log(value.toUpperCase());
        console.log(value.length);
    } else {
        // TypeScript knows value is a number here
        console.log(value.toFixed(2));
        console.log(value * 2);
    }
}

processValue("hello");  // "HELLO", 5
processValue(42);       // "42.00", 84</code></pre>

                <h4>instanceof Type Guard</h4>
                <p>Great for checking class instances:</p>

                <pre><code class="language-typescript">class Dog {
    bark() {
        return "Woof!";
    }
}

class Cat {
    meow() {
        return "Meow!";
    }
}

function makeSound(animal: Dog | Cat) {
    if (animal instanceof Dog) {
        // TypeScript knows animal is a Dog
        console.log(animal.bark());
    } else {
        // TypeScript knows animal is a Cat
        console.log(animal.meow());
    }
}

makeSound(new Dog());  // "Woof!"
makeSound(new Cat());  // "Meow!"</code></pre>

                <h4>in Operator Type Guard</h4>
                <p>Check if a property exists on an object:</p>

                <pre><code class="language-typescript">interface Car {
    drive(): void;
    wheels: number;
}

interface Boat {
    sail(): void;
    propeller: boolean;
}

function operateVehicle(vehicle: Car | Boat) {
    if ("drive" in vehicle) {
        // TypeScript knows vehicle is a Car
        console.log(`Driving with ${vehicle.wheels} wheels`);
        vehicle.drive();
    } else {
        // TypeScript knows vehicle is a Boat
        console.log(`Sailing with propeller: ${vehicle.propeller}`);
        vehicle.sail();
    }
}</code></pre>

                <h3>Custom Type Guards</h3>
                <p>Create your own type guard functions using type predicates. This is where things get really powerful! üí™</p>

                <pre><code class="language-typescript">interface Success {
    status: "success";
    data: any;
}

interface Error {
    status: "error";
    message: string;
}

type Response = Success | Error;

// Custom type guard function with type predicate
function isSuccess(response: Response): response is Success {
    return response.status === "success";
}

function handleResponse(response: Response) {
    if (isSuccess(response)) {
        // TypeScript knows response is Success
        console.log("Data:", response.data);
    } else {
        // TypeScript knows response is Error
        console.log("Error:", response.message);
    }
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Real-World Example: Form Validation</h3>
                    
                    <pre><code class="language-typescript">interface EmailField {
    type: "email";
    value: string;
    domain: string;
}

interface PhoneField {
    type: "phone";
    value: string;
    countryCode: string;
}

interface TextField {
    type: "text";
    value: string;
    maxLength: number;
}

type FormField = EmailField | PhoneField | TextField;

// Type guard functions
function isEmailField(field: FormField): field is EmailField {
    return field.type === "email";
}

function isPhoneField(field: FormField): field is PhoneField {
    return field.type === "phone";
}

// Validation function with type safety
function validateField(field: FormField): boolean {
    if (isEmailField(field)) {
        // Can safely access email-specific properties
        return field.value.includes("@") && field.domain.length > 0;
    } else if (isPhoneField(field)) {
        // Can safely access phone-specific properties
        return field.value.length >= 10 && field.countryCode.length > 0;
    } else {
        // Must be TextField
        return field.value.length <= field.maxLength;
    }
}

// Usage
const emailField: EmailField = {
    type: "email",
    value: "user@example.com",
    domain: "example.com"
};

console.log(validateField(emailField));  // true</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Type Guards Are Runtime Checks</h4>
                    <p>Type guards only work at runtime! TypeScript uses them for compile-time type checking, but the actual checking happens when your code runs. Make sure your type guard logic accurately reflects the runtime structure of your data, or you might have type safety issues.</p>
                </div>

                <h3>Truthiness Narrowing</h3>
                <p>TypeScript also narrows types based on truthiness checks:</p>

                <pre><code class="language-typescript">function printName(name: string | null | undefined) {
    if (name) {
        // TypeScript narrows to string
        console.log(name.toUpperCase());
    } else {
        // TypeScript knows name is null or undefined
        console.log("No name provided");
    }
}

// Also works with arrays
function processItems(items: string[] | null) {
    if (items && items.length > 0) {
        // TypeScript knows items is string[] and not empty
        items.forEach(item => console.log(item));
    }
}</code></pre>

                <div class="mermaid">
                    graph TD
                    A[Union Type: Bird | Fish] --> B{Type Guard Check}
                    B -->|is Bird| C[TypeScript knows: Bird<br/>Can use: fly, layEggs]
                    B -->|is Fish| D[TypeScript knows: Fish<br/>Can use: swim, layEggs]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style B fill:#ffc107,stroke:#333,stroke-width:2px
                    style C fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 4: Generics -->
            <section id="section4" class="lesson-section">
                <h2>üéÅ Generics</h2>
                <p>Generics are one of the most powerful features in TypeScript. They allow you to write reusable code that works with multiple types while maintaining type safety. Think of generics as "type variables" - placeholders that get filled in when you use the code. This is the secret sauce that makes TypeScript libraries so flexible and type-safe! üì¶</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Generics:</strong> Type parameters that allow you to write code that works with multiple types. They're like function parameters, but for types instead of values. We use angle brackets <code style="color: white;">&lt;T&gt;</code> to define them.</p>
                </div>

                <h3>Why Generics?</h3>
                <p>Imagine creating a function that returns the first element of an array. Without generics, you'd need separate functions for each type:</p>

                <pre><code class="language-typescript">// Without generics - not DRY! üò¢
function firstString(arr: string[]): string {
    return arr[0];
}

function firstNumber(arr: number[]): number {
    return arr[0];
}

function firstBoolean(arr: boolean[]): boolean {
    return arr[0];
}

// With generics - one function for all types! üéâ
function first&lt;T&gt;(arr: T[]): T {
    return arr[0];
}

const firstStr = first&lt;string&gt;(["a", "b", "c"]);      // Type: string
const firstNum = first&lt;number&gt;([1, 2, 3]);           // Type: number
const firstBool = first&lt;boolean&gt;([true, false]);     // Type: boolean

// TypeScript can often infer the generic type!
const inferredStr = first(["x", "y", "z"]);  // Type: string (inferred)</code></pre>

                <h3>Generic Functions</h3>
                <p>Generic functions use angle brackets to define type parameters:</p>

                <pre><code class="language-typescript">// Single type parameter
function identity&lt;T&gt;(value: T): T {
    return value;
}

identity&lt;string&gt;("hello");  // Returns string
identity&lt;number&gt;(42);       // Returns number

// Multiple type parameters
function pair&lt;T, U&gt;(first: T, second: U): [T, U] {
    return [first, second];
}

const stringAndNumber = pair&lt;string, number&gt;("age", 30);  // [string, number]
const numberAndBoolean = pair(42, true);                   // [number, boolean] - inferred!

// Generic with constraints
function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
    return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name");    // Type: string
const age = getProperty(person, "age");      // Type: number
// const invalid = getProperty(person, "invalid");  // ‚ùå Error!</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Generic Type Inference</h4>
                    <p>TypeScript is smart about inferring generic types from arguments. You usually don't need to explicitly specify the type parameter - TypeScript figures it out! This makes your code cleaner and easier to read.</p>
                </div>

                <h3>Generic Interfaces and Classes</h3>
                <p>You can make interfaces and classes generic too:</p>

                <pre><code class="language-typescript">// Generic interface
interface Box&lt;T&gt; {
    value: T;
    getValue(): T;
    setValue(value: T): void;
}

const stringBox: Box&lt;string&gt; = {
    value: "hello",
    getValue() { return this.value; },
    setValue(value: string) { this.value = value; }
};

const numberBox: Box&lt;number&gt; = {
    value: 42,
    getValue() { return this.value; },
    setValue(value: number) { this.value = value; }
};

// Generic class
class DataStore&lt;T&gt; {
    private data: T[] = [];

    add(item: T): void {
        this.data.push(item);
    }

    remove(item: T): void {
        const index = this.data.indexOf(item);
        if (index > -1) {
            this.data.splice(index, 1);
        }
    }

    getAll(): T[] {
        return [...this.data];
    }
}

// Usage with different types
const stringStore = new DataStore&lt;string&gt;();
stringStore.add("apple");
stringStore.add("banana");
console.log(stringStore.getAll());  // ["apple", "banana"]

const numberStore = new DataStore&lt;number&gt;();
numberStore.add(1);
numberStore.add(2);
console.log(numberStore.getAll());  // [1, 2]</code></pre>

                <h3>Generic Constraints</h3>
                <p>Sometimes you want to limit what types can be used with a generic. Use the <code>extends</code> keyword:</p>

                <pre><code class="language-typescript">// Constraint: T must have a length property
function logLength&lt;T extends { length: number }&gt;(item: T): void {
    console.log(`Length: ${item.length}`);
}

logLength("hello");        // ‚úÖ strings have length
logLength([1, 2, 3]);      // ‚úÖ arrays have length
logLength({ length: 10 }); // ‚úÖ object with length
// logLength(42);          // ‚ùå Error: numbers don't have length

// Constraint: T must be an object type
function merge&lt;T extends object, U extends object&gt;(obj1: T, obj2: U): T & U {
    return { ...obj1, ...obj2 };
}

const merged = merge({ name: "Alice" }, { age: 30 });
// merged has type: { name: string } & { age: number }
console.log(merged.name);  // "Alice"
console.log(merged.age);   // 30</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üöÄ Real-World Example: API Response Handler</h3>
                    
                    <pre><code class="language-typescript">// Generic API response type
interface ApiResponse&lt;T&gt; {
    success: boolean;
    data?: T;
    error?: string;
    timestamp: Date;
}

// Generic function to fetch data
async function fetchData&lt;T&gt;(url: string): Promise&lt;ApiResponse&lt;T&gt;&gt; {
    try {
        const response = await fetch(url);
        const data = await response.json();
        
        return {
            success: true,
            data: data as T,
            timestamp: new Date()
        };
    } catch (error) {
        return {
            success: false,
            error: error.message,
            timestamp: new Date()
        };
    }
}

// Define response data types
interface User {
    id: number;
    name: string;
    email: string;
}

interface Product {
    id: number;
    title: string;
    price: number;
}

// Use with different types - full type safety!
async function loadUserData() {
    const response = await fetchData&lt;User&gt;("/api/users/1");
    
    if (response.success && response.data) {
        // TypeScript knows response.data is a User
        console.log(response.data.name);
        console.log(response.data.email);
    }
}

async function loadProductData() {
    const response = await fetchData&lt;Product&gt;("/api/products/1");
    
    if (response.success && response.data) {
        // TypeScript knows response.data is a Product
        console.log(response.data.title);
        console.log(response.data.price);
    }
}</code></pre>
                </div>

                <h3>Generic Defaults</h3>
                <p>You can provide default types for generic parameters:</p>

                <pre><code class="language-typescript">interface Response&lt;T = any&gt; {
    data: T;
    status: number;
}

// Using default type
const response1: Response = { 
    data: "anything", 
    status: 200 
};

// Specifying type
const response2: Response&lt;string&gt; = { 
    data: "hello", 
    status: 200 
};</code></pre>

                <div class="mermaid">
                    graph LR
                    A[Generic Function&lt;T&gt;] --> B[Input: T]
                    A --> C[Process with type T]
                    A --> D[Output: T]
                    B -->|string| E[Returns string]
                    B -->|number| F[Returns number]
                    B -->|boolean| G[Returns boolean]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style C fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#4CAF50,stroke:#333,stroke-width:2px
                    style F fill:#4CAF50,stroke:#333,stroke-width:2px
                    style G fill:#4CAF50,stroke:#333,stroke-width:2px
                </div>
            </section>
            <!-- Section 5: Utility Types -->
            <section id="section5" class="lesson-section">
                <h2>üõ†Ô∏è Utility Types</h2>
                <p>TypeScript includes several built-in utility types that help you transform existing types. These are like power tools for type manipulation - they save you from writing repetitive type definitions and make your code more maintainable. Let's explore the most useful ones! üîß</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Utility Types:</strong> Built-in TypeScript types that perform transformations on existing types. They're like functions for types - you pass in a type, they return a modified version.</p>
                </div>

                <h3>Partial&lt;T&gt;</h3>
                <p>Makes all properties of a type optional. Perfect for update functions where you might only change some properties:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// Partial makes all properties optional
function updateUser(id: number, updates: Partial&lt;User&gt;) {
    // Can update just some properties
    console.log(`Updating user ${id} with:`, updates);
}

updateUser(1, { name: "Alice" });              // ‚úÖ Just name
updateUser(2, { email: "bob@example.com" });   // ‚úÖ Just email
updateUser(3, { name: "Charlie", age: 30 });   // ‚úÖ Multiple properties
updateUser(4, {});                              // ‚úÖ No updates (valid but pointless)</code></pre>

                <h3>Required&lt;T&gt;</h3>
                <p>The opposite of Partial - makes all properties required:</p>

                <pre><code class="language-typescript">interface OptionalConfig {
    theme?: string;
    language?: string;
    notifications?: boolean;
}

// Required makes all properties mandatory
type RequiredConfig = Required&lt;OptionalConfig&gt;;

const config: RequiredConfig = {
    theme: "dark",
    language: "en",
    notifications: true
    // ‚ùå Error if any property is missing
};</code></pre>

                <h3>Readonly&lt;T&gt;</h3>
                <p>Makes all properties read-only - perfect for immutable data structures:</p>

                <pre><code class="language-typescript">interface Point {
    x: number;
    y: number;
}

const point: Readonly&lt;Point&gt; = { x: 10, y: 20 };

console.log(point.x);  // ‚úÖ Can read
// point.x = 30;       // ‚ùå Error: Cannot assign to 'x' because it is a read-only property</code></pre>

                <h3>Pick&lt;T, K&gt;</h3>
                <p>Creates a type by picking specific properties from another type:</p>

                <pre><code class="language-typescript">interface Employee {
    id: number;
    name: string;
    email: string;
    department: string;
    salary: number;
    startDate: Date;
}

// Pick only the properties we need for display
type EmployeePreview = Pick&lt;Employee, "id" | "name" | "department"&gt;;

const preview: EmployeePreview = {
    id: 1,
    name: "Alice",
    department: "Engineering"
    // ‚úÖ No need for email, salary, or startDate
};</code></pre>

                <h3>Omit&lt;T, K&gt;</h3>
                <p>Creates a type by omitting specific properties from another type:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    username: string;
    password: string;
    email: string;
    createdAt: Date;
}

// Create a safe user type without password
type SafeUser = Omit&lt;User, "password"&gt;;

function sendUserToClient(user: User): SafeUser {
    // Return user without password
    const { password, ...safeUser } = user;
    return safeUser;
}

const user: User = {
    id: 1,
    username: "alice",
    password: "secret123",
    email: "alice@example.com",
    createdAt: new Date()
};

const safeUser = sendUserToClient(user);
console.log(safeUser.username);  // ‚úÖ OK
// console.log(safeUser.password);  // ‚ùå Error: password doesn't exist on SafeUser</code></pre>

                <h3>Record&lt;K, T&gt;</h3>
                <p>Creates an object type with specified keys and value type:</p>

                <pre><code class="language-typescript">// Record&lt;Keys, ValueType&gt;
type PageInfo = {
    title: string;
    description: string;
};

// Create a record where keys are page names and values are PageInfo
type SiteMap = Record&lt;string, PageInfo&gt;;

const site: SiteMap = {
    home: {
        title: "Home Page",
        description: "Welcome to our site"
    },
    about: {
        title: "About Us",
        description: "Learn more about our company"
    },
    contact: {
        title: "Contact",
        description: "Get in touch with us"
    }
};

// With specific keys
type WeekDays = "monday" | "tuesday" | "wednesday" | "thursday" | "friday";
type Schedule = Record&lt;WeekDays, string&gt;;

const workSchedule: Schedule = {
    monday: "9am - 5pm",
    tuesday: "9am - 5pm",
    wednesday: "9am - 5pm",
    thursday: "9am - 5pm",
    friday: "9am - 3pm"
    // ‚ùå Error if we try to add "saturday" or "sunday"
};</code></pre>

                <h3>Exclude&lt;T, U&gt; and Extract&lt;T, U&gt;</h3>
                <p>Work with union types to exclude or extract specific members:</p>

                <pre><code class="language-typescript">type AllColors = "red" | "green" | "blue" | "yellow" | "purple";

// Exclude removes types from union
type PrimaryColors = Exclude&lt;AllColors, "yellow" | "purple"&gt;;
// Result: "red" | "green" | "blue"

// Extract keeps only specified types
type WarmColors = Extract&lt;AllColors, "red" | "yellow"&gt;;
// Result: "red" | "yellow"

// Practical example
type Shape = 
    | { kind: "circle"; radius: number }
    | { kind: "square"; size: number }
    | { kind: "rectangle"; width: number; height: number };

// Extract only shapes with 'size' property
type ShapesWithSize = Extract&lt;Shape, { size: number }&gt;;
// Result: { kind: "square"; size: number }</code></pre>

                <h3>NonNullable&lt;T&gt;</h3>
                <p>Removes null and undefined from a type:</p>

                <pre><code class="language-typescript">type MaybeString = string | null | undefined;

type DefiniteString = NonNullable&lt;MaybeString&gt;;
// Result: string

function processValue(value: MaybeString) {
    // Type guard to ensure non-null
    if (value !== null && value !== undefined) {
        const definiteValue: DefiniteString = value;
        console.log(definiteValue.toUpperCase());
    }
}</code></pre>

                <h3>ReturnType&lt;T&gt; and Parameters&lt;T&gt;</h3>
                <p>Extract return type and parameter types from functions:</p>

                <pre><code class="language-typescript">function createUser(name: string, age: number) {
    return {
        id: Math.random(),
        name,
        age,
        createdAt: new Date()
    };
}

// Get the return type of the function
type User = ReturnType&lt;typeof createUser&gt;;
// Result: { id: number; name: string; age: number; createdAt: Date }

// Get the parameter types
type CreateUserParams = Parameters&lt;typeof createUser&gt;;
// Result: [name: string, age: number]

// Use them
const user: User = createUser("Alice", 30);
const params: CreateUserParams = ["Bob", 25];</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üéØ Real-World Example: Form State Management</h3>
                    
                    <pre><code class="language-typescript">// Base form field type
interface FormField {
    value: string;
    error?: string;
    touched: boolean;
    required: boolean;
}

// Form with multiple fields
interface UserForm {
    username: FormField;
    email: FormField;
    password: FormField;
    confirmPassword: FormField;
    bio: FormField;
    agreeToTerms: FormField;
}

// For initial state - all fields have default values
type InitialFormState = Record&lt;keyof UserForm, Partial&lt;FormField&gt;&gt;;

// For validation - only need value and error
type ValidationState = Record&lt;keyof UserForm, Pick&lt;FormField, "value" | "error"&gt;&gt;;

// For submission - omit UI-only fields
type SubmissionData = Record&lt;keyof UserForm, Omit&lt;FormField, "touched" | "error"&gt;&gt;;

// For display - all fields readonly
type DisplayForm = Readonly&lt;UserForm&gt;;

// Initialize form
const initialForm: InitialFormState = {
    username: { value: "", touched: false },
    email: { value: "", touched: false },
    password: { value: "", touched: false },
    confirmPassword: { value: "", touched: false },
    bio: { value: "", touched: false },
    agreeToTerms: { value: "", touched: false }
};</code></pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Utility Type</th>
                            <th>Purpose</th>
                            <th>Example Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Partial&lt;T&gt;</strong></td>
                            <td>All properties optional</td>
                            <td>Update functions</td>
                        </tr>
                        <tr>
                            <td><strong>Required&lt;T&gt;</strong></td>
                            <td>All properties required</td>
                            <td>Ensure completeness</td>
                        </tr>
                        <tr>
                            <td><strong>Readonly&lt;T&gt;</strong></td>
                            <td>All properties read-only</td>
                            <td>Immutable data</td>
                        </tr>
                        <tr>
                            <td><strong>Pick&lt;T, K&gt;</strong></td>
                            <td>Select specific properties</td>
                            <td>Subset of type</td>
                        </tr>
                        <tr>
                            <td><strong>Omit&lt;T, K&gt;</strong></td>
                            <td>Remove specific properties</td>
                            <td>Exclude sensitive data</td>
                        </tr>
                        <tr>
                            <td><strong>Record&lt;K, T&gt;</strong></td>
                            <td>Object with specific keys</td>
                            <td>Maps, dictionaries</td>
                        </tr>
                        <tr>
                            <td><strong>Exclude&lt;T, U&gt;</strong></td>
                            <td>Remove from union</td>
                            <td>Filter types</td>
                        </tr>
                        <tr>
                            <td><strong>Extract&lt;T, U&gt;</strong></td>
                            <td>Keep from union</td>
                            <td>Select types</td>
                        </tr>
                        <tr>
                            <td><strong>NonNullable&lt;T&gt;</strong></td>
                            <td>Remove null/undefined</td>
                            <td>Ensure values exist</td>
                        </tr>
                        <tr>
                            <td><strong>ReturnType&lt;T&gt;</strong></td>
                            <td>Function return type</td>
                            <td>Type from function</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pro Tip: Compose Utility Types</h4>
                    <p>You can combine multiple utility types for powerful transformations! For example: <code>Partial&lt;Pick&lt;User, "name" | "email"&gt;&gt;</code> creates a type with only name and email properties, both optional.</p>
                </div>
            </section>

            <!-- Section 6: Conditional Types -->
            <section id="section6" class="lesson-section">
                <h2>üîÄ Conditional Types</h2>
                <p>Conditional types allow you to create types based on conditions. They're like if-else statements for types! This is advanced TypeScript magic that lets you build incredibly flexible type systems. ‚ú®</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Conditional Type:</strong> A type that depends on a condition, using the syntax <code style="color: white;">T extends U ? X : Y</code>. If T extends U, the type is X, otherwise it's Y.</p>
                </div>

                <h3>Basic Conditional Types</h3>
                <p>Conditional types use the ternary operator syntax:</p>

                <pre><code class="language-typescript">// Basic conditional type
type IsString&lt;T&gt; = T extends string ? true : false;

type A = IsString&lt;string&gt;;   // true
type B = IsString&lt;number&gt;;   // false
type C = IsString&lt;"hello"&gt;;  // true

// Practical example: Make optional if nullable
type NullableOptional&lt;T&gt; = T extends null | undefined ? T | void : T;

type OptionalString = NullableOptional&lt;string | null&gt;;  // string | null | void
type RequiredString = NullableOptional&lt;string&gt;;         // string</code></pre>

                <h3>Distributive Conditional Types</h3>
                <p>When conditional types are applied to union types, they "distribute" over each member:</p>

                <pre><code class="language-typescript">type ToArray&lt;T&gt; = T extends any ? T[] : never;

// Distributes over union
type StrOrNumArray = ToArray&lt;string | number&gt;;
// Result: string[] | number[]
// NOT (string | number)[]

// Another example
type Filter&lt;T, U&gt; = T extends U ? T : never;

type Numbers = Filter&lt;string | number | boolean, number&gt;;
// Result: number

type StringsOrNumbers = Filter&lt;string | number | boolean, string | number&gt;;
// Result: string | number</code></pre>

                <h3>The infer Keyword</h3>
                <p>The <code>infer</code> keyword lets you extract and store types within conditional types. This is incredibly powerful! üí™</p>

                <pre><code class="language-typescript">// Extract return type from a Promise
type UnwrapPromise&lt;T&gt; = T extends Promise&lt;infer U&gt; ? U : T;

type A = UnwrapPromise&lt;Promise&lt;string&gt;&gt;;  // string
type B = UnwrapPromise&lt;Promise&lt;number&gt;&gt;;  // number
type C = UnwrapPromise&lt;boolean&gt;;          // boolean (not a Promise)

// Extract array element type
type Flatten&lt;T&gt; = T extends Array&lt;infer U&gt; ? U : T;

type D = Flatten&lt;string[]&gt;;    // string
type E = Flatten&lt;number[][]&gt;;  // number[]
type F = Flatten&lt;boolean&gt;;     // boolean

// Extract function parameters
type GetFirstParam&lt;T&gt; = T extends (first: infer U, ...args: any[]) =&gt; any ? U : never;

type Param = GetFirstParam&lt;(name: string, age: number) =&gt; void&gt;;  // string</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üé™ Real-World Example: Event Handler Types</h3>
                    
                    <pre><code class="language-typescript">// Base event type
interface Event&lt;T = any&gt; {
    type: string;
    payload: T;
}

// Conditional type to extract payload type from event
type EventPayload&lt;T&gt; = T extends Event&lt;infer P&gt; ? P : never;

// Define specific events
interface UserLoggedIn extends Event&lt;{ userId: string; timestamp: Date }&gt; {
    type: "USER_LOGGED_IN";
}

interface ItemAdded extends Event&lt;{ itemId: string; quantity: number }&gt; {
    type: "ITEM_ADDED";
}

interface ErrorOccurred extends Event&lt;{ message: string; code: number }&gt; {
    type: "ERROR";
}

type AppEvent = UserLoggedIn | ItemAdded | ErrorOccurred;

// Extract payload types
type LoginPayload = EventPayload&lt;UserLoggedIn&gt;;
// Result: { userId: string; timestamp: Date }

type ItemPayload = EventPayload&lt;ItemAdded&gt;;
// Result: { itemId: string; quantity: number }

// Event handler with type safety
function handleEvent&lt;T extends AppEvent&gt;(
    event: T,
    handler: (payload: EventPayload&lt;T&gt;) =&gt; void
) {
    handler(event.payload);
}

// Usage with full type safety
const loginEvent: UserLoggedIn = {
    type: "USER_LOGGED_IN",
    payload: { userId: "123", timestamp: new Date() }
};

handleEvent(loginEvent, (payload) =&gt; {
    // TypeScript knows payload has userId and timestamp
    console.log(`User ${payload.userId} logged in at ${payload.timestamp}`);
});</code></pre>
                </div>

                <h3>Conditional Type Chains</h3>
                <p>You can chain conditional types to create complex type logic:</p>

                <pre><code class="language-typescript">type TypeName&lt;T&gt; =
    T extends string ? "string" :
    T extends number ? "number" :
    T extends boolean ? "boolean" :
    T extends undefined ? "undefined" :
    T extends Function ? "function" :
    "object";

type T0 = TypeName&lt;string&gt;;     // "string"
type T1 = TypeName&lt;number&gt;;     // "number"
type T2 = TypeName&lt;() =&gt; void&gt;; // "function"
type T3 = TypeName&lt;{ x: 1 }&gt;;   // "object"</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Complexity</h4>
                    <p>Conditional types can get complex quickly. Keep them simple and well-documented. If a conditional type becomes hard to understand, consider breaking it into smaller pieces or using a different approach.</p>
                </div>

                <div class="mermaid">
                    graph TD
                    A[Conditional Type] --> B{T extends U?}
                    B -->|Yes| C[Type X]
                    B -->|No| D[Type Y]
                    C --> E[Result: X]
                    D --> F[Result: Y]
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style B fill:#ffc107,stroke:#333,stroke-width:2px
                    style E fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style F fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>
            <!-- Section 7: Template Literal Types -->
            <section id="section7" class="lesson-section">
                <h2>üé® Template Literal Types</h2>
                <p>Template literal types let you create new string literal types by combining existing string literal types. They're incredibly useful for creating type-safe APIs with dynamic string patterns. Think of them as template strings, but for types! üé≠</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Definition</h4>
                    <p style="color: white;"><strong>Template Literal Type:</strong> A type that uses template literal syntax to create new string literal types. They use backticks and <code style="color: white;">${}</code> interpolation, just like JavaScript template literals.</p>
                </div>

                <h3>Basic Template Literals</h3>
                <p>Use backticks and interpolation syntax:</p>

                <pre><code class="language-typescript">// Simple template literal type
type Greeting = `Hello, ${"World" | "TypeScript" | "Developer"}!`;
// Result: "Hello, World!" | "Hello, TypeScript!" | "Hello, Developer!"

// With type parameters
type EventName&lt;T extends string&gt; = `on${T}`;

type ButtonEvents = EventName&lt;"Click" | "Hover" | "Focus"&gt;;
// Result: "onClick" | "onHover" | "onFocus"

// Multiple interpolations
type HTTPMethod = "GET" | "POST" | "PUT" | "DELETE";
type APIEndpoint = "users" | "posts" | "comments";

type APIRoute = `/${HTTPMethod}/${APIEndpoint}`;
// Result: "/GET/users" | "/GET/posts" | "/GET/comments" | 
//         "/POST/users" | "/POST/posts" | ... (12 combinations)</code></pre>

                <h3>String Manipulation Types</h3>
                <p>TypeScript includes built-in types for common string transformations:</p>

                <pre><code class="language-typescript">// Uppercase - converts to uppercase
type Loud = Uppercase&lt;"hello"&gt;;  // "HELLO"

type ShoutCommands = Uppercase&lt;"start" | "stop" | "pause"&gt;;
// Result: "START" | "STOP" | "PAUSE"

// Lowercase - converts to lowercase
type Quiet = Lowercase&lt;"HELLO"&gt;;  // "hello"

// Capitalize - capitalizes first letter
type Proper = Capitalize&lt;"typescript"&gt;;  // "Typescript"

// Uncapitalize - lowercases first letter
type Camel = Uncapitalize&lt;"TypeScript"&gt;;  // "typeScript"

// Combining transformations
type ConstantCase&lt;T extends string&gt; = Uppercase&lt;T&gt;;
type PascalCase&lt;T extends string&gt; = Capitalize&lt;T&gt;;
type CamelCase&lt;T extends string&gt; = Uncapitalize&lt;T&gt;;

type MyConstant = ConstantCase&lt;"max_value"&gt;;  // "MAX_VALUE"
type MyClass = PascalCase&lt;"user"&gt;;            // "User"
type MyVariable = CamelCase&lt;"UserName"&gt;;      // "userName"</code></pre>

                <h3>Practical Applications</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üéÆ Real-World Example: Type-Safe Event System</h3>
                    
                    <pre><code class="language-typescript">// Define base event names
type EventBase = "click" | "hover" | "focus" | "blur" | "change";

// Create handler names
type EventHandler&lt;T extends string&gt; = `on${Capitalize&lt;T&gt;}`;

type Handlers = EventHandler&lt;EventBase&gt;;
// Result: "onClick" | "onHover" | "onFocus" | "onBlur" | "onChange"

// Create listener names
type EventListener&lt;T extends string&gt; = `add${Capitalize&lt;T&gt;}Listener`;

type Listeners = EventListener&lt;EventBase&gt;;
// Result: "addClickListener" | "addHoverListener" | ...

// Component with type-safe event props
type EventProps&lt;T extends string&gt; = {
    [K in EventHandler&lt;T&gt;]?: () =&gt; void;
};

type SafeButtonProps = EventProps&lt;EventBase&gt;;
// Automatically creates onClick, onHover, etc.

const button: SafeButtonProps = {
    onClick: () =&gt; console.log("Clicked!"),
    onHover: () =&gt; console.log("Hovering!")
};</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üóÑÔ∏è Real-World Example: Database Query Builder</h3>
                    
                    <pre><code class="language-typescript">// Define table columns
interface UserTable {
    id: number;
    name: string;
    email: string;
    age: number;
    isActive: boolean;
}

// Create getter method names
type Getter&lt;T extends string&gt; = `get${Capitalize&lt;T&gt;}`;
type Setter&lt;T extends string&gt; = `set${Capitalize&lt;T&gt;}`;

// Generate methods for each column
type UserGetters = {
    [K in keyof UserTable as Getter&lt;string & K&gt;]: () =&gt; UserTable[K];
};

type UserSetters = {
    [K in keyof UserTable as Setter&lt;string & K&gt;]: (value: UserTable[K]) =&gt; void;
};

// Result types:
// UserGetters: {
//     getId: () => number;
//     getName: () => string;
//     getEmail: () => string;
//     getAge: () => number;
//     getIsActive: () => boolean;
// }

// Create query builder
type QueryMethod = "find" | "create" | "update" | "delete";
type QueryBuilder = `${QueryMethod}User`;
// Result: "findUser" | "createUser" | "updateUser" | "deleteUser"

interface Database {
    findUser: (id: number) =&gt; UserTable | null;
    createUser: (data: Omit&lt;UserTable, "id"&gt;) =&gt; UserTable;
    updateUser: (id: number, data: Partial&lt;UserTable&gt;) =&gt; UserTable;
    deleteUser: (id: number) =&gt; boolean;
}</code></pre>
                </div>

                <h3>Advanced Pattern: CSS-in-JS</h3>
                <pre><code class="language-typescript">// Define CSS property names (simplified)
type CSSProperty = "color" | "backgroundColor" | "fontSize" | "margin" | "padding";

// Create CSS variable names
type CSSVariable&lt;T extends string&gt; = `--${T}`;

type CSSVars = CSSVariable&lt;CSSProperty&gt;;
// Result: "--color" | "--backgroundColor" | "--fontSize" | "--margin" | "--padding"

// Create responsive breakpoint styles
type Breakpoint = "mobile" | "tablet" | "desktop";
type ResponsiveProperty&lt;P extends string, B extends string&gt; = `${P}-${B}`;

type ResponsiveColor = ResponsiveProperty&lt;"color", Breakpoint&gt;;
// Result: "color-mobile" | "color-tablet" | "color-desktop"

// Complete style system
type StyleSystem = {
    [K in CSSProperty]: string;
} & {
    [K in CSSVars]: string;
} & {
    [K in ResponsiveColor]: string;
};

const styles: Partial&lt;StyleSystem&gt; = {
    color: "blue",
    "--color": "var(--primary)",
    "color-mobile": "red",
    "color-tablet": "green",
    "color-desktop": "blue"
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Key Takeaways: Template Literal Types</h4>
                    <ul>
                        <li>Template literals create unions of all possible string combinations</li>
                        <li>Use built-in string manipulation types: Uppercase, Lowercase, Capitalize, Uncapitalize</li>
                        <li>Perfect for creating type-safe naming conventions</li>
                        <li>Combine with mapped types for powerful code generation</li>
                        <li>Extremely useful in React for prop types, event handlers, and CSS-in-JS</li>
                    </ul>
                </div>

                <div class="mermaid">
                    graph LR
                    A[Template Literal Type] --> B[Base Type: 'click']
                    B --> C[Transform: Capitalize]
                    C --> D[Prepend: 'on']
                    D --> E[Result: 'onClick']
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 8: Hands-on Practice -->
            <section id="section8" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Build a Type-Safe API Client</h3>
                    <p><strong>Objective:</strong> Create a generic API client that handles different response types with full type safety.</p>
                    
                    <h4>Instructions:</h4>
                    <ol>
                        <li>Create a generic <code>ApiResponse&lt;T&gt;</code> interface</li>
                        <li>Write a <code>fetchData&lt;T&gt;</code> function that returns <code>Promise&lt;ApiResponse&lt;T&gt;&gt;</code></li>
                        <li>Create type guards to check if the response is successful</li>
                        <li>Define specific data types (User, Product) and use them with your API client</li>
                    </ol>
                    
                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">// TODO: Define ApiResponse interface

// TODO: Create fetchData function

// TODO: Create type guard

// Test data types
interface User {
    id: number;
    name: string;
    email: string;
}

interface Product {
    id: number;
    title: string;
    price: number;
}

// TODO: Use your API client
</code></pre>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Remember that generic functions need the type parameter before the function parameters. Use <code>response is Success</code> syntax for type predicates.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">interface ApiResponse&lt;T&gt; {
    success: boolean;
    data?: T;
    error?: string;
}

async function fetchData&lt;T&gt;(url: string): Promise&lt;ApiResponse&lt;T&gt;&gt; {
    try {
        const response = await fetch(url);
        const data = await response.json();
        return { success: true, data: data as T };
    } catch (error) {
        return { success: false, error: error.message };
    }
}

function isSuccess&lt;T&gt;(response: ApiResponse&lt;T&gt;): response is ApiResponse&lt;T&gt; & { data: T } {
    return response.success && response.data !== undefined;
}

// Usage
async function loadUser() {
    const response = await fetchData&lt;User&gt;("/api/users/1");
    if (isSuccess(response)) {
        console.log(response.data.name);
    }
}</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Create a Type-Safe Event Emitter</h3>
                    <p><strong>Objective:</strong> Build an event emitter with discriminated unions and template literal types.</p>
                    
                    <h4>Instructions:</h4>
                    <ol>
                        <li>Create event types using discriminated unions</li>
                        <li>Use template literal types to generate event handler names</li>
                        <li>Implement type-safe <code>on</code> and <code>emit</code> methods</li>
                    </ol>
                    
                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">// TODO: Define your event types

// TODO: Create EventEmitter class

// Usage example:
// const emitter = new EventEmitter();
// emitter.on("userLogin", (payload) => console.log(payload.userId));
// emitter.emit({ type: "userLogin", userId: "123", timestamp: new Date() });
</code></pre>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">type UserLoginEvent = {
    type: "userLogin";
    userId: string;
    timestamp: Date;
};

type ItemAddedEvent = {
    type: "itemAdded";
    itemId: string;
    quantity: number;
};

type AppEvent = UserLoginEvent | ItemAddedEvent;

class EventEmitter {
    private handlers: Partial&lt;Record&lt;AppEvent["type"], Function[]&gt;&gt; = {};

    on&lt;T extends AppEvent&gt;(
        eventType: T["type"],
        handler: (event: T) =&gt; void
    ) {
        if (!this.handlers[eventType]) {
            this.handlers[eventType] = [];
        }
        this.handlers[eventType]!.push(handler);
    }

    emit&lt;T extends AppEvent&gt;(event: T) {
        const handlers = this.handlers[event.type];
        if (handlers) {
            handlers.forEach(h =&gt; h(event));
        }
    }
}</code></pre>
                    </details>
                </div>

                <div class="card quiz-container">
                    <h3>üéØ Quick Quiz</h3>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What's the difference between union and intersection types?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Think about OR vs AND">
                                A) They're the same thing
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Union is OR (one of several types), intersection is AND (all types combined).">
                                B) Union is OR logic, intersection is AND logic
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Review the logic">
                                C) Union is AND logic, intersection is OR logic
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> What does a type guard do?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Type guards are about narrowing">
                                A) Prevents type errors at compile time only
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Type guards narrow types at runtime, helping TypeScript understand what type you're working with.">
                                B) Narrows types at runtime through conditional checks
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="They do more than that">
                                C) Just documentation for developers
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> When should you use generics?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Be strategic">
                                A) Always - they make code better
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly! Use generics when you need reusable code that works with multiple types while maintaining type safety.">
                                B) When you need reusable, type-safe code for multiple types
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="They have their place">
                                C) Never - they're too complex
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" class="lesson-section">
                <h2>üèÜ Best Practices</h2>
                
                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Use union types for values that can be multiple types</strong> - Perfect for status values, payment methods, or component variants</li>
                    <li><strong>Use discriminated unions with a type property</strong> - Makes type narrowing automatic and reliable</li>
                    <li><strong>Prefer intersection types when combining behaviors</strong> - Great for mixing in props or extending interfaces</li>
                    <li><strong>Write custom type guards for complex type checks</strong> - Makes your code more readable and type-safe</li>
                    <li><strong>Use generics for reusable, type-safe code</strong> - APIs, data structures, and utility functions benefit greatly</li>
                    <li><strong>Leverage utility types to transform existing types</strong> - Saves time and reduces repetition</li>
                    <li><strong>Document complex conditional types</strong> - Future you (and your team) will thank you</li>
                </ul>
                
                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't create deeply nested generics</strong> - Can slow down compilation and make errors hard to read</li>
                    <li><strong>Don't make unions with thousands of members</strong> - Performance and readability suffer</li>
                    <li><strong>Don't use type guards without runtime checks</strong> - They only work if the logic is correct</li>
                    <li><strong>Don't overuse conditional types</strong> - They can make code hard to understand</li>
                    <li><strong>Don't use generics when a simple type works</strong> - Not everything needs to be generic</li>
                    <li><strong>Don't forget generic constraints when needed</strong> - Prevents misuse of your generic types</li>
                </ul>
                
                <h3>üí° Pro Tips for React Development</h3>
                <ul>
                    <li><strong>Use discriminated unions for component variants</strong> - Button components with different modes, for example</li>
                    <li><strong>Make your component props generic when appropriate</strong> - List components, form fields, data tables</li>
                    <li><strong>Use utility types for prop transformations</strong> - Omit HTML attributes, make props optional, etc.</li>
                    <li><strong>Create type-safe event handlers with template literals</strong> - onClick, onChange, onSubmit patterns</li>
                    <li><strong>Use Pick and Omit to extend HTML element props</strong> - Build on native elements with confidence</li>
                </ul>

                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Best Type Feature</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Value can be multiple types</td>
                            <td>Union Types</td>
                            <td>string | number</td>
                        </tr>
                        <tr>
                            <td>Combine multiple interfaces</td>
                            <td>Intersection Types</td>
                            <td>Person & Employee</td>
                        </tr>
                        <tr>
                            <td>Runtime type checking</td>
                            <td>Type Guards</td>
                            <td>typeof, instanceof, custom</td>
                        </tr>
                        <tr>
                            <td>Reusable for any type</td>
                            <td>Generics</td>
                            <td>Array&lt;T&gt;, Promise&lt;T&gt;</td>
                        </tr>
                        <tr>
                            <td>Transform existing types</td>
                            <td>Utility Types</td>
                            <td>Partial, Pick, Omit</td>
                        </tr>
                        <tr>
                            <td>Type logic and conditions</td>
                            <td>Conditional Types</td>
                            <td>T extends U ? X : Y</td>
                        </tr>
                        <tr>
                            <td>String pattern types</td>
                            <td>Template Literals</td>
                            <td>`on${Event}`</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" class="lesson-section">
                <h2>üìù Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Congratulations! You've Mastered Advanced Types!</h3>
                    <p>You've completed the TypeScript Fundamentals module! Here's what you now know:</p>
                    <ul>
                        <li><strong>Union Types (|)</strong> - Multiple type possibilities with OR logic</li>
                        <li><strong>Intersection Types (&)</strong> - Combining types with AND logic</li>
                        <li><strong>Type Guards</strong> - Runtime checks for type safety (typeof, instanceof, in, custom guards)</li>
                        <li><strong>Generics</strong> - Reusable, type-safe code with type parameters</li>
                        <li><strong>Utility Types</strong> - Built-in type transformations (Partial, Pick, Omit, Record, etc.)</li>
                        <li><strong>Conditional Types</strong> - Type logic with extends and infer</li>
                        <li><strong>Template Literal Types</strong> - Type-safe string patterns</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li>TypeScript's advanced type system is incredibly powerful and flexible</li>
                        <li>These features help you write more maintainable and bug-free code</li>
                        <li>Generics enable code reuse without sacrificing type safety</li>
                        <li>Utility types save you from writing repetitive type definitions</li>
                        <li>Type guards bridge the gap between compile-time and runtime safety</li>
                        <li>These patterns are essential for professional React development</li>
                    </ul>
                </div>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/types-from-types.html" target="_blank">TypeScript Handbook: Creating Types from Types</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html" target="_blank">TypeScript Handbook: Generics</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">TypeScript Handbook: Utility Types</a></li>
                    <li><a href="https://react-typescript-cheatsheet.netlify.app/" target="_blank">React TypeScript Cheatsheet</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>You've completed Module 1: TypeScript Fundamentals! üéä</p>
                <p>Next up is the <strong>Mini-Project: Task Manager</strong>, where you'll apply everything you've learned to build a comprehensive, type-safe task management system. You'll use:</p>
                <ul>
                    <li>Interfaces and type aliases for data structures</li>
                    <li>Union types for task status and priority</li>
                    <li>Generics for reusable data handling</li>
                    <li>Type guards for validation</li>
                    <li>Utility types for partial updates</li>
                    <li>All your TypeScript skills combined!</li>
                </ul>

                <p>After that, we'll dive into <strong>Module 2: React Basics</strong>, where you'll start building actual React components with TypeScript! üí™</p>

                <div class="mermaid">
                    graph LR
                    A[TypeScript Fundamentals] --> B[Basic Types]
                    A --> C[Interfaces]
                    A --> D[Functions]
                    A --> E[Advanced Types]
                    
                    E --> F[Union & Intersection]
                    E --> G[Type Guards]
                    E --> H[Generics]
                    E --> I[Utility Types]
                    E --> J[Conditional Types]
                    E --> K[Template Literals]
                    
                    B --> L[Task Manager Project]
                    C --> L
                    D --> L
                    E --> L
                    
                    L --> M[React Basics Module]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                    style L fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                    style M fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ You Did It!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've completed all 5 lessons of TypeScript Fundamentals! You now have a solid foundation in TypeScript's type system - from basic types to advanced generic programming. You're ready to build type-safe, maintainable applications!</p>
                    <p style="color: white; font-size: 1.1rem; margin: 0;">Time to put it all together in the Task Manager mini-project! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_1_4_functions_in_typescript.html" class="prev-lesson">‚Üê Previous: Functions in TypeScript</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="mini_project_1_task_manager.html" class="next-lesson">Next: Mini-Project - Task Manager ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce - React TypeScript Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build better applications with TypeScript and React.</p>
        <p style="margin-top: 1rem; font-size: 0.9rem;">
            <a href="index.html" style="color: white; text-decoration: underline;">Course Home</a> | 
            <a href="index.html#modules" style="color: white; text-decoration: underline;">All Modules</a> | 
            <a href="#main-content" style="color: white; text-decoration: underline;">Back to Top ‚Üë</a>
        </p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
