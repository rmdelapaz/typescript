<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master TypeScript functions - Learn how to type function parameters, return values, optional parameters, rest parameters, and function overloads.">
    <meta name="author" content="PracticalAce">
    <title>Functions in TypeScript - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module1">Module 1: TypeScript Fundamentals</a></li>
            <li aria-current="page">Lesson 1.4: Functions in TypeScript</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>‚ö° Functions in TypeScript</h1>
                <p class="lead">Functions are the heart of every application - they're where the action happens! In this lesson, we'll transform your JavaScript functions into type-safe powerhouses. You'll learn how to make your functions bulletproof, self-documenting, and impossible to misuse. Let's turn good functions into great functions! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Type function parameters and return values with confidence</li>
                        <li>Use optional and default parameters effectively</li>
                        <li>Master rest parameters for variable-length arguments</li>
                        <li>Create function overloads for flexible APIs</li>
                        <li>Write arrow functions with proper type annotations</li>
                        <li>Use function types and callbacks safely</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a type-safe data processing pipeline with various function types</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Function Basics</a></li>
                        <li><a href="#section2" class="toc-link">Optional Parameters</a></li>
                        <li><a href="#section3" class="toc-link">Default Parameters</a></li>
                        <li><a href="#section4" class="toc-link">Rest Parameters</a></li>
                        <li><a href="#section5" class="toc-link">Arrow Functions</a></li>
                        <li><a href="#section6" class="toc-link">Function Types</a></li>
                        <li><a href="#section7" class="toc-link">Function Overloads</a></li>
                        <li><a href="#section8" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Function Basics -->
            <section id="section1" class="lesson-section">
                <h2>Function Basics: Parameters and Return Types</h2>
                
                <p>Every function is a mini contract: "Give me these inputs, I'll give you this output." TypeScript lets you write that contract explicitly, making your code self-documenting and error-proof. Let's start with the fundamentals! üìù</p>

                <h3>Basic Function Syntax</h3>
                <p>In TypeScript, you add types to both parameters and return values:</p>

                <pre><code class="language-typescript">// Basic function with types
function greet(name: string): string {
    return `Hello, ${name}!`;
}

// Call the function
const message = greet("Alice");  // ‚úÖ OK
console.log(message);  // "Hello, Alice!"

// TypeScript catches errors
greet(123);       // ‚ùå Error! Argument of type 'number' is not assignable to parameter of type 'string'
greet();          // ‚ùå Error! Expected 1 argument, but got 0
</code></pre>

                <p>Let's break down the anatomy of a typed function:</p>

                <pre><code class="language-typescript">// function keyword
// ‚Üì
function add(a: number, b: number): number {
//          ‚Üë          ‚Üë          ‚Üë      ‚Üë
//          param1     param2     colon  return type
    return a + b;
}
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Type Both Parameters AND Return Values?</h4>
                    <ul>
                        <li><strong>Parameters:</strong> Tell callers what to pass in (prevents misuse)</li>
                        <li><strong>Return type:</strong> Ensures you return what you promise (catches bugs in implementation)</li>
                        <li><strong>Documentation:</strong> The signature IS the documentation!</li>
                        <li><strong>Refactoring:</strong> Change the return type, TypeScript shows all affected code</li>
                    </ul>
                </div>

                <h3>Multiple Parameters</h3>
                <p>Functions can have as many parameters as needed, each with its own type:</p>

                <pre><code class="language-typescript">// Multiple parameters with different types
function createUser(
    id: number,
    name: string,
    email: string,
    isActive: boolean
): string {
    return `User ${id}: ${name} (${email}) - Active: ${isActive}`;
}

const userInfo = createUser(1, "Alice", "alice@example.com", true);
console.log(userInfo);

// Mix parameter types freely
function calculateDiscount(
    price: number,
    discountPercent: number,
    membershipLevel: "bronze" | "silver" | "gold"
): number {
    let discount = price * (discountPercent / 100);
    
    // Additional discount based on membership
    if (membershipLevel === "gold") {
        discount *= 1.5;
    } else if (membershipLevel === "silver") {
        discount *= 1.2;
    }
    
    return price - discount;
}

const finalPrice = calculateDiscount(100, 10, "gold");
console.log(finalPrice);  // 85 (10% discount + 50% bonus for gold)
</code></pre>

                <h3>void Return Type</h3>
                <p>When a function doesn't return anything (or returns <code>undefined</code>), use <code>void</code>:</p>

                <pre><code class="language-typescript">// Function that performs an action but returns nothing
function logMessage(message: string): void {
    console.log(`[LOG] ${message}`);
    // No return statement needed
}

function sendEmail(to: string, subject: string, body: string): void {
    console.log(`Sending email to ${to}`);
    console.log(`Subject: ${subject}`);
    console.log(`Body: ${body}`);
    // Side effect only, no return value
}

logMessage("Application started");
sendEmail("user@example.com", "Welcome!", "Thanks for signing up!");

// void functions can return undefined explicitly
function doNothing(): void {
    return undefined;  // ‚úÖ OK
    // return null;    // ‚ùå Error! null is not void
    // return 5;       // ‚ùå Error! number is not void
}
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Use <code>void</code> for functions that perform side effects (logging, saving to database, updating UI). Use a specific return type for functions that compute and return values.
                </blockquote>

                <h3>never Return Type</h3>
                <p>Use <code>never</code> for functions that never return (they throw errors or run forever):</p>

                <pre><code class="language-typescript">// Function that always throws an error
function throwError(message: string): never {
    throw new Error(message);
    // Execution never continues past here
}

// Function that runs forever
function infiniteLoop(): never {
    while (true) {
        console.log("Still running...");
    }
    // Never exits
}

// Useful for exhaustive checks
type Status = "pending" | "approved" | "rejected";

function handleStatus(status: Status): string {
    switch (status) {
        case "pending":
            return "Waiting for approval";
        case "approved":
            return "Request approved";
        case "rejected":
            return "Request rejected";
        default:
            // If we get here, we forgot to handle a case
            const exhaustiveCheck: never = status;
            throw new Error(`Unhandled status: ${exhaustiveCheck}`);
    }
}
</code></pre>

                <h3>Type Inference for Return Types</h3>
                <p>TypeScript can infer return types, but explicit is often better:</p>

                <pre><code class="language-typescript">// TypeScript infers return type is number
function add(a: number, b: number) {
    return a + b;  // TypeScript knows this returns number
}

// But explicit is clearer and safer
function add2(a: number, b: number): number {
    return a + b;
}

// Inference catches mistakes
function calculate(x: number) {
    if (x > 0) {
        return x * 2;        // returns number
    }
    return "negative";       // returns string
    // TypeScript infers: number | string
    // This might not be what you wanted!
}

// Explicit type catches the bug
function calculate2(x: number): number {
    if (x > 0) {
        return x * 2;
    }
    return "negative";  // ‚ùå Error! Type 'string' is not assignable to type 'number'
}
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Best Practice: Always Type Return Values</h4>
                    <p>Even though TypeScript can infer return types, explicitly typing them is recommended because:</p>
                    <ul>
                        <li>Makes your intent clear</li>
                        <li>Catches implementation bugs</li>
                        <li>Helps with API design</li>
                        <li>Better documentation</li>
                    </ul>
                </div>

                <h3>Real-World Example: User Authentication</h3>
                <pre><code class="language-typescript">// Return types make the function contract crystal clear
function authenticateUser(
    username: string,
    password: string
): { success: true; token: string } | { success: false; error: string } {
    // Simulate authentication
    if (username === "admin" && password === "secret") {
        return {
            success: true,
            token: "jwt-token-12345"
        };
    }
    
    return {
        success: false,
        error: "Invalid credentials"
    };
}

// Usage with type safety
const result = authenticateUser("admin", "secret");

if (result.success) {
    // TypeScript knows result has 'token' here
    console.log("Login successful! Token:", result.token);
} else {
    // TypeScript knows result has 'error' here
    console.log("Login failed:", result.error);
}
</code></pre>

                <div class="mermaid">
                    graph LR
                        A[Function Call] --> B[Parameters]
                        B --> C[Function Body]
                        C --> D[Return Value]
                        D --> E[Caller Receives]
                        
                        B --> B1[Type Checked]
                        D --> D1[Type Checked]
                        
                        style B1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style D1 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 2: Optional Parameters -->
            <section id="section2" class="lesson-section">
                <h2>Optional Parameters</h2>
                
                <p>Not all parameters need to be provided every time. Optional parameters let you create flexible APIs where some arguments are... well, optional! They're like saying "you can give me this, but you don't have to." üé≠</p>

                <h3>Basic Optional Parameters</h3>
                <p>Use the <code>?</code> symbol to mark a parameter as optional:</p>

                <pre><code class="language-typescript">// lastName is optional
function greetUser(firstName: string, lastName?: string): string {
    if (lastName) {
        return `Hello, ${firstName} ${lastName}!`;
    }
    return `Hello, ${firstName}!`;
}

// Both calls are valid
console.log(greetUser("Alice", "Smith"));  // "Hello, Alice Smith!"
console.log(greetUser("Bob"));             // "Hello, Bob!"

// Order matters - optional parameters must come AFTER required ones
function createUser(
    name: string,           // Required
    age: number,            // Required
    email?: string,         // Optional
    phone?: string          // Optional
): void {
    console.log(`Creating user: ${name}, age ${age}`);
    if (email) console.log(`Email: ${email}`);
    if (phone) console.log(`Phone: ${phone}`);
}

createUser("Alice", 30);                           // ‚úÖ OK
createUser("Bob", 25, "bob@example.com");         // ‚úÖ OK
createUser("Charlie", 35, "charlie@example.com", "555-1234");  // ‚úÖ OK
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Rule: Optional Parameters Go Last</h4>
                    <pre><code class="language-typescript">// ‚ùå Wrong - optional parameter before required
function wrong(optional?: string, required: number) { }

// ‚úÖ Right - optional parameters at the end
function right(required: number, optional?: string) { }
</code></pre>
                </div>

                <h3>Optional Parameters Are undefined</h3>
                <p>When an optional parameter isn't provided, its value is <code>undefined</code>:</p>

                <pre><code class="language-typescript">function printValue(value?: number): void {
    console.log(value);  // Could be undefined!
    
    // Check before using
    if (value !== undefined) {
        console.log(value.toFixed(2));  // Safe to use number methods
    }
    
    // Or use optional chaining
    console.log(value?.toFixed(2));
    
    // Or provide a default with nullish coalescing
    console.log((value ?? 0).toFixed(2));
}

printValue(42);      // 42
printValue();        // undefined
</code></pre>

                <h3>Multiple Optional Parameters</h3>
                <p>You can have several optional parameters:</p>

                <pre><code class="language-typescript">function fetchData(
    url: string,                    // Required
    method?: "GET" | "POST",        // Optional
    headers?: Record<string, string>,  // Optional
    timeout?: number                // Optional
): Promise<any> {
    const actualMethod = method ?? "GET";
    const actualTimeout = timeout ?? 5000;
    
    console.log(`Fetching ${url} with ${actualMethod}`);
    console.log(`Timeout: ${actualTimeout}ms`);
    
    if (headers) {
        console.log("Headers:", headers);
    }
    
    // Simulate API call
    return Promise.resolve({ data: "Success" });
}

// All valid calls
fetchData("/api/users");
fetchData("/api/users", "POST");
fetchData("/api/users", "POST", { "Content-Type": "application/json" });
fetchData("/api/users", "POST", { "Content-Type": "application/json" }, 10000);
</code></pre>

                <h3>Options Object Pattern</h3>
                <p>When you have many optional parameters, consider using an options object:</p>

                <pre><code class="language-typescript">// Instead of many optional parameters
function drawRectangle(
    x: number,
    y: number,
    width?: number,
    height?: number,
    color?: string,
    borderWidth?: number,
    borderColor?: string
): void {
    // Implementation
}

// Better: use an options object
interface RectangleOptions {
    x: number;
    y: number;
    width?: number;
    height?: number;
    color?: string;
    borderWidth?: number;
    borderColor?: string;
}

function drawRectangle2(options: RectangleOptions): void {
    const {
        x,
        y,
        width = 100,       // Default values
        height = 100,
        color = "black",
        borderWidth = 1,
        borderColor = "gray"
    } = options;
    
    console.log(`Drawing rectangle at (${x}, ${y})`);
    console.log(`Size: ${width}x${height}`);
    console.log(`Color: ${color}, Border: ${borderWidth}px ${borderColor}`);
}

// Much clearer to call!
drawRectangle2({
    x: 10,
    y: 20,
    width: 200,
    color: "blue"
});

// Only required properties needed
drawRectangle2({ x: 50, y: 50 });
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Optional Parameters</h4>
                    <ul>
                        <li><strong>Few optional params (1-3):</strong> Use optional parameters directly</li>
                        <li><strong>Many optional params (4+):</strong> Use an options object</li>
                        <li><strong>Complex config:</strong> Use an options object with nested structures</li>
                        <li><strong>Public APIs:</strong> Options objects are more extensible</li>
                    </ul>
                </div>

                <h3>Real-World Example: API Client</h3>
                <pre><code class="language-typescript">interface RequestOptions {
    method?: "GET" | "POST" | "PUT" | "DELETE";
    headers?: Record<string, string>;
    body?: any;
    timeout?: number;
    retries?: number;
}

async function apiRequest(
    endpoint: string,
    options?: RequestOptions
): Promise<any> {
    // Destructure with defaults
    const {
        method = "GET",
        headers = {},
        body,
        timeout = 5000,
        retries = 3
    } = options ?? {};
    
    console.log(`${method} ${endpoint}`);
    console.log(`Timeout: ${timeout}ms, Retries: ${retries}`);
    
    // Implementation would go here
    return { success: true };
}

// Flexible usage
await apiRequest("/api/users");                     // All defaults
await apiRequest("/api/users", { method: "POST" }); // Override method
await apiRequest("/api/users", {
    method: "POST",
    headers: { "Authorization": "Bearer token" },
    body: { name: "Alice" },
    timeout: 10000
});
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Optional parameters are perfect for progressive enhancement - start with the basics, let advanced users add more options as needed!
                </blockquote>
            </section>

            <!-- Section 3: Default Parameters -->
            <section id="section3" class="lesson-section">
                <h2>Default Parameters</h2>
                
                <p>Default parameters are like optional parameters with a built-in fallback. Instead of checking for <code>undefined</code>, you specify what value to use when none is provided. It's like ordering a coffee and saying "if I don't specify milk, use whole milk." ‚òï</p>

                <h3>Basic Default Parameters</h3>
                <p>Set a default value directly in the parameter list:</p>

                <pre><code class="language-typescript">// Default parameter values
function greet(name: string, greeting: string = "Hello"): string {
    return `${greeting}, ${name}!`;
}

console.log(greet("Alice"));              // "Hello, Alice!"
console.log(greet("Bob", "Hi"));          // "Hi, Bob!"
console.log(greet("Charlie", "Good morning"));  // "Good morning, Charlie!"

// Default parameters are implicitly optional
function createUser(name: string, role: string = "user"): void {
    console.log(`Creating ${role}: ${name}`);
}

createUser("Alice");           // "Creating user: Alice"
createUser("Bob", "admin");    // "Creating admin: Bob"
</code></pre>

                <h3>Type Inference with Defaults</h3>
                <p>TypeScript infers the parameter type from the default value:</p>

                <pre><code class="language-typescript">// TypeScript infers count is number
function repeat(text: string, count = 3): string {
    return text.repeat(count);
}

console.log(repeat("Ha"));         // "HaHaHa"
console.log(repeat("Ha", 5));      // "HaHaHaHaHa"
// repeat("Ha", "5");              // ‚ùå Error! Argument of type 'string' is not assignable to 'number'

// You can still add explicit types if you want
function repeat2(text: string, count: number = 3): string {
    return text.repeat(count);
}
</code></pre>

                <h3>Complex Default Values</h3>
                <p>Defaults can be expressions, not just literals:</p>

                <pre><code class="language-typescript">// Default can be a computed value
function logMessage(
    message: string,
    timestamp: string = new Date().toISOString()
): void {
    console.log(`[${timestamp}] ${message}`);
}

logMessage("Server started");                    // Uses current time
logMessage("Error occurred", "2024-01-15T10:30:00Z");  // Uses provided time

// Default can reference other parameters
function createSlug(
    title: string,
    separator: string = "-"
): string {
    return title
        .toLowerCase()
        .replace(/\s+/g, separator);
}

console.log(createSlug("Hello World"));      // "hello-world"
console.log(createSlug("Hello World", "_")); // "hello_world"

// Default can be an object or array
function processData(
    data: any[],
    options: { sort: boolean; limit: number } = { sort: true, limit: 10 }
): any[] {
    let result = [...data];
    
    if (options.sort) {
        result.sort();
    }
    
    return result.slice(0, options.limit);
}

const numbers = [5, 2, 8, 1, 9];
console.log(processData(numbers));  // Uses default options
console.log(processData(numbers, { sort: false, limit: 3 }));  // Custom options
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Default vs Optional: What's the Difference?</h4>
                    <pre><code class="language-typescript">// Optional: explicitly handle undefined
function optional(x?: number): number {
    if (x === undefined) {
        return 0;  // Manual default
    }
    return x * 2;
}

// Default: value provided automatically
function withDefault(x: number = 0): number {
    return x * 2;  // No need to check undefined
}

// Both work similarly for callers
optional();      // 0
withDefault();   // 0

optional(5);     // 10
withDefault(5);  // 10

// Key difference: optional can be explicitly undefined
optional(undefined);    // 0
withDefault(undefined); // 0 (default kicks in)
</code></pre>
                </div>

                <h3>Default Parameters with Destructuring</h3>
                <p>Combine defaults with destructuring for powerful patterns:</p>

                <pre><code class="language-typescript">interface ConnectionOptions {
    host: string;
    port: number;
    ssl: boolean;
    timeout: number;
}

// Destructure with defaults
function connect({
    host = "localhost",
    port = 3000,
    ssl = false,
    timeout = 5000
}: Partial<ConnectionOptions> = {}): void {
    console.log(`Connecting to ${ssl ? "https" : "http"}://${host}:${port}`);
    console.log(`Timeout: ${timeout}ms`);
}

// All these work!
connect();                                   // All defaults
connect({ host: "example.com" });           // Override host
connect({ host: "example.com", port: 8080, ssl: true });
</code></pre>

                <h3>When Defaults Are Calculated</h3>
                <p>Important: default values are evaluated each time the function is called:</p>

                <pre><code class="language-typescript">// Default is evaluated on EACH call
function logWithTime(
    message: string,
    time: Date = new Date()  // New Date() called each time!
): void {
    console.log(`[${time.toISOString()}] ${message}`);
}

logWithTime("First message");
// Wait a second...
setTimeout(() => {
    logWithTime("Second message");  // Different timestamp!
}, 1000);

// Be careful with mutable defaults
function addItem(
    item: string,
    list: string[] = []  // New empty array each time
): string[] {
    list.push(item);
    return list;
}

const list1 = addItem("apple");   // ["apple"]
const list2 = addItem("banana");  // ["banana"] - different array!
console.log(list1 === list2);     // false
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Default Parameter Gotchas</h4>
                    <ul>
                        <li>Defaults are evaluated every call (not once at function definition)</li>
                        <li>Default parameters must come after required parameters</li>
                        <li>Passing <code>undefined</code> explicitly triggers the default</li>
                        <li>Passing <code>null</code> does NOT trigger the default</li>
                    </ul>
                    <pre><code class="language-typescript">function test(x: number = 10): number {
    return x;
}

test();           // 10 (default used)
test(undefined);  // 10 (default used)
test(null as any);// null (default NOT used - null is a value!)
test(0);          // 0 (default NOT used - 0 is a value!)
</code></pre>
                </div>

                <h3>Real-World Example: Configuration Function</h3>
                <pre><code class="language-typescript">interface ServerConfig {
    port: number;
    host: string;
    ssl: boolean;
    corsEnabled: boolean;
    maxConnections: number;
    logLevel: "debug" | "info" | "warn" | "error";
}

function startServer({
    port = 3000,
    host = "0.0.0.0",
    ssl = false,
    corsEnabled = true,
    maxConnections = 100,
    logLevel = "info"
}: Partial<ServerConfig> = {}): void {
    console.log("Server Configuration:");
    console.log(`  Address: ${ssl ? "https" : "http"}://${host}:${port}`);
    console.log(`  CORS: ${corsEnabled ? "enabled" : "disabled"}`);
    console.log(`  Max connections: ${maxConnections}`);
    console.log(`  Log level: ${logLevel}`);
    console.log("\nServer started successfully!");
}

// Minimal config - all defaults
startServer();

// Custom config - override some values
startServer({
    port: 8080,
    ssl: true,
    logLevel: "debug"
});

// Full custom config
startServer({
    port: 443,
    host: "api.example.com",
    ssl: true,
    corsEnabled: false,
    maxConnections: 500,
    logLevel: "warn"
});
</code></pre>

                <blockquote>
                    <strong>üí° Best Practice:</strong> Use default parameters when you have a sensible default value. Use optional parameters when there's no good default and you need to handle the absence explicitly.
                </blockquote>
            </section>
            <!-- Section 4: Rest Parameters -->
            <section id="section4" class="lesson-section">
                <h2>Rest Parameters</h2>
                
                <p>What if you don't know how many arguments you'll receive? Maybe you want to sum any number of values, or log multiple messages at once. Rest parameters let you handle variable-length argument lists elegantly! Think of them as "pack everything else into an array." üì¶</p>

                <h3>Basic Rest Parameters</h3>
                <p>Use three dots (<code>...</code>) to collect remaining arguments into an array:</p>

                <pre><code class="language-typescript">// Rest parameter collects all arguments into an array
function sum(...numbers: number[]): number {
    return numbers.reduce((total, n) => total + n, 0);
}

console.log(sum(1, 2, 3));           // 6
console.log(sum(1, 2, 3, 4, 5));     // 15
console.log(sum(10));                // 10
console.log(sum());                  // 0 (empty array)

// Log multiple messages
function logAll(...messages: string[]): void {
    messages.forEach(msg => console.log(msg));
}

logAll("Hello", "World", "!");
logAll("TypeScript", "is", "awesome");
</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üìñ Key Concept</h3>
                    <p style="color: white;"><strong>Rest Parameter:</strong> A special parameter that collects any number of arguments into an array. It must be the last parameter and there can only be one per function. The type is always an array type.</p>
                </div>

                <h3>Combining Regular and Rest Parameters</h3>
                <p>You can have regular parameters before the rest parameter:</p>

                <pre><code class="language-typescript">// First parameter is required, rest are collected
function greetAll(greeting: string, ...names: string[]): string[] {
    return names.map(name => `${greeting}, ${name}!`);
}

const greetings = greetAll("Hello", "Alice", "Bob", "Charlie");
console.log(greetings);
// ["Hello, Alice!", "Hello, Bob!", "Hello, Charlie!"]

// Mix types in regular parameters
function buildUrl(
    baseUrl: string,
    ...pathSegments: string[]
): string {
    return baseUrl + "/" + pathSegments.join("/");
}

console.log(buildUrl("https://api.example.com", "users", "123", "posts"));
// "https://api.example.com/users/123/posts"

console.log(buildUrl("https://api.example.com", "products"));
// "https://api.example.com/products"
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Rules for Rest Parameters</h4>
                    <ul>
                        <li>Must be the LAST parameter (nothing can come after it)</li>
                        <li>Can only have ONE rest parameter per function</li>
                        <li>The type must be an array type</li>
                        <li>It's always optional (can receive zero arguments)</li>
                    </ul>
                    <pre><code class="language-typescript">// ‚úÖ Correct
function correct(a: number, ...rest: string[]): void { }

// ‚ùå Wrong - rest parameter must be last
function wrong(...rest: string[], a: number): void { }

// ‚ùå Wrong - can't have two rest parameters
function wrong2(...rest1: string[], ...rest2: number[]): void { }
</code></pre>
                </div>

                <h3>Rest Parameters with Different Types</h3>
                <p>The rest parameter can collect any type of values:</p>

                <pre><code class="language-typescript">// Collect numbers
function max(...numbers: number[]): number {
    if (numbers.length === 0) {
        return -Infinity;
    }
    return Math.max(...numbers);
}

console.log(max(1, 5, 3, 9, 2));  // 9

// Collect objects
interface Product {
    name: string;
    price: number;
}

function calculateTotal(...products: Product[]): number {
    return products.reduce((total, product) => total + product.price, 0);
}

const total = calculateTotal(
    { name: "Laptop", price: 999 },
    { name: "Mouse", price: 25 },
    { name: "Keyboard", price: 75 }
);
console.log(total);  // 1099

// Collect any type with union
function logValues(...values: (string | number | boolean)[]): void {
    values.forEach(value => {
        console.log(`${typeof value}: ${value}`);
    });
}

logValues("hello", 42, true, "world", 3.14);
</code></pre>

                <h3>Rest Parameters with Tuples</h3>
                <p>For more precise typing, you can use tuple types with rest parameters:</p>

                <pre><code class="language-typescript">// Rest parameter as tuple (TypeScript 4.0+)
function coordinate(x: number, y: number, ...rest: [z?: number, label?: string]): void {
    console.log(`Point at (${x}, ${y})`);
    
    if (rest[0] !== undefined) {
        console.log(`Z coordinate: ${rest[0]}`);
    }
    
    if (rest[1]) {
        console.log(`Label: ${rest[1]}`);
    }
}

coordinate(10, 20);                    // 2D point
coordinate(10, 20, 30);                // 3D point
coordinate(10, 20, 30, "Origin");      // 3D point with label

// More complex: variadic tuple types
function concat<T>(...arrays: T[][]): T[] {
    return arrays.flat();
}

const numbers = concat([1, 2], [3, 4], [5, 6]);
const strings = concat(["a", "b"], ["c", "d"]);
console.log(numbers);  // [1, 2, 3, 4, 5, 6]
console.log(strings);  // ["a", "b", "c", "d"]
</code></pre>

                <h3>Spread Operator vs Rest Parameter</h3>
                <p>Rest parameters collect, spread operator expands. They look the same but do opposite things!</p>

                <pre><code class="language-typescript">// Rest parameter: collects arguments INTO an array
function sum(...numbers: number[]): number {
    return numbers.reduce((a, b) => a + b, 0);
}

// Spread operator: expands an array INTO arguments
const numbersArray = [1, 2, 3, 4, 5];
const result = sum(...numbersArray);  // Spreading array into arguments
console.log(result);  // 15

// Another example
function createUser(name: string, ...roles: string[]): void {
    console.log(`User: ${name}`);
    console.log(`Roles: ${roles.join(", ")}`);
}

const rolesList = ["admin", "editor", "viewer"];
createUser("Alice", ...rolesList);  // Spreading array
// User: Alice
// Roles: admin, editor, viewer

// You can combine them!
function merge(...arrays: number[][]): number[] {
    return arrays.flat();
}

const result2 = merge([1, 2], [3, 4], [5, 6]);
console.log(result2);  // [1, 2, 3, 4, 5, 6]
</code></pre>

                <div class="mermaid">
                    graph LR
                        A[Function Call] --> B[Multiple Arguments]
                        B --> C[Rest Parameter ...]
                        C --> D[Collected into Array]
                        
                        E[Array] --> F[Spread Operator ...]
                        F --> G[Expanded to Arguments]
                        G --> A
                        
                        style C fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style F fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>Real-World Example: SQL Query Builder</h3>
                <pre><code class="language-typescript">type WhereCondition = [field: string, operator: string, value: any];

class QueryBuilder {
    private table: string = "";
    private conditions: WhereCondition[] = [];
    
    // Use rest parameters for flexible WHERE clauses
    where(...conditions: WhereCondition[]): this {
        this.conditions.push(...conditions);
        return this;
    }
    
    from(table: string): this {
        this.table = table;
        return this;
    }
    
    build(): string {
        let query = `SELECT * FROM ${this.table}`;
        
        if (this.conditions.length > 0) {
            const whereClause = this.conditions
                .map(([field, op, value]) => `${field} ${op} '${value}'`)
                .join(" AND ");
            query += ` WHERE ${whereClause}`;
        }
        
        return query;
    }
}

// Flexible usage with any number of conditions
const query1 = new QueryBuilder()
    .from("users")
    .where(["age", ">", 18])
    .build();

const query2 = new QueryBuilder()
    .from("users")
    .where(
        ["age", ">", 18],
        ["status", "=", "active"],
        ["role", "=", "admin"]
    )
    .build();

console.log(query1);
// SELECT * FROM users WHERE age > '18'

console.log(query2);
// SELECT * FROM users WHERE age > '18' AND status = 'active' AND role = 'admin'
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Rest parameters are perfect for functions that naturally work with collections - mathematical operations, array utilities, logging functions, and builder patterns!
                </blockquote>
            </section>

            <!-- Section 5: Arrow Functions -->
            <section id="section5" class="lesson-section">
                <h2>Arrow Functions</h2>
                
                <p>Arrow functions are the modern, concise way to write functions in JavaScript and TypeScript. They're shorter, cleaner, and have some special behaviors. Let's master them with types! üèπ</p>

                <h3>Basic Arrow Function Syntax</h3>
                <p>Arrow functions use the <code>=&gt;</code> syntax:</p>

                <pre><code class="language-typescript">// Regular function
function add(a: number, b: number): number {
    return a + b;
}

// Arrow function - equivalent
const add2 = (a: number, b: number): number => {
    return a + b;
};

// Shorter - implicit return (no braces needed for single expression)
const add3 = (a: number, b: number): number => a + b;

// All three work the same way
console.log(add(5, 3));   // 8
console.log(add2(5, 3));  // 8
console.log(add3(5, 3));  // 8
</code></pre>

                <h3>Type Annotations in Arrow Functions</h3>
                <p>You can type arrow functions in several ways:</p>

                <pre><code class="language-typescript">// Method 1: Type parameters and return type
const greet1 = (name: string): string => `Hello, ${name}!`;

// Method 2: Type the entire function variable
const greet2: (name: string) => string = (name) => `Hello, ${name}!`;

// Method 3: Use a type alias
type GreetFunction = (name: string) => string;
const greet3: GreetFunction = (name) => `Hello, ${name}!`;

// Method 4: Use an interface
interface GreetFunction2 {
    (name: string): string;
}
const greet4: GreetFunction2 = (name) => `Hello, ${name}!`;

// Most common: Method 1 (type parameters directly)
const multiply = (a: number, b: number): number => a * b;
</code></pre>

                <h3>Implicit Returns</h3>
                <p>When the function body is a single expression, you can omit the braces and return:</p>

                <pre><code class="language-typescript">// With explicit return
const double1 = (n: number): number => {
    return n * 2;
};

// Implicit return - cleaner!
const double2 = (n: number): number => n * 2;

// Works with any single expression
const isEven = (n: number): boolean => n % 2 === 0;
const square = (n: number): number => n * n;
const exclaim = (text: string): string => `${text}!`;

// Returning objects requires parentheses
const createUser = (name: string, age: number) => ({
    name,
    age,
    createdAt: new Date()
});

// Without parens, it looks like a code block!
// const wrong = (name: string) => { name: name };  // This is a code block, not an object!
</code></pre>

                <h3>Arrow Functions with Rest Parameters</h3>
                <pre><code class="language-typescript">// Rest parameters work perfectly in arrow functions
const sum = (...numbers: number[]): number => 
    numbers.reduce((total, n) => total + n, 0);

const max = (...numbers: number[]): number => 
    Math.max(...numbers);

const concat = (...strings: string[]): string => 
    strings.join("");

console.log(sum(1, 2, 3, 4));        // 10
console.log(max(5, 2, 9, 1));        // 9
console.log(concat("Type", "Script")); // "TypeScript"
</code></pre>

                <h3>Arrow Functions with Optional/Default Parameters</h3>
                <pre><code class="language-typescript">// Optional parameters
const greet = (name: string, greeting?: string): string => 
    `${greeting ?? "Hello"}, ${name}!`;

// Default parameters
const repeat = (text: string, times: number = 3): string => 
    text.repeat(times);

// Destructuring with defaults
const createPoint = ({
    x = 0,
    y = 0
}: { x?: number; y?: number } = {}): string => 
    `Point(${x}, ${y})`;

console.log(greet("Alice"));              // "Hello, Alice!"
console.log(repeat("Ha"));                // "HaHaHa"
console.log(createPoint({ x: 10 }));      // "Point(10, 0)"
</code></pre>

                <h3>Arrow Functions as Callbacks</h3>
                <p>Arrow functions really shine when used as callbacks:</p>

                <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    age: number;
}

const users: User[] = [
    { id: 1, name: "Alice", age: 30 },
    { id: 2, name: "Bob", age: 25 },
    { id: 3, name: "Charlie", age: 35 }
];

// Array methods with arrow functions
const names = users.map((user) => user.name);
const adults = users.filter((user) => user.age >= 18);
const totalAge = users.reduce((sum, user) => sum + user.age, 0);
const sorted = users.sort((a, b) => a.age - b.age);

console.log(names);     // ["Alice", "Bob", "Charlie"]
console.log(totalAge);  // 90

// Even cleaner with implicit returns
const activeUsers = users.filter(u => u.age > 25);
const userIds = users.map(u => u.id);

// TypeScript infers types from the array!
users.forEach(user => {
    // user is typed as User automatically
    console.log(user.name);
});
</code></pre>

                <h3>Arrow Functions vs Regular Functions: this Binding</h3>
                <p>Arrow functions don't create their own <code>this</code> context - they inherit it. This is crucial in TypeScript:</p>

                <pre><code class="language-typescript">class Counter {
    count: number = 0;
    
    // Regular function - 'this' can be problematic
    incrementRegular() {
        setTimeout(function() {
            // 'this' is undefined here in strict mode!
            // this.count++;  // Error!
        }, 100);
    }
    
    // Arrow function - 'this' works correctly
    incrementArrow() {
        setTimeout(() => {
            this.count++;  // ‚úÖ Works! 'this' refers to Counter instance
        }, 100);
    }
    
    // Public method using arrow function property
    increment = (): void => {
        this.count++;
    }
}

const counter = new Counter();
counter.incrementArrow();

// Arrow functions preserve 'this' when passed as callbacks
const button = {
    label: "Click me",
    handleClick: () => {
        console.log(this.label);  // 'this' comes from surrounding scope
    }
};
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Arrow Functions</h4>
                    <ul>
                        <li><strong>Callbacks:</strong> Array methods, event handlers, promises</li>
                        <li><strong>Short functions:</strong> One-liners and simple transformations</li>
                        <li><strong>Preserving 'this':</strong> When you need lexical 'this' binding</li>
                        <li><strong>Functional programming:</strong> Map, filter, reduce chains</li>
                    </ul>
                    
                    <h4>When to Use Regular Functions</h4>
                    <ul>
                        <li><strong>Methods:</strong> Class methods that use 'this'</li>
                        <li><strong>Constructors:</strong> Functions used with 'new'</li>
                        <li><strong>Complex logic:</strong> Multiple statements, better with explicit returns</li>
                        <li><strong>Function hoisting:</strong> When you need the function before it's defined</li>
                    </ul>
                </div>

                <h3>Real-World Example: Data Pipeline</h3>
                <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
    inStock: boolean;
}

const products: Product[] = [
    { id: 1, name: "Laptop", price: 999, category: "electronics", inStock: true },
    { id: 2, name: "Mouse", price: 25, category: "electronics", inStock: true },
    { id: 3, name: "Desk", price: 299, category: "furniture", inStock: false },
    { id: 4, name: "Chair", price: 199, category: "furniture", inStock: true }
];

// Data processing pipeline with arrow functions
const processProducts = (products: Product[], maxPrice: number): Product[] => 
    products
        .filter(p => p.inStock)              // Only in-stock items
        .filter(p => p.price <= maxPrice)    // Within budget
        .map(p => ({                         // Add discount
            ...p,
            price: p.price * 0.9
        }))
        .sort((a, b) => a.price - b.price);  // Sort by price

const affordable = processProducts(products, 500);
console.log(affordable);

// Reusable transforms as arrow functions
const applyDiscount = (percent: number) => 
    (product: Product): Product => ({
        ...product,
        price: product.price * (1 - percent / 100)
    });

const addTax = (rate: number) => 
    (product: Product): Product => ({
        ...product,
        price: product.price * (1 + rate / 100)
    });

// Compose transforms
const finalPrice = products
    .map(applyDiscount(10))
    .map(addTax(8));
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Arrow functions make functional programming patterns much cleaner in TypeScript. Use them for transformations, filters, and data pipelines!
                </blockquote>
            </section>

            <!-- Section 6: Function Types -->
            <section id="section6" class="lesson-section">
                <h2>Function Types</h2>
                
                <p>Sometimes you need to describe what a function looks like without implementing it. Maybe you're accepting a callback, or defining a common interface for different implementations. Function types let you specify the contract! üìã</p>

                <h3>Basic Function Type Syntax</h3>
                <p>Function types describe parameter types and return type:</p>

                <pre><code class="language-typescript">// Function type: (parameters) => return type
type MathOperation = (a: number, b: number) => number;

// Implement functions matching this type
const add: MathOperation = (a, b) => a + b;
const subtract: MathOperation = (a, b) => a - b;
const multiply: MathOperation = (a, b) => a * b;

console.log(add(5, 3));       // 8
console.log(subtract(5, 3));  // 2
console.log(multiply(5, 3));  // 15

// Function that takes another function
function applyOperation(
    a: number,
    b: number,
    operation: MathOperation
): number {
    return operation(a, b);
}

console.log(applyOperation(10, 5, add));       // 15
console.log(applyOperation(10, 5, multiply));  // 50
</code></pre>

                <h3>Function Types with Interfaces</h3>
                <p>You can also define function types using interfaces:</p>

                <pre><code class="language-typescript">// Using interface for function type
interface Validator {
    (value: string): boolean;
}

const isEmail: Validator = (value) => {
    return value.includes("@");
};

const isNotEmpty: Validator = (value) => {
    return value.length > 0;
};

console.log(isEmail("test@example.com"));  // true
console.log(isNotEmpty(""));               // false

// Interface can also have properties (callable object)
interface Counter {
    (start: number): number;  // Call signature
    reset: () => void;         // Method
    current: number;           // Property
}

// This is advanced - functions are objects in JavaScript!
</code></pre>

                <h3>Callback Function Types</h3>
                <p>Define types for callbacks to ensure they're called correctly:</p>

                <pre><code class="language-typescript">// Define callback types
type SuccessCallback = (data: any) => void;
type ErrorCallback = (error: string) => void;

// Function that accepts callbacks
function fetchData(
    url: string,
    onSuccess: SuccessCallback,
    onError: ErrorCallback
): void {
    // Simulate API call
    setTimeout(() => {
        if (url.startsWith("http")) {
            onSuccess({ data: "Success!" });
        } else {
            onError("Invalid URL");
        }
    }, 1000);
}

// Use with type-safe callbacks
fetchData(
    "https://api.example.com",
    (data) => console.log("Success:", data),
    (error) => console.error("Error:", error)
);

// More specific callback types
type UserCallback = (user: { id: number; name: string }) => void;
type ErrorCallback2 = (error: { code: number; message: string }) => void;

function getUser(id: number, callback: UserCallback, onError: ErrorCallback2): void {
    // Implementation
}
</code></pre>

                <h3>Generic Function Types</h3>
                <p>Function types can be generic for maximum flexibility:</p>

                <pre><code class="language-typescript">// Generic function type
type Transform<T, U> = (input: T) => U;

// Specific implementations
const numberToString: Transform<number, string> = (n) => n.toString();
const stringToNumber: Transform<string, number> = (s) => parseInt(s);
const doubleNumber: Transform<number, number> = (n) => n * 2;

console.log(numberToString(42));    // "42"
console.log(stringToNumber("100")); // 100
console.log(doubleNumber(21));      // 42

// Generic array processor
type Processor<T> = (item: T, index: number) => T;

function processArray<T>(items: T[], processor: Processor<T>): T[] {
    return items.map((item, index) => processor(item, index));
}

const numbers = [1, 2, 3, 4, 5];
const doubled = processArray(numbers, (n, i) => n * 2);
console.log(doubled);  // [2, 4, 6, 8, 10]

const strings = ["a", "b", "c"];
const indexed = processArray(strings, (s, i) => `${i}: ${s}`);
console.log(indexed);  // ["0: a", "1: b", "2: c"]
</code></pre>

                <h3>Predicate Functions</h3>
                <p>Special function types for filtering and validation:</p>

                <pre><code class="language-typescript">// Predicate: function that returns boolean
type Predicate<T> = (item: T) => boolean;

interface User {
    id: number;
    name: string;
    age: number;
    isActive: boolean;
}

// Use predicates for filtering
const isAdult: Predicate<User> = (user) => user.age >= 18;
const isActive: Predicate<User> = (user) => user.isActive;

const users: User[] = [
    { id: 1, name: "Alice", age: 30, isActive: true },
    { id: 2, name: "Bob", age: 17, isActive: true },
    { id: 3, name: "Charlie", age: 25, isActive: false }
];

const adults = users.filter(isAdult);
const activeUsers = users.filter(isActive);

console.log(adults.length);       // 2
console.log(activeUsers.length);  // 2

// Combine predicates
const combinePredicates = <T>(
    ...predicates: Predicate<T>[]
): Predicate<T> => {
    return (item: T) => predicates.every(pred => pred(item));
};

const activeAdults = users.filter(
    combinePredicates(isAdult, isActive)
);
console.log(activeAdults);  // [{ id: 1, name: "Alice", ... }]
</code></pre>

                <h3>Function Type Parameters</h3>
                <p>Functions can receive other functions as parameters:</p>

                <pre><code class="language-typescript">// Higher-order function types
type Comparator<T> = (a: T, b: T) => number;
type Mapper<T, U> = (item: T) => U;
type Reducer<T, U> = (accumulator: U, current: T) => U;

// Sort with custom comparator
function sort<T>(items: T[], compare: Comparator<T>): T[] {
    return [...items].sort(compare);
}

const numbers = [3, 1, 4, 1, 5, 9, 2, 6];

const ascending = sort(numbers, (a, b) => a - b);
const descending = sort(numbers, (a, b) => b - a);

console.log(ascending);   // [1, 1, 2, 3, 4, 5, 6, 9]
console.log(descending);  // [9, 6, 5, 4, 3, 2, 1, 1]

// Map with custom mapper
function map<T, U>(items: T[], mapper: Mapper<T, U>): U[] {
    return items.map(mapper);
}

const doubled = map(numbers, n => n * 2);
const stringified = map(numbers, n => n.toString());

// Reduce with custom reducer
function reduce<T, U>(
    items: T[],
    reducer: Reducer<T, U>,
    initialValue: U
): U {
    return items.reduce(reducer, initialValue);
}

const sum = reduce(numbers, (acc, n) => acc + n, 0);
console.log(sum);  // 31
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Real-World Example: Event System</h4>
                    <pre><code class="language-typescript">// Define event types
type EventHandler<T = any> = (data: T) => void;
type Unsubscribe = () => void;

class EventBus {
    private listeners: Map<string, EventHandler[]> = new Map();
    
    // Subscribe with typed handler
    on<T>(event: string, handler: EventHandler<T>): Unsubscribe {
        if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
        }
        
        this.listeners.get(event)!.push(handler);
        
        // Return unsubscribe function
        return () => {
            const handlers = this.listeners.get(event);
            if (handlers) {
                const index = handlers.indexOf(handler);
                if (index > -1) {
                    handlers.splice(index, 1);
                }
            }
        };
    }
    
    // Emit with typed data
    emit<T>(event: string, data: T): void {
        const handlers = this.listeners.get(event);
        if (handlers) {
            handlers.forEach(handler => handler(data));
        }
    }
}

// Usage with type safety
const bus = new EventBus();

interface UserLoginEvent {
    userId: number;
    timestamp: Date;
}

const unsubscribe = bus.on<UserLoginEvent>("user:login", (data) => {
    // data is typed as UserLoginEvent
    console.log(`User ${data.userId} logged in at ${data.timestamp}`);
});

bus.emit("user:login", {
    userId: 123,
    timestamp: new Date()
});

unsubscribe();  // Remove listener
</code></pre>
                </div>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Function types are essential for building flexible, reusable APIs. Use them for callbacks, event handlers, data processors, and higher-order functions!
                </blockquote>
            </section>
            <!-- Section 7: Function Overloads -->
            <section id="section7" class="lesson-section">
                <h2>Function Overloads</h2>
                
                <p>Sometimes you want the same function to work differently based on what you pass in. Function overloads let you define multiple signatures for one function - like having different versions of the same tool for different jobs! üîß</p>

                <h3>What Are Function Overloads?</h3>
                <p>Function overloads allow you to define multiple type signatures for a single function implementation:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üìñ Definition</h3>
                    <p style="color: white;"><strong>Function Overload:</strong> Multiple function signatures that describe different ways to call the same function. The implementation must handle all the overload cases.</p>
                </div>

                <h3>Basic Function Overload Syntax</h3>
                <pre><code class="language-typescript">// Overload signatures
function format(value: string): string;
function format(value: number): string;
function format(value: boolean): string;

// Implementation signature (must be compatible with all overloads)
function format(value: string | number | boolean): string {
    if (typeof value === "string") {
        return `"${value}"`;
    } else if (typeof value === "number") {
        return value.toFixed(2);
    } else {
        return value ? "Yes" : "No";
    }
}

// TypeScript knows the return type based on the input!
console.log(format("hello"));    // "hello"
console.log(format(42));         // 42.00
console.log(format(true));       // Yes

// The implementation signature is not callable!
// format([1, 2, 3]);  // ‚ùå Error! No overload matches this call
</code></pre>

                <h3>Why Use Function Overloads?</h3>
                <p>Overloads provide better type inference and clearer API contracts:</p>

                <pre><code class="language-typescript">// Without overloads - less precise
function createElement(tag: string, className?: string): HTMLElement {
    const element = document.createElement(tag);
    if (className) {
        element.className = className;
    }
    return element;
}

// With overloads - more precise!
function createElement2(tag: "div"): HTMLDivElement;
function createElement2(tag: "span"): HTMLSpanElement;
function createElement2(tag: "a"): HTMLAnchorElement;
function createElement2(tag: string): HTMLElement;

function createElement2(tag: string): HTMLElement {
    return document.createElement(tag);
}

// TypeScript knows the specific return type!
const div = createElement2("div");     // Type: HTMLDivElement
const span = createElement2("span");   // Type: HTMLSpanElement
const anchor = createElement2("a");    // Type: HTMLAnchorElement
const custom = createElement2("custom"); // Type: HTMLElement

// You get autocomplete for specific element properties
div.style.display = "block";           // ‚úÖ OK - div has style
anchor.href = "https://example.com";   // ‚úÖ OK - anchor has href
</code></pre>

                <h3>Overloads with Different Parameter Counts</h3>
                <pre><code class="language-typescript">// Different numbers of parameters
function createPoint(x: number, y: number): { x: number; y: number };
function createPoint(x: number, y: number, z: number): { x: number; y: number; z: number };

function createPoint(x: number, y: number, z?: number) {
    if (z !== undefined) {
        return { x, y, z };
    }
    return { x, y };
}

const point2D = createPoint(10, 20);       // Type: { x: number; y: number }
const point3D = createPoint(10, 20, 30);   // Type: { x: number; y: number; z: number }

// TypeScript enforces the correct structure
console.log(point2D.x, point2D.y);         // ‚úÖ OK
// console.log(point2D.z);                 // ‚ùå Error! z doesn't exist on 2D point
console.log(point3D.x, point3D.y, point3D.z);  // ‚úÖ OK
</code></pre>

                <h3>Overloads with Different Return Types</h3>
                <pre><code class="language-typescript">// Return different types based on input
function getValue(key: "name"): string;
function getValue(key: "age"): number;
function getValue(key: "active"): boolean;

function getValue(key: string): string | number | boolean {
    const data: Record<string, string | number | boolean> = {
        name: "Alice",
        age: 30,
        active: true
    };
    return data[key];
}

// TypeScript knows the exact return type!
const name = getValue("name");     // Type: string
const age = getValue("age");       // Type: number
const active = getValue("active"); // Type: boolean

// Can use without type guards
console.log(name.toUpperCase());   // ‚úÖ OK - name is definitely string
console.log(age.toFixed(2));       // ‚úÖ OK - age is definitely number
console.log(active ? "Yes" : "No"); // ‚úÖ OK - active is definitely boolean
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Overload Rules</h4>
                    <ul>
                        <li>Overload signatures come BEFORE the implementation</li>
                        <li>The implementation signature must be compatible with ALL overloads</li>
                        <li>Only overload signatures are visible to callers (not the implementation)</li>
                        <li>Order matters - more specific overloads should come before general ones</li>
                    </ul>
                </div>

                <h3>Conditional Return Types with Overloads</h3>
                <pre><code class="language-typescript">// Parse based on format
function parse(data: string, format: "json"): object;
function parse(data: string, format: "number"): number;
function parse(data: string, format: "date"): Date;

function parse(data: string, format: string): object | number | Date {
    switch (format) {
        case "json":
            return JSON.parse(data);
        case "number":
            return parseFloat(data);
        case "date":
            return new Date(data);
        default:
            throw new Error(`Unknown format: ${format}`);
    }
}

// Type-safe parsing!
const obj = parse('{"name": "Alice"}', "json");   // Type: object
const num = parse("42.5", "number");              // Type: number
const date = parse("2024-01-15", "date");         // Type: Date

// You can use specific methods
console.log(num.toFixed(2));          // ‚úÖ OK
console.log(date.getFullYear());      // ‚úÖ OK
</code></pre>

                <h3>Generic Overloads</h3>
                <p>Combine overloads with generics for ultimate flexibility:</p>

                <pre><code class="language-typescript">// Generic overloads
function map<T, U>(arr: T[], fn: (item: T) => U): U[];
function map<T, U>(arr: T[], fn: (item: T, index: number) => U): U[];

function map<T, U>(
    arr: T[],
    fn: (item: T, index?: number) => U
): U[] {
    return arr.map(fn);
}

const numbers = [1, 2, 3];

// Both work with full type inference
const doubled = map(numbers, n => n * 2);              // U[] where U = number
const indexed = map(numbers, (n, i) => `${i}: ${n}`);  // U[] where U = string

// Another example: flexible fetch
function fetch<T>(url: string): Promise<T>;
function fetch<T>(url: string, options: RequestInit): Promise<T>;

function fetch<T>(url: string, options?: RequestInit): Promise<T> {
    return window.fetch(url, options).then(r => r.json());
}

interface User {
    id: number;
    name: string;
}

// Type-safe API calls
const user = await fetch<User>("/api/users/1");
console.log(user.name);  // TypeScript knows user has name
</code></pre>

                <h3>Real-World Example: Database Query</h3>
                <pre><code class="language-typescript">// Different return types based on whether we're fetching one or many
interface User {
    id: number;
    name: string;
    email: string;
}

function query(sql: string, single: true): User | null;
function query(sql: string, single: false): User[];
function query(sql: string): User[];

function query(sql: string, single?: boolean): User | User[] | null {
    // Simulate database query
    const allUsers: User[] = [
        { id: 1, name: "Alice", email: "alice@example.com" },
        { id: 2, name: "Bob", email: "bob@example.com" }
    ];
    
    if (single) {
        return allUsers[0] || null;
    }
    
    return allUsers;
}

// Type-safe queries!
const oneUser = query("SELECT * FROM users WHERE id = 1", true);
// Type: User | null
if (oneUser) {
    console.log(oneUser.name);  // Safe to access
}

const manyUsers = query("SELECT * FROM users", false);
// Type: User[]
manyUsers.forEach(user => {
    console.log(user.name);  // Safe to iterate
});

const allUsers = query("SELECT * FROM users");
// Type: User[] (default behavior)
console.log(allUsers.length);
</code></pre>

                <h3>Overloads vs Union Types</h3>
                <p>When should you use overloads instead of union types?</p>

                <pre><code class="language-typescript">// Using union types (less precise)
function process(
    input: string | number
): string | number {
    if (typeof input === "string") {
        return input.toUpperCase();
    }
    return input * 2;
}

const result1 = process("hello");  // Type: string | number (not precise!)
const result2 = process(42);       // Type: string | number (not precise!)

// You need type guards to use the result
if (typeof result1 === "string") {
    console.log(result1.toUpperCase());
}

// Using overloads (more precise)
function process2(input: string): string;
function process2(input: number): number;

function process2(input: string | number): string | number {
    if (typeof input === "string") {
        return input.toUpperCase();
    }
    return input * 2;
}

const result3 = process2("hello");  // Type: string (precise!)
const result4 = process2(42);       // Type: number (precise!)

// No type guards needed!
console.log(result3.toUpperCase());  // ‚úÖ TypeScript knows it's string
console.log(result4.toFixed(2));     // ‚úÖ TypeScript knows it's number
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Function Overloads</h4>
                    <ul>
                        <li>When return type depends on parameter types</li>
                        <li>When you need different parameter combinations</li>
                        <li>When union types would require many type guards</li>
                        <li>When you want precise type inference</li>
                        <li>When building libraries with complex APIs</li>
                    </ul>
                    
                    <h4>When to Use Union Types</h4>
                    <ul>
                        <li>When the function truly returns multiple types</li>
                        <li>When the relationship between input and output is complex</li>
                        <li>When simpler is better (don't over-engineer!)</li>
                    </ul>
                </div>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Function overloads are powerful but add complexity. Use them when they truly improve type safety and developer experience, not just because you can!
                </blockquote>
            </section>

            <!-- Section 8: Hands-on Practice -->
            <section id="section8" class="lesson-section">
                <h2>Hands-on Practice: Data Processing Pipeline</h2>
                
                <p>Let's build a complete data processing system that uses everything we've learned - typed functions, optional parameters, rest parameters, arrow functions, function types, and overloads! üöÄ</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Project Goal</h3>
                    <p style="color: white;">Create a type-safe data processing pipeline that can filter, transform, sort, and aggregate data with full type safety and flexibility.</p>
                </div>

                <h3>Step 1: Define Core Types</h3>
                <pre><code class="language-typescript">// Core function types
type Predicate<T> = (item: T) => boolean;
type Mapper<T, U> = (item: T) => U;
type Comparator<T> = (a: T, b: T) => number;
type Reducer<T, U> = (accumulator: U, current: T) => U;

// Sample data type
interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
    inStock: boolean;
    rating: number;
}
</code></pre>

                <h3>Step 2: Create the Pipeline Class</h3>
                <pre><code class="language-typescript">class DataPipeline<T> {
    constructor(private data: T[]) {}
    
    // Filter with predicate
    filter(predicate: Predicate<T>): DataPipeline<T> {
        return new DataPipeline(this.data.filter(predicate));
    }
    
    // Map to new type
    map<U>(mapper: Mapper<T, U>): DataPipeline<U> {
        return new DataPipeline(this.data.map(mapper));
    }
    
    // Sort with comparator
    sort(comparator: Comparator<T>): DataPipeline<T> {
        return new DataPipeline([...this.data].sort(comparator));
    }
    
    // Take first n items
    take(count: number): DataPipeline<T> {
        return new DataPipeline(this.data.slice(0, count));
    }
    
    // Skip first n items
    skip(count: number): DataPipeline<T> {
        return new DataPipeline(this.data.slice(count));
    }
    
    // Reduce to single value
    reduce<U>(reducer: Reducer<T, U>, initialValue: U): U {
        return this.data.reduce(reducer, initialValue);
    }
    
    // Group by key
    groupBy<K extends keyof T>(key: K): Map<T[K], T[]> {
        const groups = new Map<T[K], T[]>();
        
        for (const item of this.data) {
            const groupKey = item[key];
            if (!groups.has(groupKey)) {
                groups.set(groupKey, []);
            }
            groups.get(groupKey)!.push(item);
        }
        
        return groups;
    }
    
    // Get results
    value(): T[] {
        return this.data;
    }
    
    // Get count
    count(): number {
        return this.data.length;
    }
}
</code></pre>

                <h3>Step 3: Create Helper Functions with Overloads</h3>
                <pre><code class="language-typescript">// Overloaded sort helpers
function sortBy<T>(key: keyof T, order: "asc"): Comparator<T>;
function sortBy<T>(key: keyof T, order: "desc"): Comparator<T>;

function sortBy<T>(key: keyof T, order: "asc" | "desc"): Comparator<T> {
    return (a, b) => {
        const aVal = a[key];
        const bVal = b[key];
        
        if (aVal < bVal) return order === "asc" ? -1 : 1;
        if (aVal > bVal) return order === "asc" ? 1 : -1;
        return 0;
    };
}

// Predicate combinators
function and<T>(...predicates: Predicate<T>[]): Predicate<T> {
    return (item) => predicates.every(pred => pred(item));
}

function or<T>(...predicates: Predicate<T>[]): Predicate<T> {
    return (item) => predicates.some(pred => pred(item));
}

function not<T>(predicate: Predicate<T>): Predicate<T> {
    return (item) => !predicate(item);
}

// Common predicates
const inStock = <T extends { inStock: boolean }>(item: T) => item.inStock;
const highRated = <T extends { rating: number }>(item: T) => item.rating >= 4;
const affordable = <T extends { price: number }>(maxPrice: number) => 
    (item: T) => item.price <= maxPrice;
</code></pre>

                <h3>Step 4: Create Analysis Functions</h3>
                <pre><code class="language-typescript">// Aggregation functions with proper typing
function sum<T>(items: T[], selector: (item: T) => number): number {
    return items.reduce((total, item) => total + selector(item), 0);
}

function average<T>(items: T[], selector: (item: T) => number): number {
    if (items.length === 0) return 0;
    return sum(items, selector) / items.length;
}

function min<T>(items: T[], selector: (item: T) => number): number {
    if (items.length === 0) return Infinity;
    return Math.min(...items.map(selector));
}

function max<T>(items: T[], selector: (item: T) => number): number {
    if (items.length === 0) return -Infinity;
    return Math.max(...items.map(selector));
}

// Statistics object
function statistics<T>(
    items: T[],
    selector: (item: T) => number
): {
    count: number;
    sum: number;
    average: number;
    min: number;
    max: number;
} {
    return {
        count: items.length,
        sum: sum(items, selector),
        average: average(items, selector),
        min: min(items, selector),
        max: max(items, selector)
    };
}
</code></pre>

                <h3>Step 5: Use the Pipeline</h3>
                <pre><code class="language-typescript">// Sample data
const products: Product[] = [
    { id: 1, name: "Laptop", price: 999, category: "electronics", inStock: true, rating: 4.5 },
    { id: 2, name: "Mouse", price: 25, category: "electronics", inStock: true, rating: 4.2 },
    { id: 3, name: "Desk", price: 299, category: "furniture", inStock: false, rating: 4.0 },
    { id: 4, name: "Chair", price: 199, category: "furniture", inStock: true, rating: 4.8 },
    { id: 5, name: "Monitor", price: 399, category: "electronics", inStock: true, rating: 4.6 },
    { id: 6, name: "Keyboard", price: 79, category: "electronics", inStock: false, rating: 3.9 }
];

// Example 1: Find affordable, in-stock, highly-rated electronics
const recommendedElectronics = new DataPipeline(products)
    .filter(item => item.category === "electronics")
    .filter(and(inStock, highRated, affordable(500)))
    .sort(sortBy("price", "asc"))
    .value();

console.log("Recommended Electronics:", recommendedElectronics);

// Example 2: Get top 3 products by rating
const topRated = new DataPipeline(products)
    .filter(inStock)
    .sort(sortBy("rating", "desc"))
    .take(3)
    .value();

console.log("Top Rated:", topRated);

// Example 3: Calculate category statistics
const categoryStats = new DataPipeline(products)
    .filter(inStock)
    .groupBy("category");

categoryStats.forEach((items, category) => {
    console.log(`\nCategory: ${category}`);
    console.log("Statistics:", statistics(items, p => p.price));
});

// Example 4: Transform to summary
interface ProductSummary {
    name: string;
    priceLabel: string;
    available: string;
}

const summaries = new DataPipeline(products)
    .filter(inStock)
    .map<ProductSummary>(p => ({
        name: p.name,
        priceLabel: `$${p.price.toFixed(2)}`,
        available: p.inStock ? "‚úì In Stock" : "‚úó Out of Stock"
    }))
    .value();

console.log("\nProduct Summaries:", summaries);

// Example 5: Complex aggregation
const totalValue = new DataPipeline(products)
    .filter(inStock)
    .reduce((total, product) => total + product.price, 0);

console.log(`\nTotal Inventory Value: $${totalValue}`);

// Example 6: Multi-stage pipeline
const result = new DataPipeline(products)
    .filter(item => item.price < 500)           // Affordable items
    .filter(or(                                  // In stock OR highly rated
        inStock,
        (item) => item.rating >= 4.5
    ))
    .sort(sortBy("rating", "desc"))             // Best rated first
    .take(5)                                     // Top 5
    .map(p => ({                                 // Transform
        name: p.name,
        score: p.rating * (p.inStock ? 1 : 0.8) // Boost in-stock items
    }))
    .sort((a, b) => b.score - a.score)          // Sort by score
    .value();

console.log("\nBest Value Products:", result);
</code></pre>

                <div class="card" style="background-color: #f0f0f0; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Sample Output:</h4>
                    <pre><code>Recommended Electronics: [
  { id: 2, name: "Mouse", price: 25, category: "electronics", ... },
  { id: 5, name: "Monitor", price: 399, category: "electronics", ... }
]

Top Rated: [
  { id: 4, name: "Chair", price: 199, rating: 4.8, ... },
  { id: 5, name: "Monitor", price: 399, rating: 4.6, ... },
  { id: 1, name: "Laptop", price: 999, rating: 4.5, ... }
]

Category: electronics
Statistics: { count: 3, sum: 1423, average: 474.33, min: 25, max: 999 }

Category: furniture
Statistics: { count: 1, sum: 199, average: 199, min: 199, max: 199 }
</code></pre>
                </div>

                <h3>Your Challenge: Extend the Pipeline</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üèãÔ∏è Exercise: Add More Pipeline Methods</h4>
                    <p><strong>Challenge:</strong> Add these methods to the DataPipeline class:</p>
                    <ol>
                        <li><code>distinct()</code> - Remove duplicates</li>
                        <li><code>distinctBy(key)</code> - Remove duplicates by a specific key</li>
                        <li><code>findFirst(predicate)</code> - Find first matching item</li>
                        <li><code>partition(predicate)</code> - Split into two arrays [matching, notMatching]</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>For <code>distinct()</code>, use a Set. For <code>distinctBy()</code>, track seen keys in a Set.</p>
                    </details>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Outstanding Work!</h3>
                    <p style="color: white; margin: 0;">You've built a production-quality data processing pipeline with complete type safety! This demonstrates mastery of TypeScript functions, types, and functional programming patterns. üöÄ</p>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" class="lesson-section">
                <h2>Best Practices</h2>
                
                <p>Let's consolidate everything with the golden rules for writing great TypeScript functions! ‚ú®</p>

                <h3>‚úÖ Do's: Function Excellence</h3>

                <h4>1. Always Type Function Parameters</h4>
                <pre><code class="language-typescript">// ‚ùå Bad - no type safety
function process(data) {
    return data.value * 2;
}

// ‚úÖ Good - fully typed
function process(data: { value: number }): number {
    return data.value * 2;
}
</code></pre>

                <h4>2. Explicitly Type Return Values</h4>
                <pre><code class="language-typescript">// ‚ùå Relying on inference can hide bugs
function calculate(x: number) {
    if (x > 0) {
        return x * 2;
    }
    return "negative";  // Bug! Mixed return types
}

// ‚úÖ Explicit return type catches the bug
function calculate(x: number): number {
    if (x > 0) {
        return x * 2;
    }
    return -1;  // Fixed!
}
</code></pre>

                <h4>3. Use Arrow Functions for Simple Callbacks</h4>
                <pre><code class="language-typescript">// ‚úÖ Clean and concise
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(n => n * 2);
const evens = numbers.filter(n => n % 2 === 0);
</code></pre>

                <h4>4. Use Function Types for Callbacks</h4>
                <pre><code class="language-typescript">// ‚úÖ Type the callback properly
type EventHandler = (event: MouseEvent) => void;

function onClick(handler: EventHandler): void {
    document.addEventListener("click", handler);
}
</code></pre>

                <h4>5. Prefer Optional Parameters Over Undefined Unions</h4>
                <pre><code class="language-typescript">// ‚ùå Awkward
function greet(name: string, title: string | undefined) { }

// ‚úÖ Cleaner
function greet(name: string, title?: string) { }
</code></pre>

                <h3>‚ùå Don'ts: Common Pitfalls</h3>

                <h4>1. Don't Use any in Function Signatures</h4>
                <pre><code class="language-typescript">// ‚ùå No type safety
function process(data: any): any {
    return data.value * 2;
}

// ‚úÖ Use proper types or generics
function process<T extends { value: number }>(data: T): number {
    return data.value * 2;
}
</code></pre>

                <h4>2. Don't Make Everything Optional</h4>
                <pre><code class="language-typescript">// ‚ùå Too permissive
function createUser(
    name?: string,
    email?: string,
    age?: number
): void { }

// ‚úÖ Required params first
function createUser(
    name: string,
    email: string,
    age?: number
): void { }
</code></pre>

                <h4>3. Don't Overuse Function Overloads</h4>
                <pre><code class="language-typescript">// ‚ùå Overengineered
function format(value: string): string;
function format(value: number): string;
function format(value: boolean): string;
function format(value: Date): string;
// ... 10 more overloads

// ‚úÖ Sometimes union types are simpler
function format(value: string | number | boolean | Date): string {
    return String(value);
}
</code></pre>

                <h3>üí° Pro Tips</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 1: Use Descriptive Parameter Names</h4>
                    <pre><code class="language-typescript">// ‚ùå Unclear
function process(a: number, b: number, c: boolean): number {
    return c ? a + b : a - b;
}

// ‚úÖ Self-documenting
function calculate(
    firstValue: number,
    secondValue: number,
    shouldAdd: boolean
): number {
    return shouldAdd ? firstValue + secondValue : firstValue - secondValue;
}
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 2: Keep Functions Small and Focused</h4>
                    <pre><code class="language-typescript">// ‚úÖ Single responsibility
function validateEmail(email: string): boolean {
    return email.includes("@");
}

function saveUser(user: User): void {
    // Just save, don't also validate, format, log, etc.
}

function sendEmail(to: string, subject: string, body: string): void {
    // Just send, don't also validate, log, retry, etc.
}
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 3: Document Complex Functions</h4>
                    <pre><code class="language-typescript">/**
 * Calculates the compound interest
 * @param principal - Initial amount invested
 * @param rate - Annual interest rate (as decimal, e.g., 0.05 for 5%)
 * @param years - Number of years
 * @param compoundFrequency - How many times per year interest compounds
 * @returns The final amount after interest
 */
function calculateCompoundInterest(
    principal: number,
    rate: number,
    years: number,
    compoundFrequency: number = 12
): number {
    return principal * Math.pow(1 + rate / compoundFrequency, compoundFrequency * years);
}
</code></pre>
                </div>

                <h3>Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Syntax</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Basic Function</td>
                            <td><code>function f(x: number): number</code></td>
                            <td>Standard function</td>
                        </tr>
                        <tr>
                            <td>Optional Parameter</td>
                            <td><code>function f(x?: number)</code></td>
                            <td>Parameter may be omitted</td>
                        </tr>
                        <tr>
                            <td>Default Parameter</td>
                            <td><code>function f(x: number = 0)</code></td>
                            <td>Parameter with default value</td>
                        </tr>
                        <tr>
                            <td>Rest Parameters</td>
                            <td><code>function f(...nums: number[])</code></td>
                            <td>Variable number of arguments</td>
                        </tr>
                        <tr>
                            <td>Arrow Function</td>
                            <td><code>const f = (x: number) => x * 2</code></td>
                            <td>Concise function syntax</td>
                        </tr>
                        <tr>
                            <td>Function Type</td>
                            <td><code>type F = (x: number) => number</code></td>
                            <td>Reusable function signature</td>
                        </tr>
                        <tr>
                            <td>Function Overload</td>
                            <td><code>function f(x: string): string;<br>function f(x: number): number;</code></td>
                            <td>Multiple signatures</td>
                        </tr>
                        <tr>
                            <td>void Return</td>
                            <td><code>function f(): void</code></td>
                            <td>No return value</td>
                        </tr>
                        <tr>
                            <td>never Return</td>
                            <td><code>function f(): never</code></td>
                            <td>Never returns (throws/loops)</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" class="lesson-section">
                <h2>Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Always type parameters and return values</strong> - it's the foundation of type safety</li>
                        <li><strong>Optional parameters (?)</strong> let parameters be omitted</li>
                        <li><strong>Default parameters</strong> provide automatic fallback values</li>
                        <li><strong>Rest parameters (...)</strong> collect variable arguments into an array</li>
                        <li><strong>Arrow functions</strong> are concise and preserve 'this' context</li>
                        <li><strong>Function types</strong> let you define reusable function signatures</li>
                        <li><strong>Function overloads</strong> provide precise types for different call patterns</li>
                        <li><strong>void means "no return value"</strong>, never means "never returns"</li>
                        <li><strong>Keep functions focused</strong> - single responsibility principle</li>
                        <li><strong>Document complex functions</strong> with JSDoc comments</li>
                    </ul>
                </div>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/functions.html" target="_blank">TypeScript Handbook: Functions</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/more-on-functions.html" target="_blank">TypeScript Handbook: More on Functions</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank">MDN: Arrow Functions</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>Advanced Types</strong>. You'll learn about:</p>
                <ul>
                    <li>Generics for reusable, flexible code</li>
                    <li>Utility types (Partial, Pick, Omit, Record)</li>
                    <li>Conditional types and mapped types</li>
                    <li>Type guards and type assertions</li>
                    <li>Template literal types</li>
                </ul>

                <p>This is where TypeScript's type system really shows its power! üí™</p>

                <h3>Quick Quiz</h3>
                <div class="card quiz-container">
                    <h4>üéØ Test Your Knowledge</h4>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What's the difference between optional parameters and default parameters?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Both can be omitted">
                                A) Optional parameters must be provided
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Optional parameters become undefined if omitted. Default parameters get a specific default value.">
                                B) Optional parameters are undefined when omitted, default parameters have a fallback value
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="They work differently">
                                C) They're exactly the same
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> What must be true about rest parameters?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="They can be at the end">
                                A) They must be the first parameter
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Rest parameters must be the last parameter and collect remaining arguments into an array.">
                                B) They must be the last parameter
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Only one rest parameter is allowed">
                                C) You can have multiple rest parameters
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> When should you use function overloads?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Use them strategically">
                                A) Always - they're always better than union types
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly! Use overloads when the return type depends on parameter types and you want precise type inference.">
                                B) When return type depends on parameter types and you need precise inference
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="They have their place">
                                C) Never - union types are always sufficient
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Incredible Progress!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've mastered TypeScript functions! You can now write type-safe, flexible, and maintainable functions that form the backbone of great applications. This is a major milestone in your TypeScript journey!</p>
                    <p style="color: white; font-size: 1.1rem; margin: 0;">Next up: Advanced Types - where things get REALLY powerful! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_1_3_interfaces_and_type_aliases_part_c.html" class="prev-lesson">‚Üê Previous: Interfaces & Type Aliases</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_1_5_advanced_types.html" class="next-lesson">Next: Advanced Types ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce - React TypeScript Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build better applications with TypeScript and React.</p>
        <p style="margin-top: 1rem; font-size: 0.9rem;">
            <a href="index.html" style="color: white; text-decoration: underline;">Course Home</a> | 
            <a href="index.html#modules" style="color: white; text-decoration: underline;">All Modules</a> | 
            <a href="#main-content" style="color: white; text-decoration: underline;">Back to Top ‚Üë</a>
        </p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
