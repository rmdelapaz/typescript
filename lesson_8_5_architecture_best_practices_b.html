                <h3>4. UI Components (Shared Components)</h3>

                <p>Generic, reusable components that have no knowledge of business logic. These live in the <code>shared/components/</code> folder and can be used across features.</p>

                <pre><code class="language-typescript">// shared/components/Button/Button.tsx
interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  loading?: boolean;
  children: React.ReactNode;
}

export function Button({
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled,
  children,
  className = '',
  ...props
}: ButtonProps) {
  const baseClasses = 'btn';
  const variantClass = `btn-${variant}`;
  const sizeClass = `btn-${size}`;
  
  return (
    &lt;button
      className={`${baseClasses} ${variantClass} ${sizeClass} ${className}`}
      disabled={disabled || loading}
      {...props}
    &gt;
      {loading ? &lt;Spinner size="small" /&gt; : children}
    &lt;/button&gt;
  );
}

// Characteristics:
// - Generic and reusable
// - No business logic
// - Highly configurable through props
// - Can be documented in Storybook
// - Could be published as a library</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Component Organization Summary</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Component Type</th>
                                <th>Responsibility</th>
                                <th>Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Page</strong></td>
                                <td>Route orchestration</td>
                                <td>pages/</td>
                            </tr>
                            <tr>
                                <td><strong>Layout</strong></td>
                                <td>Shared page structure</td>
                                <td>layouts/</td>
                            </tr>
                            <tr>
                                <td><strong>Feature</strong></td>
                                <td>Domain-specific features</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Container</strong></td>
                                <td>State & data management</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Presentational</strong></td>
                                <td>Pure UI rendering</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Shared UI</strong></td>
                                <td>Generic reusable UI</td>
                                <td>shared/components/</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </section>

            <!-- Section 4: Separation of Concerns -->
            <section id="section4">
                <h2>üîÄ Separation of Concerns</h2>
                
                <p>Separation of concerns is about organizing code so that each piece has a clear, focused responsibility. In React applications, this means separating presentation, business logic, and data fetching into distinct layers.</p>

                <h3>The Three Layers</h3>

                <div class="mermaid">
graph TB
    A[Presentation Layer] --> B[Business Logic Layer]
    B --> C[Data Access Layer]
    
    A1[Components] --> A
    A2[JSX/UI] --> A
    
    B1[Custom Hooks] --> B
    B2[Utility Functions] --> B
    B3[Validation] --> B
    
    C1[API Services] --> C
    C2[React Query] --> C
    C3[State Management] --> C
    
    style A fill:#e3f2fd
    style B fill:#fff3cd
    style C fill:#c8e6c9
</div>

                <h3>1. Presentation Layer (Components)</h3>

                <p>Handles only rendering and user interactions. No business logic or data fetching.</p>

                <pre><code class="language-typescript">// ‚úÖ GOOD - Pure presentation
function ProductCard({ product, onAddToCart }: ProductCardProps) {
  return (
    &lt;Card&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;${product.price.toFixed(2)}&lt;/p&gt;
      &lt;Button onClick={() => onAddToCart(product.id)}&gt;
        Add to Cart
      &lt;/Button&gt;
    &lt;/Card&gt;
  );
}

// ‚ùå BAD - Mixed concerns
function ProductCard({ productId }: { productId: string }) {
  const [product, setProduct] = useState(null);
  const [cart, setCart] = useState([]);
  
  useEffect(() => {
    // Data fetching in component
    fetch(`/api/products/${productId}`)
      .then(res => res.json())
      .then(setProduct);
  }, [productId]);
  
  const addToCart = () => {
    // Business logic in component
    if (cart.length >= 10) {
      alert('Cart is full!');
      return;
    }
    
    const tax = product.price * 0.08;
    const total = product.price + tax;
    
    setCart([...cart, { ...product, total }]);
    
    // Data mutation in component
    fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId })
    });
  };
  
  return (/* ... */);
}</code></pre>

                <h3>2. Business Logic Layer (Custom Hooks)</h3>

                <p>Encapsulates business rules, calculations, and state management logic.</p>

                <pre><code class="language-typescript">// hooks/useCart.ts
export function useCart() {
  const [cart, setCart] = useState&lt;CartItem[]&gt;([]);
  
  const addToCart = useCallback((product: Product) => {
    // Business rule: Max 10 items
    if (cart.length >= 10) {
      throw new Error('Cart is full. Maximum 10 items allowed.');
    }
    
    // Business logic: Calculate totals
    const tax = calculateTax(product.price);
    const total = product.price + tax;
    
    const cartItem: CartItem = {
      ...product,
      tax,
      total,
      addedAt: new Date()
    };
    
    setCart(prev => [...prev, cartItem]);
    return cartItem;
  }, [cart.length]);
  
  const removeFromCart = useCallback((itemId: string) => {
    setCart(prev => prev.filter(item => item.id !== itemId));
  }, []);
  
  const cartTotal = useMemo(() => {
    return cart.reduce((sum, item) => sum + item.total, 0);
  }, [cart]);
  
  const itemCount = cart.length;
  const isFull = itemCount >= 10;
  
  return {
    cart,
    cartTotal,
    itemCount,
    isFull,
    addToCart,
    removeFromCart
  };
}

// Utility function for business logic
function calculateTax(price: number): number {
  const TAX_RATE = 0.08;
  return price * TAX_RATE;
}</code></pre>

                <h3>3. Data Access Layer (Services)</h3>

                <p>Handles all communication with external systems (APIs, localStorage, etc.).</p>

                <pre><code class="language-typescript">// services/cartService.ts
import { apiClient } from '@/lib/axios';

export const cartService = {
  async getCart(userId: string): Promise&lt;CartItem[]&gt; {
    const response = await apiClient.get(`/users/${userId}/cart`);
    return response.data;
  },
  
  async addToCart(userId: string, productId: string): Promise&lt;CartItem&gt; {
    const response = await apiClient.post(`/users/${userId}/cart`, {
      productId
    });
    return response.data;
  },
  
  async removeFromCart(userId: string, itemId: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${userId}/cart/${itemId}`);
  },
  
  async clearCart(userId: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${userId}/cart`);
  }
};</code></pre>

                <h3>Putting It All Together</h3>

                <pre><code class="language-typescript">// Component uses hook (business logic)
function ProductPage({ productId }: { productId: string }) {
  const { product } = useProduct(productId);
  const { addToCart, isFull } = useCart();
  
  const handleAddToCart = async () => {
    try {
      await addToCart(product);
      toast.success('Added to cart!');
    } catch (error) {
      toast.error(error.message);
    }
  };
  
  return (
    &lt;ProductCard
      product={product}
      onAddToCart={handleAddToCart}
      disabled={isFull}
    /&gt;
  );
}

// Hook uses service (data access)
function useCart() {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  
  const { data: cart = [] } = useQuery({
    queryKey: ['cart', user?.id],
    queryFn: () => cartService.getCart(user!.id),
    enabled: !!user
  });
  
  const addMutation = useMutation({
    mutationFn: (product: Product) => {
      // Business logic first
      if (cart.length >= 10) {
        throw new Error('Cart is full');
      }
      
      // Then data access
      return cartService.addToCart(user!.id, product.id);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['cart'] });
    }
  });
  
  const addToCart = async (product: Product) => {
    return addMutation.mutateAsync(product);
  };
  
  return {
    cart,
    addToCart,
    isFull: cart.length >= 10
  };
}

// Service handles API calls
const cartService = {
  async addToCart(userId: string, productId: string) {
    const response = await apiClient.post(`/users/${userId}/cart`, {
      productId
    });
    return response.data;
  }
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Separation</h4>
                    <ul>
                        <li><strong>Testability:</strong> Each layer can be tested independently</li>
                        <li><strong>Reusability:</strong> Business logic can be used in multiple components</li>
                        <li><strong>Maintainability:</strong> Changes are localized to one layer</li>
                        <li><strong>Readability:</strong> Each file has a clear, focused purpose</li>
                        <li><strong>Flexibility:</strong> Easy to swap implementations (e.g., change API)</li>
                    </ul>
                </div>

            </section>

            <!-- Section 5: Custom Hooks for Business Logic -->
            <section id="section5">
                <h2>ü™ù Custom Hooks for Business Logic</h2>
                
                <p>Custom hooks are the perfect place to encapsulate business logic in React applications. They keep components clean and focused on rendering while making logic reusable and testable.</p>

                <h3>When to Create a Custom Hook</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Create a Custom Hook When...</h4>
                    <ul>
                        <li>Logic is used in multiple components</li>
                        <li>Component has complex state management</li>
                        <li>You want to test business logic independently</li>
                        <li>Logic involves multiple React hooks</li>
                        <li>You need to share stateful logic between components</li>
                    </ul>
                </div>

                <h3>Hook Patterns and Examples</h3>

                <h4>1. Data Fetching Hooks</h4>

                <pre><code class="language-typescript">// hooks/useUser.ts
export function useUser(userId: string) {
  return useQuery({
    queryKey: ['users', userId],
    queryFn: () => userService.getById(userId),
    staleTime: 1000 * 60 * 5
  });
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useUser(userId);
  
  if (isLoading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}</code></pre>

                <h4>2. Form Handling Hooks</h4>

                <pre><code class="language-typescript">// hooks/useForm.ts
interface UseFormOptions&lt;T&gt; {
  initialValues: T;
  onSubmit: (values: T) => void | Promise&lt;void&gt;;
  validate?: (values: T) => Record&lt;string, string&gt;;
}

export function useForm&lt;T extends Record&lt;string, any&gt;&gt;({
  initialValues,
  onSubmit,
  validate
}: UseFormOptions&lt;T&gt;) {
  const [values, setValues] = useState&lt;T&gt;(initialValues);
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    // Clear error when user starts typing
    if (errors[name as string]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name as string];
        return newErrors;
      });
    }
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    if (validate) {
      const validationErrors = validate(values);
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors);
        return;
      }
    }
    
    // Submit
    setIsSubmitting(true);
    try {
      await onSubmit(values);
      setValues(initialValues); // Reset form
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    reset
  };
}

// Usage
function LoginForm() {
  const { values, errors, handleChange, handleSubmit, isSubmitting } = useForm({
    initialValues: { email: '', password: '' },
    onSubmit: async (values) => {
      await authService.login(values);
    },
    validate: (values) => {
      const errors: Record&lt;string, string&gt; = {};
      if (!values.email) errors.email = 'Email is required';
      if (!values.password) errors.password = 'Password is required';
      return errors;
    }
  });
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;Input
        value={values.email}
        onChange={(e) => handleChange('email', e.target.value)}
        error={errors.email}
      /&gt;
      &lt;Button type="submit" loading={isSubmitting}&gt;
        Login
      &lt;/Button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h4>3. Business Logic Hooks</h4>

                <pre><code class="language-typescript">// hooks/useShoppingCart.ts
export function useShoppingCart() {
  const [items, setItems] = useState&lt;CartItem[]&gt;([]);
  
  const addItem = useCallback((product: Product, quantity = 1) => {
    setItems(prev => {
      const existing = prev.find(item => item.product.id === product.id);
      
      if (existing) {
        // Update quantity if item exists
        return prev.map(item =>
          item.product.id === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }
      
      // Add new item
      return [...prev, { product, quantity }];
    });
  }, []);
  
  const removeItem = useCallback((productId: string) => {
    setItems(prev => prev.filter(item => item.product.id !== productId));
  }, []);
  
  const updateQuantity = useCallback((productId: string, quantity: number) => {
    if (quantity <= 0) {
      removeItem(productId);
      return;
    }
    
    setItems(prev =>
      prev.map(item =>
        item.product.id === productId
          ? { ...item, quantity }
          : item
      )
    );
  }, [removeItem]);
  
  const clearCart = useCallback(() => {
    setItems([]);
  }, []);
  
  // Computed values
  const subtotal = useMemo(() => {
    return items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
  }, [items]);
  
  const tax = useMemo(() => subtotal * 0.08, [subtotal]);
  const total = subtotal + tax;
  const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
  
  return {
    items,
    itemCount,
    subtotal,
    tax,
    total,
    addItem,
    removeItem,
    updateQuantity,
    clearCart
  };
}</code></pre>

                <h4>4. Utility Hooks</h4>

                <pre><code class="language-typescript">// hooks/useDebounce.ts
export function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// hooks/useLocalStorage.ts
export function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue] as const;
}

// hooks/useMediaQuery.ts
export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    
    const handleChange = (e: MediaQueryListEvent) => {
      setMatches(e.matches);
    };
    
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [query]);
  
  return matches;
}

// Usage
function SearchBar() {
  const [search, setSearch] = useState('');
  const debouncedSearch = useDebounce(search, 500);
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  // Use debouncedSearch for API calls
  const { data } = useQuery({
    queryKey: ['search', debouncedSearch],
    queryFn: () => searchApi(debouncedSearch),
    enabled: debouncedSearch.length > 0
  });
  
  return (/* ... */);
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Hook Best Practices</h4>
                    <ul>
                        <li><strong>Naming:</strong> Always start with "use" (useCart, useAuth, useDebounce)</li>
                        <li><strong>Single Responsibility:</strong> Each hook should do one thing well</li>
                        <li><strong>Return Object:</strong> Return objects for flexibility, not arrays (unless 2 items max)</li>
                        <li><strong>Memoization:</strong> Use useCallback and useMemo for expensive operations</li>
                        <li><strong>Dependencies:</strong> Always list all dependencies correctly</li>
                        <li><strong>Type Safety:</strong> Use TypeScript generics for reusable hooks</li>
                    </ul>
                </div>

            </section>

            <!-- Section 6: Service Layer Pattern -->
            <section id="section6">
                <h2>üîå Service Layer Pattern</h2>
                
                <p>The service layer is a dedicated abstraction for all external communication. It centralizes API calls, error handling, and data transformation, making your application easier to maintain and test.</p>

                <h3>Why Use a Service Layer?</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Benefit</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Centralization</strong></td>
                            <td>All API logic in one place</td>
                        </tr>
                        <tr>
                            <td><strong>Reusability</strong></td>
                            <td>Same endpoints used across features</td>
                        </tr>
                        <tr>
                            <td><strong>Testability</strong></td>
                            <td>Easy to mock for tests</td>
                        </tr>
                        <tr>
                            <td><strong>Type Safety</strong></td>
                            <td>Typed inputs and outputs</td>
                        </tr>
                        <tr>
                            <td><strong>Error Handling</strong></td>
                            <td>Consistent error handling</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Service Structure</h3>

                <pre><code class="language-typescript">// lib/axios.ts - Configure axios instance
import axios from 'axios';

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor - Add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor - Handle errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);</code></pre>

                <h3>Creating Services</h3>

                <pre><code class="language-typescript">// services/userService.ts
import { apiClient } from '@/lib/axios';
import type { User, CreateUserDto, UpdateUserDto } from '@/types';

export const userService = {
  /**
   * Get all users
   */
  async getAll(): Promise&lt;User[]&gt; {
    const response = await apiClient.get&lt;User[]&gt;('/users');
    return response.data;
  },

  /**
   * Get user by ID
   */
  async getById(id: string): Promise&lt;User&gt; {
    const response = await apiClient.get&lt;User&gt;(`/users/${id}`);
    return response.data;
  },

  /**
   * Create new user
   */
  async create(data: CreateUserDto): Promise&lt;User&gt; {
    const response = await apiClient.post&lt;User&gt;('/users', data);
    return response.data;
  },

  /**
   * Update existing user
   */
  async update(id: string, data: UpdateUserDto): Promise&lt;User&gt; {
    const response = await apiClient.patch&lt;User&gt;(`/users/${id}`, data);
    return response.data;
  },

  /**
   * Delete user
   */
  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${id}`);
  },

  /**
   * Search users by query
   */
  async search(query: string): Promise&lt;User[]&gt; {
    const response = await apiClient.get&lt;User[]&gt;('/users/search', {
      params: { q: query }
    });
    return response.data;
  }
};</code></pre>

                <h3>Advanced Service Patterns</h3>

                <pre><code class="language-typescript">// services/baseService.ts - Generic base service
export class BaseService&lt;T&gt; {
  constructor(private endpoint: string) {}

  async getAll(): Promise&lt;T[]&gt; {
    const response = await apiClient.get&lt;T[]&gt;(this.endpoint);
    return response.data;
  }

  async getById(id: string): Promise&lt;T&gt; {
    const response = await apiClient.get&lt;T&gt;(`${this.endpoint}/${id}`);
    return response.data;
  }

  async create(data: Partial&lt;T&gt;): Promise&lt;T&gt; {
    const response = await apiClient.post&lt;T&gt;(this.endpoint, data);
    return response.data;
  }

  async update(id: string, data: Partial&lt;T&gt;): Promise&lt;T&gt; {
    const response = await apiClient.patch&lt;T&gt;(`${this.endpoint}/${id}`, data);
    return response.data;
  }

  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`${this.endpoint}/${id}`);
  }
}

// services/userService.ts - Extend base service
class UserService extends BaseService&lt;User&gt; {
  constructor() {
    super('/users');
  }

  // Add user-specific methods
  async getProfile(): Promise&lt;User&gt; {
    const response = await apiClient.get&lt;User&gt;('/users/profile');
    return response.data;
  }

  async updateProfile(data: UpdateProfileDto): Promise&lt;User&gt; {
    const response = await apiClient.patch&lt;User&gt;('/users/profile', data);
    return response.data;
  }

  async changePassword(data: ChangePasswordDto): Promise&lt;void&gt; {
    await apiClient.post('/users/change-password', data);
  }
}

export const userService = new UserService();</code></pre>

                <h3>Service with React Query</h3>

                <pre><code class="language-typescript">// hooks/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userService } from '@/services/userService';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers() {
  return useQuery({
    queryKey: userKeys.lists(),
    queryFn: userService.getAll
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => userService.getById(id)
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: userService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    }
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      userService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: userKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    }
  });
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Service Layer Anti-Patterns</h4>
                    <ul>
                        <li><strong>Business Logic in Services:</strong> Services should only handle data access, not business rules</li>
                        <li><strong>Direct State Updates:</strong> Services shouldn't update React state directly</li>
                        <li><strong>Component Dependencies:</strong> Services shouldn't import components or hooks</li>
                        <li><strong>Mixed Responsibilities:</strong> Keep services focused on API communication</li>
                    </ul>
                </div>

            </section>

            <!-- Section 7: Type Organization -->
            <section id="section7">
                <h2>üìê Type Organization</h2>
                
                <p>Proper TypeScript type organization makes your codebase more maintainable and helps developers understand data structures quickly.</p>

                <h3>Type Organization Strategies</h3>

                <h4>1. Feature-Based Types</h4>

                <pre><code class="language-typescript">// features/users/types/user.types.ts
export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserDto {
  email: string;
  name: string;
  password: string;
}

export interface UpdateUserDto {
  name?: string;
  avatar?: string;
}

export interface UserFilters {
  search?: string;
  role?: UserRole;
  status?: UserStatus;
}

export type UserRole = 'admin' | 'user' | 'moderator';
export type UserStatus = 'active' | 'inactive' | 'suspended';</code></pre>

                <h4>2. Shared/Common Types</h4>

                <pre><code class="language-typescript">// shared/types/common.types.ts
export interface ApiResponse&lt;T&gt; {
  data: T;
  message?: string;
  success: boolean;
}

export interface PaginatedResponse&lt;T&gt; {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

export interface ApiError {
  message: string;
  code: string;
  statusCode: number;
  details?: Record&lt;string, any&gt;;
}

export type Nullable&lt;T&gt; = T | null;
export type Optional&lt;T&gt; = T | undefined;
export type ID = string | number;</code></pre>

                <h4>3. Utility Types</h4>

                <pre><code class="language-typescript">// shared/types/utils.types.ts

// Make all properties optional recursively
export type DeepPartial&lt;T&gt; = {
  [P in keyof T]?: T[P] extends object ? DeepPartial&lt;T[P]&gt; : T[P];
};

// Make all properties required recursively
export type DeepRequired&lt;T&gt; = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired&lt;T[P]&gt; : T[P];
};

// Extract keys of type
export type KeysOfType&lt;T, U&gt; = {
  [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

// Async function return type
export type AsyncReturnType&lt;T extends (...args: any) => Promise&lt;any&gt;&gt; =
  T extends (...args: any) => Promise&lt;infer R&gt; ? R : any;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Type Organization Best Practices</h4>
                    <ul>
                        <li><strong>Naming:</strong> Use descriptive names (UserDto, not UD)</li>
                        <li><strong>DTOs:</strong> Create separate types for API requests/responses</li>
                        <li><strong>Consistency:</strong> Use same naming patterns across types</li>
                        <li><strong>Documentation:</strong> Add JSDoc comments for complex types</li>
                        <li><strong>Exports:</strong> Export through index.ts files</li>
                        <li><strong>Avoid Any:</strong> Never use 'any', use 'unknown' instead</li>
                    </ul>
                </div>

            </section>

            <!-- Section 8: Error Handling Architecture -->
            <section id="section8">
                <h2>üö® Error Handling Architecture</h2>
                
                <p>Consistent, well-architected error handling improves user experience and makes debugging easier. A good error handling strategy catches errors at the right level and provides meaningful feedback.</p>

                <h3>Error Handling Layers</h3>

                <div class="mermaid">
graph TB
    A[API Layer] --> B[Service Layer]
    B --> C[Hook Layer]
    C --> D[Component Layer]
    
    A --> E[Axios Interceptor]
    B --> F[Custom Error Classes]
    C --> G[React Query onError]
    D --> H[Error Boundaries]
    D --> I[Toast Notifications]
    
    style A fill:#ffcdd2
    style B fill:#fff3cd
    style C fill:#e3f2fd
    style D fill:#c8e6c9
</div>

                <h3>1. Custom Error Classes</h3>

                <pre><code class="language-typescript">// shared/errors/AppError.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record&lt;string, string&gt;) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 'AUTHORIZATION_ERROR', 403);
    this.name = 'AuthorizationError';
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 'NOT_FOUND', 404);
    this.name = 'NotFoundError';
  }
}</code></pre>

                <h3>2. Error Handling in Services</h3>

                <pre><code class="language-typescript">// lib/axios.ts
import { AppError, ValidationError, AuthenticationError } from '@/shared/errors';

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (axios.isAxiosError(error)) {
      const status = error.response?.status;
      const data = error.response?.data;

      switch (status) {
        case 400:
          throw new ValidationError(
            data?.message || 'Validation failed',
            data?.errors
          );
        case 401:
          throw new AuthenticationError(data?.message);
        case 403:
          throw new AuthorizationError(data?.message);
        case 404:
          throw new NotFoundError(data?.resource || 'Resource');
        default:
          throw new AppError(
            data?.message || 'An error occurred',
            'UNKNOWN_ERROR',
            status || 500,
            data
          );
      }
    }

    throw error;
  }
);</code></pre>

                <h3>3. Error Boundaries</h3>

                <pre><code class="language-typescript">// shared/components/ErrorBoundary.tsx
interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType&lt;{ error: Error; reset: () => void }&gt;;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component&lt;
  ErrorBoundaryProps,
  ErrorBoundaryState
&gt; {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Log to error reporting service
    // errorReportingService.log(error, errorInfo);
  }

  reset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return &lt;FallbackComponent error={this.state.error!} reset={this.reset} /&gt;;
    }

    return this.props.children;
  }
}

// Default error fallback
function DefaultErrorFallback({ error, reset }: { error: Error; reset: () => void }) {
  return (
    &lt;div className="error-fallback"&gt;
      &lt;h2&gt;Something went wrong&lt;/h2&gt;
      &lt;p&gt;{error.message}&lt;/p&gt;
      &lt;button onClick={reset}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>4. Error Handling in Components</h3>

                <pre><code class="language-typescript">// Component with error handling
function UserProfile({ userId }: { userId: string }) {
  const { data, error, isLoading } = useUser(userId);
  const updateMutation = useUpdateUser();

  const handleUpdate = async (data: UpdateUserDto) => {
    try {
      await updateMutation.mutateAsync({ id: userId, data });
      toast.success('Profile updated successfully!');
    } catch (error) {
      if (error instanceof ValidationError) {
        // Show field-specific errors
        Object.entries(error.details || {}).forEach(([field, message]) => {
          toast.error(`${field}: ${message}`);
        });
      } else if (error instanceof AppError) {
        toast.error(error.message);
      } else {
        toast.error('An unexpected error occurred');
      }
    }
  };

  if (isLoading) return &lt;Spinner /&gt;;
  
  if (error) {
    if (error instanceof NotFoundError) {
      return &lt;NotFound message="User not found" /&gt;;
    }
    if (error instanceof AuthorizationError) {
      return &lt;Unauthorized /&gt;;
    }
    return &lt;ErrorMessage error={error} /&gt;;
  }

  return &lt;UserForm user={data} onSubmit={handleUpdate} /&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Error Handling Best Practices</h4>
                    <ul>
                        <li><strong>Fail Fast:</strong> Catch errors as early as possible</li>
                        <li><strong>Be Specific:</strong> Use custom error classes for different scenarios</li>
                        <li><strong>User-Friendly:</strong> Show helpful messages, not technical jargon</li>
                        <li><strong>Logging:</strong> Log errors to a service for debugging</li>
                        <li><strong>Recovery:</strong> Provide ways to recover (retry button, reset)</li>
                        <li><strong>Boundaries:</strong> Use Error Boundaries for unexpected errors</li>
                    </ul>
                </div>

            </section>