<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Working with APIs in React with TypeScript - Learn RESTful API patterns, CRUD operations, authentication basics, error handling strategies, API response typing, and environment variables. Build production-ready API integrations.">
    <meta name="author" content="PracticalAce">
    <title>Working with APIs - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module4">Module 4: Side Effects and Data Fetching</a></li>
            <li aria-current="page">Lesson 4.5: Working with APIs</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üåê Working with APIs</h1>
                <p class="lead">You've learned data fetching fundamentals, custom hooks, and advanced patterns. Now it's time to master real-world API integration! Most React applications communicate with backend servers through APIs (Application Programming Interfaces). Whether you're building a social media app, an e-commerce site, or a productivity tool, you'll need to understand RESTful APIs, handle authentication, manage errors gracefully, and structure your code for maintainability. In this lesson, we'll cover everything you need to build production-ready API integrations. Let's dive into the world of APIs! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand RESTful API architecture and conventions</li>
                        <li>Implement all CRUD operations (Create, Read, Update, Delete)</li>
                        <li>Structure API calls in a maintainable service layer</li>
                        <li>Handle authentication with tokens (JWT)</li>
                        <li>Implement proper error handling strategies</li>
                        <li>Type API requests and responses with TypeScript</li>
                        <li>Use environment variables for configuration</li>
                        <li>Handle different HTTP status codes appropriately</li>
                        <li>Build a reusable API client with interceptors</li>
                        <li>Implement request/response transformations</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a complete API integration layer for a task management app</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">RESTful API Fundamentals</a></li>
                        <li><a href="#section2" class="toc-link">CRUD Operations</a></li>
                        <li><a href="#section3" class="toc-link">Creating an API Service Layer</a></li>
                        <li><a href="#section4" class="toc-link">Authentication and Authorization</a></li>
                        <li><a href="#section5" class="toc-link">Error Handling Strategies</a></li>
                        <li><a href="#section6" class="toc-link">TypeScript for APIs</a></li>
                        <li><a href="#section7" class="toc-link">Environment Variables</a></li>
                        <li><a href="#section8" class="toc-link">Building an API Client</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: RESTful API Fundamentals -->
            <section id="section1" class="lesson-section">
                <h2>üèóÔ∏è RESTful API Fundamentals</h2>
                <p>REST (Representational State Transfer) is an architectural style for designing networked applications. Most modern web APIs follow REST principles. Let's understand the fundamentals!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>REST API:</strong> An API that uses HTTP requests to GET, POST, PUT, PATCH, and DELETE data. It treats data as resources (like users, posts, products) that can be accessed via URLs (endpoints) and manipulated using standard HTTP methods.</p>
                </div>

                <h3>HTTP Methods (Verbs)</h3>
                <p>REST APIs use HTTP methods to indicate the desired action:</p>

                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Purpose</th>
                                <th>Example</th>
                                <th>Idempotent?</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>GET</strong></td>
                                <td>Retrieve data</td>
                                <td><code>GET /api/users/123</code></td>
                                <td>‚úÖ Yes</td>
                            </tr>
                            <tr>
                                <td><strong>POST</strong></td>
                                <td>Create new resource</td>
                                <td><code>POST /api/users</code></td>
                                <td>‚ùå No</td>
                            </tr>
                            <tr>
                                <td><strong>PUT</strong></td>
                                <td>Replace entire resource</td>
                                <td><code>PUT /api/users/123</code></td>
                                <td>‚úÖ Yes</td>
                            </tr>
                            <tr>
                                <td><strong>PATCH</strong></td>
                                <td>Partial update</td>
                                <td><code>PATCH /api/users/123</code></td>
                                <td>‚ö†Ô∏è Maybe</td>
                            </tr>
                            <tr>
                                <td><strong>DELETE</strong></td>
                                <td>Remove resource</td>
                                <td><code>DELETE /api/users/123</code></td>
                                <td>‚úÖ Yes</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° What is Idempotent?</h4>
                    <p><strong>Idempotent</strong> means making the same request multiple times has the same effect as making it once. GET, PUT, and DELETE are idempotent:</p>
                    <ul>
                        <li>GET /users/123 ‚Üí Always returns the same user (unless data changed)</li>
                        <li>DELETE /users/123 ‚Üí First call deletes, subsequent calls do nothing (already deleted)</li>
                        <li>PUT /users/123 ‚Üí Always sets user to the same state</li>
                    </ul>
                    <p>POST is NOT idempotent:</p>
                    <ul>
                        <li>POST /users ‚Üí Creates a NEW user each time (duplicate entries!)</li>
                    </ul>
                </div>

                <h3>HTTP Status Codes</h3>
                <p>APIs communicate success or failure using status codes:</p>

                <div class="card">
                    <h4>Success Codes (2xx)</h4>
                    <ul>
                        <li><strong>200 OK</strong> - Request succeeded (GET, PUT, PATCH)</li>
                        <li><strong>201 Created</strong> - Resource created successfully (POST)</li>
                        <li><strong>204 No Content</strong> - Success but no response body (DELETE)</li>
                    </ul>

                    <h4>Client Error Codes (4xx)</h4>
                    <ul>
                        <li><strong>400 Bad Request</strong> - Invalid request data</li>
                        <li><strong>401 Unauthorized</strong> - Authentication required or failed</li>
                        <li><strong>403 Forbidden</strong> - Authenticated but not authorized</li>
                        <li><strong>404 Not Found</strong> - Resource doesn't exist</li>
                        <li><strong>422 Unprocessable Entity</strong> - Validation errors</li>
                    </ul>

                    <h4>Server Error Codes (5xx)</h4>
                    <ul>
                        <li><strong>500 Internal Server Error</strong> - Server-side error</li>
                        <li><strong>502 Bad Gateway</strong> - Invalid response from upstream server</li>
                        <li><strong>503 Service Unavailable</strong> - Server temporarily down</li>
                    </ul>
                </div>

                <h3>RESTful URL Structure</h3>
                <p>REST APIs use predictable URL patterns:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Good RESTful URLs</h4>
                    <pre><code class="language-typescript">// Collections (plural nouns)
GET    /api/users              // Get all users
POST   /api/users              // Create a new user

// Specific resources (by ID)
GET    /api/users/123          // Get user with ID 123
PUT    /api/users/123          // Replace user 123
PATCH  /api/users/123          // Update user 123
DELETE /api/users/123          // Delete user 123

// Nested resources
GET    /api/users/123/posts    // Get posts by user 123
POST   /api/users/123/posts    // Create post for user 123
GET    /api/posts/456/comments // Get comments for post 456

// Filtering and pagination (query params)
GET    /api/users?role=admin&page=2&limit=20
GET    /api/posts?author=123&status=published&sort=createdAt:desc</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Bad RESTful URLs (Avoid These!)</h4>
                    <pre><code class="language-typescript">// Using verbs in URLs (the HTTP method is the verb!)
GET    /api/getUsers           ‚ùå Should be: GET /api/users
POST   /api/createUser         ‚ùå Should be: POST /api/users
POST   /api/deleteUser/123     ‚ùå Should be: DELETE /api/users/123

// Inconsistent naming
GET    /api/user               ‚ùå Should be: /api/users (plural)
GET    /api/Users              ‚ùå Should be: /api/users (lowercase)
GET    /api/user-list          ‚ùå Should be: /api/users

// Not resource-based
POST   /api/login              ‚ö†Ô∏è Sometimes acceptable for actions
GET    /api/search?q=test      ‚ö†Ô∏è Sometimes acceptable for complex queries</code></pre>
                </div>

                <h3>Anatomy of an API Request</h3>
                <div class="mermaid">
graph LR
    A[Client] -->|"1. Request"| B[API Server]
    B -->|"2. Response"| A
    
    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
    style B fill:#764ba2,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <div class="card">
                    <h4>A Complete HTTP Request</h4>
                    <pre><code class="language-typescript">// Request Line
POST /api/users HTTP/1.1

// Headers
Host: api.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
Accept: application/json
User-Agent: MyApp/1.0

// Body (for POST, PUT, PATCH)
{
  "name": "Jane Doe",
  "email": "jane@example.com",
  "role": "admin"
}</code></pre>

                    <h4>A Complete HTTP Response</h4>
                    <pre><code class="language-typescript">// Status Line
HTTP/1.1 201 Created

// Headers
Content-Type: application/json
Location: /api/users/456
Cache-Control: no-cache
X-RateLimit-Remaining: 99

// Body
{
  "id": 456,
  "name": "Jane Doe",
  "email": "jane@example.com",
  "role": "admin",
  "createdAt": "2024-01-15T10:30:00Z"
}</code></pre>
                </div>

                <h3>Common API Patterns</h3>
                <div class="card">
                    <h4>Pagination</h4>
                    <pre><code class="language-typescript">// Offset-based
GET /api/posts?page=2&limit=20

// Cursor-based
GET /api/posts?cursor=abc123&limit=20

// Response includes metadata
{
  "data": [...],
  "pagination": {
    "total": 500,
    "page": 2,
    "limit": 20,
    "totalPages": 25,
    "hasNext": true,
    "hasPrevious": true
  }
}</code></pre>

                    <h4>Filtering and Sorting</h4>
                    <pre><code class="language-typescript">// Filtering
GET /api/users?role=admin&status=active&createdAfter=2024-01-01

// Sorting
GET /api/posts?sort=createdAt:desc,title:asc

// Searching
GET /api/products?q=laptop&category=electronics</code></pre>

                    <h4>Field Selection (Sparse Fieldsets)</h4>
                    <pre><code class="language-typescript">// Only return specific fields
GET /api/users?fields=id,name,email

// Response
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com"
  // Other fields omitted
}</code></pre>

                    <h4>Relationship Inclusion</h4>
                    <pre><code class="language-typescript">// Include related resources
GET /api/posts/123?include=author,comments

// Response
{
  "id": 123,
  "title": "My Post",
  "author": {
    "id": 456,
    "name": "Jane Doe"
  },
  "comments": [
    { "id": 789, "text": "Great post!" }
  ]
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ RESTful API Best Practices</h4>
                    <ul>
                        <li><strong>Use nouns, not verbs</strong> - URLs represent resources, methods represent actions</li>
                        <li><strong>Use plural names</strong> - /users not /user (collections are plural)</li>
                        <li><strong>Use lowercase</strong> - /api/users not /api/Users</li>
                        <li><strong>Use hyphens, not underscores</strong> - /user-profiles not /user_profiles</li>
                        <li><strong>Nest resources logically</strong> - /users/123/posts makes sense</li>
                        <li><strong>Version your API</strong> - /api/v1/users or api.example.com/v1/users</li>
                        <li><strong>Return appropriate status codes</strong> - 201 for creation, 404 for not found, etc.</li>
                        <li><strong>Use query params for filters</strong> - /users?role=admin&active=true</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: CRUD Operations -->
            <section id="section2" class="lesson-section">
                <h2>üîÑ CRUD Operations</h2>
                <p>CRUD stands for Create, Read, Update, Delete‚Äîthe four basic operations for persistent storage. Let's implement all of them with proper TypeScript typing!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ CRUD Overview</h4>
                    <p style="color: white;"><strong>CREATE:</strong> Add new data (POST)</p>
                    <p style="color: white;"><strong>READ:</strong> Retrieve existing data (GET)</p>
                    <p style="color: white;"><strong>UPDATE:</strong> Modify existing data (PUT/PATCH)</p>
                    <p style="color: white;"><strong>DELETE:</strong> Remove data (DELETE)</p>
                </div>

                <h3>Defining Types for Our API</h3>
                <p>First, let's define TypeScript interfaces for our data:</p>

                <div class="card">
                    <pre><code class="language-typescript">// types/api.ts

// Base user type from API
interface User {
    id: number;
    name: string;
    email: string;
    role: 'user' | 'admin';
    avatar?: string;
    createdAt: string;
    updatedAt: string;
}

// Data for creating a new user (no id, timestamps)
interface CreateUserData {
    name: string;
    email: string;
    role?: 'user' | 'admin';
    avatar?: string;
}

// Data for updating a user (all fields optional)
interface UpdateUserData {
    name?: string;
    email?: string;
    role?: 'user' | 'admin';
    avatar?: string;
}

// API response wrapper
interface ApiResponse&lt;T&gt; {
    data: T;
    message?: string;
}

// Paginated response
interface PaginatedResponse&lt;T&gt; {
    data: T[];
    pagination: {
        total: number;
        page: number;
        limit: number;
        totalPages: number;
    };
}

// Error response
interface ApiError {
    message: string;
    errors?: Record&lt;string, string[]&gt;; // Validation errors
    statusCode: number;
}</code></pre>
                </div>

                <h3>CREATE: Adding New Resources</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Create User (POST)</h4>
                    <pre><code class="language-typescript">async function createUser(userData: CreateUserData): Promise&lt;User&gt; {
    try {
        const response = await fetch('https://api.example.com/api/users', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(userData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result: ApiResponse&lt;User&gt; = await response.json();
        return result.data;
    } catch (error) {
        console.error('Failed to create user:', error);
        throw error;
    }
}

// Usage in a component
const CreateUserForm: React.FC = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState&lt;string | null&gt;(null);

    const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);

        const userData: CreateUserData = {
            name: formData.get('name') as string,
            email: formData.get('email') as string,
            role: formData.get('role') as 'user' | 'admin',
        };

        setLoading(true);
        setError(null);

        try {
            const newUser = await createUser(userData);
            console.log('User created:', newUser);
            // Handle success (redirect, show message, etc.)
        } catch (err) {
            setError('Failed to create user');
        } finally {
            setLoading(false);
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input name="name" required placeholder="Name" /&gt;
            &lt;input name="email" type="email" required placeholder="Email" /&gt;
            &lt;select name="role"&gt;
                &lt;option value="user"&gt;User&lt;/option&gt;
                &lt;option value="admin"&gt;Admin&lt;/option&gt;
            &lt;/select&gt;
            &lt;button type="submit" disabled={loading}&gt;
                {loading ? 'Creating...' : 'Create User'}
            &lt;/button&gt;
            {error && &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <h3>READ: Fetching Resources</h3>
                <div class="card">
                    <h4>Read Single User (GET)</h4>
                    <pre><code class="language-typescript">async function getUser(userId: number): Promise&lt;User&gt; {
    try {
        const response = await fetch(`https://api.example.com/api/users/${userId}`, {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('User not found');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result: ApiResponse&lt;User&gt; = await response.json();
        return result.data;
    } catch (error) {
        console.error('Failed to fetch user:', error);
        throw error;
    }
}</code></pre>

                    <h4>Read Multiple Users (GET with Pagination)</h4>
                    <pre><code class="language-typescript">interface GetUsersParams {
    page?: number;
    limit?: number;
    role?: 'user' | 'admin';
    search?: string;
    sortBy?: string;
}

async function getUsers(params: GetUsersParams = {}): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {
    // Build query string from params
    const queryParams = new URLSearchParams();
    
    if (params.page) queryParams.append('page', params.page.toString());
    if (params.limit) queryParams.append('limit', params.limit.toString());
    if (params.role) queryParams.append('role', params.role);
    if (params.search) queryParams.append('q', params.search);
    if (params.sortBy) queryParams.append('sort', params.sortBy);

    const queryString = queryParams.toString();
    const url = `https://api.example.com/api/users${queryString ? `?${queryString}` : ''}`;

    try {
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Failed to fetch users:', error);
        throw error;
    }
}

// Usage
const UserList: React.FC = () => {
    const [users, setUsers] = useState&lt;User[]&gt;([]);
    const [page, setPage] = useState(1);
    const [totalPages, setTotalPages] = useState(1);
    const [loading, setLoading] = useState(false);

    useEffect(() => {
        const fetchUsers = async () => {
            setLoading(true);
            try {
                const response = await getUsers({ page, limit: 20 });
                setUsers(response.data);
                setTotalPages(response.pagination.totalPages);
            } catch (error) {
                console.error(error);
            } finally {
                setLoading(false);
            }
        };

        fetchUsers();
    }, [page]);

    return (
        &lt;div&gt;
            {loading && &lt;div&gt;Loading...&lt;/div&gt;}
            {users.map(user => (
                &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
            ))}
            &lt;button onClick={() => setPage(p => p - 1)} disabled={page === 1}&gt;
                Previous
            &lt;/button&gt;
            &lt;span&gt;Page {page} of {totalPages}&lt;/span&gt;
            &lt;button onClick={() => setPage(p => p + 1)} disabled={page === totalPages}&gt;
                Next
            &lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>


                <h3>UPDATE: Modifying Existing Resources</h3>
                <p>There are two HTTP methods for updating: PUT (full replacement) and PATCH (partial update).</p>

                <div class="card">
                    <h4>PUT vs PATCH</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>PUT</th>
                                <th>PATCH</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Replaces entire resource</td>
                                <td>Updates only specified fields</td>
                            </tr>
                            <tr>
                                <td>Must send all fields</td>
                                <td>Send only changed fields</td>
                            </tr>
                            <tr>
                                <td>Idempotent</td>
                                <td>Usually idempotent</td>
                            </tr>
                            <tr>
                                <td>Missing fields ‚Üí defaults or null</td>
                                <td>Missing fields ‚Üí unchanged</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Update User (PATCH)</h4>
                    <pre><code class="language-typescript">async function updateUser(
    userId: number, 
    updates: UpdateUserData
): Promise&lt;User&gt; {
    try {
        const response = await fetch(`https://api.example.com/api/users/${userId}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(updates)
        });

        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('User not found');
            }
            if (response.status === 422) {
                const errorData = await response.json();
                throw new Error(errorData.message || 'Validation failed');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result: ApiResponse&lt;User&gt; = await response.json();
        return result.data;
    } catch (error) {
        console.error('Failed to update user:', error);
        throw error;
    }
}

// Usage in a component
const EditUserForm: React.FC&lt;{ user: User }&gt; = ({ user }) => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState&lt;string | null&gt;(null);
    const [success, setSuccess] = useState(false);

    const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);

        // Only include changed fields
        const updates: UpdateUserData = {};
        const name = formData.get('name') as string;
        const email = formData.get('email') as string;

        if (name !== user.name) updates.name = name;
        if (email !== user.email) updates.email = email;

        // If nothing changed, don't make request
        if (Object.keys(updates).length === 0) {
            setError('No changes detected');
            return;
        }

        setLoading(true);
        setError(null);
        setSuccess(false);

        try {
            await updateUser(user.id, updates);
            setSuccess(true);
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to update user');
        } finally {
            setLoading(false);
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input 
                name="name" 
                defaultValue={user.name} 
                required 
                placeholder="Name" 
            /&gt;
            &lt;input 
                name="email" 
                type="email" 
                defaultValue={user.email} 
                required 
                placeholder="Email" 
            /&gt;
            &lt;button type="submit" disabled={loading}&gt;
                {loading ? 'Updating...' : 'Update User'}
            &lt;/button&gt;
            {error && &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}
            {success && &lt;p style={{ color: 'green' }}&gt;User updated successfully!&lt;/p&gt;}
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <div class="card">
                    <h4>Update User (PUT - Full Replacement)</h4>
                    <pre><code class="language-typescript">async function replaceUser(
    userId: number, 
    userData: CreateUserData // Same as create, but for existing user
): Promise&lt;User&gt; {
    try {
        const response = await fetch(`https://api.example.com/api/users/${userId}`, {
            method: 'PUT',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(userData)
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result: ApiResponse&lt;User&gt; = await response.json();
        return result.data;
    } catch (error) {
        console.error('Failed to replace user:', error);
        throw error;
    }
}

// PUT example: All fields must be provided!
await replaceUser(123, {
    name: 'Jane Doe',
    email: 'jane@example.com',
    role: 'admin'
    // If avatar is not provided, it will be set to null or default
});</code></pre>
                </div>

                <h3>DELETE: Removing Resources</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Delete User (DELETE)</h4>
                    <pre><code class="language-typescript">async function deleteUser(userId: number): Promise&lt;void&gt; {
    try {
        const response = await fetch(`https://api.example.com/api/users/${userId}`, {
            method: 'DELETE',
            headers: {
                'Accept': 'application/json'
            }
        });

        if (!response.ok) {
            if (response.status === 404) {
                throw new Error('User not found');
            }
            if (response.status === 403) {
                throw new Error('You do not have permission to delete this user');
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        // DELETE typically returns 204 No Content (no body)
        // Or 200 OK with a success message
        if (response.status === 204) {
            return; // No content
        }

        // If there's a body, parse it
        const result = await response.json();
        console.log(result.message); // e.g., "User deleted successfully"
    } catch (error) {
        console.error('Failed to delete user:', error);
        throw error;
    }
}

// Usage with confirmation
const DeleteUserButton: React.FC&lt;{ user: User; onDeleted: () => void }&gt; = ({ 
    user, 
    onDeleted 
}) => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState&lt;string | null&gt;(null);

    const handleDelete = async () => {
        // Always confirm destructive actions!
        const confirmed = window.confirm(
            `Are you sure you want to delete ${user.name}? This action cannot be undone.`
        );

        if (!confirmed) return;

        setLoading(true);
        setError(null);

        try {
            await deleteUser(user.id);
            onDeleted(); // Notify parent component
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to delete user');
        } finally {
            setLoading(false);
        }
    };

    return (
        &lt;div&gt;
            &lt;button 
                onClick={handleDelete}
                disabled={loading}
                style={{
                    backgroundColor: '#f44336',
                    color: 'white',
                    padding: '0.5rem 1rem',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: loading ? 'not-allowed' : 'pointer'
                }}
            &gt;
                {loading ? 'Deleting...' : 'Delete User'}
            &lt;/button&gt;
            {error && &lt;p style={{ color: 'red' }}&gt;{error}&lt;/p&gt;}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Complete CRUD Example</h3>
                <p>Putting it all together in a user management component:</p>

                <div class="card">
                    <pre><code class="language-typescript">const UserManagement: React.FC = () => {
    const [users, setUsers] = useState&lt;User[]&gt;([]);
    const [loading, setLoading] = useState(false);
    const [editingUser, setEditingUser] = useState&lt;User | null&gt;(null);

    // READ: Fetch all users
    const fetchUsers = async () => {
        setLoading(true);
        try {
            const response = await getUsers({ limit: 50 });
            setUsers(response.data);
        } catch (error) {
            console.error('Failed to fetch users:', error);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchUsers();
    }, []);

    // CREATE: Add new user
    const handleCreate = async (userData: CreateUserData) => {
        try {
            const newUser = await createUser(userData);
            setUsers(prev => [...prev, newUser]);
        } catch (error) {
            console.error('Failed to create user:', error);
        }
    };

    // UPDATE: Edit existing user
    const handleUpdate = async (userId: number, updates: UpdateUserData) => {
        try {
            const updatedUser = await updateUser(userId, updates);
            setUsers(prev => prev.map(u => u.id === userId ? updatedUser : u));
            setEditingUser(null);
        } catch (error) {
            console.error('Failed to update user:', error);
        }
    };

    // DELETE: Remove user
    const handleDelete = async (userId: number) => {
        try {
            await deleteUser(userId);
            setUsers(prev => prev.filter(u => u.id !== userId));
        } catch (error) {
            console.error('Failed to delete user:', error);
        }
    };

    if (loading) return &lt;div&gt;Loading users...&lt;/div&gt;;

    return (
        &lt;div&gt;
            &lt;h2&gt;User Management&lt;/h2&gt;

            {/* User list */}
            &lt;div&gt;
                {users.map(user => (
                    &lt;div key={user.id} style={{ 
                        border: '1px solid #ddd', 
                        padding: '1rem', 
                        marginBottom: '0.5rem' 
                    }}&gt;
                        &lt;h3&gt;{user.name}&lt;/h3&gt;
                        &lt;p&gt;{user.email} - {user.role}&lt;/p&gt;
                        &lt;button onClick={() => setEditingUser(user)}&gt;
                            Edit
                        &lt;/button&gt;
                        &lt;button onClick={() => handleDelete(user.id)}&gt;
                            Delete
                        &lt;/button&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;

            {/* Edit modal */}
            {editingUser && (
                &lt;div style={{
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    backgroundColor: 'rgba(0,0,0,0.5)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                }}&gt;
                    &lt;div style={{ 
                        backgroundColor: 'white', 
                        padding: '2rem', 
                        borderRadius: '8px' 
                    }}&gt;
                        &lt;h3&gt;Edit User&lt;/h3&gt;
                        &lt;EditUserForm 
                            user={editingUser} 
                            onUpdate={handleUpdate}
                            onCancel={() => setEditingUser(null)}
                        /&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° CRUD Best Practices</h4>
                    <ul>
                        <li><strong>Always confirm DELETE operations</strong> - Use confirmation dialogs for destructive actions</li>
                        <li><strong>Show loading states</strong> - Users need feedback during operations</li>
                        <li><strong>Handle errors gracefully</strong> - Display meaningful error messages</li>
                        <li><strong>Update UI optimistically</strong> - Update state immediately, rollback on failure</li>
                        <li><strong>Refresh list after mutations</strong> - Ensure data stays in sync</li>
                        <li><strong>Use PATCH for partial updates</strong> - Only send changed fields</li>
                        <li><strong>Validate on client and server</strong> - Client validation for UX, server for security</li>
                    </ul>
                </div>
            </section>

            <!-- Section 3: Creating an API Service Layer -->
            <section id="section3" class="lesson-section">
                <h2>üèõÔ∏è Creating an API Service Layer</h2>
                <p>Instead of scattering API calls throughout your components, organize them in a dedicated service layer. This improves maintainability, testability, and reusability!</p>

                <h3>Why Use a Service Layer?</h3>
                <div class="card">
                    <h4>‚ùå Without Service Layer (Bad)</h4>
                    <pre><code class="language-typescript">// Component A
const ComponentA = () => {
    const fetchData = async () => {
        const response = await fetch('https://api.example.com/api/users', {
            headers: { 'Authorization': 'Bearer token123' }
        });
        // ...
    };
};

// Component B (duplicated code!)
const ComponentB = () => {
    const fetchData = async () => {
        const response = await fetch('https://api.example.com/api/users', {
            headers: { 'Authorization': 'Bearer token123' }
        });
        // ...
    };
};

// Problems:
// ‚ùå Code duplication
// ‚ùå Hard to change API URL
// ‚ùå Hard to add authentication
// ‚ùå Hard to test
// ‚ùå Hard to add error handling</code></pre>

                    <h4>‚úÖ With Service Layer (Good)</h4>
                    <pre><code class="language-typescript">// services/userService.ts (centralized)
export const userService = {
    getUsers: () => { /* ... */ },
    getUser: (id) => { /* ... */ },
    createUser: (data) => { /* ... */ },
    updateUser: (id, data) => { /* ... */ },
    deleteUser: (id) => { /* ... */ }
};

// Component A
import { userService } from '@/services/userService';
const ComponentA = () => {
    const fetchData = () => userService.getUsers();
};

// Component B (no duplication!)
import { userService } from '@/services/userService';
const ComponentB = () => {
    const fetchData = () => userService.getUsers();
};

// Benefits:
// ‚úÖ No duplication
// ‚úÖ Single place to update
// ‚úÖ Easy to add authentication
// ‚úÖ Easy to test
// ‚úÖ Consistent error handling</code></pre>
                </div>

                <h3>Building a User Service</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Complete User Service</h4>
                    <pre><code class="language-typescript">// services/api/userService.ts
import { apiClient } from './apiClient'; // We'll build this next!

export interface User {
    id: number;
    name: string;
    email: string;
    role: 'user' | 'admin';
    avatar?: string;
    createdAt: string;
    updatedAt: string;
}

export interface CreateUserData {
    name: string;
    email: string;
    role?: 'user' | 'admin';
    avatar?: string;
}

export interface UpdateUserData {
    name?: string;
    email?: string;
    role?: 'user' | 'admin';
    avatar?: string;
}

export interface GetUsersParams {
    page?: number;
    limit?: number;
    role?: 'user' | 'admin';
    search?: string;
    sortBy?: string;
}

export interface PaginatedResponse&lt;T&gt; {
    data: T[];
    pagination: {
        total: number;
        page: number;
        limit: number;
        totalPages: number;
    };
}

class UserService {
    private baseUrl = '/users';

    async getUsers(params?: GetUsersParams): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {
        const queryParams = new URLSearchParams();
        if (params?.page) queryParams.append('page', params.page.toString());
        if (params?.limit) queryParams.append('limit', params.limit.toString());
        if (params?.role) queryParams.append('role', params.role);
        if (params?.search) queryParams.append('q', params.search);
        if (params?.sortBy) queryParams.append('sort', params.sortBy);

        const query = queryParams.toString();
        const url = `${this.baseUrl}${query ? `?${query}` : ''}`;

        return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;(url);
    }

    async getUser(id: number): Promise&lt;User&gt; {
        return apiClient.get&lt;User&gt;(`${this.baseUrl}/${id}`);
    }

    async createUser(data: CreateUserData): Promise&lt;User&gt; {
        return apiClient.post&lt;User&gt;(this.baseUrl, data);
    }

    async updateUser(id: number, data: UpdateUserData): Promise&lt;User&gt; {
        return apiClient.patch&lt;User&gt;(`${this.baseUrl}/${id}`, data);
    }

    async deleteUser(id: number): Promise&lt;void&gt; {
        return apiClient.delete(`${this.baseUrl}/${id}`);
    }

    // Additional methods
    async getUserPosts(userId: number): Promise&lt;Post[]&gt; {
        return apiClient.get&lt;Post[]&gt;(`${this.baseUrl}/${userId}/posts`);
    }

    async uploadAvatar(userId: number, file: File): Promise&lt;User&gt; {
        const formData = new FormData();
        formData.append('avatar', file);
        
        return apiClient.post&lt;User&gt;(
            `${this.baseUrl}/${userId}/avatar`,
            formData,
            {
                headers: {
                    'Content-Type': 'multipart/form-data'
                }
            }
        );
    }
}

// Export singleton instance
export const userService = new UserService();</code></pre>
                </div>

                <h3>Building an API Client</h3>
                <p>Create a base API client that all services use:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Reusable API Client</h4>
                    <pre><code class="language-typescript">// services/api/apiClient.ts

export interface ApiClientConfig {
    baseURL: string;
    headers?: Record&lt;string, string&gt;;
    timeout?: number;
}

export interface RequestConfig {
    headers?: Record&lt;string, string&gt;;
    params?: Record&lt;string, any&gt;;
}

class ApiClient {
    private baseURL: string;
    private defaultHeaders: Record&lt;string, string&gt;;
    private timeout: number;

    constructor(config: ApiClientConfig) {
        this.baseURL = config.baseURL;
        this.defaultHeaders = config.headers || {
            'Content-Type': 'application/json',
            'Accept': 'application/json'
        };
        this.timeout = config.timeout || 30000; // 30 seconds
    }

    // Set authorization token
    setAuthToken(token: string) {
        this.defaultHeaders['Authorization'] = `Bearer ${token}`;
    }

    // Remove authorization token
    clearAuthToken() {
        delete this.defaultHeaders['Authorization'];
    }

    // Build full URL
    private buildURL(endpoint: string): string {
        return `${this.baseURL}${endpoint}`;
    }

    // Merge headers
    private mergeHeaders(customHeaders?: Record&lt;string, string&gt;): HeadersInit {
        return {
            ...this.defaultHeaders,
            ...customHeaders
        };
    }

    // Generic request method
    private async request&lt;T&gt;(
        method: string,
        endpoint: string,
        data?: any,
        config?: RequestConfig
    ): Promise&lt;T&gt; {
        const url = this.buildURL(endpoint);
        const headers = this.mergeHeaders(config?.headers);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const options: RequestInit = {
                method,
                headers,
                signal: controller.signal
            };

            // Add body for POST, PUT, PATCH
            if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
                if (data instanceof FormData) {
                    // Don't set Content-Type for FormData (browser sets it with boundary)
                    delete (options.headers as any)['Content-Type'];
                    options.body = data;
                } else {
                    options.body = JSON.stringify(data);
                }
            }

            const response = await fetch(url, options);
            clearTimeout(timeoutId);

            // Handle different status codes
            if (!response.ok) {
                await this.handleError(response);
            }

            // Handle 204 No Content
            if (response.status === 204) {
                return undefined as any;
            }

            // Parse JSON response
            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);
            
            if (error instanceof Error && error.name === 'AbortError') {
                throw new Error('Request timeout');
            }
            
            throw error;
        }
    }

    // Error handling
    private async handleError(response: Response): Promise&lt;never&gt; {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        
        try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorMessage;
            
            if (errorData.errors) {
                // Validation errors
                const errors = Object.entries(errorData.errors)
                    .map(([field, messages]) => `${field}: ${(messages as string[]).join(', ')}`)
                    .join('; ');
                errorMessage += ` - ${errors}`;
            }
        } catch {
            // Response body is not JSON
        }

        throw new Error(errorMessage);
    }

    // HTTP methods
    async get&lt;T&gt;(endpoint: string, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('GET', endpoint, undefined, config);
    }

    async post&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('POST', endpoint, data, config);
    }

    async put&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('PUT', endpoint, data, config);
    }

    async patch&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('PATCH', endpoint, data, config);
    }

    async delete&lt;T&gt;(endpoint: string, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('DELETE', endpoint, undefined, config);
    }
}

// Create and export default instance
export const apiClient = new ApiClient({
    baseURL: import.meta.env.VITE_API_URL || 'https://api.example.com/api',
    timeout: 30000
});</code></pre>
                </div>

                <h3>Using the Service Layer</h3>
                <div class="card">
                    <pre><code class="language-typescript">// In your components - clean and simple!
import { userService } from '@/services/api/userService';

const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);

    useEffect(() => {
        const fetchUser = async () => {
            try {
                const userData = await userService.getUser(userId);
                setUser(userData);
            } catch (err) {
                setError(err instanceof Error ? err.message : 'Failed to load user');
            } finally {
                setLoading(false);
            }
        };

        fetchUser();
    }, [userId]);

    if (loading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!user) return null;

    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
            &lt;p&gt;Role: {user.role}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Organizing Multiple Services</h3>
                <div class="card">
                    <pre><code class="language-typescript">// services/api/index.ts
export { userService } from './userService';
export { postService } from './postService';
export { authService } from './authService';
export { commentService } from './commentService';

// Now import everything from one place!
import { userService, postService, authService } from '@/services/api';</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Service Layer Benefits</h4>
                    <ul>
                        <li><strong>Centralized API calls</strong> - All API logic in one place</li>
                        <li><strong>No duplication</strong> - Write once, use everywhere</li>
                        <li><strong>Easy to test</strong> - Mock services instead of fetch</li>
                        <li><strong>Easy to update</strong> - Change URL or auth in one place</li>
                        <li><strong>Type safety</strong> - TypeScript interfaces for all requests/responses</li>
                        <li><strong>Consistent error handling</strong> - Handle errors uniformly</li>
                        <li><strong>Reusable client</strong> - Share logic across services</li>
                    </ul>
                </div>
            </section>


            <!-- Section 4: Authentication and Authorization -->
            <section id="section4" class="lesson-section">
                <h2>üîê Authentication and Authorization</h2>
                <p>Most APIs require authentication to identify users and authorization to control what they can access. Let's implement JWT-based authentication, the most common pattern for modern web apps!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definitions</h4>
                    <p style="color: white;"><strong>Authentication:</strong> Verifying who you are (proving identity with username/password, proving you're logged in with a token)</p>
                    <p style="color: white; margin-top: 1rem;"><strong>Authorization:</strong> Verifying what you can do (checking permissions, roles, access levels)</p>
                    <p style="color: white; margin-top: 1rem;"><strong>JWT (JSON Web Token):</strong> A secure, compact token format for transmitting information between parties. Contains user info and is signed to prevent tampering.</p>
                </div>

                <h3>Authentication Flow</h3>
                <div class="mermaid">
sequenceDiagram
    participant User
    participant App
    participant API
    
    User->>App: Enter credentials
    App->>API: POST /auth/login {email, password}
    API->>API: Verify credentials
    API->>App: 200 OK {token, user}
    App->>App: Store token in localStorage
    
    Note over App: User is now authenticated
    
    User->>App: Request protected resource
    App->>API: GET /api/users (Authorization: Bearer token)
    API->>API: Verify token
    API->>App: 200 OK {data}
    App->>User: Display data
    
    Note over App: Token expires
    
    App->>API: GET /api/users (expired token)
    API->>App: 401 Unauthorized
    App->>App: Clear token, redirect to login
    App->>User: Please log in again
                </div>

                <h3>Building an Auth Service</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Complete Auth Service</h4>
                    <pre><code class="language-typescript">// services/api/authService.ts
import { apiClient } from './apiClient';

export interface LoginCredentials {
    email: string;
    password: string;
}

export interface RegisterData {
    name: string;
    email: string;
    password: string;
    passwordConfirmation: string;
}

export interface AuthResponse {
    token: string;
    user: {
        id: number;
        name: string;
        email: string;
        role: 'user' | 'admin';
    };
}

export interface User {
    id: number;
    name: string;
    email: string;
    role: 'user' | 'admin';
}

const TOKEN_KEY = 'auth_token';
const USER_KEY = 'auth_user';

class AuthService {
    // Login
    async login(credentials: LoginCredentials): Promise&lt;AuthResponse&gt; {
        const response = await apiClient.post&lt;AuthResponse&gt;(
            '/auth/login',
            credentials
        );

        // Store token and user
        this.setToken(response.token);
        this.setUser(response.user);

        // Set token in API client for future requests
        apiClient.setAuthToken(response.token);

        return response;
    }

    // Register
    async register(data: RegisterData): Promise&lt;AuthResponse&gt; {
        const response = await apiClient.post&lt;AuthResponse&gt;(
            '/auth/register',
            data
        );

        // Store token and user
        this.setToken(response.token);
        this.setUser(response.user);

        // Set token in API client
        apiClient.setAuthToken(response.token);

        return response;
    }

    // Logout
    async logout(): Promise&lt;void&gt; {
        try {
            // Call logout endpoint (optional - invalidates token on server)
            await apiClient.post('/auth/logout');
        } catch (error) {
            console.error('Logout request failed:', error);
        } finally {
            // Always clear local data
            this.clearAuth();
        }
    }

    // Get current user
    async getCurrentUser(): Promise&lt;User&gt; {
        return apiClient.get&lt;User&gt;('/auth/me');
    }

    // Refresh token
    async refreshToken(): Promise&lt;string&gt; {
        const response = await apiClient.post&lt;{ token: string }&gt;('/auth/refresh');
        this.setToken(response.token);
        apiClient.setAuthToken(response.token);
        return response.token;
    }

    // Token management
    setToken(token: string): void {
        localStorage.setItem(TOKEN_KEY, token);
    }

    getToken(): string | null {
        return localStorage.getItem(TOKEN_KEY);
    }

    // User management
    setUser(user: User): void {
        localStorage.setItem(USER_KEY, JSON.stringify(user));
    }

    getUser(): User | null {
        const userStr = localStorage.getItem(USER_KEY);
        if (!userStr) return null;
        try {
            return JSON.parse(userStr);
        } catch {
            return null;
        }
    }

    // Check if authenticated
    isAuthenticated(): boolean {
        return this.getToken() !== null;
    }

    // Clear auth data
    clearAuth(): void {
        localStorage.removeItem(TOKEN_KEY);
        localStorage.removeItem(USER_KEY);
        apiClient.clearAuthToken();
    }

    // Initialize (call on app startup)
    initialize(): void {
        const token = this.getToken();
        if (token) {
            apiClient.setAuthToken(token);
        }
    }
}

export const authService = new AuthService();</code></pre>
                </div>

                <h3>Login Component</h3>
                <div class="card">
                    <pre><code class="language-typescript">import { authService } from '@/services/api/authService';

const LoginForm: React.FC = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState&lt;string | null&gt;(null);
    const navigate = useNavigate(); // From react-router-dom

    const handleSubmit = async (e: React.FormEvent&lt;HTMLFormElement&gt;) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);

        const credentials = {
            email: formData.get('email') as string,
            password: formData.get('password') as string,
        };

        setLoading(true);
        setError(null);

        try {
            await authService.login(credentials);
            // Redirect to dashboard on success
            navigate('/dashboard');
        } catch (err) {
            setError(
                err instanceof Error 
                    ? err.message 
                    : 'Login failed. Please check your credentials.'
            );
        } finally {
            setLoading(false);
        }
    };

    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;h2&gt;Login&lt;/h2&gt;
            
            {error && (
                &lt;div style={{ 
                    backgroundColor: '#ffebee', 
                    color: '#c62828', 
                    padding: '1rem',
                    borderRadius: '4px',
                    marginBottom: '1rem'
                }}&gt;
                    {error}
                &lt;/div&gt;
            )}

            &lt;div style={{ marginBottom: '1rem' }}&gt;
                &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
                &lt;input
                    id="email"
                    name="email"
                    type="email"
                    required
                    placeholder="your@email.com"
                    style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
            &lt;/div&gt;

            &lt;div style={{ marginBottom: '1rem' }}&gt;
                &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
                &lt;input
                    id="password"
                    name="password"
                    type="password"
                    required
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
            &lt;/div&gt;

            &lt;button 
                type="submit" 
                disabled={loading}
                style={{
                    width: '100%',
                    padding: '0.75rem',
                    backgroundColor: '#667eea',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: loading ? 'not-allowed' : 'pointer'
                }}
            &gt;
                {loading ? 'Logging in...' : 'Login'}
            &lt;/button&gt;
        &lt;/form&gt;
    );
};</code></pre>
                </div>

                <h3>Protected Routes</h3>
                <p>Prevent unauthenticated users from accessing protected pages:</p>

                <div class="card">
                    <pre><code class="language-typescript">// components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { authService } from '@/services/api/authService';

interface ProtectedRouteProps {
    children: React.ReactNode;
    requiredRole?: 'user' | 'admin';
}

const ProtectedRoute: React.FC&lt;ProtectedRouteProps&gt; = ({ 
    children, 
    requiredRole 
}) => {
    const isAuthenticated = authService.isAuthenticated();

    if (!isAuthenticated) {
        // Redirect to login if not authenticated
        return &lt;Navigate to="/login" replace /&gt;;
    }

    // Check role if required
    if (requiredRole) {
        const user = authService.getUser();
        if (!user || user.role !== requiredRole) {
            // Redirect to unauthorized page
            return &lt;Navigate to="/unauthorized" replace /&gt;;
        }
    }

    return &lt;&gt;{children}&lt;/&gt;;
};

// Usage in App.tsx
import { BrowserRouter, Routes, Route } from 'react-router-dom';

function App() {
    // Initialize auth on app startup
    useEffect(() => {
        authService.initialize();
    }, []);

    return (
        &lt;BrowserRouter&gt;
            &lt;Routes&gt;
                {/* Public routes */}
                &lt;Route path="/login" element={&lt;LoginForm /&gt;} /&gt;
                &lt;Route path="/register" element={&lt;RegisterForm /&gt;} /&gt;

                {/* Protected routes - any authenticated user */}
                &lt;Route 
                    path="/dashboard" 
                    element={
                        &lt;ProtectedRoute&gt;
                            &lt;Dashboard /&gt;
                        &lt;/ProtectedRoute&gt;
                    } 
                /&gt;

                {/* Protected routes - admin only */}
                &lt;Route 
                    path="/admin" 
                    element={
                        &lt;ProtectedRoute requiredRole="admin"&gt;
                            &lt;AdminPanel /&gt;
                        &lt;/ProtectedRoute&gt;
                    } 
                /&gt;
            &lt;/Routes&gt;
        &lt;/BrowserRouter&gt;
    );
}</code></pre>
                </div>

                <h3>Auto-Refreshing Tokens</h3>
                <p>Handle token expiration automatically:</p>

                <div class="card">
                    <pre><code class="language-typescript">// Enhance API Client with token refresh
class ApiClient {
    // ... existing code ...

    private async request&lt;T&gt;(
        method: string,
        endpoint: string,
        data?: any,
        config?: RequestConfig
    ): Promise&lt;T&gt; {
        try {
            // Make request
            const response = await fetch(url, options);

            // If 401 Unauthorized, try to refresh token
            if (response.status === 401) {
                try {
                    // Attempt token refresh
                    await authService.refreshToken();
                    
                    // Retry original request with new token
                    const retryResponse = await fetch(url, {
                        ...options,
                        headers: this.mergeHeaders(config?.headers)
                    });

                    if (!retryResponse.ok) {
                        await this.handleError(retryResponse);
                    }

                    return await retryResponse.json();
                } catch (refreshError) {
                    // Refresh failed - logout user
                    authService.clearAuth();
                    window.location.href = '/login';
                    throw new Error('Session expired. Please login again.');
                }
            }

            if (!response.ok) {
                await this.handleError(response);
            }

            return await response.json();
        } catch (error) {
            throw error;
        }
    }
}</code></pre>
                </div>

                <h3>Using Auth Context</h3>
                <p>Provide auth state globally with React Context:</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Auth Context Provider</h4>
                    <pre><code class="language-typescript">// contexts/AuthContext.tsx
import { createContext, useContext, useState, useEffect } from 'react';
import { authService, User } from '@/services/api/authService';

interface AuthContextType {
    user: User | null;
    isAuthenticated: boolean;
    isLoading: boolean;
    login: (email: string, password: string) => Promise&lt;void&gt;;
    logout: () => Promise&lt;void&gt;;
    refreshUser: () => Promise&lt;void&gt;;
}

const AuthContext = createContext&lt;AuthContextType | undefined&gt;(undefined);

export const AuthProvider: React.FC&lt;{ children: React.ReactNode }&gt; = ({ children }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);

    // Initialize - load user from localStorage
    useEffect(() => {
        const initAuth = async () => {
            authService.initialize();
            const storedUser = authService.getUser();
            
            if (storedUser && authService.isAuthenticated()) {
                try {
                    // Verify token is still valid by fetching current user
                    const currentUser = await authService.getCurrentUser();
                    setUser(currentUser);
                } catch (error) {
                    // Token invalid - clear auth
                    authService.clearAuth();
                }
            }
            
            setIsLoading(false);
        };

        initAuth();
    }, []);

    const login = async (email: string, password: string) => {
        const response = await authService.login({ email, password });
        setUser(response.user);
    };

    const logout = async () => {
        await authService.logout();
        setUser(null);
    };

    const refreshUser = async () => {
        const currentUser = await authService.getCurrentUser();
        setUser(currentUser);
    };

    return (
        &lt;AuthContext.Provider 
            value={{
                user,
                isAuthenticated: !!user,
                isLoading,
                login,
                logout,
                refreshUser
            }}
        &gt;
            {children}
        &lt;/AuthContext.Provider&gt;
    );
};

// Custom hook
export const useAuth = () => {
    const context = useContext(AuthContext);
    if (!context) {
        throw new Error('useAuth must be used within AuthProvider');
    }
    return context;
};

// Usage in App.tsx
function App() {
    return (
        &lt;AuthProvider&gt;
            &lt;BrowserRouter&gt;
                &lt;Routes&gt;
                    {/* routes */}
                &lt;/Routes&gt;
            &lt;/BrowserRouter&gt;
        &lt;/AuthProvider&gt;
    );
}

// Usage in components
const UserProfile: React.FC = () => {
    const { user, logout } = useAuth();

    if (!user) return null;

    return (
        &lt;div&gt;
            &lt;h2&gt;Welcome, {user.name}!&lt;/h2&gt;
            &lt;p&gt;Email: {user.email}&lt;/p&gt;
            &lt;p&gt;Role: {user.role}&lt;/p&gt;
            &lt;button onClick={logout}&gt;Logout&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Authentication Best Practices</h4>
                    <ul>
                        <li><strong>Store tokens securely</strong> - localStorage for SPAs, httpOnly cookies for SSR</li>
                        <li><strong>Never store passwords</strong> - Only send them during login/register</li>
                        <li><strong>Handle token expiration</strong> - Auto-refresh or redirect to login</li>
                        <li><strong>Clear auth on logout</strong> - Remove tokens and user data</li>
                        <li><strong>Validate on every request</strong> - Server should verify tokens</li>
                        <li><strong>Use HTTPS in production</strong> - Never send tokens over HTTP</li>
                        <li><strong>Implement role-based access</strong> - Check permissions on client AND server</li>
                        <li><strong>Show loading states</strong> - While checking authentication status</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Error Handling Strategies -->
            <section id="section5" class="lesson-section">
                <h2>üö® Error Handling Strategies</h2>
                <p>Things go wrong: network fails, servers crash, users lose internet. Proper error handling is crucial for good UX. Let's build a robust error handling system!</p>

                <h3>Types of API Errors</h3>
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Error Type</th>
                                <th>Cause</th>
                                <th>Example</th>
                                <th>How to Handle</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Network Error</strong></td>
                                <td>No internet, DNS failure</td>
                                <td>fetch() rejects</td>
                                <td>Show "offline" message, retry button</td>
                            </tr>
                            <tr>
                                <td><strong>Timeout</strong></td>
                                <td>Request takes too long</td>
                                <td>AbortController aborts</td>
                                <td>Show timeout message, retry option</td>
                            </tr>
                            <tr>
                                <td><strong>4xx Client Error</strong></td>
                                <td>Bad request, unauthorized</td>
                                <td>400, 401, 403, 404, 422</td>
                                <td>Show specific error message</td>
                            </tr>
                            <tr>
                                <td><strong>5xx Server Error</strong></td>
                                <td>Server crashed, overloaded</td>
                                <td>500, 502, 503</td>
                                <td>Show generic message, retry</td>
                            </tr>
                            <tr>
                                <td><strong>Validation Error</strong></td>
                                <td>Invalid form data</td>
                                <td>422 with field errors</td>
                                <td>Show field-specific errors</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Enhanced API Client with Error Handling</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Comprehensive Error Handling</h4>
                    <pre><code class="language-typescript">// types/errors.ts
export class ApiError extends Error {
    statusCode: number;
    errors?: Record&lt;string, string[]&gt;; // Validation errors
    
    constructor(message: string, statusCode: number, errors?: Record&lt;string, string[]&gt;) {
        super(message);
        this.name = 'ApiError';
        this.statusCode = statusCode;
        this.errors = errors;
    }

    isClientError(): boolean {
        return this.statusCode >= 400 && this.statusCode < 500;
    }

    isServerError(): boolean {
        return this.statusCode >= 500;
    }

    isValidationError(): boolean {
        return this.statusCode === 422 && !!this.errors;
    }
}

export class NetworkError extends Error {
    constructor(message: string = 'Network error. Please check your internet connection.') {
        super(message);
        this.name = 'NetworkError';
    }
}

export class TimeoutError extends Error {
    constructor(message: string = 'Request timeout. Please try again.') {
        super(message);
        this.name = 'TimeoutError';
    }
}

// Enhanced API Client
class ApiClient {
    // ... existing code ...

    private async handleError(response: Response): Promise&lt;never&gt; {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        let errors: Record&lt;string, string[]&gt; | undefined;
        
        try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorMessage;
            
            // Extract validation errors
            if (errorData.errors) {
                errors = errorData.errors;
            }
        } catch {
            // Response body is not JSON or empty
        }

        throw new ApiError(errorMessage, response.status, errors);
    }

    private async request&lt;T&gt;(
        method: string,
        endpoint: string,
        data?: any,
        config?: RequestConfig
    ): Promise&lt;T&gt; {
        const url = this.buildURL(endpoint);
        const headers = this.mergeHeaders(config?.headers);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const options: RequestInit = {
                method,
                headers,
                signal: controller.signal
            };

            if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
                options.body = JSON.stringify(data);
            }

            const response = await fetch(url, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                await this.handleError(response);
            }

            if (response.status === 204) {
                return undefined as any;
            }

            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);
            
            // Handle different error types
            if (error instanceof Error) {
                if (error.name === 'AbortError') {
                    throw new TimeoutError();
                }
                
                // Network errors (no response from server)
                if (error.message.includes('Failed to fetch') || 
                    error.message.includes('Network request failed')) {
                    throw new NetworkError();
                }
            }
            
            // Re-throw API errors and unknown errors
            throw error;
        }
    }
}</code></pre>
                </div>

                <h3>Error Display Component</h3>
                <div class="card">
                    <pre><code class="language-typescript">// components/ErrorDisplay.tsx
import { ApiError, NetworkError, TimeoutError } from '@/types/errors';

interface ErrorDisplayProps {
    error: Error | null;
    onRetry?: () => void;
}

const ErrorDisplay: React.FC&lt;ErrorDisplayProps&gt; = ({ error, onRetry }) => {
    if (!error) return null;

    // Network error
    if (error instanceof NetworkError) {
        return (
            &lt;div style={{
                backgroundColor: '#fff3cd',
                border: '1px solid #ffc107',
                borderRadius: '4px',
                padding: '1rem',
                marginBottom: '1rem'
            }}&gt;
                &lt;h4 style={{ marginTop: 0 }}&gt;üì° Connection Error&lt;/h4&gt;
                &lt;p&gt;{error.message}&lt;/p&gt;
                {onRetry && (
                    &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
                )}
            &lt;/div&gt;
        );
    }

    // Timeout error
    if (error instanceof TimeoutError) {
        return (
            &lt;div style={{
                backgroundColor: '#fff3cd',
                border: '1px solid #ffc107',
                borderRadius: '4px',
                padding: '1rem',
                marginBottom: '1rem'
            }}&gt;
                &lt;h4 style={{ marginTop: 0 }}&gt;‚è±Ô∏è Request Timeout&lt;/h4&gt;
                &lt;p&gt;{error.message}&lt;/p&gt;
                {onRetry && (
                    &lt;button onClick={onRetry}&gt;Try Again&lt;/button&gt;
                )}
            &lt;/div&gt;
        );
    }

    // API error with validation errors
    if (error instanceof ApiError && error.isValidationError() && error.errors) {
        return (
            &lt;div style={{
                backgroundColor: '#ffebee',
                border: '1px solid #f44336',
                borderRadius: '4px',
                padding: '1rem',
                marginBottom: '1rem'
            }}&gt;
                &lt;h4 style={{ marginTop: 0 }}&gt;‚ùå Validation Errors&lt;/h4&gt;
                &lt;ul style={{ margin: 0 }}&gt;
                    {Object.entries(error.errors).map(([field, messages]) => (
                        &lt;li key={field}&gt;
                            &lt;strong&gt;{field}:&lt;/strong&gt; {messages.join(', ')}
                        &lt;/li&gt;
                    ))}
                &lt;/ul&gt;
            &lt;/div&gt;
        );
    }

    // Server error (5xx)
    if (error instanceof ApiError && error.isServerError()) {
        return (
            &lt;div style={{
                backgroundColor: '#ffebee',
                border: '1px solid #f44336',
                borderRadius: '4px',
                padding: '1rem',
                marginBottom: '1rem'
            }}&gt;
                &lt;h4 style={{ marginTop: 0 }}&gt;üîß Server Error&lt;/h4&gt;
                &lt;p&gt;Something went wrong on our end. Please try again later.&lt;/p&gt;
                {onRetry && (
                    &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
                )}
            &lt;/div&gt;
        );
    }

    // Generic error
    return (
        &lt;div style={{
            backgroundColor: '#ffebee',
            border: '1px solid #f44336',
            borderRadius: '4px',
            padding: '1rem',
            marginBottom: '1rem'
        }}&gt;
            &lt;h4 style={{ marginTop: 0 }}&gt;‚ùå Error&lt;/h4&gt;
            &lt;p&gt;{error.message}&lt;/p&gt;
            {onRetry && (
                &lt;button onClick={onRetry}&gt;Retry&lt;/button&gt;
            )}
        &lt;/div&gt;
    );
};

// Usage
const UserList: React.FC = () => {
    const [users, setUsers] = useState&lt;User[]&gt;([]);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState&lt;Error | null&gt;(null);

    const fetchUsers = async () => {
        setLoading(true);
        setError(null);

        try {
            const response = await userService.getUsers();
            setUsers(response.data);
        } catch (err) {
            setError(err as Error);
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchUsers();
    }, []);

    return (
        &lt;div&gt;
            &lt;ErrorDisplay error={error} onRetry={fetchUsers} /&gt;
            
            {loading && &lt;div&gt;Loading...&lt;/div&gt;}
            
            {users.map(user => (
                &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Retry Logic</h3>
                <p>Automatically retry failed requests:</p>

                <div class="card">
                    <pre><code class="language-typescript">// utils/retry.ts
interface RetryOptions {
    maxAttempts?: number;
    delay?: number;
    backoff?: boolean; // Exponential backoff
}

export async function withRetry&lt;T&gt;(
    fn: () => Promise&lt;T&gt;,
    options: RetryOptions = {}
): Promise&lt;T&gt; {
    const { maxAttempts = 3, delay = 1000, backoff = true } = options;
    
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
            return await fn();
        } catch (error) {
            lastError = error as Error;
            
            // Don't retry client errors (4xx) or validation errors
            if (error instanceof ApiError && error.isClientError()) {
                throw error;
            }
            
            // If not last attempt, wait and retry
            if (attempt < maxAttempts) {
                const waitTime = backoff ? delay * Math.pow(2, attempt - 1) : delay;
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }
        }
    }
    
    throw lastError!;
}

// Usage
const fetchUserWithRetry = async (userId: number) => {
    return withRetry(
        () => userService.getUser(userId),
        { maxAttempts: 3, delay: 1000, backoff: true }
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Error Handling Best Practices</h4>
                    <ul>
                        <li><strong>Use specific error types</strong> - Different errors need different handling</li>
                        <li><strong>Show user-friendly messages</strong> - "Network error" not "fetch failed"</li>
                        <li><strong>Provide retry options</strong> - Let users try again after failures</li>
                        <li><strong>Log errors properly</strong> - Send to error tracking (Sentry, LogRocket)</li>
                        <li><strong>Don't retry client errors</strong> - 4xx errors won't succeed on retry</li>
                        <li><strong>Use exponential backoff</strong> - Don't hammer failing servers</li>
                        <li><strong>Handle validation errors specially</strong> - Show field-specific errors</li>
                        <li><strong>Test error scenarios</strong> - Simulate network failures, timeouts, etc.</li>
                    </ul>
                </div>
            </section>


            <!-- Section 6: TypeScript for APIs -->
            <section id="section6" class="lesson-section">
                <h2>üìò TypeScript for APIs</h2>
                <p>TypeScript's type system shines when working with APIs. Proper typing catches bugs at compile-time, provides autocomplete, and makes your code self-documenting. Let's master TypeScript for APIs!</p>

                <h3>Typing API Responses</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Best Practices for Response Types</h4>
                    <pre><code class="language-typescript">// types/api/user.ts

// Domain model - the core data type
export interface User {
    id: number;
    name: string;
    email: string;
    role: 'user' | 'admin' | 'moderator';
    avatar?: string;
    bio?: string;
    createdAt: string; // ISO date string from API
    updatedAt: string;
}

// API response wrapper
export interface ApiResponse&lt;T&gt; {
    data: T;
    message?: string;
    meta?: {
        timestamp: string;
        version: string;
    };
}

// Paginated response
export interface PaginatedResponse&lt;T&gt; {
    data: T[];
    pagination: {
        total: number;
        page: number;
        limit: number;
        totalPages: number;
        hasNext: boolean;
        hasPrevious: boolean;
    };
}

// List response (no pagination)
export interface ListResponse&lt;T&gt; {
    data: T[];
    count: number;
}

// Input types - what we send to API
export interface CreateUserInput {
    name: string;
    email: string;
    password: string;
    role?: 'user' | 'admin';
}

export interface UpdateUserInput {
    name?: string;
    email?: string;
    bio?: string;
    avatar?: string;
}

// Query parameters
export interface GetUsersParams {
    page?: number;
    limit?: number;
    role?: 'user' | 'admin' | 'moderator';
    search?: string;
    sortBy?: 'name' | 'email' | 'createdAt';
    sortOrder?: 'asc' | 'desc';
}</code></pre>
                </div>

                <h3>Generic API Methods</h3>
                <div class="card">
                    <pre><code class="language-typescript">// Fully typed service methods
class UserService {
    async getUsers(
        params?: GetUsersParams
    ): Promise&lt;PaginatedResponse&lt;User&gt;&gt; {
        return apiClient.get&lt;PaginatedResponse&lt;User&gt;&gt;('/users', { params });
    }

    async getUser(id: number): Promise&lt;User&gt; {
        // ApiResponse wrapper is unpacked
        const response = await apiClient.get&lt;ApiResponse&lt;User&gt;&gt;(`/users/${id}`);
        return response.data;
    }

    async createUser(input: CreateUserInput): Promise&lt;User&gt; {
        const response = await apiClient.post&lt;ApiResponse&lt;User&gt;&gt;('/users', input);
        return response.data;
    }

    async updateUser(id: number, input: UpdateUserInput): Promise&lt;User&gt; {
        const response = await apiClient.patch&lt;ApiResponse&lt;User&gt;&gt;(`/users/${id}`, input);
        return response.data;
    }

    async deleteUser(id: number): Promise&lt;void&gt; {
        await apiClient.delete(`/users/${id}`);
    }
}

// Usage in components - TypeScript knows all the types!
const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    
    useEffect(() => {
        userService.getUser(userId).then(setUser);
    }, [userId]);

    // TypeScript knows user.name, user.email, etc.
    return user && &lt;h2&gt;{user.name}&lt;/h2&gt;;
};</code></pre>
                </div>

                <h3>Utility Types for APIs</h3>
                <div class="card">
                    <pre><code class="language-typescript">// Omit sensitive fields
type PublicUser = Omit&lt;User, 'email' | 'role'&gt;;

// Pick specific fields
type UserPreview = Pick&lt;User, 'id' | 'name' | 'avatar'&gt;;

// Make all fields optional for PATCH
type PartialUser = Partial&lt;User&gt;;

// Make all fields required
type CompleteUser = Required&lt;User&gt;;

// Make all fields readonly
type ImmutableUser = Readonly&lt;User&gt;;

// Custom mapped types
type WithTimestamps&lt;T&gt; = T & {
    createdAt: string;
    updatedAt: string;
};

type UserWithTimestamps = WithTimestamps&lt;{
    id: number;
    name: string;
}&gt;;</code></pre>
                </div>

                <h3>Discriminated Unions for API States</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Type-Safe Async State</h4>
                    <pre><code class="language-typescript">// Better than separate loading/error/data states!
type AsyncState&lt;T&gt; =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: Error };

// Usage
const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [state, setState] = useState&lt;AsyncState&lt;User&gt;&gt;({ status: 'idle' });

    useEffect(() => {
        setState({ status: 'loading' });
        
        userService.getUser(userId)
            .then(data => setState({ status: 'success', data }))
            .catch(error => setState({ status: 'error', error }));
    }, [userId]);

    // TypeScript enforces proper handling of each state
    switch (state.status) {
        case 'idle':
        case 'loading':
            return &lt;div&gt;Loading...&lt;/div&gt;;
        
        case 'success':
            // TypeScript knows state.data exists here!
            return &lt;h2&gt;{state.data.name}&lt;/h2&gt;;
        
        case 'error':
            // TypeScript knows state.error exists here!
            return &lt;div&gt;Error: {state.error.message}&lt;/div&gt;;
        
        default:
            // TypeScript ensures we've handled all cases
            const exhaustiveCheck: never = state;
            return exhaustiveCheck;
    }
};</code></pre>
                </div>

                <h3>Type Guards for API Data</h3>
                <div class="card">
                    <pre><code class="language-typescript">// Type guard to check if user is admin
function isAdmin(user: User): user is User & { role: 'admin' } {
    return user.role === 'admin';
}

// Usage
const user = await userService.getUser(123);

if (isAdmin(user)) {
    // TypeScript knows user.role === 'admin' here
    console.log('Admin user:', user.name);
}

// Runtime validation with Zod (recommended!)
import { z } from 'zod';

const UserSchema = z.object({
    id: z.number(),
    name: z.string().min(1),
    email: z.string().email(),
    role: z.enum(['user', 'admin', 'moderator']),
    avatar: z.string().url().optional(),
    bio: z.string().optional(),
    createdAt: z.string().datetime(),
    updatedAt: z.string().datetime(),
});

// Infer TypeScript type from schema
type User = z.infer&lt;typeof UserSchema&gt;;

// Validate API responses at runtime
async function getUser(id: number): Promise&lt;User&gt; {
    const response = await apiClient.get(`/users/${id}`);
    // This will throw if response doesn't match schema!
    return UserSchema.parse(response.data);
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° TypeScript API Tips</h4>
                    <ul>
                        <li><strong>Define types for everything</strong> - Requests, responses, params, errors</li>
                        <li><strong>Use discriminated unions</strong> - Better than separate boolean flags</li>
                        <li><strong>Leverage utility types</strong> - Partial, Pick, Omit save time</li>
                        <li><strong>Validate at runtime</strong> - TypeScript types disappear at runtime; use Zod</li>
                        <li><strong>Keep types close to usage</strong> - Organize by feature/domain</li>
                        <li><strong>Export types</strong> - Share types between services and components</li>
                        <li><strong>Use enums sparingly</strong> - Prefer union types for flexibility</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Environment Variables -->
            <section id="section7" class="lesson-section">
                <h2>üîê Environment Variables</h2>
                <p>Never hardcode API URLs, keys, or secrets! Environment variables let you configure your app for different environments (development, staging, production) without changing code.</p>

                <h3>Setting Up Environment Variables</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Vite Environment Variables</h4>
                    <pre><code class="language-bash"># .env.development
VITE_API_URL=http://localhost:3000/api
VITE_API_TIMEOUT=30000
VITE_ENABLE_LOGGING=true

# .env.production
VITE_API_URL=https://api.production.com/api
VITE_API_TIMEOUT=30000
VITE_ENABLE_LOGGING=false

# .env.local (ignored by git, for local overrides)
VITE_API_URL=http://192.168.1.100:3000/api</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Rules</h4>
                    <ul>
                        <li><strong>Prefix with VITE_</strong> - Required for Vite to expose variables to client</li>
                        <li><strong>Never commit secrets</strong> - Add .env.local to .gitignore</li>
                        <li><strong>No sensitive data</strong> - These are visible in browser! No API keys, passwords</li>
                        <li><strong>Use .env.example</strong> - Commit a template showing required variables</li>
                    </ul>
                </div>

                <h3>Using Environment Variables</h3>
                <div class="card">
                    <pre><code class="language-typescript">// vite-env.d.ts - Type definitions
/// &lt;reference types="vite/client" /&gt;

interface ImportMetaEnv {
    readonly VITE_API_URL: string;
    readonly VITE_API_TIMEOUT: string;
    readonly VITE_ENABLE_LOGGING: string;
}

interface ImportMeta {
    readonly env: ImportMetaEnv;
}

// config/env.ts - Centralized config
export const config = {
    apiUrl: import.meta.env.VITE_API_URL || 'http://localhost:3000/api',
    apiTimeout: parseInt(import.meta.env.VITE_API_TIMEOUT) || 30000,
    enableLogging: import.meta.env.VITE_ENABLE_LOGGING === 'true',
    isDevelopment: import.meta.env.DEV,
    isProduction: import.meta.env.PROD,
};

// services/api/apiClient.ts - Use in API client
import { config } from '@/config/env';

export const apiClient = new ApiClient({
    baseURL: config.apiUrl,
    timeout: config.apiTimeout,
});

// utils/logger.ts - Conditional logging
import { config } from '@/config/env';

export function log(...args: any[]) {
    if (config.enableLogging) {
        console.log('[API]', ...args);
    }
}</code></pre>
                </div>

                <h3>Example .env Files</h3>
                <div class="card">
                    <pre><code class="language-bash"># .env.example (commit this!)
# API Configuration
VITE_API_URL=
VITE_API_TIMEOUT=30000

# Feature Flags
VITE_ENABLE_LOGGING=false
VITE_ENABLE_ANALYTICS=false

# Third-party Services (public keys only!)
VITE_STRIPE_PUBLIC_KEY=
VITE_GOOGLE_MAPS_KEY=</code></pre>

                    <pre><code class="language-bash"># .gitignore
# Environment files
.env.local
.env.*.local

# Keep these:
# .env
# .env.development
# .env.production
# .env.example</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Environment Variables Best Practices</h4>
                    <ul>
                        <li><strong>Use for configuration only</strong> - URLs, timeouts, feature flags</li>
                        <li><strong>Never store secrets</strong> - Client-side code is public!</li>
                        <li><strong>Provide defaults</strong> - Use || operator for fallback values</li>
                        <li><strong>Validate on startup</strong> - Check required vars are present</li>
                        <li><strong>Document in .env.example</strong> - Team knows what's needed</li>
                        <li><strong>Use different values per environment</strong> - Dev/staging/prod</li>
                        <li><strong>Centralize access</strong> - Import from config file, not scattered</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Building an API Client -->
            <section id="section8" class="lesson-section">
                <h2>üõ†Ô∏è Building an API Client</h2>
                <p>Let's put everything together and build a production-ready API client with all the features we've learned!</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Complete Production API Client</h4>
                    <pre><code class="language-typescript">// services/api/apiClient.ts
import { config } from '@/config/env';
import { ApiError, NetworkError, TimeoutError } from '@/types/errors';

interface ApiClientConfig {
    baseURL: string;
    timeout?: number;
    headers?: Record&lt;string, string&gt;;
}

interface RequestConfig {
    headers?: Record&lt;string, string&gt;;
    params?: Record&lt;string, any&gt;;
}

// Request/Response interceptors
type RequestInterceptor = (config: RequestConfig) => RequestConfig | Promise&lt;RequestConfig&gt;;
type ResponseInterceptor = (response: any) => any | Promise&lt;any&gt;;
type ErrorInterceptor = (error: Error) => Error | Promise&lt;Error&gt;;

class ApiClient {
    private baseURL: string;
    private timeout: number;
    private defaultHeaders: Record&lt;string, string&gt;;
    private requestInterceptors: RequestInterceptor[] = [];
    private responseInterceptors: ResponseInterceptor[] = [];
    private errorInterceptors: ErrorInterceptor[] = [];

    constructor(config: ApiClientConfig) {
        this.baseURL = config.baseURL;
        this.timeout = config.timeout || 30000;
        this.defaultHeaders = {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            ...config.headers,
        };
    }

    // Interceptor management
    addRequestInterceptor(interceptor: RequestInterceptor) {
        this.requestInterceptors.push(interceptor);
    }

    addResponseInterceptor(interceptor: ResponseInterceptor) {
        this.responseInterceptors.push(interceptor);
    }

    addErrorInterceptor(interceptor: ErrorInterceptor) {
        this.errorInterceptors.push(interceptor);
    }

    // Auth token management
    setAuthToken(token: string) {
        this.defaultHeaders['Authorization'] = `Bearer ${token}`;
    }

    clearAuthToken() {
        delete this.defaultHeaders['Authorization'];
    }

    // Build full URL
    private buildURL(endpoint: string, params?: Record&lt;string, any&gt;): string {
        const url = `${this.baseURL}${endpoint}`;
        
        if (params) {
            const searchParams = new URLSearchParams();
            Object.entries(params).forEach(([key, value]) => {
                if (value !== undefined && value !== null) {
                    searchParams.append(key, String(value));
                }
            });
            const queryString = searchParams.toString();
            return queryString ? `${url}?${queryString}` : url;
        }
        
        return url;
    }

    // Merge headers
    private mergeHeaders(customHeaders?: Record&lt;string, string&gt;): HeadersInit {
        return { ...this.defaultHeaders, ...customHeaders };
    }

    // Apply request interceptors
    private async applyRequestInterceptors(config: RequestConfig): Promise&lt;RequestConfig&gt; {
        let finalConfig = config;
        for (const interceptor of this.requestInterceptors) {
            finalConfig = await interceptor(finalConfig);
        }
        return finalConfig;
    }

    // Apply response interceptors
    private async applyResponseInterceptors(response: any): Promise&lt;any&gt; {
        let finalResponse = response;
        for (const interceptor of this.responseInterceptors) {
            finalResponse = await interceptor(finalResponse);
        }
        return finalResponse;
    }

    // Apply error interceptors
    private async applyErrorInterceptors(error: Error): Promise&lt;Error&gt; {
        let finalError = error;
        for (const interceptor of this.errorInterceptors) {
            finalError = await interceptor(finalError);
        }
        return finalError;
    }

    // Handle errors
    private async handleError(response: Response): Promise&lt;never&gt; {
        let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        let errors: Record&lt;string, string[]&gt; | undefined;

        try {
            const errorData = await response.json();
            errorMessage = errorData.message || errorMessage;
            errors = errorData.errors;
        } catch {
            // Response body is not JSON
        }

        throw new ApiError(errorMessage, response.status, errors);
    }

    // Generic request method
    private async request&lt;T&gt;(
        method: string,
        endpoint: string,
        data?: any,
        config?: RequestConfig
    ): Promise&lt;T&gt; {
        // Apply request interceptors
        const interceptedConfig = await this.applyRequestInterceptors(config || {});

        const url = this.buildURL(endpoint, interceptedConfig.params);
        const headers = this.mergeHeaders(interceptedConfig.headers);

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);

        try {
            const options: RequestInit = {
                method,
                headers,
                signal: controller.signal,
            };

            // Add body for POST, PUT, PATCH
            if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
                if (data instanceof FormData) {
                    delete (options.headers as any)['Content-Type'];
                    options.body = data;
                } else {
                    options.body = JSON.stringify(data);
                }
            }

            if (config.enableLogging) {
                console.log(`[API] ${method} ${url}`, data);
            }

            const response = await fetch(url, options);
            clearTimeout(timeoutId);

            if (!response.ok) {
                await this.handleError(response);
            }

            // Handle 204 No Content
            if (response.status === 204) {
                return undefined as any;
            }

            const result = await response.json();

            // Apply response interceptors
            const interceptedResult = await this.applyResponseInterceptors(result);

            return interceptedResult;
        } catch (error) {
            clearTimeout(timeoutId);

            let finalError = error as Error;

            // Handle timeout
            if (finalError.name === 'AbortError') {
                finalError = new TimeoutError();
            }

            // Handle network errors
            if (finalError.message?.includes('Failed to fetch')) {
                finalError = new NetworkError();
            }

            // Apply error interceptors
            finalError = await this.applyErrorInterceptors(finalError);

            throw finalError;
        }
    }

    // HTTP methods
    async get&lt;T&gt;(endpoint: string, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('GET', endpoint, undefined, config);
    }

    async post&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('POST', endpoint, data, config);
    }

    async put&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('PUT', endpoint, data, config);
    }

    async patch&lt;T&gt;(endpoint: string, data?: any, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('PATCH', endpoint, data, config);
    }

    async delete&lt;T&gt;(endpoint: string, config?: RequestConfig): Promise&lt;T&gt; {
        return this.request&lt;T&gt;('DELETE', endpoint, undefined, config);
    }
}

// Create and export singleton
export const apiClient = new ApiClient({
    baseURL: config.apiUrl,
    timeout: config.apiTimeout,
});

// Add logging interceptor in development
if (config.isDevelopment) {
    apiClient.addResponseInterceptor((response) => {
        console.log('[API Response]', response);
        return response;
    });

    apiClient.addErrorInterceptor((error) => {
        console.error('[API Error]', error);
        return error;
    });
}</code></pre>
                </div>

                <h3>Using Interceptors</h3>
                <div class="card">
                    <pre><code class="language-typescript">// Add request ID to all requests
apiClient.addRequestInterceptor((config) => {
    return {
        ...config,
        headers: {
            ...config.headers,
            'X-Request-ID': crypto.randomUUID(),
        },
    };
});

// Transform all dates from strings to Date objects
apiClient.addResponseInterceptor((response) => {
    if (response.createdAt) {
        response.createdAt = new Date(response.createdAt);
    }
    if (response.updatedAt) {
        response.updatedAt = new Date(response.updatedAt);
    }
    return response;
});

// Handle token refresh on 401
apiClient.addErrorInterceptor(async (error) => {
    if (error instanceof ApiError && error.statusCode === 401) {
        try {
            await authService.refreshToken();
            // Retry original request (you'd need to store it)
        } catch {
            authService.clearAuth();
            window.location.href = '/login';
        }
    }
    return error;
});</code></pre>
                </div>
            </section>


            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to apply everything you've learned! These exercises will solidify your API integration skills.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Build a Task Service</h3>
                    <p>Create a complete service layer for a task management API.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Define TypeScript interfaces for Task, CreateTaskInput, UpdateTaskInput</li>
                        <li>Implement all CRUD operations (create, read, update, delete)</li>
                        <li>Add methods for: getTasks (with pagination), getTasksByStatus, completeTask</li>
                        <li>Use the API client we built</li>
                        <li>Type everything properly</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Start by defining your types, then create a TaskService class with methods that use apiClient.get/post/patch/delete. Each method should be async and return properly typed promises.</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">// types/api/task.ts
export interface Task {
    id: number;
    title: string;
    description: string;
    status: 'todo' | 'in_progress' | 'done';
    priority: 'low' | 'medium' | 'high';
    dueDate?: string;
    assigneeId?: number;
    createdAt: string;
    updatedAt: string;
}

export interface CreateTaskInput {
    title: string;
    description?: string;
    status?: 'todo' | 'in_progress' | 'done';
    priority?: 'low' | 'medium' | 'high';
    dueDate?: string;
    assigneeId?: number;
}

export interface UpdateTaskInput {
    title?: string;
    description?: string;
    status?: 'todo' | 'in_progress' | 'done';
    priority?: 'low' | 'medium' | 'high';
    dueDate?: string;
    assigneeId?: number;
}

export interface GetTasksParams {
    page?: number;
    limit?: number;
    status?: 'todo' | 'in_progress' | 'done';
    priority?: 'low' | 'medium' | 'high';
    assigneeId?: number;
    sortBy?: 'createdAt' | 'dueDate' | 'priority';
    sortOrder?: 'asc' | 'desc';
}

// services/api/taskService.ts
import { apiClient } from './apiClient';
import { Task, CreateTaskInput, UpdateTaskInput, GetTasksParams } from '@/types/api/task';
import { PaginatedResponse } from '@/types/api';

class TaskService {
    private baseUrl = '/tasks';

    async getTasks(params?: GetTasksParams): Promise<PaginatedResponse<Task>> {
        return apiClient.get<PaginatedResponse<Task>>(this.baseUrl, { params });
    }

    async getTask(id: number): Promise<Task> {
        return apiClient.get<Task>(`${this.baseUrl}/${id}`);
    }

    async getTasksByStatus(status: 'todo' | 'in_progress' | 'done'): Promise<Task[]> {
        const response = await apiClient.get<{ data: Task[] }>(
            this.baseUrl,
            { params: { status } }
        );
        return response.data;
    }

    async createTask(input: CreateTaskInput): Promise<Task> {
        return apiClient.post<Task>(this.baseUrl, input);
    }

    async updateTask(id: number, input: UpdateTaskInput): Promise<Task> {
        return apiClient.patch<Task>(`${this.baseUrl}/${id}`, input);
    }

    async completeTask(id: number): Promise<Task> {
        return apiClient.patch<Task>(`${this.baseUrl}/${id}`, { status: 'done' });
    }

    async deleteTask(id: number): Promise<void> {
        return apiClient.delete(`${this.baseUrl}/${id}`);
    }

    async assignTask(taskId: number, userId: number): Promise<Task> {
        return apiClient.patch<Task>(`${this.baseUrl}/${taskId}`, { assigneeId: userId });
    }
}

export const taskService = new TaskService();</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Implement Authentication</h3>
                    <p>Add authentication to your task app with login, register, and protected routes.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Create login and register forms</li>
                        <li>Store JWT token in localStorage</li>
                        <li>Add token to all API requests</li>
                        <li>Create ProtectedRoute component</li>
                        <li>Handle token expiration (401 errors)</li>
                        <li>Implement logout functionality</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use the authService pattern we built earlier. Initialize auth on app startup to restore sessions. Use an AuthContext to provide auth state globally.</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">// App.tsx
import { useEffect } from 'react';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { authService } from '@/services/api/authService';
import { LoginForm } from '@/components/LoginForm';
import { Dashboard } from '@/pages/Dashboard';
import { ProtectedRoute } from '@/components/ProtectedRoute';

function App() {
    // Initialize auth on startup
    useEffect(() => {
        authService.initialize();
    }, []);

    return (
        <BrowserRouter>
            <Routes>
                <Route path="/login" element={<LoginForm />} />
                <Route 
                    path="/dashboard" 
                    element={
                        <ProtectedRoute>
                            <Dashboard />
                        </ProtectedRoute>
                    } 
                />
                <Route path="/" element={<Navigate to="/dashboard" replace />} />
            </Routes>
        </BrowserRouter>
    );
}

// components/LoginForm.tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { authService } from '@/services/api/authService';

export const LoginForm: React.FC = () => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const navigate = useNavigate();

    const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        const formData = new FormData(e.currentTarget);

        setLoading(true);
        setError(null);

        try {
            await authService.login({
                email: formData.get('email') as string,
                password: formData.get('password') as string,
            });
            navigate('/dashboard');
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Login failed');
        } finally {
            setLoading(false);
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h2>Login</h2>
            {error && <div className="error">{error}</div>}
            <input name="email" type="email" required placeholder="Email" />
            <input name="password" type="password" required placeholder="Password" />
            <button type="submit" disabled={loading}>
                {loading ? 'Logging in...' : 'Login'}
            </button>
        </form>
    );
};

// components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { authService } from '@/services/api/authService';

interface ProtectedRouteProps {
    children: React.ReactNode;
}

export const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
    if (!authService.isAuthenticated()) {
        return <Navigate to="/login" replace />;
    }
    return <>{children}</>;
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Error Handling Component</h3>
                    <p>Build a reusable error boundary and error display system.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Create ErrorDisplay component for API errors</li>
                        <li>Handle different error types (network, timeout, validation)</li>
                        <li>Show user-friendly messages</li>
                        <li>Provide retry functionality</li>
                        <li>Add error logging (console in dev, service in prod)</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use instanceof checks to determine error types. Create different UI for each error type. Accept an onRetry callback prop.</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <p>See Section 5 for the complete ErrorDisplay component implementation!</p>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: Complete Task Management App</h3>
                    <p>Build a full-featured task management application using everything you've learned.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>User authentication (login/logout)</li>
                        <li>Task CRUD operations</li>
                        <li>Filter tasks by status and priority</li>
                        <li>Pagination for task list</li>
                        <li>Proper error handling with retry</li>
                        <li>Loading states for all operations</li>
                        <li>TypeScript types for everything</li>
                        <li>Environment variables for API URL</li>
                        <li>Service layer architecture</li>
                    </ul>

                    <details>
                        <summary>üí° Architecture Tips</summary>
                        <div class="card">
                            <p><strong>Project Structure:</strong></p>
                            <pre><code>src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ TaskList.tsx
‚îÇ   ‚îú‚îÄ‚îÄ TaskForm.tsx
‚îÇ   ‚îú‚îÄ‚îÄ TaskFilter.tsx
‚îÇ   ‚îú‚îÄ‚îÄ ErrorDisplay.tsx
‚îÇ   ‚îî‚îÄ‚îÄ ProtectedRoute.tsx
‚îú‚îÄ‚îÄ pages/
‚îÇ   ‚îú‚îÄ‚îÄ Login.tsx
‚îÇ   ‚îú‚îÄ‚îÄ Dashboard.tsx
‚îÇ   ‚îî‚îÄ‚îÄ TaskDetail.tsx
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ api/
‚îÇ       ‚îú‚îÄ‚îÄ apiClient.ts
‚îÇ       ‚îú‚îÄ‚îÄ authService.ts
‚îÇ       ‚îú‚îÄ‚îÄ taskService.ts
‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ task.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ errors.ts
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ env.ts
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useAuth.tsx
‚îÇ   ‚îî‚îÄ‚îÄ useTasks.tsx
‚îî‚îÄ‚îÄ App.tsx</code></pre>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>üåü Best Practices</h2>

                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Use a service layer</strong> - Centralize all API calls in service files, not scattered in components.</li>
                    <li><strong>Type everything</strong> - Create TypeScript interfaces for all requests, responses, and errors.</li>
                    <li><strong>Handle all error cases</strong> - Network errors, timeouts, 4xx, 5xx, validation errors all need handling.</li>
                    <li><strong>Use environment variables</strong> - Never hardcode API URLs or configuration.</li>
                    <li><strong>Implement authentication properly</strong> - Store tokens securely, handle expiration, protect routes.</li>
                    <li><strong>Show loading states</strong> - Users need feedback during async operations.</li>
                    <li><strong>Provide retry options</strong> - Let users retry failed requests.</li>
                    <li><strong>Use AbortController</strong> - Cancel requests when components unmount or dependencies change.</li>
                    <li><strong>Validate at runtime</strong> - Use libraries like Zod to validate API responses.</li>
                    <li><strong>Log errors properly</strong> - Use error tracking services (Sentry, LogRocket) in production.</li>
                </ul>

                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't scatter API calls</strong> - Keep them in services, not directly in components.</li>
                    <li><strong>Don't hardcode URLs</strong> - Use environment variables for configuration.</li>
                    <li><strong>Don't ignore errors</strong> - Every API call can fail; handle it gracefully.</li>
                    <li><strong>Don't store secrets client-side</strong> - API keys, passwords, etc. should never be in client code.</li>
                    <li><strong>Don't retry everything</strong> - 4xx client errors won't succeed on retry.</li>
                    <li><strong>Don't forget cleanup</strong> - Cancel in-flight requests when components unmount.</li>
                    <li><strong>Don't trust API data</strong> - Validate responses at runtime.</li>
                    <li><strong>Don't expose implementation details</strong> - Services should return clean, typed data.</li>
                </ul>

                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Use React Query or SWR</strong> - These libraries handle caching, refetching, and state management better than manual solutions.</li>
                    <li><strong>Implement request deduplication</strong> - If 5 components request the same data, make only one API call.</li>
                    <li><strong>Use interceptors</strong> - Add logging, auth tokens, and error handling globally.</li>
                    <li><strong>Implement optimistic updates</strong> - Update UI immediately, rollback on failure.</li>
                    <li><strong>Cache aggressively</strong> - Most data doesn't change that often; cache it!</li>
                    <li><strong>Prefetch data</strong> - Load data before users need it for instant perceived performance.</li>
                    <li><strong>Use HTTP/2</strong> - Multiple concurrent requests are efficient with HTTP/2.</li>
                    <li><strong>Monitor API performance</strong> - Track response times, error rates, and success rates.</li>
                    <li><strong>Version your API</strong> - Use /v1/, /v2/ in URLs for backward compatibility.</li>
                    <li><strong>Document your services</strong> - Add JSDoc comments explaining what each method does.</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ API Integration Checklist</h4>
                    <ul>
                        <li>‚úÖ Service layer created with typed methods</li>
                        <li>‚úÖ API client with error handling and interceptors</li>
                        <li>‚úÖ Authentication with JWT tokens</li>
                        <li>‚úÖ Protected routes implemented</li>
                        <li>‚úÖ Environment variables configured</li>
                        <li>‚úÖ Error display components created</li>
                        <li>‚úÖ Loading states shown to users</li>
                        <li>‚úÖ Request cancellation with AbortController</li>
                        <li>‚úÖ TypeScript types for all API interactions</li>
                        <li>‚úÖ Retry logic for failed requests</li>
                        <li>‚úÖ Validation with Zod or similar</li>
                        <li>‚úÖ Error tracking service integrated</li>
                    </ul>
                </div>

                <h3>Security Best Practices</h3>
                <div class="card">
                    <ul>
                        <li><strong>Always use HTTPS</strong> - Never send tokens or sensitive data over HTTP</li>
                        <li><strong>Store tokens securely</strong> - localStorage for SPAs, httpOnly cookies for SSR</li>
                        <li><strong>Implement CORS properly</strong> - Configure allowed origins on your server</li>
                        <li><strong>Validate on server</strong> - Client-side validation is for UX, not security</li>
                        <li><strong>Use Content Security Policy</strong> - Prevent XSS attacks</li>
                        <li><strong>Sanitize user input</strong> - Never trust user-provided data</li>
                        <li><strong>Implement rate limiting</strong> - Prevent abuse of your API</li>
                        <li><strong>Log security events</strong> - Track failed login attempts, unusual patterns</li>
                    </ul>
                </div>

                <h3>Performance Best Practices</h3>
                <div class="card">
                    <ul>
                        <li><strong>Minimize request size</strong> - Send only necessary data</li>
                        <li><strong>Use pagination</strong> - Don't fetch 1000 items at once</li>
                        <li><strong>Implement caching</strong> - Reduce redundant API calls</li>
                        <li><strong>Compress responses</strong> - Enable gzip/brotli on your server</li>
                        <li><strong>Use CDN for static assets</strong> - Serve images, fonts, etc. from CDN</li>
                        <li><strong>Batch requests</strong> - Combine multiple small requests into one</li>
                        <li><strong>Debounce search inputs</strong> - Wait for users to stop typing</li>
                        <li><strong>Use HTTP/2 Server Push</strong> - Push resources before they're requested</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Summary -->
            <section id="section11" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>REST APIs use HTTP methods</strong> - GET, POST, PUT, PATCH, DELETE for different operations</li>
                        <li><strong>CRUD is fundamental</strong> - Create, Read, Update, Delete are the building blocks of most apps</li>
                        <li><strong>Service layers organize API calls</strong> - Centralized, maintainable, testable architecture</li>
                        <li><strong>Authentication uses JWT tokens</strong> - Store tokens, send with requests, handle expiration</li>
                        <li><strong>Error handling is critical</strong> - Handle network errors, timeouts, 4xx, 5xx, validation errors</li>
                        <li><strong>TypeScript makes APIs safer</strong> - Type requests, responses, errors, and use discriminated unions</li>
                        <li><strong>Environment variables configure apps</strong> - Use .env files for API URLs and settings</li>
                        <li><strong>API clients centralize logic</strong> - Interceptors, error handling, and auth in one place</li>
                        <li><strong>Retry and resilience matter</strong> - Implement retry logic with exponential backoff</li>
                        <li><strong>Security is non-negotiable</strong> - HTTPS, token storage, CORS, validation, and more</li>
                    </ul>
                </div>
                
                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://restfulapi.net/" target="_blank">RESTful API Design Guidelines</a></li>
                    <li><a href="https://jwt.io/" target="_blank">JWT.io - JSON Web Token Introduction</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">MDN: Fetch API</a></li>
                    <li><a href="https://tanstack.com/query/latest" target="_blank">TanStack Query (React Query)</a></li>
                    <li><a href="https://github.com/colinhacks/zod" target="_blank">Zod - Runtime Validation</a></li>
                    <li><a href="https://www.oauth.com/" target="_blank">OAuth 2.0 - Advanced Authentication</a></li>
                    <li><a href="https://owasp.org/www-project-web-security-testing-guide/" target="_blank">OWASP Web Security</a></li>
                </ul>
                
                <h3>üöÄ What's Next?</h3>
                <p>Congratulations! You've mastered API integration in React with TypeScript. You now know how to build production-ready applications that communicate with backend servers securely and efficiently.</p>
                
                <p>Next, we'll work on the <strong>Module 4 Project: Weather Dashboard</strong>, where you'll apply everything:</p>
                <ul>
                    <li>Build a complete weather app with city search</li>
                    <li>Integrate with a real weather API</li>
                    <li>Implement caching and error handling</li>
                    <li>Add authentication and user preferences</li>
                    <li>Deploy to production with environment variables</li>
                </ul>

                <!-- Quiz Section -->
                <div class="card quiz-container">
                    <h3>üéØ Quick Quiz</h3>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> Which HTTP method should you use to partially update a resource?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="PUT replaces the entire resource">
                                A) PUT
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! PATCH is designed for partial updates where you only send the fields that changed.">
                                B) PATCH
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="POST is for creating new resources">
                                C) POST
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="GET is for reading data">
                                D) GET
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> Where should API calls be organized in a React application?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="This leads to duplication and maintenance issues">
                                A) Directly in components
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! A service layer centralizes API calls, making them reusable, testable, and maintainable.">
                                B) In a service layer
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Redux is for state management, not API calls">
                                C) In Redux actions
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="The App component shouldn't handle all API logic">
                                D) In the App component
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> How should JWT tokens be stored in a React SPA?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Component state is lost on refresh">
                                A) In component state
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! localStorage persists tokens across page reloads and is the standard approach for SPAs.">
                                B) In localStorage
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Cookies are better for SSR apps">
                                C) In httpOnly cookies
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="sessionStorage is cleared when the tab closes">
                                D) In sessionStorage
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 4:</strong> What's the correct way to handle a 401 Unauthorized error?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Retrying won't help if the token is invalid">
                                A) Retry the request immediately
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Try to refresh the token, and if that fails, redirect to login as the session has expired.">
                                B) Try to refresh the token, then redirect to login if it fails
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="This provides poor user experience">
                                C) Show an error and do nothing
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="401 means unauthorized, not a server error">
                                D) Show a server error message
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 5:</strong> Why use environment variables for API URLs?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Speed isn't affected by environment variables">
                                A) They make the app faster
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Environment variables let you use different URLs for dev/staging/production without changing code.">
                                B) They allow different URLs for different environments
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Environment variables don't provide security for client code">
                                C) They keep URLs secret
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="TypeScript doesn't require environment variables">
                                D) They're required by TypeScript
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem; margin-top: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've completed Lesson 4.5: Working with APIs! You now have the skills to build production-ready applications that communicate with backend servers securely and efficiently.</p>
                    <p style="color: white; margin-top: 1rem;">You've learned professional API integration patterns used by companies worldwide. Time to build something amazing! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_4_4_advanced_data_fetching.html" class="prev-lesson">‚Üê Previous: Advanced Data Fetching</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="module_project_4_weather_dashboard.html" class="next-lesson">Next: Module Project - Weather Dashboard ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
