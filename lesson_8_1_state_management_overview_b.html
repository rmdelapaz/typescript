            <!-- Section 5: State Management Solutions Landscape -->
            <section id="section5" class="lesson-section">
                <h2>üó∫Ô∏è State Management Solutions Landscape</h2>
                
                <p>The React ecosystem offers numerous state management solutions, each designed to solve different problems. Let's explore the landscape and understand where each tool fits.</p>

                <h3>The State Management Spectrum</h3>

                <div class="mermaid">
                    graph LR
                    A[Built-in React] --> B[Context + Hooks]
                    B --> C[Lightweight Libraries]
                    C --> D[Full-Featured Libraries]
                    D --> E[Server State Libraries]
                    
                    A1[useState<br/>useReducer] -.-> A
                    B1[Context API<br/>Custom Hooks] -.-> B
                    C1[Zustand<br/>Jotai<br/>Valtio] -.-> C
                    D1[Redux Toolkit<br/>MobX<br/>XState] -.-> D
                    E1[React Query<br/>SWR<br/>Apollo] -.-> E
                    
                    style A fill:#667eea,color:#fff
                    style E fill:#4CAF50,color:#fff
                </div>

                <h3>Category 1: Built-in React Solutions</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üì¶ What's Included</h4>
                    <ul style="color: white;">
                        <li><strong>useState:</strong> Local state management</li>
                        <li><strong>useReducer:</strong> Complex local state with actions</li>
                        <li><strong>useContext:</strong> Sharing state without prop drilling</li>
                        <li><strong>useRef:</strong> Mutable values that don't trigger re-renders</li>
                    </ul>
                </div>

                <p><strong>Best for:</strong> Small to medium apps, localized state, simple sharing between components</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Zero dependencies‚Äîbuilt into React</li>
                    <li>‚úÖ Simple API, easy to learn</li>
                    <li>‚úÖ Great TypeScript support</li>
                    <li>‚úÖ Perfect for local component state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Context can cause unnecessary re-renders</li>
                    <li>‚ùå No built-in devtools</li>
                    <li>‚ùå Boilerplate increases with app complexity</li>
                    <li>‚ùå No built-in async handling or middleware</li>
                </ul>

                <h3>Category 2: Lightweight State Libraries</h3>

                <p>These libraries provide global state with minimal boilerplate and excellent performance:</p>

                <h4>Zustand</h4>
                <pre><code class="language-typescript">// Simple, hook-based global state
import create from 'zustand';

interface BearStore {
  bears: number;
  addBear: () => void;
  removeAllBears: () => void;
}

const useStore = create&lt;BearStore&gt;((set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  removeAllBears: () => set({ bears: 0 })
}));

function BearCounter() {
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears} bears&lt;/h1&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Most React applications, simple to moderate state complexity</p>

                <h4>Jotai</h4>
                <pre><code class="language-typescript">// Atomic state management
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(countAtom);
  return (
    &lt;div&gt;
      {count}
      &lt;button onClick={() => setCount(c => c + 1)}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Bottom-up state architecture, derived state, atomic updates</p>

                <h4>Valtio</h4>
                <pre><code class="language-typescript">// Proxy-based state
import { proxy, useSnapshot } from 'valtio';

const state = proxy({ count: 0 });

function Counter() {
  const snap = useSnapshot(state);
  return (
    &lt;div&gt;
      {snap.count}
      &lt;button onClick={() => state.count++}&gt;+1&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Developers who prefer mutable syntax, quick prototyping</p>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Bundle Size</th>
                            <th>Learning Curve</th>
                            <th>Best Feature</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Zustand</strong></td>
                            <td>~1KB</td>
                            <td>Very Low</td>
                            <td>Simplicity + power</td>
                        </tr>
                        <tr>
                            <td><strong>Jotai</strong></td>
                            <td>~3KB</td>
                            <td>Low</td>
                            <td>Atomic architecture</td>
                        </tr>
                        <tr>
                            <td><strong>Valtio</strong></td>
                            <td>~3KB</td>
                            <td>Very Low</td>
                            <td>Mutable syntax</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Category 3: Full-Featured State Libraries</h3>

                <h4>Redux Toolkit (RTK)</h4>

                <p>The modern, official way to write Redux code:</p>

                <pre><code class="language-typescript">// Redux Toolkit slice
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1; // Immer allows "mutation"
    },
    incrementByAmount: (state, action: PayloadAction&lt;number&gt;) => {
      state.value += action.payload;
    }
  }
});

export const { increment, incrementByAmount } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>

                <p><strong>Best for:</strong> Large enterprise apps, teams familiar with Redux, complex state logic</p>

                <p><strong>Pros:</strong></p>
                <ul>
                    <li>‚úÖ Mature ecosystem with lots of resources</li>
                    <li>‚úÖ Excellent DevTools (Redux DevTools)</li>
                    <li>‚úÖ Predictable state updates</li>
                    <li>‚úÖ Great for time-travel debugging</li>
                    <li>‚úÖ RTK Query for server state</li>
                </ul>

                <p><strong>Cons:</strong></p>
                <ul>
                    <li>‚ùå Steeper learning curve</li>
                    <li>‚ùå More boilerplate than alternatives</li>
                    <li>‚ùå Larger bundle size (~20KB)</li>
                </ul>

                <h4>MobX</h4>

                <p>Observable-based reactive state management:</p>

                <pre><code class="language-typescript">// MobX store
import { makeAutoObservable } from 'mobx';
import { observer } from 'mobx-react-lite';

class TodoStore {
  todos: string[] = [];

  constructor() {
    makeAutoObservable(this);
  }

  addTodo(todo: string) {
    this.todos.push(todo);
  }
}

const todoStore = new TodoStore();

const TodoList = observer(() => {
  return (
    &lt;ul&gt;
      {todoStore.todos.map((todo, i) => (
        &lt;li key={i}&gt;{todo}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
});</code></pre>

                <p><strong>Best for:</strong> Complex domain models, developers familiar with OOP patterns</p>

                <h4>XState</h4>

                <p>State machine-based state management:</p>

                <pre><code class="language-typescript">// XState machine
import { createMachine } from 'xstate';
import { useMachine } from '@xstate/react';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

function Toggle() {
  const [state, send] = useMachine(toggleMachine);
  
  return (
    &lt;button onClick={() => send('TOGGLE')}&gt;
      {state.value === 'active' ? 'ON' : 'OFF'}
    &lt;/button&gt;
  );
}</code></pre>

                <p><strong>Best for:</strong> Complex workflows, multi-step processes, state machines</p>

                <h3>Category 4: Server State Libraries</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üåü The Game Changer</h4>
                    <p>Server state libraries revolutionized React development by recognizing that <strong>server data is fundamentally different</strong> from client state and should be managed differently.</p>
                </div>

                <h4>React Query (TanStack Query)</h4>

                <pre><code class="language-typescript">// React Query hooks
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

function UserProfile({ userId }: { userId: number }) {
  // Automatic loading, error, caching, refetching
  const { data, isLoading, error } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetch(`/api/users/${userId}`).then(r => r.json())
  });

  const queryClient = useQueryClient();

  const updateMutation = useMutation({
    mutationFn: (updates: Partial&lt;User&gt;) => 
      fetch(`/api/users/${userId}`, {
        method: 'PATCH',
        body: JSON.stringify(updates)
      }),
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries(['user', userId]);
    }
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error!&lt;/div&gt;;

  return &lt;div&gt;{data.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Features:</strong></p>
                <ul>
                    <li>‚úÖ Automatic caching and background refetching</li>
                    <li>‚úÖ Request deduplication</li>
                    <li>‚úÖ Optimistic updates</li>
                    <li>‚úÖ Pagination and infinite scroll</li>
                    <li>‚úÖ Built-in loading and error states</li>
                    <li>‚úÖ DevTools for debugging</li>
                </ul>

                <h4>SWR (Stale-While-Revalidate)</h4>

                <pre><code class="language-typescript">// SWR - Similar to React Query, Vercel's solution
import useSWR from 'swr';

function Profile() {
  const { data, error, isLoading } = useSWR('/api/user', fetcher);

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Failed to load&lt;/div&gt;;
  return &lt;div&gt;Hello {data.name}!&lt;/div&gt;;
}</code></pre>

                <p><strong>Best for:</strong> Simpler API needs, Next.js projects</p>

                <h4>Apollo Client (GraphQL)</h4>

                <p>Specialized for GraphQL APIs:</p>

                <pre><code class="language-typescript">// Apollo Client for GraphQL
import { useQuery, gql } from '@apollo/client';

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return &lt;p&gt;Loading...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error!&lt;/p&gt;;

  return data.users.map((user: User) => (
    &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
  ));
}</code></pre>

                <p><strong>Best for:</strong> GraphQL APIs, apps with complex data requirements</p>

                <h3>Solution Selection Matrix</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Your Situation</th>
                            <th>Recommended Solution</th>
                            <th>Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Small app, local state</td>
                            <td>useState + Context</td>
                            <td>No dependencies needed</td>
                        </tr>
                        <tr>
                            <td>Medium app, some global state</td>
                            <td>Zustand or Jotai</td>
                            <td>Simple, performant, small bundle</td>
                        </tr>
                        <tr>
                            <td>Large enterprise app</td>
                            <td>Redux Toolkit</td>
                            <td>Mature, predictable, great DevTools</td>
                        </tr>
                        <tr>
                            <td>Lots of API data</td>
                            <td>React Query + Zustand</td>
                            <td>Separate concerns: server vs client state</td>
                        </tr>
                        <tr>
                            <td>Complex workflows</td>
                            <td>XState</td>
                            <td>State machines model workflows naturally</td>
                        </tr>
                        <tr>
                            <td>GraphQL API</td>
                            <td>Apollo Client</td>
                            <td>Purpose-built for GraphQL</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Modern Best Practice</h4>
                    <p><strong>Hybrid approach:</strong> Use React Query (or SWR) for server state + a lightweight library like Zustand for client state. This separation of concerns is becoming the industry standard.</p>
                </div>
            </section>

            <!-- Section 6: Comparing State Management Libraries -->
            <section id="section6" class="lesson-section">
                <h2>‚öñÔ∏è Comparing State Management Libraries</h2>
                
                <p>Let's dive deeper into how these libraries compare across key dimensions that matter for real-world development.</p>

                <h3>Comparison Dimensions</h3>

                <h4>1. Learning Curve</h4>

                <div class="mermaid">
                    graph LR
                    A[Easy] --> B[Moderate] --> C[Challenging]
                    
                    A1[Zustand<br/>Valtio<br/>SWR] -.-> A
                    B1[Jotai<br/>React Query<br/>Context API] -.-> B
                    C1[Redux Toolkit<br/>MobX<br/>XState] -.-> C
                    
                    style A fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <ul>
                    <li><strong>Easy:</strong> Can be productive within hours</li>
                    <li><strong>Moderate:</strong> Takes a day or two to grasp concepts</li>
                    <li><strong>Challenging:</strong> Requires dedicated learning time, often several days</li>
                </ul>

                <h4>2. Bundle Size Impact</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Minified + Gzipped</th>
                            <th>Impact Rating</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>~1KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>~3KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>~13KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê Small</td>
                        </tr>
                        <tr>
                            <td>SWR</td>
                            <td>~4KB</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Minimal</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>~20KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>~16KB</td>
                            <td>‚≠ê‚≠ê‚≠ê Moderate</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>~25KB</td>
                            <td>‚≠ê‚≠ê Larger</td>
                        </tr>
                    </tbody>
                </table>

                <h4>3. TypeScript Support</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Type Safety</th>
                            <th>Type Inference</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Written in TS, zero config</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Best-in-class TS support</td>
                        </tr>
                        <tr>
                            <td>React Query</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Generics work beautifully</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Excellent</td>
                            <td>Full inference</td>
                            <td>Atom types inferred</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Good</td>
                            <td>Some manual typing</td>
                            <td>Decorators can be tricky</td>
                        </tr>
                        <tr>
                            <td>XState</td>
                            <td>Good</td>
                            <td>Complex typing</td>
                            <td>State machine types are verbose</td>
                        </tr>
                    </tbody>
                </table>

                <h4>4. Developer Experience</h4>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Excellent DX</h4>
                    <p><strong>Zustand, React Query, Jotai</strong></p>
                    <ul>
                        <li>Minimal boilerplate</li>
                        <li>Intuitive APIs</li>
                        <li>Great documentation</li>
                        <li>Fast feedback loop</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è More Setup Required</h4>
                    <p><strong>Redux Toolkit, XState</strong></p>
                    <ul>
                        <li>More concepts to learn</li>
                        <li>More configuration needed</li>
                        <li>Steeper initial learning curve</li>
                        <li>But: Very powerful once mastered</li>
                    </ul>
                </div>

                <h4>5. Performance Characteristics</h4>

                <pre><code class="language-typescript">// Example: Zustand's selector optimization
function BearCounter() {
  // Only re-renders when bears count changes
  const bears = useStore(state => state.bears);
  return &lt;h1&gt;{bears}&lt;/h1&gt;;
}

function AddBearButton() {
  // Only re-renders when addBear function changes (never)
  const addBear = useStore(state => state.addBear);
  return &lt;button onClick={addBear}&gt;Add Bear&lt;/button&gt;;
}</code></pre>

                <table>
                    <thead>
                        <tr>
                            <th>Library</th>
                            <th>Re-render Optimization</th>
                            <th>Approach</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Zustand</td>
                            <td>Automatic with selectors</td>
                            <td>Fine-grained subscriptions</td>
                        </tr>
                        <tr>
                            <td>Jotai</td>
                            <td>Automatic</td>
                            <td>Atomic state updates</td>
                        </tr>
                        <tr>
                            <td>Valtio</td>
                            <td>Automatic</td>
                            <td>Proxy-based tracking</td>
                        </tr>
                        <tr>
                            <td>Redux Toolkit</td>
                            <td>Manual with reselect</td>
                            <td>Memoized selectors</td>
                        </tr>
                        <tr>
                            <td>Context API</td>
                            <td>Manual with memo</td>
                            <td>Context splitting</td>
                        </tr>
                        <tr>
                            <td>MobX</td>
                            <td>Automatic</td>
                            <td>Observable tracking</td>
                        </tr>
                    </tbody>
                </table>

                <h4>6. DevTools and Debugging</h4>

                <ul>
                    <li><strong>Redux Toolkit:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Industry-leading Redux DevTools with time travel</li>
                    <li><strong>React Query:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excellent dedicated DevTools for queries</li>
                    <li><strong>Zustand:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê Redux DevTools compatible</li>
                    <li><strong>MobX:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê MobX DevTools available</li>
                    <li><strong>Jotai:</strong> ‚≠ê‚≠ê‚≠ê React DevTools + debug utilities</li>
                    <li><strong>XState:</strong> ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Visual state machine inspector</li>
                    <li><strong>Context API:</strong> ‚≠ê‚≠ê React DevTools only</li>
                </ul>

                <h3>When to Choose Each Library</h3>

                <h4>Choose Zustand When:</h4>
                <ul>
                    <li>‚úÖ You want something simple and powerful</li>
                    <li>‚úÖ Bundle size matters</li>
                    <li>‚úÖ You like hook-based APIs</li>
                    <li>‚úÖ You want fine-grained performance control</li>
                    <li>‚úÖ You're building a new app</li>
                </ul>

                <h4>Choose Redux Toolkit When:</h4>
                <ul>
                    <li>‚úÖ You have a large, complex application</li>
                    <li>‚úÖ Multiple teams working on the same codebase</li>
                    <li>‚úÖ You need strict state update patterns</li>
                    <li>‚úÖ Time-travel debugging is valuable</li>
                    <li>‚úÖ Your team already knows Redux</li>
                </ul>

                <h4>Choose React Query When:</h4>
                <ul>
                    <li>‚úÖ Your app is heavily data-driven</li>
                    <li>‚úÖ You fetch a lot of data from APIs</li>
                    <li>‚úÖ You need caching and background refetching</li>
                    <li>‚úÖ You want automatic loading/error states</li>
                    <li>‚úÖ Always (as server state solution)!</li>
                </ul>

                <h4>Choose Jotai When:</h4>
                <ul>
                    <li>‚úÖ You like atomic state architecture</li>
                    <li>‚úÖ You need lots of derived state</li>
                    <li>‚úÖ Bottom-up state design appeals to you</li>
                    <li>‚úÖ You want built-in async atom support</li>
                </ul>

                <h4>Choose XState When:</h4>
                <ul>
                    <li>‚úÖ You have complex workflows or processes</li>
                    <li>‚úÖ State machines model your domain well</li>
                    <li>‚úÖ You need to visualize state transitions</li>
                    <li>‚úÖ You want impossible states to be impossible</li>
                </ul>

                <h4>Choose Context API When:</h4>
                <ul>
                    <li>‚úÖ You have 2-5 global values maximum</li>
                    <li>‚úÖ Updates are infrequent</li>
                    <li>‚úÖ You want zero dependencies</li>
                    <li>‚úÖ Values rarely change (theme, locale, auth)</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ The Winner?</h4>
                    <p style="color: white;">There isn't one! Each library excels in different scenarios. The "best" choice depends on your specific needs:</p>
                    <ul style="color: white;">
                        <li><strong>Most versatile:</strong> Zustand (client state) + React Query (server state)</li>
                        <li><strong>Enterprise standard:</strong> Redux Toolkit</li>
                        <li><strong>Simplest:</strong> Context API + useState</li>
                        <li><strong>Most innovative:</strong> Jotai, XState</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Architectural Patterns -->
            <section id="section7" class="lesson-section">
                <h2>üèõÔ∏è Architectural Patterns</h2>
                
                <p>Beyond choosing a library, how you organize your state and structure your application matters immensely. Let's explore proven architectural patterns.</p>

                <h3>Pattern 1: Feature-Based Organization</h3>

                <p>Organize code by feature rather than by file type:</p>

                <pre><code class="language-plaintext">src/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useAuth.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ authStore.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.types.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ cart/
‚îÇ       ‚îú‚îÄ‚îÄ components/
‚îÇ       ‚îú‚îÄ‚îÄ hooks/
‚îÇ       ‚îú‚îÄ‚îÄ store/
‚îÇ       ‚îî‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îî‚îÄ‚îÄ App.tsx</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits</h4>
                    <ul>
                        <li>Feature code is colocated‚Äîeasy to find everything related</li>
                        <li>Can delete entire feature folder without hunting across directories</li>
                        <li>Clear boundaries between features</li>
                        <li>Teams can work on different features independently</li>
                    </ul>
                </div>

                <h3>Pattern 2: Separation of Client and Server State</h3>

                <div class="mermaid">
                    graph TB
                    A[Application State] --> B[Client State]
                    A --> C[Server State]
                    
                    B --> B1[UI State: Zustand/Redux]
                    B --> B2[Form State: React Hook Form]
                    B --> B3[URL State: Router]
                    
                    C --> C1[API Data: React Query]
                    C --> C2[Real-time: WebSocket + Query]
                    C --> C3[GraphQL: Apollo Client]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                </div>

                <p><strong>Client State:</strong> Managed by Zustand, Redux, Context</p>
                <ul>
                    <li>Theme preference</li>
                    <li>Sidebar open/closed</li>
                    <li>Current tab selection</li>
                    <li>Modal state</li>
                    <li>Filter selections (before applying)</li>
                </ul>

                <p><strong>Server State:</strong> Managed by React Query, SWR, Apollo</p>
                <ul>
                    <li>User profile data</li>
                    <li>Product lists</li>
                    <li>Search results</li>
                    <li>Dashboard metrics</li>
                    <li>Any data fetched from APIs</li>
                </ul>

                <pre><code class="language-typescript">// Example: Hybrid approach
// Client state: Zustand
const useUIStore = create&lt;UIStore&gt;((set) => ({
  sidebarOpen: true,
  theme: 'light',
  toggleSidebar: () => set(state => ({ sidebarOpen: !state.sidebarOpen })),
  setTheme: (theme) => set({ theme })
}));

// Server state: React Query
function ProductList() {
  const { sidebarOpen } = useUIStore(); // Client state
  
  const { data: products } = useQuery({ // Server state
    queryKey: ['products'],
    queryFn: fetchProducts
  });
  
  return (
    &lt;div className={sidebarOpen ? 'with-sidebar' : 'full-width'}&gt;
      {products?.map(p => &lt;ProductCard key={p.id} product={p} /&gt;)}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 3: Custom Hooks for Business Logic</h3>

                <p>Encapsulate complex logic in custom hooks:</p>

                <pre><code class="language-typescript">// Custom hook pattern
function useCart() {
  const { items, addItem, removeItem, clearCart } = useCartStore();
  const queryClient = useQueryClient();
  
  const addToCart = async (product: Product) => {
    // Business logic
    addItem(product);
    
    // Side effects
    toast.success('Added to cart');
    analytics.track('add_to_cart', { productId: product.id });
  };
  
  const checkout = useMutation({
    mutationFn: async () => {
      const response = await fetch('/api/checkout', {
        method: 'POST',
        body: JSON.stringify({ items })
      });
      return response.json();
    },
    onSuccess: () => {
      clearCart();
      queryClient.invalidateQueries(['orders']);
    }
  });
  
  const total = useMemo(() => 
    items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    [items]
  );
  
  return {
    items,
    total,
    addToCart,
    removeItem,
    clearCart,
    checkout
  };
}

// Components stay clean
function ProductCard({ product }: { product: Product }) {
  const { addToCart } = useCart();
  
  return (
    &lt;div&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;button onClick={() => addToCart(product)}&gt;Add to Cart&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Pattern 4: Domain-Driven Design</h3>

                <p>Structure state around your business domains:</p>

                <pre><code class="language-typescript">// Domain stores
// User domain
const useUserStore = create&lt;UserStore&gt;(/* ... */);

// Product domain
const useProductStore = create&lt;ProductStore&gt;(/* ... */);

// Order domain
const useOrderStore = create&lt;OrderStore&gt;(/* ... */);

// Each domain is independent
// Domains communicate via actions, not shared state</code></pre>

                <h3>Pattern 5: Normalized State</h3>

                <p>Store data in a normalized format to avoid duplication and keep it consistent:</p>

                <pre><code class="language-typescript">// ‚ùå Denormalized - duplication and inconsistency risk
interface DenormalizedState {
  posts: Array&lt;{
    id: string;
    title: string;
    author: {
      id: string;
      name: string;
      email: string;
    };
    comments: Array&lt;{
      id: string;
      text: string;
      author: {
        id: string;
        name: string;
        email: string;
      };
    }&gt;;
  }&gt;;
}

// ‚úÖ Normalized - single source of truth
interface NormalizedState {
  users: {
    byId: Record&lt;string, User&gt;;
    allIds: string[];
  };
  posts: {
    byId: Record&lt;string, Post&gt;; // Just has authorId
    allIds: string[];
  };
  comments: {
    byId: Record&lt;string, Comment&gt;; // Just has authorId, postId
    allIds: string[];
  };
}

// Selectors can reconstruct the full object
const selectPostWithAuthor = (state: State, postId: string) => {
  const post = state.posts.byId[postId];
  const author = state.users.byId[post.authorId];
  return { ...post, author };
};</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Normalize</h4>
                    <ul>
                        <li><strong>Do normalize:</strong> When data is shared across features, updated frequently, or duplicated</li>
                        <li><strong>Don't normalize:</strong> Server state (React Query handles it), deeply nested read-only data, or simple apps</li>
                    </ul>
                </div>

                <h3>Pattern 6: Middleware and Side Effects</h3>

                <p>Handle side effects systematically:</p>

                <pre><code class="language-typescript">// Zustand middleware example
const useStore = create&lt;Store&gt;()(
  devtools(
    persist(
      immer((set) => ({
        // Store definition
        count: 0,
        increment: () => set(state => { state.count += 1; }),
        
        // Side effect
        incrementWithLog: () => set(state => {
          console.log('Before:', state.count);
          state.count += 1;
          console.log('After:', state.count);
          
          // Analytics
          analytics.track('count_incremented', { value: state.count });
        })
      })),
      {
        name: 'my-store',
        storage: createJSONStorage(() => localStorage)
      }
    )
  )
);</code></pre>

                <h3>Pattern 7: Optimistic Updates</h3>

                <p>Update UI immediately, rollback if server fails:</p>

                <pre><code class="language-typescript">// Optimistic update with React Query
const mutation = useMutation({
  mutationFn: updateTodo,
  onMutate: async (newTodo) => {
    // Cancel outgoing refetches
    await queryClient.cancelQueries(['todos']);
    
    // Snapshot previous value
    const previousTodos = queryClient.getQueryData(['todos']);
    
    // Optimistically update
    queryClient.setQueryData(['todos'], (old: Todo[]) => 
      [...old, newTodo]
    );
    
    // Return context with snapshot
    return { previousTodos };
  },
  onError: (err, newTodo, context) => {
    // Rollback on error
    queryClient.setQueryData(['todos'], context?.previousTodos);
  },
  onSettled: () => {
    // Always refetch after error or success
    queryClient.invalidateQueries(['todos']);
  }
});</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Architecture Principles</h4>
                    <ul style="color: white;">
                        <li><strong>Colocation:</strong> Keep related code together</li>
                        <li><strong>Separation:</strong> Separate client and server state</li>
                        <li><strong>Encapsulation:</strong> Hide complexity in custom hooks</li>
                        <li><strong>Single Responsibility:</strong> Each store/slice does one thing</li>
                        <li><strong>Testability:</strong> Make state logic easy to test in isolation</li>
                    </ul>
                </div>
            </section>
