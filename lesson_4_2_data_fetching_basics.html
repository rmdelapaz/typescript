<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master data fetching in React with TypeScript - Learn to use the Fetch API, handle loading and error states, type API responses, and build robust data-fetching components.">
    <meta name="author" content="PracticalAce">
    <title>Data Fetching Basics - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module4">Module 4: Side Effects and Data Fetching</a></li>
            <li aria-current="page">Lesson 4.2: Data Fetching Basics</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üåê Data Fetching Basics</h1>
                <p class="lead">Most React applications need to fetch data from APIs. Whether you're building a weather app, a social media feed, or an e-commerce site, you'll need to request data from servers and display it to users. In this lesson, you'll learn how to fetch data using the Fetch API, handle loading and error states gracefully, type your API responses with TypeScript, and build production-ready data-fetching components. By the end, you'll be able to integrate any REST API into your React applications! üöÄ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the Fetch API and how it works</li>
                        <li>Fetch data from REST APIs using useEffect</li>
                        <li>Handle loading states while data fetches</li>
                        <li>Handle and display error states properly</li>
                        <li>Type API responses with TypeScript interfaces</li>
                        <li>Cancel fetch requests to prevent memory leaks</li>
                        <li>Use async/await syntax in effects</li>
                        <li>Build reusable data-fetching components</li>
                        <li>Implement common patterns (refetch, pagination)</li>
                        <li>Debug network requests effectively</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Build a user profile viewer and a posts list with real API data</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding the Fetch API</a></li>
                        <li><a href="#section2" class="toc-link">Fetch with useEffect</a></li>
                        <li><a href="#section3" class="toc-link">Loading States</a></li>
                        <li><a href="#section4" class="toc-link">Error Handling</a></li>
                        <li><a href="#section5" class="toc-link">Typing API Responses</a></li>
                        <li><a href="#section6" class="toc-link">Async/Await in Effects</a></li>
                        <li><a href="#section7" class="toc-link">Canceling Requests</a></li>
                        <li><a href="#section8" class="toc-link">Complete Data Fetching Pattern</a></li>
                        <li><a href="#section9" class="toc-link">Common Patterns</a></li>
                        <li><a href="#section10" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section11" class="toc-link">Best Practices</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding the Fetch API -->
            <section id="section1" class="lesson-section">
                <h2>üåç Understanding the Fetch API</h2>
                <p>Before we integrate fetch into React, let's understand how the Fetch API works in JavaScript.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Fetch API:</strong> A modern JavaScript interface for making HTTP requests to servers. It returns Promises and provides a cleaner alternative to XMLHttpRequest.</p>
                </div>

                <h3>Basic Fetch Syntax</h3>
                <div class="card">
                    <h4>Simple GET Request</h4>
                    <pre><code class="language-typescript">// Basic fetch - returns a Promise
fetch('https://api.example.com/data')
    .then(response => response.json()) // Parse JSON
    .then(data => console.log(data))   // Use data
    .catch(error => console.error(error)); // Handle errors

// With async/await (cleaner)
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.error(error);
    }
}</code></pre>
                </div>

                <h3>How Fetch Works</h3>
                <div class="card">
                    <div class="mermaid">
sequenceDiagram
    participant C as üíª Your Code
    participant F as üåê Fetch API
    participant S as üñ•Ô∏è Server
    participant U as üë§ User
    
    C->>F: fetch(url)
    F->>S: HTTP Request
    S->>F: HTTP Response
    F->>C: Response Object
    C->>C: response.json()
    C->>C: Parse JSON
    C->>U: Display Data
                    </div>
                </div>

                <!-- Interactive Fetch Demo -->
                <h3>üéÆ Interactive: Watch a Fetch Request</h3>
                <div class="card">
                    <p>Click the button to simulate a fetch request and watch the data flow:</p>
                    <div id="fetch-demo" style="padding: 1rem;">
                        <div style="text-align: center; margin-bottom: 1rem;">
                            <button id="fetch-start" style="padding: 0.75rem 2rem; font-size: 1rem; cursor: pointer; background: #667eea; color: white; border: none; border-radius: 4px;">üöÄ Make Fetch Request</button>
                            <button id="fetch-reset" style="padding: 0.75rem 1rem; font-size: 1rem; cursor: pointer; background: #9e9e9e; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;">Reset</button>
                        </div>
                        <canvas id="fetch-canvas" width="700" height="200" style="width: 100%; max-width: 700px; border: 1px solid #ddd; border-radius: 8px; display: block; margin: 0 auto;"></canvas>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-top: 1rem;">
                            <div style="padding: 0.75rem; background: #f5f5f5; border-radius: 4px;">
                                <strong>Request:</strong>
                                <pre id="fetch-request" style="margin: 0.5rem 0 0 0; font-size: 0.8rem; overflow-x: auto;">GET /users/1</pre>
                            </div>
                            <div style="padding: 0.75rem; background: #e3f2fd; border-radius: 4px;">
                                <strong>Response:</strong>
                                <pre id="fetch-response" style="margin: 0.5rem 0 0 0; font-size: 0.8rem; overflow-x: auto;">Waiting...</pre>
                            </div>
                        </div>
                    </div>
                </div>
                <script>
                (function() {
                    const canvas = document.getElementById('fetch-canvas');
                    const ctx = canvas.getContext('2d');
                    const responseDiv = document.getElementById('fetch-response');
                    let animationStep = 0;
                    let animationId = null;
                    
                    const stages = [
                        { label: 'Code', x: 80, icon: 'üíª', color: '#667eea' },
                        { label: 'Fetch API', x: 280, icon: 'üåê', color: '#2196f3' },
                        { label: 'Server', x: 480, icon: 'üñ•Ô∏è', color: '#4caf50' },
                        { label: 'User', x: 620, icon: 'üë§', color: '#ff9800' }
                    ];
                    
                    function drawCanvas() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw stages
                        stages.forEach((stage, i) => {
                            ctx.beginPath();
                            ctx.arc(stage.x, 60, 30, 0, Math.PI * 2);
                            ctx.fillStyle = stage.color + '33';
                            ctx.fill();
                            ctx.strokeStyle = stage.color;
                            ctx.lineWidth = 3;
                            ctx.stroke();
                            
                            ctx.font = '24px system-ui';
                            ctx.textAlign = 'center';
                            ctx.fillText(stage.icon, stage.x, 68);
                            
                            ctx.font = 'bold 12px system-ui';
                            ctx.fillStyle = '#333';
                            ctx.fillText(stage.label, stage.x, 110);
                        });
                        
                        // Draw arrows based on animation step
                        const arrowY = 60;
                        ctx.lineWidth = 2;
                        
                        if (animationStep >= 1) {
                            // Request arrow: Code -> Fetch
                            drawArrow(120, arrowY, 240, arrowY, '#667eea', 'fetch(url)');
                        }
                        if (animationStep >= 2) {
                            // Request arrow: Fetch -> Server
                            drawArrow(320, arrowY, 440, arrowY, '#2196f3', 'HTTP GET');
                        }
                        if (animationStep >= 3) {
                            // Response arrow: Server -> Fetch
                            drawArrow(440, arrowY + 30, 320, arrowY + 30, '#4caf50', 'JSON Data');
                        }
                        if (animationStep >= 4) {
                            // Response arrow: Fetch -> Code
                            drawArrow(240, arrowY + 30, 120, arrowY + 30, '#2196f3', 'Response');
                        }
                        if (animationStep >= 5) {
                            // Display: Code -> User
                            drawArrow(520, arrowY, 590, arrowY, '#ff9800', 'Display');
                        }
                        
                        // Status text
                        ctx.font = '14px system-ui';
                        ctx.fillStyle = '#666';
                        ctx.textAlign = 'center';
                        const statusMessages = [
                            'Ready to fetch',
                            'Calling fetch()...',
                            'Sending HTTP request...',
                            'Server responding with data...',
                            'Processing response...',
                            'Data displayed to user! ‚úÖ'
                        ];
                        ctx.fillText(statusMessages[animationStep] || '', canvas.width / 2, 180);
                    }
                    
                    function drawArrow(fromX, fromY, toX, toY, color, label) {
                        ctx.strokeStyle = color;
                        ctx.fillStyle = color;
                        
                        // Line
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();
                        
                        // Arrowhead
                        const angle = Math.atan2(toY - fromY, toX - fromX);
                        ctx.beginPath();
                        ctx.moveTo(toX, toY);
                        ctx.lineTo(toX - 10 * Math.cos(angle - Math.PI / 6), toY - 10 * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(toX - 10 * Math.cos(angle + Math.PI / 6), toY - 10 * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fill();
                        
                        // Label
                        ctx.font = '10px system-ui';
                        ctx.textAlign = 'center';
                        const midX = (fromX + toX) / 2;
                        const midY = (fromY + toY) / 2 - 8;
                        ctx.fillText(label, midX, midY);
                    }
                    
                    function animate() {
                        if (animationStep <= 5) {
                            drawCanvas();
                            
                            if (animationStep === 3) {
                                responseDiv.textContent = '{ "id": 1, "name": "John" }';
                            }
                            if (animationStep === 5) {
                                responseDiv.innerHTML = '<span style="color:#4caf50;">‚úÖ { "id": 1, "name": "John" }</span>';
                            }
                            
                            animationStep++;
                            animationId = setTimeout(animate, 800);
                        }
                    }
                    
                    document.getElementById('fetch-start').addEventListener('click', () => {
                        if (animationId) clearTimeout(animationId);
                        animationStep = 0;
                        responseDiv.textContent = 'Waiting...';
                        animate();
                    });
                    
                    document.getElementById('fetch-reset').addEventListener('click', () => {
                        if (animationId) clearTimeout(animationId);
                        animationStep = 0;
                        responseDiv.textContent = 'Waiting...';
                        drawCanvas();
                    });
                    
                    drawCanvas();
                })();
                </script>

                <h3>The Response Object</h3>
                <div class="card">
                    <h4>Understanding the Response</h4>
                    <pre><code class="language-typescript">const response = await fetch('https://api.example.com/data');

// Response properties
console.log(response.ok);        // true if status 200-299
console.log(response.status);    // HTTP status code (200, 404, etc.)
console.log(response.statusText); // Status text ("OK", "Not Found")
console.log(response.headers);   // Response headers

// Getting data from response
const json = await response.json();        // Parse as JSON
const text = await response.text();        // Get as text
const blob = await response.blob();        // Get as binary data
const formData = await response.formData(); // Get as form data</code></pre>
                </div>

                <h3>HTTP Methods</h3>
                <div class="card">
                    <h4>Different Request Types</h4>
                    <pre><code class="language-typescript">// GET (default) - Retrieve data
fetch('https://api.example.com/users');

// POST - Create data
fetch('https://api.example.com/users', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ name: 'Alice', email: 'alice@example.com' })
});

// PUT - Update data (replace entire resource)
fetch('https://api.example.com/users/1', {
    method: 'PUT',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ name: 'Alice Smith', email: 'alice@example.com' })
});

// PATCH - Update data (modify specific fields)
fetch('https://api.example.com/users/1', {
    method: 'PATCH',
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({ name: 'Alice Smith' })
});

// DELETE - Remove data
fetch('https://api.example.com/users/1', {
    method: 'DELETE'
});</code></pre>
                </div>

                <h3>Request Options</h3>
                <div class="card">
                    <h4>Configuring Fetch Requests</h4>
                    <pre><code class="language-typescript">fetch('https://api.example.com/data', {
    method: 'GET',              // HTTP method
    headers: {                  // Request headers
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
    },
    body: JSON.stringify(data), // Request body (for POST/PUT/PATCH)
    mode: 'cors',               // CORS mode
    credentials: 'include',     // Send cookies
    cache: 'no-cache',          // Cache mode
    redirect: 'follow',         // Redirect behavior
    signal: abortController.signal // For cancellation
});</code></pre>
                </div>

                <h3>Public APIs for Practice</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Free APIs to Use</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>API</th>
                                <th>URL</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>JSONPlaceholder</strong></td>
                                <td>jsonplaceholder.typicode.com</td>
                                <td>Fake REST API for testing</td>
                            </tr>
                            <tr>
                                <td><strong>Pok√©API</strong></td>
                                <td>pokeapi.co</td>
                                <td>Pok√©mon data</td>
                            </tr>
                            <tr>
                                <td><strong>OpenWeather</strong></td>
                                <td>openweathermap.org</td>
                                <td>Weather data (API key required)</td>
                            </tr>
                            <tr>
                                <td><strong>Dog API</strong></td>
                                <td>dog.ceo/dog-api</td>
                                <td>Random dog images</td>
                            </tr>
                            <tr>
                                <td><strong>Rick and Morty</strong></td>
                                <td>rickandmortyapi.com</td>
                                <td>TV show data</td>
                            </tr>
                        </tbody>
                    </table>
                    <p>We'll use JSONPlaceholder for examples - it's perfect for learning!</p>
                </div>
            </section>

            <!-- Section 2: Fetch with useEffect -->
            <section id="section2" class="lesson-section">
                <h2>‚ö° Fetch with useEffect</h2>
                <p>Now let's integrate fetch into React components using useEffect. This is where data fetching happens in React!</p>

                <h3>Basic Pattern</h3>
                <div class="card">
                    <h4>Fetching Data on Mount</h4>
                    <pre><code class="language-typescript">import { useState, useEffect } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
}

const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    
    useEffect(() => {
        // Fetch user data when component mounts
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => setUser(data));
    }, []); // Empty array = run once on mount
    
    if (!user) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Why useEffect?</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why Not Fetch During Render?</h4>
                    <pre><code class="language-typescript">// ‚ùå WRONG: Fetching during render
const BadComponent: React.FC = () => {
    const [data, setData] = useState(null);
    
    // This runs on EVERY render!
    fetch('/api/data')
        .then(res => res.json())
        .then(setData); // Causes re-render
    // Re-render causes fetch again... infinite loop! üí•
    
    return &lt;div&gt;{data}&lt;/div&gt;;
};

// ‚úÖ CORRECT: Fetching in useEffect
const GoodComponent: React.FC = () => {
    const [data, setData] = useState(null);
    
    useEffect(() => {
        fetch('/api/data')
            .then(res => res.json())
            .then(setData);
    }, []); // Runs once on mount
    
    return &lt;div&gt;{data}&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>Fetching Based on Props</h3>
                <div class="card">
                    <h4>Re-fetch When Data Changes</h4>
                    <pre><code class="language-typescript">interface UserProfileProps {
    userId: number;
}

const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    
    useEffect(() => {
        // Fetch different user when userId changes
        fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
            .then(response => response.json())
            .then(data => setUser(data));
    }, [userId]); // Re-run when userId changes
    
    if (!user) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};

// Usage
&lt;UserProfile userId={1} /&gt; // Fetches user 1
&lt;UserProfile userId={2} /&gt; // Fetches user 2</code></pre>
                </div>

                <h3>Multiple Fetches</h3>
                <div class="card">
                    <h4>Fetching Multiple Resources</h4>
                    <pre><code class="language-typescript">const Dashboard: React.FC = () => {
    const [user, setUser] = useState(null);
    const [posts, setPosts] = useState([]);
    const [todos, setTodos] = useState([]);
    
    useEffect(() => {
        // Fetch user
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(res => res.json())
            .then(setUser);
        
        // Fetch posts
        fetch('https://jsonplaceholder.typicode.com/posts?userId=1')
            .then(res => res.json())
            .then(setPosts);
        
        // Fetch todos
        fetch('https://jsonplaceholder.typicode.com/todos?userId=1')
            .then(res => res.json())
            .then(setTodos);
    }, []);
    
    return (
        &lt;div&gt;
            &lt;h1&gt;Dashboard&lt;/h1&gt;
            {/* Display data */}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Sequential Fetches</h3>
                <div class="card">
                    <h4>Fetching Data That Depends on Other Data</h4>
                    <pre><code class="language-typescript">const UserWithPosts: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState(null);
    const [posts, setPosts] = useState([]);
    
    // First effect: Fetch user
    useEffect(() => {
        fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
            .then(res => res.json())
            .then(setUser);
    }, [userId]);
    
    // Second effect: Fetch posts after we have user
    useEffect(() => {
        if (!user) return; // Wait for user to load
        
        fetch(`https://jsonplaceholder.typicode.com/posts?userId=${user.id}`)
            .then(res => res.json())
            .then(setPosts);
    }, [user]); // Run when user changes
    
    if (!user) return &lt;div&gt;Loading user...&lt;/div&gt;;
    if (posts.length === 0) return &lt;div&gt;Loading posts...&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}'s Posts&lt;/h2&gt;
            {posts.map(post => (
                &lt;article key={post.id}&gt;
                    &lt;h3&gt;{post.title}&lt;/h3&gt;
                    &lt;p&gt;{post.body}&lt;/p&gt;
                &lt;/article&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                </div>
            </section>

            <!-- Section 3: Loading States -->
            <section id="section3" class="lesson-section">
                <h2>‚è≥ Loading States</h2>
                <p>Good UX means showing users what's happening. Loading states tell users "we're working on it‚Äîplease wait!"</p>

                <h3>Basic Loading State</h3>
                <div class="card">
                    <h4>Simple Loading Indicator</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    
    useEffect(() => {
        setIsLoading(true); // Start loading
        
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => {
                setUser(data);
                setIsLoading(false); // Done loading
            });
    }, []);
    
    if (isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;p&gt;{user?.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Loading State Flow</h3>
                <div class="card">
                    <div class="mermaid">
stateDiagram-v2
    [*] --> Loading: Component Mounts
    Loading --> Success: Data Received
    Loading --> Error: Request Failed
    Success --> [*]
    Error --> [*]
                    </div>
                </div>

                <!-- Interactive Loading State Demo -->
                <h3>üéÆ Interactive: Loading State Machine</h3>
                <div class="card">
                    <p>Click buttons to simulate different fetch outcomes and see how states change:</p>
                    <div id="loading-demo" style="padding: 1rem;">
                        <div style="text-align: center; margin-bottom: 1rem;">
                            <button id="loading-fetch" style="padding: 0.5rem 1rem; cursor: pointer; background: #667eea; color: white; border: none; border-radius: 4px;">üöÄ Start Fetch</button>
                            <button id="loading-success" style="padding: 0.5rem 1rem; cursor: pointer; background: #4caf50; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;" disabled>‚úÖ Simulate Success</button>
                            <button id="loading-error" style="padding: 0.5rem 1rem; cursor: pointer; background: #f44336; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;" disabled>‚ùå Simulate Error</button>
                            <button id="loading-reset" style="padding: 0.5rem 1rem; cursor: pointer; background: #9e9e9e; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;">Reset</button>
                        </div>
                        <canvas id="loading-canvas" width="600" height="200" style="width: 100%; max-width: 600px; border: 1px solid #ddd; border-radius: 8px; display: block; margin: 0 auto;"></canvas>
                        <div id="loading-ui-preview" style="margin-top: 1rem; padding: 1rem; background: #f9f9f9; border-radius: 8px; text-align: center; min-height: 80px;">
                            <p style="color: #999;">Click "Start Fetch" to begin</p>
                        </div>
                        <div style="margin-top: 0.5rem; padding: 0.5rem; background: #263238; border-radius: 4px; font-family: monospace; font-size: 0.8rem; color: #aed581;">
                            <span>State: </span><span id="loading-state-code">{ isLoading: false, error: null, data: null }</span>
                        </div>
                    </div>
                </div>
                <script>
                (function() {
                    const canvas = document.getElementById('loading-canvas');
                    const ctx = canvas.getContext('2d');
                    const uiPreview = document.getElementById('loading-ui-preview');
                    const stateCode = document.getElementById('loading-state-code');
                    const fetchBtn = document.getElementById('loading-fetch');
                    const successBtn = document.getElementById('loading-success');
                    const errorBtn = document.getElementById('loading-error');
                    
                    let currentState = 'idle'; // idle, loading, success, error
                    
                    const states = {
                        idle: { x: 100, y: 100, color: '#9e9e9e', label: 'Idle' },
                        loading: { x: 300, y: 100, color: '#ff9800', label: 'Loading' },
                        success: { x: 500, y: 60, color: '#4caf50', label: 'Success' },
                        error: { x: 500, y: 140, color: '#f44336', label: 'Error' }
                    };
                    
                    function drawCanvas() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw arrows
                        ctx.strokeStyle = '#ccc';
                        ctx.lineWidth = 2;
                        
                        // Idle -> Loading
                        drawArrow(140, 100, 260, 100, currentState === 'loading' ? '#ff9800' : '#ccc');
                        ctx.font = '10px system-ui';
                        ctx.fillStyle = '#666';
                        ctx.textAlign = 'center';
                        ctx.fillText('fetch()', 200, 90);
                        
                        // Loading -> Success
                        drawArrow(340, 85, 460, 65, currentState === 'success' ? '#4caf50' : '#ccc');
                        ctx.fillText('data received', 400, 60);
                        
                        // Loading -> Error
                        drawArrow(340, 115, 460, 135, currentState === 'error' ? '#f44336' : '#ccc');
                        ctx.fillText('request failed', 400, 145);
                        
                        // Draw state circles
                        Object.entries(states).forEach(([key, state]) => {
                            const isActive = currentState === key;
                            
                            ctx.beginPath();
                            ctx.arc(state.x, state.y, isActive ? 35 : 30, 0, Math.PI * 2);
                            ctx.fillStyle = isActive ? state.color : state.color + '44';
                            ctx.fill();
                            ctx.strokeStyle = state.color;
                            ctx.lineWidth = isActive ? 4 : 2;
                            ctx.stroke();
                            
                            ctx.font = isActive ? 'bold 12px system-ui' : '12px system-ui';
                            ctx.fillStyle = isActive ? 'white' : '#333';
                            ctx.textAlign = 'center';
                            ctx.fillText(state.label, state.x, state.y + 4);
                        });
                    }
                    
                    function drawArrow(fromX, fromY, toX, toY, color) {
                        ctx.strokeStyle = color;
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.moveTo(fromX, fromY);
                        ctx.lineTo(toX, toY);
                        ctx.stroke();
                        
                        const angle = Math.atan2(toY - fromY, toX - fromX);
                        ctx.beginPath();
                        ctx.moveTo(toX, toY);
                        ctx.lineTo(toX - 8 * Math.cos(angle - Math.PI / 6), toY - 8 * Math.sin(angle - Math.PI / 6));
                        ctx.lineTo(toX - 8 * Math.cos(angle + Math.PI / 6), toY - 8 * Math.sin(angle + Math.PI / 6));
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    function updateUI() {
                        drawCanvas();
                        
                        switch (currentState) {
                            case 'idle':
                                uiPreview.innerHTML = '<p style="color: #999;">Click "Start Fetch" to begin</p>';
                                stateCode.textContent = '{ isLoading: false, error: null, data: null }';
                                fetchBtn.disabled = false;
                                successBtn.disabled = true;
                                errorBtn.disabled = true;
                                break;
                            case 'loading':
                                uiPreview.innerHTML = '<div style="display:inline-block;width:30px;height:30px;border:3px solid #667eea;border-top-color:transparent;border-radius:50%;animation:spin 1s linear infinite;"></div><p>Loading user data...</p><style>@keyframes spin{to{transform:rotate(360deg)}}</style>';
                                stateCode.textContent = '{ isLoading: true, error: null, data: null }';
                                fetchBtn.disabled = true;
                                successBtn.disabled = false;
                                errorBtn.disabled = false;
                                break;
                            case 'success':
                                uiPreview.innerHTML = '<div style="color:#4caf50;font-size:2rem;">‚úÖ</div><h4>John Doe</h4><p>john@example.com</p>';
                                stateCode.innerHTML = '{ isLoading: false, error: null, data: <span style="color:#4caf50;">{ name: "John Doe" }</span> }';
                                fetchBtn.disabled = true;
                                successBtn.disabled = true;
                                errorBtn.disabled = true;
                                break;
                            case 'error':
                                uiPreview.innerHTML = '<div style="color:#f44336;font-size:2rem;">‚ùå</div><h4 style="color:#f44336;">Error</h4><p>Failed to fetch user data</p><button onclick="document.getElementById(\'loading-reset\').click()" style="padding:0.5rem 1rem;cursor:pointer;">Retry</button>';
                                stateCode.innerHTML = '{ isLoading: false, error: <span style="color:#f44336;">"Failed to fetch"</span>, data: null }';
                                fetchBtn.disabled = true;
                                successBtn.disabled = true;
                                errorBtn.disabled = true;
                                break;
                        }
                    }
                    
                    fetchBtn.addEventListener('click', () => {
                        currentState = 'loading';
                        updateUI();
                    });
                    
                    successBtn.addEventListener('click', () => {
                        currentState = 'success';
                        updateUI();
                    });
                    
                    errorBtn.addEventListener('click', () => {
                        currentState = 'error';
                        updateUI();
                    });
                    
                    document.getElementById('loading-reset').addEventListener('click', () => {
                        currentState = 'idle';
                        updateUI();
                    });
                    
                    updateUI();
                })();
                </script>

                <h3>Better Loading UI</h3>
                <div class="card">
                    <h4>Spinner Component</h4>
                    <pre><code class="language-typescript">const LoadingSpinner: React.FC = () => (
    &lt;div className="loading-spinner"&gt;
        &lt;div className="spinner"&gt;&lt;/div&gt;
        &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/div&gt;
);

const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    
    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => {
                setUser(data);
                setIsLoading(false);
            });
    }, []);
    
    if (isLoading) {
        return &lt;LoadingSpinner /&gt;;
    }
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;p&gt;{user?.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Skeleton Screens</h3>
                <div class="card">
                    <h4>Show Content Structure While Loading</h4>
                    <pre><code class="language-typescript">const UserSkeleton: React.FC = () => (
    &lt;div className="user-skeleton"&gt;
        &lt;div className="skeleton skeleton-avatar"&gt;&lt;/div&gt;
        &lt;div className="skeleton skeleton-title"&gt;&lt;/div&gt;
        &lt;div className="skeleton skeleton-text"&gt;&lt;/div&gt;
        &lt;div className="skeleton skeleton-text"&gt;&lt;/div&gt;
    &lt;/div&gt;
);

// CSS for skeleton
/*
.skeleton {
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 4px;
}

@keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
}
*/</code></pre>
                </div>

                <h3>Inline Loading State</h3>
                <div class="card">
                    <h4>Show Loading Without Replacing Content</h4>
                    <pre><code class="language-typescript">const PostsList: React.FC = () => {
    const [posts, setPosts] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    
    const loadMore = () => {
        setIsLoading(true);
        
        fetch('https://jsonplaceholder.typicode.com/posts?_limit=10')
            .then(res => res.json())
            .then(newPosts => {
                setPosts([...posts, ...newPosts]);
                setIsLoading(false);
            });
    };
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Posts&lt;/h2&gt;
            {posts.map(post => (
                &lt;article key={post.id}&gt;
                    &lt;h3&gt;{post.title}&lt;/h3&gt;
                    &lt;p&gt;{post.body}&lt;/p&gt;
                &lt;/article&gt;
            ))}
            
            {/* Show button or loading spinner */}
            {isLoading ? (
                &lt;div&gt;Loading more...&lt;/div&gt;
            ) : (
                &lt;button onClick={loadMore}&gt;Load More&lt;/button&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Loading State Best Practices</h4>
                    <ul>
                        <li><strong>Always show loading state:</strong> Never leave users wondering</li>
                        <li><strong>Be specific:</strong> "Loading posts..." is better than "Loading..."</li>
                        <li><strong>Use skeletons for complex UI:</strong> Shows structure, feels faster</li>
                        <li><strong>Show progress if possible:</strong> Progress bars when applicable</li>
                        <li><strong>Keep it fast:</strong> If loading takes >3 seconds, explain why</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Error Handling -->
            <section id="section4" class="lesson-section">
                <h2>‚ùå Error Handling</h2>
                <p>Networks fail. APIs go down. Users lose connection. Proper error handling is essential for production apps!</p>

                <h3>Basic Error Handling</h3>
                <div class="card">
                    <h4>Catching Fetch Errors</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => {
                setUser(data);
                setIsLoading(false);
            })
            .catch(err => {
                setError(err.message);
                setIsLoading(false);
            });
    }, []);
    
    if (isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    }
    
    if (error) {
        return &lt;div&gt;Error: {error}&lt;/div&gt;;
    }
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;p&gt;{user?.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>HTTP Status Error Handling</h3>
                <div class="card">
                    <h4>Check Response Status</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
            .then(response => {
                // Check if response is OK (status 200-299)
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                setUser(data);
                setIsLoading(false);
            })
            .catch(err => {
                setError(err.message);
                setIsLoading(false);
            });
    }, [userId]);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}&lt;/h2&gt;
            &lt;p&gt;{user?.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Error Types</h3>
                <div class="card">
                    <h4>Different Error Scenarios</h4>
                    <pre><code class="language-typescript">const fetchWithErrorHandling = async (url: string) => {
    try {
        const response = await fetch(url);
        
        // Network error (offline, DNS failure, etc.)
        if (!response.ok) {
            // HTTP error status codes
            switch (response.status) {
                case 404:
                    throw new Error('Resource not found');
                case 401:
                    throw new Error('Unauthorized - please login');
                case 403:
                    throw new Error('Forbidden - no access');
                case 500:
                    throw new Error('Server error - try again later');
                default:
                    throw new Error(`Error: ${response.status}`);
            }
        }
        
        const data = await response.json();
        return data;
        
    } catch (error) {
        // Network failure (no internet, CORS, etc.)
        if (error instanceof TypeError) {
            throw new Error('Network error - check your connection');
        }
        
        // JSON parse error
        if (error instanceof SyntaxError) {
            throw new Error('Invalid response format');
        }
        
        // Re-throw other errors
        throw error;
    }
};</code></pre>
                </div>

                <h3>Better Error UI</h3>
                <div class="card">
                    <h4>User-Friendly Error Display</h4>
                    <pre><code class="language-typescript">interface ErrorDisplayProps {
    error: string;
    onRetry?: () => void;
}

const ErrorDisplay: React.FC&lt;ErrorDisplayProps&gt; = ({ error, onRetry }) => (
    &lt;div className="error-display"&gt;
        &lt;div className="error-icon"&gt;‚ùå&lt;/div&gt;
        &lt;h3&gt;Oops! Something went wrong&lt;/h3&gt;
        &lt;p&gt;{error}&lt;/p&gt;
        {onRetry && (
            &lt;button onClick={onRetry}&gt;Try Again&lt;/button&gt;
        )}
    &lt;/div&gt;
);

// Usage
const UserProfile: React.FC = () => {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    
    const fetchUser = () => {
        setIsLoading(true);
        setError(null);
        
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => {
                if (!response.ok) throw new Error('Failed to load user');
                return response.json();
            })
            .then(setUser)
            .catch(err => setError(err.message))
            .finally(() => setIsLoading(false));
    };
    
    useEffect(() => {
        fetchUser();
    }, []);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;ErrorDisplay error={error} onRetry={fetchUser} /&gt;;
    
    return &lt;div&gt;{user?.name}&lt;/div&gt;;
};</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Error Handling Best Practices</h4>
                    <ul>
                        <li><strong>Always handle errors:</strong> Never leave users with broken UI</li>
                        <li><strong>Check response.ok:</strong> Fetch doesn't throw on HTTP errors</li>
                        <li><strong>Provide context:</strong> Tell users what went wrong</li>
                        <li><strong>Offer recovery:</strong> Retry buttons, alternative actions</li>
                        <li><strong>Log errors:</strong> Send to error tracking service in production</li>
                        <li><strong>Don't expose technical details:</strong> "Server error" not "500 Internal"</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Typing API Responses -->
            <section id="section5" class="lesson-section">
                <h2>üìê Typing API Responses</h2>
                <p>TypeScript makes APIs safer and easier to work with. Let's learn how to properly type our API responses!</p>

                <h3>Defining Response Types</h3>
                <div class="card">
                    <h4>Create Interfaces for API Data</h4>
                    <pre><code class="language-typescript">// types/user.ts
export interface User {
    id: number;
    name: string;
    username: string;
    email: string;
    address: Address;
    phone: string;
    website: string;
    company: Company;
}

export interface Address {
    street: string;
    suite: string;
    city: string;
    zipcode: string;
    geo: Geo;
}

export interface Geo {
    lat: string;
    lng: string;
}

export interface Company {
    name: string;
    catchPhrase: string;
    bs: string;
}

// types/post.ts
export interface Post {
    userId: number;
    id: number;
    title: string;
    body: string;
}

// types/comment.ts
export interface Comment {
    postId: number;
    id: number;
    name: string;
    email: string;
    body: string;
}</code></pre>
                </div>

                <h3>Using Types with useState</h3>
                <div class="card">
                    <h4>Type State Correctly</h4>
                    <pre><code class="language-typescript">import { useState, useEffect } from 'react';
import { User } from './types/user';

const UserProfile: React.FC = () => {
    // Type as User | null (could be null while loading)
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState&lt;boolean&gt;(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then((data: User) => { // Type the data
                setUser(data);
                setIsLoading(false);
            })
            .catch((err: Error) => {
                setError(err.message);
                setIsLoading(false);
            });
    }, []);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!user) return &lt;div&gt;No user found&lt;/div&gt;;
    
    // TypeScript knows user is User here!
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
            &lt;p&gt;{user.address.city}&lt;/p&gt; {/* TypeScript autocomplete! */}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Typing Fetch Functions</h3>
                <div class="card">
                    <h4>Generic Fetch Function</h4>
                    <pre><code class="language-typescript">// utils/api.ts
export async function fetchData&lt;T&gt;(url: string): Promise&lt;T&gt; {
    const response = await fetch(url);
    
    if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    return data as T;
}

// Usage
import { fetchData } from './utils/api';
import { User } from './types/user';

const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    
    useEffect(() => {
        fetchData&lt;User&gt;('https://jsonplaceholder.typicode.com/users/1')
            .then(setUser)
            .catch(console.error);
    }, []);
    
    // user is typed as User!
};</code></pre>
                </div>

                <h3>Validating API Responses</h3>
                <div class="card">
                    <h4>Runtime Type Checking</h4>
                    <pre><code class="language-typescript">// Type guards
function isUser(data: any): data is User {
    return (
        typeof data === 'object' &&
        data !== null &&
        typeof data.id === 'number' &&
        typeof data.name === 'string' &&
        typeof data.email === 'string'
    );
}

// Usage
const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => {
                if (isUser(data)) {
                    setUser(data);
                } else {
                    throw new Error('Invalid user data');
                }
            })
            .catch(err => setError(err.message));
    }, []);
    
    // ...
};</code></pre>
                </div>

                <h3>Using Zod for Validation</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Better Validation with Zod</h4>
                    <pre><code class="language-typescript">// Install: npm install zod

import { z } from 'zod';

// Define schema
const UserSchema = z.object({
    id: z.number(),
    name: z.string(),
    email: z.string().email(),
    username: z.string(),
    phone: z.string(),
    website: z.string()
});

// Infer TypeScript type from schema
type User = z.infer&lt;typeof UserSchema&gt;;

// Validate API response
const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        fetch('https://jsonplaceholder.typicode.com/users/1')
            .then(response => response.json())
            .then(data => {
                // Validate and parse
                const validatedUser = UserSchema.parse(data);
                setUser(validatedUser);
            })
            .catch(err => setError(err.message));
    }, []);
    
    // ...
};</code></pre>
                </div>
            </section>

            <!-- Section 6: Async/Await in Effects -->
            <section id="section6" class="lesson-section">
                <h2>‚ö° Async/Await in Effects</h2>
                <p>Async/await makes asynchronous code much more readable. Let's learn how to use it properly with useEffect!</p>

                <h3>The Problem: Can't Make Effect Async</h3>
                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è This Doesn't Work</h4>
                    <pre><code class="language-typescript">// ‚ùå WRONG: Effect function can't be async
useEffect(async () => {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    setData(data);
}, []);

// TypeScript Error: 
// Effect callbacks are synchronous to prevent race conditions.
// Put the async function inside the effect.</code></pre>
                </div>

                <h3>Solution 1: Define Async Function Inside</h3>
                <div class="card">
                    <h4>‚úÖ Correct Pattern</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC = () => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        // Define async function inside effect
        const fetchUser = async () => {
            try {
                setIsLoading(true);
                
                const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                setUser(data);
                
            } catch (err) {
                setError(err instanceof Error ? err.message : 'An error occurred');
            } finally {
                setIsLoading(false);
            }
        };
        
        // Call the async function
        fetchUser();
    }, []);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!user) return &lt;div&gt;No user found&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Solution 2: Immediately Invoked Async Function</h3>
                <div class="card">
                    <h4>IIFE Pattern</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    // Immediately invoked async function
    (async () => {
        try {
            const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
            const data = await response.json();
            setUser(data);
        } catch (err) {
            setError(err.message);
        }
    })();
}, []);</code></pre>
                </div>

                <h3>Multiple Async Operations</h3>
                <div class="card">
                    <h4>Sequential Fetches</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    const fetchData = async () => {
        try {
            setIsLoading(true);
            
            // Fetch user first
            const userResponse = await fetch('https://jsonplaceholder.typicode.com/users/1');
            const userData = await userResponse.json();
            setUser(userData);
            
            // Then fetch their posts
            const postsResponse = await fetch(`https://jsonplaceholder.typicode.com/posts?userId=${userData.id}`);
            const postsData = await postsResponse.json();
            setPosts(postsData);
            
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };
    
    fetchData();
}, []);</code></pre>
                </div>

                <h3>Parallel Fetches with Promise.all</h3>
                <div class="card">
                    <h4>Fetch Multiple Resources Simultaneously</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    const fetchAllData = async () => {
        try {
            setIsLoading(true);
            
            // Fetch all at once
            const [userResponse, postsResponse, todosResponse] = await Promise.all([
                fetch('https://jsonplaceholder.typicode.com/users/1'),
                fetch('https://jsonplaceholder.typicode.com/posts?userId=1'),
                fetch('https://jsonplaceholder.typicode.com/todos?userId=1')
            ]);
            
            // Parse all responses
            const [userData, postsData, todosData] = await Promise.all([
                userResponse.json(),
                postsResponse.json(),
                todosResponse.json()
            ]);
            
            setUser(userData);
            setPosts(postsData);
            setTodos(todosData);
            
        } catch (err) {
            setError(err.message);
        } finally {
            setIsLoading(false);
        }
    };
    
    fetchAllData();
}, []);

// Promise.all is faster because requests happen in parallel!
// Sequential: 300ms + 300ms + 300ms = 900ms
// Parallel: max(300ms, 300ms, 300ms) = 300ms</code></pre>
                </div>

                <h3>Error Handling with Try-Catch</h3>
                <div class="card">
                    <h4>Comprehensive Error Handling</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    const fetchUser = async () => {
        try {
            setIsLoading(true);
            setError(null);
            
            const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
            
            // Check response status
            if (!response.ok) {
                throw new Error(`Failed to fetch user: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Validate data
            if (!data.id || !data.name) {
                throw new Error('Invalid user data received');
            }
            
            setUser(data);
            
        } catch (err) {
            // Handle different error types
            if (err instanceof TypeError) {
                setError('Network error - please check your connection');
            } else if (err instanceof SyntaxError) {
                setError('Invalid response format');
            } else if (err instanceof Error) {
                setError(err.message);
            } else {
                setError('An unknown error occurred');
            }
        } finally {
            // Always runs, even if there's an error
            setIsLoading(false);
        }
    };
    
    fetchUser();
}, []);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Async/Await Best Practices</h4>
                    <ul>
                        <li><strong>Define async function inside effect:</strong> Don't make effect itself async</li>
                        <li><strong>Always use try-catch:</strong> Handle errors properly</li>
                        <li><strong>Use finally:</strong> For cleanup like setting loading to false</li>
                        <li><strong>Use Promise.all:</strong> For parallel requests</li>
                        <li><strong>Check response.ok:</strong> Before parsing JSON</li>
                        <li><strong>Type your data:</strong> Add type annotations to responses</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Canceling Requests -->
            <section id="section7" class="lesson-section">
                <h2>üõë Canceling Requests</h2>
                <p>When components unmount or dependencies change, we need to cancel in-flight requests to prevent memory leaks and race conditions!</p>

                <h3>The Problem: Memory Leaks</h3>
                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Without Cancellation</h4>
                    <pre><code class="language-typescript">// ‚ùå PROBLEM: Request completes after unmount
const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        fetch(`https://jsonplaceholder.typicode.com/users/${userId}`)
            .then(res => res.json())
            .then(setUser); // What if component unmounted?
    }, [userId]);
    
    return &lt;div&gt;{user?.name}&lt;/div&gt;;
};

// Scenario:
// 1. userId = 1, fetch starts
// 2. userId changes to 2, new fetch starts
// 3. First fetch completes (slow network)
// 4. setUser called with old data!
// Result: Wrong user displayed! üí•</code></pre>
                </div>

                <h3>Solution: AbortController</h3>
                <div class="card">
                    <h4>Properly Canceling Requests</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        // Create abort controller
        const controller = new AbortController();
        
        const fetchUser = async () => {
            try {
                setIsLoading(true);
                
                // Pass signal to fetch
                const response = await fetch(
                    `https://jsonplaceholder.typicode.com/users/${userId}`,
                    { signal: controller.signal }
                );
                
                if (!response.ok) {
                    throw new Error('Failed to fetch user');
                }
                
                const data = await response.json();
                setUser(data);
                
            } catch (err) {
                // Don't set error if request was aborted
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err.message);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchUser();
        
        // Cleanup: Cancel request on unmount or userId change
        return () => {
            controller.abort();
        };
    }, [userId]);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!user) return &lt;div&gt;No user found&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>How AbortController Works</h3>
                <div class="card">
                    <div class="mermaid">
sequenceDiagram
    participant E as ‚ö° Effect
    participant A as üõë AbortController
    participant F as üåê Fetch
    participant S as üñ•Ô∏è Server
    
    E->>A: Create controller
    E->>F: fetch(url, {signal})
    F->>S: HTTP Request
    
    Note over E,A: Component unmounts or deps change
    E->>A: controller.abort()
    A->>F: Cancel request
    F->>F: Throw AbortError
    
    Note over S: Response never processed
                    </div>
                </div>

                <!-- Interactive AbortController Demo -->
                <h3>üéÆ Interactive: Request Cancellation</h3>
                <div class="card">
                    <p>See how AbortController prevents race conditions when requests are cancelled:</p>
                    <div id="abort-demo" style="padding: 1rem;">
                        <div style="text-align: center; margin-bottom: 1rem;">
                            <button id="abort-start" style="padding: 0.5rem 1rem; cursor: pointer; background: #667eea; color: white; border: none; border-radius: 4px;">üöÄ Start Request</button>
                            <button id="abort-cancel" style="padding: 0.5rem 1rem; cursor: pointer; background: #f44336; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;" disabled>üõë Abort Request</button>
                            <button id="abort-race" style="padding: 0.5rem 1rem; cursor: pointer; background: #ff9800; color: white; border: none; border-radius: 4px; margin-left: 0.5rem;">‚ö° Simulate Race Condition</button>
                        </div>
                        <canvas id="abort-canvas" width="650" height="220" style="width: 100%; max-width: 650px; border: 1px solid #ddd; border-radius: 8px; display: block; margin: 0 auto;"></canvas>
                        <div id="abort-log" style="margin-top: 1rem; padding: 0.75rem; background: #263238; border-radius: 4px; color: #aed581; font-family: monospace; font-size: 0.8rem; max-height: 100px; overflow-y: auto;">Ready to demonstrate request cancellation...</div>
                    </div>
                </div>
                <script>
                (function() {
                    const canvas = document.getElementById('abort-canvas');
                    const ctx = canvas.getContext('2d');
                    const logDiv = document.getElementById('abort-log');
                    const startBtn = document.getElementById('abort-start');
                    const cancelBtn = document.getElementById('abort-cancel');
                    const raceBtn = document.getElementById('abort-race');
                    
                    let requestState = 'idle'; // idle, pending, success, aborted
                    let progress = 0;
                    let animationId = null;
                    
                    function log(message, color = '#aed581') {
                        logDiv.innerHTML += `<div style="color:${color};">${message}</div>`;
                        logDiv.scrollTop = logDiv.scrollHeight;
                    }
                    
                    function drawCanvas() {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw components
                        const components = [
                            { x: 80, y: 70, label: 'Component', icon: '‚ö°', color: '#667eea' },
                            { x: 240, y: 70, label: 'AbortController', icon: 'üõë', color: '#ff9800' },
                            { x: 400, y: 70, label: 'Fetch', icon: 'üåê', color: '#2196f3' },
                            { x: 560, y: 70, label: 'Server', icon: 'üñ•Ô∏è', color: '#4caf50' }
                        ];
                        
                        components.forEach(comp => {
                            ctx.beginPath();
                            ctx.arc(comp.x, comp.y, 28, 0, Math.PI * 2);
                            ctx.fillStyle = comp.color + '33';
                            ctx.fill();
                            ctx.strokeStyle = comp.color;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            ctx.font = '20px system-ui';
                            ctx.textAlign = 'center';
                            ctx.fillText(comp.icon, comp.x, comp.y + 6);
                            
                            ctx.font = '11px system-ui';
                            ctx.fillStyle = '#333';
                            ctx.fillText(comp.label, comp.x, comp.y + 50);
                        });
                        
                        // Draw progress bar for request
                        if (requestState === 'pending') {
                            ctx.fillStyle = '#e0e0e0';
                            ctx.fillRect(130, 145, 400, 20);
                            ctx.fillStyle = '#2196f3';
                            ctx.fillRect(130, 145, progress * 4, 20);
                            ctx.font = '12px system-ui';
                            ctx.fillStyle = '#333';
                            ctx.textAlign = 'center';
                            ctx.fillText(`Request in progress... ${progress}%`, 330, 160);
                            
                            // Animated packet
                            const packetX = 130 + (progress * 4);
                            ctx.fillStyle = '#667eea';
                            ctx.beginPath();
                            ctx.arc(packetX, 155, 8, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Status message
                        ctx.font = 'bold 14px system-ui';
                        ctx.textAlign = 'center';
                        
                        if (requestState === 'success') {
                            ctx.fillStyle = '#4caf50';
                            ctx.fillText('‚úÖ Request completed successfully!', canvas.width / 2, 160);
                        } else if (requestState === 'aborted') {
                            ctx.fillStyle = '#f44336';
                            ctx.fillText('üõë Request aborted - no state update!', canvas.width / 2, 160);
                            
                            // Draw X over fetch
                            ctx.strokeStyle = '#f44336';
                            ctx.lineWidth = 3;
                            ctx.beginPath();
                            ctx.moveTo(380, 50);
                            ctx.lineTo(420, 90);
                            ctx.moveTo(420, 50);
                            ctx.lineTo(380, 90);
                            ctx.stroke();
                        }
                        
                        // Instructions
                        ctx.font = '11px system-ui';
                        ctx.fillStyle = '#666';
                        ctx.fillText('Without AbortController, cancelled requests can still update state!', canvas.width / 2, 200);
                    }
                    
                    function animateRequest(shouldAbort = false, abortAt = 50) {
                        if (animationId) cancelAnimationFrame(animationId);
                        requestState = 'pending';
                        progress = 0;
                        startBtn.disabled = true;
                        cancelBtn.disabled = false;
                        
                        function step() {
                            if (shouldAbort && progress >= abortAt) {
                                requestState = 'aborted';
                                cancelBtn.disabled = true;
                                startBtn.disabled = false;
                                log('üõë AbortError: The user aborted a request.', '#f44336');
                                log('‚úÖ State NOT updated (memory leak prevented!)', '#4caf50');
                                drawCanvas();
                                return;
                            }
                            
                            progress += 2;
                            drawCanvas();
                            
                            if (progress >= 100) {
                                requestState = 'success';
                                cancelBtn.disabled = true;
                                startBtn.disabled = false;
                                log('‚úÖ Data received: { id: 1, name: "John" }', '#4caf50');
                                drawCanvas();
                            } else {
                                animationId = requestAnimationFrame(step);
                            }
                        }
                        
                        log('üöÄ Starting fetch request...', '#2196f3');
                        step();
                    }
                    
                    startBtn.addEventListener('click', () => {
                        logDiv.innerHTML = '';
                        animateRequest(false);
                    });
                    
                    cancelBtn.addEventListener('click', () => {
                        log('üëÜ User clicked abort (simulating unmount)', '#ff9800');
                        requestState = 'aborted';
                        cancelBtn.disabled = true;
                        startBtn.disabled = false;
                        if (animationId) cancelAnimationFrame(animationId);
                        log('üõë AbortError: The user aborted a request.', '#f44336');
                        log('‚úÖ State NOT updated (memory leak prevented!)', '#4caf50');
                        drawCanvas();
                    });
                    
                    raceBtn.addEventListener('click', () => {
                        logDiv.innerHTML = '';
                        log('‚ö° Simulating race condition scenario...', '#ff9800');
                        log('User clicks button, component unmounts mid-request', '#ff9800');
                        animateRequest(true, 60);
                    });
                    
                    drawCanvas();
                })();
                </script>

                <h3>Using with Async Functions</h3>
                <div class="card">
                    <h4>Pattern with Try-Catch</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    const controller = new AbortController();
    
    const fetchData = async () => {
        try {
            const response = await fetch(url, {
                signal: controller.signal
            });
            
            const data = await response.json();
            setData(data);
            
        } catch (err) {
            // Check if error is from abort
            if (err instanceof Error) {
                if (err.name === 'AbortError') {
                    console.log('Fetch aborted');
                    return; // Don't set error state
                }
                setError(err.message);
            }
        }
    };
    
    fetchData();
    
    return () => {
        controller.abort();
    };
}, [url]);</code></pre>
                </div>

                <h3>Race Condition Prevention</h3>
                <div class="card">
                    <h4>Search Component Example</h4>
                    <pre><code class="language-typescript">const Search: React.FC = () => {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState([]);
    const [isLoading, setIsLoading] = useState(false);
    
    useEffect(() => {
        if (!query) {
            setResults([]);
            return;
        }
        
        const controller = new AbortController();
        
        const searchAPI = async () => {
            try {
                setIsLoading(true);
                
                const response = await fetch(
                    `https://api.example.com/search?q=${query}`,
                    { signal: controller.signal }
                );
                
                const data = await response.json();
                setResults(data);
                
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    console.error(err);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        searchAPI();
        
        // Cancel when query changes
        return () => {
            controller.abort();
        };
    }, [query]);
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Search..."
            /&gt;
            {isLoading && &lt;div&gt;Searching...&lt;/div&gt;}
            &lt;ul&gt;
                {results.map(result => (
                    &lt;li key={result.id}&gt;{result.name}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Multiple Requests Cancellation</h3>
                <div class="card">
                    <h4>Cancel All Requests on Cleanup</h4>
                    <pre><code class="language-typescript">useEffect(() => {
    const controller = new AbortController();
    
    const fetchAllData = async () => {
        try {
            // Use same signal for all requests
            const [usersRes, postsRes] = await Promise.all([
                fetch('https://jsonplaceholder.typicode.com/users', {
                    signal: controller.signal
                }),
                fetch('https://jsonplaceholder.typicode.com/posts', {
                    signal: controller.signal
                })
            ]);
            
            const [users, posts] = await Promise.all([
                usersRes.json(),
                postsRes.json()
            ]);
            
            setUsers(users);
            setPosts(posts);
            
        } catch (err) {
            if (err instanceof Error && err.name !== 'AbortError') {
                setError(err.message);
            }
        }
    };
    
    fetchAllData();
    
    // Aborts ALL requests using this controller
    return () => {
        controller.abort();
    };
}, []);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Request Cancellation Best Practices</h4>
                    <ul>
                        <li><strong>Always use AbortController:</strong> For all fetch requests in effects</li>
                        <li><strong>Check for AbortError:</strong> Don't treat it as a real error</li>
                        <li><strong>One controller per effect:</strong> Create new controller in each effect run</li>
                        <li><strong>Cancel in cleanup:</strong> Return cleanup function that calls abort()</li>
                        <li><strong>Don't update state after abort:</strong> Check for AbortError first</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Complete Data Fetching Pattern -->
            <section id="section8" class="lesson-section">
                <h2>üéØ Complete Data Fetching Pattern</h2>
                <p>Let's put everything together into a production-ready pattern that handles all edge cases!</p>

                <h3>The Complete Pattern</h3>
                <div class="card">
                    <h4>Full-Featured Data Fetching Component</h4>
                    <pre><code class="language-typescript">import { useState, useEffect } from 'react';

interface User {
    id: number;
    name: string;
    email: string;
    username: string;
}

interface UserProfileProps {
    userId: number;
}

const UserProfile: React.FC&lt;UserProfileProps&gt; = ({ userId }) => {
    // State
    const [user, setUser] = useState&lt;User | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        // Create abort controller
        const controller = new AbortController();
        
        const fetchUser = async () => {
            try {
                // Reset states
                setIsLoading(true);
                setError(null);
                
                // Fetch with cancellation support
                const response = await fetch(
                    `https://jsonplaceholder.typicode.com/users/${userId}`,
                    { signal: controller.signal }
                );
                
                // Check response status
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Parse JSON
                const data: User = await response.json();
                
                // Validate data
                if (!data.id || !data.name) {
                    throw new Error('Invalid user data');
                }
                
                // Update state
                setUser(data);
                
            } catch (err) {
                // Don't set error if aborted
                if (err instanceof Error && err.name === 'AbortError') {
                    console.log('Fetch aborted');
                    return;
                }
                
                // Handle different error types
                if (err instanceof TypeError) {
                    setError('Network error - check your connection');
                } else if (err instanceof Error) {
                    setError(err.message);
                } else {
                    setError('An unknown error occurred');
                }
            } finally {
                // Always set loading to false
                setIsLoading(false);
            }
        };
        
        fetchUser();
        
        // Cleanup: cancel request
        return () => {
            controller.abort();
        };
    }, [userId]); // Re-fetch when userId changes
    
    // Loading state
    if (isLoading) {
        return (
            &lt;div className="loading"&gt;
                &lt;div className="spinner"&gt;&lt;/div&gt;
                &lt;p&gt;Loading user...&lt;/p&gt;
            &lt;/div&gt;
        );
    }
    
    // Error state
    if (error) {
        return (
            &lt;div className="error"&gt;
                &lt;h3&gt;‚ùå Error&lt;/h3&gt;
                &lt;p&gt;{error}&lt;/p&gt;
                &lt;button onClick={() => window.location.reload()}&gt;
                    Retry
                &lt;/button&gt;
            &lt;/div&gt;
        );
    }
    
    // No data state
    if (!user) {
        return (
            &lt;div className="empty"&gt;
                &lt;p&gt;No user found&lt;/p&gt;
            &lt;/div&gt;
        );
    }
    
    // Success state
    return (
        &lt;div className="user-profile"&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;Username: {user.username}&lt;/p&gt;
            &lt;p&gt;Email: {user.email}&lt;/p&gt;
        &lt;/div&gt;
    );
};

export default UserProfile;</code></pre>
                </div>

                <h3>Reusable Fetch Hook</h3>
                <div class="card">
                    <h4>Custom Hook for Data Fetching</h4>
                    <pre><code class="language-typescript">// hooks/useFetch.ts
import { useState, useEffect } from 'react';

interface UseFetchResult&lt;T&gt; {
    data: T | null;
    isLoading: boolean;
    error: string | null;
    refetch: () => void;
}

export function useFetch&lt;T&gt;(url: string): UseFetchResult&lt;T&gt; {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    const [refetchTrigger, setRefetchTrigger] = useState(0);
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                setError(null);
                
                const response = await fetch(url, {
                    signal: controller.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
                
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err.message);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        return () => {
            controller.abort();
        };
    }, [url, refetchTrigger]);
    
    const refetch = () => {
        setRefetchTrigger(prev => prev + 1);
    };
    
    return { data, isLoading, error, refetch };
}

// Usage
const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const { data: user, isLoading, error, refetch } = useFetch&lt;User&gt;(
        `https://jsonplaceholder.typicode.com/users/${userId}`
    );
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error} &lt;button onClick={refetch}&gt;Retry&lt;/button&gt;&lt;/div&gt;;
    if (!user) return &lt;div&gt;No user&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user.name}&lt;/h2&gt;
            &lt;p&gt;{user.email}&lt;/p&gt;
            &lt;button onClick={refetch}&gt;Refresh&lt;/button&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>State Machine Pattern</h3>
                <div class="card">
                    <h4>Better State Management</h4>
                    <pre><code class="language-typescript">type FetchState&lt;T&gt; =
    | { status: 'idle' }
    | { status: 'loading' }
    | { status: 'success'; data: T }
    | { status: 'error'; error: string };

const UserProfile: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [state, setState] = useState&lt;FetchState&lt;User&gt;&gt;({
        status: 'idle'
    });
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchUser = async () => {
            setState({ status: 'loading' });
            
            try {
                const response = await fetch(
                    `https://jsonplaceholder.typicode.com/users/${userId}`,
                    { signal: controller.signal }
                );
                
                if (!response.ok) throw new Error('Failed to fetch');
                
                const data = await response.json();
                setState({ status: 'success', data });
                
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setState({ status: 'error', error: err.message });
                }
            }
        };
        
        fetchUser();
        
        return () => controller.abort();
    }, [userId]);
    
    // Render based on status
    switch (state.status) {
        case 'idle':
        case 'loading':
            return &lt;div&gt;Loading...&lt;/div&gt;;
        
        case 'error':
            return &lt;div&gt;Error: {state.error}&lt;/div&gt;;
        
        case 'success':
            return (
                &lt;div&gt;
                    &lt;h2&gt;{state.data.name}&lt;/h2&gt;
                    &lt;p&gt;{state.data.email}&lt;/p&gt;
                &lt;/div&gt;
            );
    }
};</code></pre>
                </div>
            </section>

            <!-- Section 9: Common Patterns -->
            <section id="section9" class="lesson-section">
                <h2>üé® Common Patterns</h2>
                <p>Let's explore practical patterns you'll use frequently in real applications!</p>

                <h3>Pattern 1: Manual Refetch</h3>
                <div class="card">
                    <h4>Refresh Button</h4>
                    <pre><code class="language-typescript">const UserProfile: React.FC = () => {
    const [user, setUser] = useState(null);
    const [isLoading, setIsLoading] = useState(false);
    const [refreshKey, setRefreshKey] = useState(0);
    
    useEffect(() => {
        const fetchUser = async () => {
            setIsLoading(true);
            const response = await fetch('https://jsonplaceholder.typicode.com/users/1');
            const data = await response.json();
            setUser(data);
            setIsLoading(false);
        };
        
        fetchUser();
    }, [refreshKey]); // Re-run when refreshKey changes
    
    const handleRefresh = () => {
        setRefreshKey(prev => prev + 1);
    };
    
    return (
        &lt;div&gt;
            {isLoading ? (
                &lt;div&gt;Loading...&lt;/div&gt;
            ) : (
                &lt;&gt;
                    &lt;h2&gt;{user?.name}&lt;/h2&gt;
                    &lt;button onClick={handleRefresh} disabled={isLoading}&gt;
                        {isLoading ? 'Refreshing...' : 'Refresh'}
                    &lt;/button&gt;
                &lt;/&gt;
            )}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Pattern 2: Polling (Auto-Refresh)</h3>
                <div class="card">
                    <h4>Fetch Data on Interval</h4>
                    <pre><code class="language-typescript">const LiveData: React.FC = () => {
    const [data, setData] = useState(null);
    const [isPolling, setIsPolling] = useState(true);
    
    useEffect(() => {
        if (!isPolling) return;
        
        const fetchData = async () => {
            const response = await fetch('https://api.example.com/live-data');
            const json = await response.json();
            setData(json);
        };
        
        // Fetch immediately
        fetchData();
        
        // Then fetch every 5 seconds
        const intervalId = setInterval(fetchData, 5000);
        
        return () => {
            clearInterval(intervalId);
        };
    }, [isPolling]);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Live Data&lt;/h2&gt;
            &lt;button onClick={() => setIsPolling(!isPolling)}&gt;
                {isPolling ? 'Stop Polling' : 'Start Polling'}
            &lt;/button&gt;
            &lt;pre&gt;{JSON.stringify(data, null, 2)}&lt;/pre&gt;
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Pattern 3: Pagination</h3>
                <div class="card">
                    <h4>Load More Pattern</h4>
                    <pre><code class="language-typescript">const PostsList: React.FC = () => {
    const [posts, setPosts] = useState&lt;Post[]&gt;([]);
    const [page, setPage] = useState(1);
    const [isLoading, setIsLoading] = useState(false);
    const [hasMore, setHasMore] = useState(true);
    
    useEffect(() => {
        const fetchPosts = async () => {
            setIsLoading(true);
            
            const response = await fetch(
                `https://jsonplaceholder.typicode.com/posts?_page=${page}&_limit=10`
            );
            const newPosts = await response.json();
            
            if (newPosts.length === 0) {
                setHasMore(false);
            } else {
                setPosts(prev => [...prev, ...newPosts]);
            }
            
            setIsLoading(false);
        };
        
        fetchPosts();
    }, [page]);
    
    const loadMore = () => {
        setPage(prev => prev + 1);
    };
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Posts&lt;/h2&gt;
            {posts.map(post => (
                &lt;article key={post.id}&gt;
                    &lt;h3&gt;{post.title}&lt;/h3&gt;
                    &lt;p&gt;{post.body}&lt;/p&gt;
                &lt;/article&gt;
            ))}
            
            {isLoading && &lt;div&gt;Loading more...&lt;/div&gt;}
            
            {hasMore && !isLoading && (
                &lt;button onClick={loadMore}&gt;Load More&lt;/button&gt;
            )}
            
            {!hasMore && &lt;div&gt;No more posts&lt;/div&gt;}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Pattern 4: Dependent Fetches</h3>
                <div class="card">
                    <h4>Fetch Data Based on Other Data</h4>
                    <pre><code class="language-typescript">const UserWithPosts: React.FC&lt;{ userId: number }&gt; = ({ userId }) => {
    const [user, setUser] = useState(null);
    const [posts, setPosts] = useState([]);
    const [isLoadingUser, setIsLoadingUser] = useState(true);
    const [isLoadingPosts, setIsLoadingPosts] = useState(false);
    
    // Fetch user first
    useEffect(() => {
        const fetchUser = async () => {
            setIsLoadingUser(true);
            const response = await fetch(
                `https://jsonplaceholder.typicode.com/users/${userId}`
            );
            const data = await response.json();
            setUser(data);
            setIsLoadingUser(false);
        };
        
        fetchUser();
    }, [userId]);
    
    // Fetch posts after we have user
    useEffect(() => {
        if (!user) return;
        
        const fetchPosts = async () => {
            setIsLoadingPosts(true);
            const response = await fetch(
                `https://jsonplaceholder.typicode.com/posts?userId=${user.id}`
            );
            const data = await response.json();
            setPosts(data);
            setIsLoadingPosts(false);
        };
        
        fetchPosts();
    }, [user]);
    
    if (isLoadingUser) return &lt;div&gt;Loading user...&lt;/div&gt;;
    if (isLoadingPosts) return &lt;div&gt;Loading posts...&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h2&gt;{user?.name}'s Posts&lt;/h2&gt;
            {posts.map(post => (
                &lt;article key={post.id}&gt;
                    &lt;h3&gt;{post.title}&lt;/h3&gt;
                    &lt;p&gt;{post.body}&lt;/p&gt;
                &lt;/article&gt;
            ))}
        &lt;/div&gt;
    );
};</code></pre>
                </div>

                <h3>Pattern 5: Caching Results</h3>
                <div class="card">
                    <h4>Simple Cache Implementation</h4>
                    <pre><code class="language-typescript">// Simple cache outside component
const cache = new Map&lt;string, any&gt;();

const useCachedFetch = &lt;T,&gt;(url: string) => {
    const [data, setData] = useState&lt;T | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    
    useEffect(() => {
        // Check cache first
        if (cache.has(url)) {
            setData(cache.get(url));
            setIsLoading(false);
            return;
        }
        
        const fetchData = async () => {
            const response = await fetch(url);
            const json = await response.json();
            
            // Save to cache
            cache.set(url, json);
            setData(json);
            setIsLoading(false);
        };
        
        fetchData();
    }, [url]);
    
    return { data, isLoading };
};</code></pre>
                </div>
            </section>

            <!-- Section 10: Hands-on Practice -->
            <section id="section10" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to build real data-fetching components!</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: User Directory</h3>
                    <p>Build a component that displays a list of users from the API.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Fetch all users from: <code>https://jsonplaceholder.typicode.com/users</code></li>
                        <li>Display name, email, and city for each user</li>
                        <li>Show loading state while fetching</li>
                        <li>Handle and display errors</li>
                        <li>Add a refresh button</li>
                    </ul>

                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    address: {
        city: string;
    };
}

const UserDirectory: React.FC = () => {
    // Your code here!
    
    return (
        &lt;div&gt;
            &lt;h1&gt;User Directory&lt;/h1&gt;
            {/* Display users */}
        &lt;/div&gt;
    );
};</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <div class="card">
                            <p>Use useState for users array, loading, and error. Use useEffect with empty dependency array to fetch on mount.</p>
                        </div>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">const UserDirectory: React.FC = () => {
    const [users, setUsers] = useState&lt;User[]&gt;([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    const fetchUsers = async () => {
        try {
            setIsLoading(true);
            setError(null);
            
            const response = await fetch('https://jsonplaceholder.typicode.com/users');
            
            if (!response.ok) {
                throw new Error('Failed to fetch users');
            }
            
            const data = await response.json();
            setUsers(data);
            
        } catch (err) {
            setError(err instanceof Error ? err.message : 'An error occurred');
        } finally {
            setIsLoading(false);
        }
    };
    
    useEffect(() => {
        fetchUsers();
    }, []);
    
    if (isLoading) return &lt;div&gt;Loading users...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;h1&gt;User Directory&lt;/h1&gt;
            &lt;button onClick={fetchUsers}&gt;Refresh&lt;/button&gt;
            &lt;ul&gt;
                {users.map(user => (
                    &lt;li key={user.id}&gt;
                        &lt;h3&gt;{user.name}&lt;/h3&gt;
                        &lt;p&gt;Email: {user.email}&lt;/p&gt;
                        &lt;p&gt;City: {user.address.city}&lt;/p&gt;
                    &lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Post Viewer</h3>
                    <p>Create a component that shows a single post with its comments.</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Accept postId as prop</li>
                        <li>Fetch post: <code>https://jsonplaceholder.typicode.com/posts/{postId}</code></li>
                        <li>Fetch comments: <code>https://jsonplaceholder.typicode.com/comments?postId={postId}</code></li>
                        <li>Use Promise.all to fetch both simultaneously</li>
                        <li>Handle loading and error states</li>
                        <li>Cancel requests when component unmounts</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="card">
                            <pre><code class="language-typescript">interface Post {
    id: number;
    title: string;
    body: string;
}

interface Comment {
    id: number;
    name: string;
    email: string;
    body: string;
}

const PostViewer: React.FC&lt;{ postId: number }&gt; = ({ postId }) => {
    const [post, setPost] = useState&lt;Post | null&gt;(null);
    const [comments, setComments] = useState&lt;Comment[]&gt;([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                
                const [postRes, commentsRes] = await Promise.all([
                    fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`, {
                        signal: controller.signal
                    }),
                    fetch(`https://jsonplaceholder.typicode.com/comments?postId=${postId}`, {
                        signal: controller.signal
                    })
                ]);
                
                const [postData, commentsData] = await Promise.all([
                    postRes.json(),
                    commentsRes.json()
                ]);
                
                setPost(postData);
                setComments(commentsData);
                
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err.message);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        return () => controller.abort();
    }, [postId]);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!post) return &lt;div&gt;Post not found&lt;/div&gt;;
    
    return (
        &lt;div&gt;
            &lt;article&gt;
                &lt;h2&gt;{post.title}&lt;/h2&gt;
                &lt;p&gt;{post.body}&lt;/p&gt;
            &lt;/article&gt;
            
            &lt;section&gt;
                &lt;h3&gt;Comments ({comments.length})&lt;/h3&gt;
                {comments.map(comment => (
                    &lt;div key={comment.id}&gt;
                        &lt;h4&gt;{comment.name}&lt;/h4&gt;
                        &lt;p&gt;{comment.body}&lt;/p&gt;
                        &lt;small&gt;{comment.email}&lt;/small&gt;
                    &lt;/div&gt;
                ))}
            &lt;/section&gt;
        &lt;/div&gt;
    );
};</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: Search & Filter</h3>
                    <p>Build a searchable, filterable user list!</p>
                    
                    <h4>Requirements:</h4>
                    <ul>
                        <li>Fetch all users</li>
                        <li>Add search input to filter by name</li>
                        <li>Add dropdown to filter by city</li>
                        <li>Debounce search (wait 500ms after typing)</li>
                        <li>Show "No results" when filters match nothing</li>
                        <li>Display count of filtered users</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Best Practices -->
            <section id="section11" class="lesson-section">
                <h2>‚ú® Best Practices</h2>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>‚úÖ Do's</h3>
                    <ul>
                        <li><strong>Always handle loading states:</strong> Users need feedback</li>
                        <li><strong>Always handle errors:</strong> Networks fail, APIs go down</li>
                        <li><strong>Use AbortController:</strong> Cancel requests to prevent memory leaks</li>
                        <li><strong>Check response.ok:</strong> Fetch doesn't throw on HTTP errors</li>
                        <li><strong>Type your API responses:</strong> Create interfaces for data</li>
                        <li><strong>Use async/await:</strong> More readable than promise chains</li>
                        <li><strong>Validate API responses:</strong> Don't trust external data blindly</li>
                        <li><strong>Show specific error messages:</strong> Help users understand what went wrong</li>
                        <li><strong>Provide retry mechanisms:</strong> Let users recover from errors</li>
                        <li><strong>Use custom hooks:</strong> Extract reusable fetch logic</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h3>‚ùå Don'ts</h3>
                    <ul>
                        <li><strong>Don't fetch during render:</strong> Always use useEffect</li>
                        <li><strong>Don't forget dependencies:</strong> Include all values used in effect</li>
                        <li><strong>Don't ignore AbortError:</strong> It's expected, not a real error</li>
                        <li><strong>Don't update state after unmount:</strong> Check if request was aborted</li>
                        <li><strong>Don't expose technical errors:</strong> Be user-friendly</li>
                        <li><strong>Don't fetch on every render:</strong> Use proper dependency arrays</li>
                        <li><strong>Don't forget empty states:</strong> Show when there's no data</li>
                        <li><strong>Don't block UI:</strong> Show loading indicators, not blank screens</li>
                        <li><strong>Don't trust response format:</strong> Validate data structure</li>
                    </ul>
                </div>

                <h3>Error Handling Strategy</h3>
                <div class="card">
                    <h4>Comprehensive Error Management</h4>
                    <pre><code class="language-typescript">const fetchWithErrorHandling = async (url: string) => {
    try {
        const response = await fetch(url);
        
        // HTTP errors
        if (!response.ok) {
            switch (response.status) {
                case 400:
                    throw new Error('Bad request - check your input');
                case 401:
                    throw new Error('Please log in to continue');
                case 403:
                    throw new Error('You don\'t have permission');
                case 404:
                    throw new Error('Resource not found');
                case 500:
                    throw new Error('Server error - try again later');
                case 503:
                    throw new Error('Service unavailable - try again later');
                default:
                    throw new Error(`Error: ${response.status}`);
            }
        }
        
        const data = await response.json();
        return data;
        
    } catch (err) {
        // Network errors
        if (err instanceof TypeError) {
            throw new Error('Network error - check your connection');
        }
        
        // JSON parse errors
        if (err instanceof SyntaxError) {
            throw new Error('Invalid response format');
        }
        
        // Abort errors (don't treat as error)
        if (err instanceof Error && err.name === 'AbortError') {
            return null; // Or handle specially
        }
        
        // Re-throw other errors
        throw err;
    }
};</code></pre>
                </div>

                <h3>Loading State Best Practices</h3>
                <div class="card">
                    <h4>Better UX for Loading</h4>
                    <pre><code class="language-typescript">// ‚ùå Bad: Just shows "Loading..."
if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;

// ‚úÖ Better: Skeleton screen
if (isLoading) {
    return (
        &lt;div className="user-skeleton"&gt;
            &lt;div className="skeleton-avatar"&gt;&lt;/div&gt;
            &lt;div className="skeleton-title"&gt;&lt;/div&gt;
            &lt;div className="skeleton-text"&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ Best: Specific message with spinner
if (isLoading) {
    return (
        &lt;div className="loading-state"&gt;
            &lt;div className="spinner"&gt;&lt;/div&gt;
            &lt;p&gt;Loading user profile...&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>API Organization</h3>
                <div class="card">
                    <h4>Centralize API Calls</h4>
                    <pre><code class="language-typescript">// api/users.ts
const BASE_URL = 'https://jsonplaceholder.typicode.com';

export const usersAPI = {
    getAll: async (): Promise&lt;User[]&gt; => {
        const response = await fetch(`${BASE_URL}/users`);
        if (!response.ok) throw new Error('Failed to fetch users');
        return response.json();
    },
    
    getById: async (id: number): Promise&lt;User&gt; => {
        const response = await fetch(`${BASE_URL}/users/${id}`);
        if (!response.ok) throw new Error('Failed to fetch user');
        return response.json();
    },
    
    create: async (user: Omit&lt;User, 'id'&gt;): Promise&lt;User&gt; => {
        const response = await fetch(`${BASE_URL}/users`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(user)
        });
        if (!response.ok) throw new Error('Failed to create user');
        return response.json();
    },
    
    update: async (id: number, user: Partial&lt;User&gt;): Promise&lt;User&gt; => {
        const response = await fetch(`${BASE_URL}/users/${id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(user)
        });
        if (!response.ok) throw new Error('Failed to update user');
        return response.json();
    },
    
    delete: async (id: number): Promise&lt;void&gt; => {
        const response = await fetch(`${BASE_URL}/users/${id}`, {
            method: 'DELETE'
        });
        if (!response.ok) throw new Error('Failed to delete user');
    }
};

// Usage in component
const UserProfile: React.FC = () => {
    const [user, setUser] = useState(null);
    
    useEffect(() => {
        usersAPI.getById(1)
            .then(setUser)
            .catch(console.error);
    }, []);
    
    // ...
};</code></pre>
                </div>

                <h3>Performance Considerations</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Optimize Data Fetching</h4>
                    <ul>
                        <li><strong>Debounce search inputs:</strong> Don't fetch on every keystroke</li>
                        <li><strong>Use pagination:</strong> Don't load all data at once</li>
                        <li><strong>Implement caching:</strong> Avoid redundant requests</li>
                        <li><strong>Lazy load:</strong> Fetch data only when needed</li>
                        <li><strong>Use parallel requests:</strong> Promise.all for independent data</li>
                        <li><strong>Set timeouts:</strong> Don't let requests hang forever</li>
                        <li><strong>Optimize payload size:</strong> Request only needed fields</li>
                    </ul>
                    
                    <pre><code class="language-typescript">// Example: Request with timeout
const fetchWithTimeout = async (url: string, timeout = 5000) => {
    const controller = new AbortController();
    
    const timeoutId = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeoutId);
        return response;
    } catch (err) {
        clearTimeout(timeoutId);
        throw err;
    }
};</code></pre>
                </div>

                <h3>Security Considerations</h3>
                <div class="card">
                    <h4>Secure Data Fetching</h4>
                    <ul>
                        <li><strong>Never expose API keys in frontend code</strong></li>
                        <li><strong>Use HTTPS:</strong> Always, never HTTP</li>
                        <li><strong>Sanitize user input:</strong> Before sending to API</li>
                        <li><strong>Validate responses:</strong> Don't trust API data blindly</li>
                        <li><strong>Handle sensitive data carefully:</strong> Don't log passwords, tokens</li>
                        <li><strong>Implement CORS properly:</strong> Understand cross-origin requests</li>
                        <li><strong>Use authentication tokens:</strong> Store securely, not in localStorage for sensitive apps</li>
                    </ul>
                </div>

                <h3>Testing Data Fetching</h3>
                <div class="card">
                    <h4>How to Test API Calls</h4>
                    <pre><code class="language-typescript">// Mock fetch in tests
global.fetch = jest.fn(() =>
    Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ id: 1, name: 'Test User' })
    })
) as jest.Mock;

// Test component
test('fetches and displays user', async () => {
    render(&lt;UserProfile userId={1} /&gt;);
    
    // Check loading state
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    
    // Wait for data to load
    await waitFor(() => {
        expect(screen.getByText('Test User')).toBeInTheDocument();
    });
    
    // Verify fetch was called
    expect(fetch).toHaveBeenCalledWith(
        'https://api.example.com/users/1'
    );
});</code></pre>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card">
                    <h3>What You Learned</h3>
                    <p>Congratulations! You've mastered data fetching in React‚Äîa critical skill for building real-world applications:</p>
                    
                    <ul>
                        <li>‚úÖ Understanding the Fetch API and how it works</li>
                        <li>‚úÖ Integrating fetch with useEffect for data fetching</li>
                        <li>‚úÖ Managing loading states to provide user feedback</li>
                        <li>‚úÖ Handling errors gracefully with proper error messages</li>
                        <li>‚úÖ Typing API responses with TypeScript interfaces</li>
                        <li>‚úÖ Using async/await for cleaner asynchronous code</li>
                        <li>‚úÖ Canceling requests with AbortController</li>
                        <li>‚úÖ Building reusable fetch hooks and patterns</li>
                        <li>‚úÖ Implementing common patterns (pagination, polling, refetch)</li>
                        <li>‚úÖ Following best practices for production apps</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Takeaways</h3>
                    <ul style="color: white;">
                        <li><strong>Always use useEffect:</strong> Never fetch during render</li>
                        <li><strong>Handle three states:</strong> Loading, error, and success</li>
                        <li><strong>Cancel your requests:</strong> Use AbortController to prevent leaks</li>
                        <li><strong>Check response.ok:</strong> Fetch doesn't throw on HTTP errors</li>
                        <li><strong>Type everything:</strong> TypeScript makes APIs safer</li>
                        <li><strong>Think about UX:</strong> Good loading and error states matter</li>
                    </ul>
                </div>

                <h3>Data Fetching Checklist</h3>
                <div class="card">
                    <h4>‚úÖ Before You Ship</h4>
                    <ul>
                        <li>‚òê Loading state implemented</li>
                        <li>‚òê Error state handled</li>
                        <li>‚òê Empty state shown when no data</li>
                        <li>‚òê AbortController used for cancellation</li>
                        <li>‚òê Response status checked (response.ok)</li>
                        <li>‚òê API responses typed with TypeScript</li>
                        <li>‚òê Error messages user-friendly</li>
                        <li>‚òê Retry mechanism available</li>
                        <li>‚òê No infinite loops or memory leaks</li>
                        <li>‚òê Loading indicators visible and clear</li>
                    </ul>
                </div>

                <h3>Complete Example Reference</h3>
                <div class="card">
                    <h4>Full Pattern to Copy</h4>
                    <pre><code class="language-typescript">import { useState, useEffect } from 'react';

interface DataType {
    // Your data structure
}

const MyComponent: React.FC&lt;{ id: number }&gt; = ({ id }) => {
    const [data, setData] = useState&lt;DataType | null&gt;(null);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState&lt;string | null&gt;(null);
    
    useEffect(() => {
        const controller = new AbortController();
        
        const fetchData = async () => {
            try {
                setIsLoading(true);
                setError(null);
                
                const response = await fetch(`https://api.example.com/data/${id}`, {
                    signal: controller.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const json = await response.json();
                setData(json);
                
            } catch (err) {
                if (err instanceof Error && err.name !== 'AbortError') {
                    setError(err.message);
                }
            } finally {
                setIsLoading(false);
            }
        };
        
        fetchData();
        
        return () => controller.abort();
    }, [id]);
    
    if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
    if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
    if (!data) return &lt;div&gt;No data&lt;/div&gt;;
    
    return &lt;div&gt;{/* Display data */}&lt;/div&gt;;
};</code></pre>
                </div>

                <h3>Quick Reference</h3>
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Task</th>
                                <th>Code</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Basic Fetch</strong></td>
                                <td><code>fetch(url).then(r => r.json())</code></td>
                            </tr>
                            <tr>
                                <td><strong>With Async/Await</strong></td>
                                <td><code>const res = await fetch(url); const data = await res.json();</code></td>
                            </tr>
                            <tr>
                                <td><strong>Check Status</strong></td>
                                <td><code>if (!response.ok) throw new Error();</code></td>
                            </tr>
                            <tr>
                                <td><strong>Cancel Request</strong></td>
                                <td><code>controller.abort()</code></td>
                            </tr>
                            <tr>
                                <td><strong>Handle Abort</strong></td>
                                <td><code>if (err.name !== 'AbortError') ...</code></td>
                            </tr>
                            <tr>
                                <td><strong>POST Request</strong></td>
                                <td><code>fetch(url, {method: 'POST', body: JSON.stringify(data)})</code></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üöÄ What's Next?</h3>
                    <p>In the next lesson, we'll learn about <strong>Custom Hooks</strong>:</p>
                    <ul>
                        <li>Creating reusable hook logic</li>
                        <li>Building custom hooks for data fetching</li>
                        <li>Hook composition and patterns</li>
                        <li>Sharing logic between components</li>
                        <li>Advanced custom hook techniques</li>
                    </ul>
                    <p>You'll take your data fetching code and make it truly reusable! üí™</p>
                </div>

                <h3>Additional Resources</h3>
                <div class="card">
                    <h4>üìñ Further Reading</h4>
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">MDN: Fetch API</a></li>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortController" target="_blank">MDN: AbortController</a></li>
                        <li><a href="https://react.dev/reference/react/useEffect" target="_blank">React: useEffect</a></li>
                        <li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html" target="_blank">TypeScript: Everyday Types</a></li>
                    </ul>
                    
                    <h4>üõ†Ô∏è Useful Libraries</h4>
                    <ul>
                        <li><strong>Axios:</strong> Popular alternative to fetch with better defaults</li>
                        <li><strong>React Query:</strong> Powerful data fetching and caching library</li>
                        <li><strong>SWR:</strong> React Hooks for data fetching by Vercel</li>
                        <li><strong>Zod:</strong> TypeScript-first schema validation</li>
                    </ul>
                </div>

                <h3>Congratulations! üéâ</h3>
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h2 style="color: white;">üèÜ You're Now a Data Fetching Pro!</h2>
                    <p style="color: white;">You've learned how to fetch data from APIs, handle all edge cases, and build production-ready components. This is a fundamental skill that you'll use in every React application you build.</p>
                    <p style="color: white;"><strong>Key Achievement:</strong> You can now integrate any REST API into your React applications with confidence!</p>
                    <p style="color: white;">Keep practicing with different APIs, and you'll soon be building complex, data-driven applications! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <div class="lesson-nav">
                <a href="lesson_4_1_useeffect_hook.html" class="prev-lesson">‚Üê Previous: useEffect Hook</a>
                <a href="index.html" class="home-link">üè† Home</a>
                <a href="lesson_4_3_custom_hooks.html" class="next-lesson">Next: Custom Hooks ‚Üí</a>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org/docs/" target="_blank">TypeScript Docs</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
