<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master URL search parameters with useSearchParams hook, build dynamic filters, implement search functionality, and sync application state with URLs in React Router">
    <meta name="author" content="React TypeScript Course">
    <title>Lesson 6.4: Search and Query Parameters - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module6">Module 6: Routing and Navigation</a></li>
            <li aria-current="page">Lesson 6.4: Search and Query Parameters</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üîç Lesson 6.4: Search and Query Parameters</h1>
                <p class="lead">Master URL query parameters to build powerful search, filter, and pagination features. Learn to sync application state with the URL, making your app shareable, bookmarkable, and SEO-friendly with the useSearchParams hook.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Use the useSearchParams hook to read and write URL query parameters</li>
                        <li>Build search functionality with URL state management</li>
                        <li>Implement filters that sync with the URL</li>
                        <li>Create pagination using query parameters</li>
                        <li>Type search parameters properly with TypeScript</li>
                        <li>Handle complex URL state with multiple parameters</li>
                        <li>Build shareable and bookmarkable application states</li>
                        <li>Understand URL state vs component state trade-offs</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 6.1-6.3 (React Router fundamentals, navigation, and protection)</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding URL Query Parameters</a></li>
                        <li><a href="#section2" class="toc-link">The useSearchParams Hook</a></li>
                        <li><a href="#section3" class="toc-link">Building Search Functionality</a></li>
                        <li><a href="#section4" class="toc-link">Implementing Filters with URL State</a></li>
                        <li><a href="#section5" class="toc-link">Pagination with Query Parameters</a></li>
                        <li><a href="#section6" class="toc-link">Typing Search Parameters</a></li>
                        <li><a href="#section7" class="toc-link">Advanced URL State Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Summary and Next Steps</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding URL Query Parameters -->
            <section id="section1" aria-labelledby="section1-title">
                <h2 id="section1-title">üåê Understanding URL Query Parameters</h2>
                <p>URL query parameters (also called search parameters or query strings) are key-value pairs that appear after the <code>?</code> in a URL. They're a powerful way to store and share application state.</p>

                <h3>Anatomy of a URL with Query Parameters</h3>
                <pre><code>https://example.com/products?category=electronics&sort=price&order=asc&page=2
                ‚îÇ                  ‚îÇ        ‚îÇ                                        ‚îÇ
                ‚îÇ                  ‚îÇ        ‚îî‚îÄ Query String (search parameters)
                ‚îÇ                  ‚îî‚îÄ Pathname
                ‚îî‚îÄ Base URL</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Query Parameter Structure</h4>
                    <ul style="color: white;">
                        <li><strong>?</strong> - Separates pathname from query string</li>
                        <li><strong>key=value</strong> - Parameter name and value</li>
                        <li><strong>&</strong> - Separates multiple parameters</li>
                        <li><strong>Encoding</strong> - Special characters are URL-encoded (space = %20)</li>
                    </ul>
                </div>

                <h3>Why Use Query Parameters?</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Benefit</th>
                            <th>Description</th>
                            <th>Example Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Shareable</td>
                            <td>URLs can be copied and shared</td>
                            <td>Share search results with colleagues</td>
                        </tr>
                        <tr>
                            <td>Bookmarkable</td>
                            <td>Users can bookmark specific states</td>
                            <td>Save favorite filter combinations</td>
                        </tr>
                        <tr>
                            <td>Browser History</td>
                            <td>Back/forward buttons work naturally</td>
                            <td>Navigate through search history</td>
                        </tr>
                        <tr>
                            <td>SEO Friendly</td>
                            <td>Search engines can index different states</td>
                            <td>Product listings with filters</td>
                        </tr>
                        <tr>
                            <td>Deep Linking</td>
                            <td>Link directly to specific app states</td>
                            <td>Email notifications with context</td>
                        </tr>
                        <tr>
                            <td>Persistent</td>
                            <td>Survives page refreshes</td>
                            <td>Maintain filters after reload</td>
                        </tr>
                    </tbody>
                </table>

                <h3>URL State vs Component State</h3>
                <div class="mermaid">
                flowchart LR
                    A[Application State] --> B{Should it be in URL?}
                    B -->|Yes| C[URL Parameters]
                    B -->|No| D[Component State]
                    
                    C --> E[Shareable]
                    C --> F[Bookmarkable]
                    C --> G[SEO Indexed]
                    
                    D --> H[Private]
                    D --> I[Temporary]
                    D --> J[Not Shareable]
                    
                    style C fill:#48bb78,color:#fff
                    style D fill:#667eea,color:#fff
                </div>

                <h3>When to Use URL Parameters</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Good Candidates for URL State</h4>
                    <ul>
                        <li><strong>Search queries</strong> - What the user searched for</li>
                        <li><strong>Filters</strong> - Category, price range, ratings</li>
                        <li><strong>Sorting</strong> - Sort field and order</li>
                        <li><strong>Pagination</strong> - Current page number</li>
                        <li><strong>View modes</strong> - List vs grid, expanded vs collapsed</li>
                        <li><strong>Tab selection</strong> - Active tab in multi-tab interfaces</li>
                        <li><strong>Date ranges</strong> - Start and end dates for reports</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ùå Poor Candidates for URL State</h4>
                    <ul>
                        <li><strong>Passwords</strong> - Never put sensitive data in URLs</li>
                        <li><strong>Form input</strong> - Partial form data during editing</li>
                        <li><strong>Temporary UI</strong> - Modal open/closed, hover states</li>
                        <li><strong>Large data</strong> - Entire objects or arrays</li>
                        <li><strong>Private data</strong> - User IDs, session tokens</li>
                        <li><strong>Animation state</strong> - Purely visual, transient states</li>
                    </ul>
                </div>

                <h3>Common Query Parameter Patterns</h3>
                <pre><code class="language-typescript">// Search
/products?q=laptop

// Single filter
/products?category=electronics

// Multiple filters
/products?category=electronics&brand=apple&minPrice=500

// Sorting
/products?sort=price&order=desc

// Pagination
/products?page=2&limit=20

// Combined
/products?q=laptop&category=electronics&sort=price&order=asc&page=1

// Arrays (multiple values for same key)
/products?tags=new&tags=sale&tags=featured
// or
/products?tags=new,sale,featured

// Boolean flags
/products?inStock=true&onSale=true</code></pre>
            </section>

            <!-- Section 2: The useSearchParams Hook -->
            <section id="section2" aria-labelledby="section2-title">
                <h2 id="section2-title">üîß The useSearchParams Hook</h2>
                <p>React Router provides the <code>useSearchParams</code> hook to read and manipulate URL query parameters. It works similarly to <code>useState</code>, but syncs with the URL.</p>

                <h3>Basic useSearchParams Usage</h3>
                <p>The hook returns a tuple: the current search params and a function to update them:</p>

                <pre><code class="language-typescript">import { useSearchParams } from 'react-router-dom';

function SearchExample() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Read a parameter
  const query = searchParams.get('q');
  
  // Read with default value
  const page = searchParams.get('page') || '1';
  
  return (
    &lt;div&gt;
      &lt;p&gt;Search query: {query}&lt;/p&gt;
      &lt;p&gt;Current page: {page}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ SearchParams API</h4>
                    <p style="color: white;">The searchParams object (URLSearchParams) provides:</p>
                    <ul style="color: white;">
                        <li><code>get(key)</code> - Get a single value (or null)</li>
                        <li><code>getAll(key)</code> - Get all values for a key (array)</li>
                        <li><code>has(key)</code> - Check if parameter exists</li>
                        <li><code>set(key, value)</code> - Set a parameter</li>
                        <li><code>delete(key)</code> - Remove a parameter</li>
                        <li><code>toString()</code> - Convert to query string</li>
                    </ul>
                </div>

                <h3>Reading Query Parameters</h3>
                <pre><code class="language-typescript">function ProductList() {
  const [searchParams] = useSearchParams();
  
  // Get single values
  const category = searchParams.get('category'); // "electronics" or null
  const sortBy = searchParams.get('sort'); // "price" or null
  
  // Get with default
  const page = searchParams.get('page') ?? '1';
  const limit = searchParams.get('limit') ?? '10';
  
  // Check existence
  const hasFilters = searchParams.has('category') || searchParams.has('brand');
  
  // Get all values for a key (for arrays)
  const tags = searchParams.getAll('tags'); // ["new", "sale", "featured"]
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Products&lt;/h1&gt;
      {category && &lt;p&gt;Category: {category}&lt;/p&gt;}
      {sortBy && &lt;p&gt;Sorted by: {sortBy}&lt;/p&gt;}
      &lt;p&gt;Page {page} of results&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Setting Query Parameters</h3>
                <p>Update parameters using the setter function:</p>

                <pre><code class="language-typescript">function SearchBar() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [query, setQuery] = useState('');
  
  const handleSearch = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Option 1: Set individual parameter
    setSearchParams({ q: query });
    
    // Option 2: Update existing params
    const newParams = new URLSearchParams(searchParams);
    newParams.set('q', query);
    newParams.set('page', '1'); // Reset to page 1 on new search
    setSearchParams(newParams);
  };
  
  return (
    &lt;form onSubmit={handleSearch}&gt;
      &lt;input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
      /&gt;
      &lt;button type="submit"&gt;Search&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h3>Preserving Existing Parameters</h3>
                <p>When updating parameters, you often want to keep existing ones:</p>

                <pre><code class="language-typescript">function CategoryFilter() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const handleCategoryChange = (category: string) => {
    // Create new URLSearchParams from current params
    const newParams = new URLSearchParams(searchParams);
    
    // Update only the category
    newParams.set('category', category);
    
    // Reset page to 1 when changing filters
    newParams.set('page', '1');
    
    // Apply the updated params
    setSearchParams(newParams);
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={() => handleCategoryChange('electronics')}&gt;
        Electronics
      &lt;/button&gt;
      &lt;button onClick={() => handleCategoryChange('books')}&gt;
        Books
      &lt;/button&gt;
      &lt;button onClick={() => handleCategoryChange('clothing')}&gt;
        Clothing
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Removing Query Parameters</h3>
                <pre><code class="language-typescript">function FilterControls() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const clearCategory = () => {
    const newParams = new URLSearchParams(searchParams);
    newParams.delete('category');
    setSearchParams(newParams);
  };
  
  const clearAllFilters = () => {
    // Remove all filter-related params
    const newParams = new URLSearchParams(searchParams);
    newParams.delete('category');
    newParams.delete('brand');
    newParams.delete('minPrice');
    newParams.delete('maxPrice');
    setSearchParams(newParams);
  };
  
  const resetToDefaults = () => {
    // Start fresh with only specific params
    setSearchParams({ page: '1', limit: '10' });
  };
  
  return (
    &lt;div&gt;
      &lt;button onClick={clearCategory}&gt;Clear Category&lt;/button&gt;
      &lt;button onClick={clearAllFilters}&gt;Clear All Filters&lt;/button&gt;
      &lt;button onClick={resetToDefaults}&gt;Reset&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Replace vs Push Navigation</h3>
                <p>Control whether parameter changes create new history entries:</p>

                <pre><code class="language-typescript">function SearchExample() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const updateSearch = (query: string) => {
    // Default: adds to browser history (can go back)
    setSearchParams({ q: query });
    
    // Replace: doesn't add to history (replaces current entry)
    setSearchParams({ q: query }, { replace: true });
  };
  
  // Use replace for:
  // - Filters (users don't want to click back through each filter)
  // - Pagination (going back shouldn't go page by page)
  // - Real-time updates (like search-as-you-type)
  
  // Use push (default) for:
  // - Explicit search submissions
  // - Navigation between distinct views
  
  return &lt;div&gt;Search Example&lt;/div&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Navigation Behavior Tips</h4>
                    <ul>
                        <li><strong>Use replace for filters</strong> - Users don't want to back through each filter change</li>
                        <li><strong>Use replace for pagination</strong> - Avoid backing through pages</li>
                        <li><strong>Use push for searches</strong> - Allow users to revisit previous searches</li>
                        <li><strong>Be consistent</strong> - Don't mix behaviors for similar actions</li>
                    </ul>
                </div>

                <h3>Working with Multiple Parameters</h3>
                <pre><code class="language-typescript">function AdvancedFilters() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const updateMultipleParams = (updates: Record&lt;string, string&gt;) => {
    const newParams = new URLSearchParams(searchParams);
    
    // Update multiple parameters at once
    Object.entries(updates).forEach(([key, value]) => {
      if (value) {
        newParams.set(key, value);
      } else {
        newParams.delete(key);
      }
    });
    
    setSearchParams(newParams, { replace: true });
  };
  
  const handleFilterSubmit = (filters: {
    category?: string;
    minPrice?: string;
    maxPrice?: string;
    brand?: string;
  }) => {
    updateMultipleParams({
      category: filters.category || '',
      minPrice: filters.minPrice || '',
      maxPrice: filters.maxPrice || '',
      brand: filters.brand || '',
      page: '1' // Reset pagination
    });
  };
  
  return &lt;div&gt;Filters&lt;/div&gt;;
}</code></pre>


                <h3>üèãÔ∏è Exercise: Basic Search Parameters</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Create a simple product search interface that uses URL query parameters.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create a search input that updates the <code>q</code> parameter</li>
                        <li>Display the current search query from the URL</li>
                        <li>Add a "Clear Search" button that removes the <code>q</code> parameter</li>
                        <li>Use replace navigation for the search updates</li>
                        <li>Show "No search query" when the parameter is empty</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use the useSearchParams hook and handle form submission:</p>
                        <pre><code>const [searchParams, setSearchParams] = useSearchParams();
const query = searchParams.get('q') || '';

const handleSubmit = (e: React.FormEvent) => {
  e.preventDefault();
  setSearchParams({ q: inputValue }, { replace: true });
};</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

function ProductSearch() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [inputValue, setInputValue] = useState('');
  
  // Get current search query from URL
  const currentQuery = searchParams.get('q') || '';
  
  // Sync input with URL on mount and when URL changes
  useEffect(() => {
    setInputValue(currentQuery);
  }, [currentQuery]);
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (inputValue.trim()) {
      setSearchParams({ q: inputValue.trim() }, { replace: true });
    }
  };
  
  const handleClear = () => {
    setInputValue('');
    setSearchParams({}, { replace: true });
  };
  
  return (
    &lt;div&gt;
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input
          type="text"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          placeholder="Search products..."
        /&gt;
        &lt;button type="submit"&gt;Search&lt;/button&gt;
        {currentQuery && (
          &lt;button type="button" onClick={handleClear}&gt;
            Clear Search
          &lt;/button&gt;
        )}
      &lt;/form&gt;
      
      &lt;div className="search-status"&gt;
        {currentQuery ? (
          &lt;p&gt;Searching for: &lt;strong&gt;{currentQuery}&lt;/strong&gt;&lt;/p&gt;
        ) : (
          &lt;p&gt;No search query&lt;/p&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 3: Building Search Functionality -->
            <section id="section3" aria-labelledby="section3-title">
                <h2 id="section3-title">üîé Building Search Functionality</h2>
                <p>Let's build a complete search feature that syncs with URL parameters, handles debouncing, and provides a great user experience.</p>

                <h3>Simple Search Implementation</h3>
                <p>A basic search that updates the URL on form submission:</p>

                <pre><code class="language-typescript">// components/SearchBar.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, FormEvent } from 'react';

export function SearchBar() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [query, setQuery] = useState(searchParams.get('q') || '');
  
  const handleSubmit = (e: FormEvent) => {
    e.preventDefault();
    
    if (query.trim()) {
      // Preserve other params, update search
      const newParams = new URLSearchParams(searchParams);
      newParams.set('q', query.trim());
      newParams.set('page', '1'); // Reset to first page
      setSearchParams(newParams);
    } else {
      // Remove search param if empty
      const newParams = new URLSearchParams(searchParams);
      newParams.delete('q');
      setSearchParams(newParams);
    }
  };
  
  const handleClear = () => {
    setQuery('');
    const newParams = new URLSearchParams(searchParams);
    newParams.delete('q');
    setSearchParams(newParams);
  };
  
  return (
    &lt;form onSubmit={handleSubmit} className="search-bar"&gt;
      &lt;input
        type="search"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search..."
        aria-label="Search"
      /&gt;
      &lt;button type="submit"&gt;
        üîç Search
      &lt;/button&gt;
      {query && (
        &lt;button type="button" onClick={handleClear}&gt;
          ‚úï Clear
        &lt;/button&gt;
      )}
    &lt;/form&gt;
  );
}</code></pre>

                <h3>Search with Debouncing</h3>
                <p>Implement search-as-you-type with debouncing to avoid excessive updates:</p>

                <pre><code class="language-typescript">// hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// components/DebouncedSearch.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';
import { useDebounce } from '../hooks/useDebounce';

export function DebouncedSearch() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [query, setQuery] = useState(searchParams.get('q') || '');
  
  // Debounce the query by 500ms
  const debouncedQuery = useDebounce(query, 500);
  
  // Update URL when debounced query changes
  useEffect(() => {
    const newParams = new URLSearchParams(searchParams);
    
    if (debouncedQuery.trim()) {
      newParams.set('q', debouncedQuery.trim());
      newParams.set('page', '1');
    } else {
      newParams.delete('q');
    }
    
    // Use replace to avoid cluttering history
    setSearchParams(newParams, { replace: true });
  }, [debouncedQuery]);
  
  return (
    &lt;div className="search-container"&gt;
      &lt;input
        type="search"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
        placeholder="Search as you type..."
        aria-label="Search"
      /&gt;
      {query !== debouncedQuery && (
        &lt;span className="searching-indicator"&gt;Searching...&lt;/span&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Search Results Component</h3>
                <p>Display results based on the search query from the URL:</p>

                <pre><code class="language-typescript">// pages/SearchResults.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

interface Product {
  id: number;
  name: string;
  category: string;
  price: number;
}

export function SearchResults() {
  const [searchParams] = useSearchParams();
  const query = searchParams.get('q') || '';
  
  const [results, setResults] = useState&lt;Product[]&gt;([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState&lt;string | null&gt;(null);
  
  useEffect(() => {
    if (!query) {
      setResults([]);
      return;
    }
    
    const fetchResults = async () => {
      setIsLoading(true);
      setError(null);
      
      try {
        const response = await fetch(
          `/api/products/search?q=${encodeURIComponent(query)}`
        );
        
        if (!response.ok) {
          throw new Error('Search failed');
        }
        
        const data = await response.json();
        setResults(data.products);
      } catch (err) {
        setError('Failed to load search results');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchResults();
  }, [query]);
  
  if (!query) {
    return (
      &lt;div className="search-empty"&gt;
        &lt;p&gt;Enter a search query to find products&lt;/p&gt;
      &lt;/div&gt;
    );
  }
  
  if (isLoading) {
    return &lt;div className="loading"&gt;Searching...&lt;/div&gt;;
  }
  
  if (error) {
    return &lt;div className="error"&gt;{error}&lt;/div&gt;;
  }
  
  return (
    &lt;div className="search-results"&gt;
      &lt;h2&gt;
        Results for "{query}" ({results.length} found)
      &lt;/h2&gt;
      
      {results.length === 0 ? (
        &lt;div className="no-results"&gt;
          &lt;p&gt;No products found for "{query}"&lt;/p&gt;
          &lt;p&gt;Try a different search term&lt;/p&gt;
        &lt;/div&gt;
      ) : (
        &lt;div className="results-grid"&gt;
          {results.map(product => (
            &lt;div key={product.id} className="product-card"&gt;
              &lt;h3&gt;{product.name}&lt;/h3&gt;
              &lt;p&gt;{product.category}&lt;/p&gt;
              &lt;p className="price"&gt;${product.price}&lt;/p&gt;
            &lt;/div&gt;
          ))}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Search Suggestions</h3>
                <p>Add autocomplete suggestions that appear as the user types:</p>

                <pre><code class="language-typescript">// components/SearchWithSuggestions.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect, useRef } from 'react';

interface Suggestion {
  id: number;
  text: string;
  category: string;
}

export function SearchWithSuggestions() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [query, setQuery] = useState(searchParams.get('q') || '');
  const [suggestions, setSuggestions] = useState&lt;Suggestion[]&gt;([]);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [selectedIndex, setSelectedIndex] = useState(-1);
  const inputRef = useRef&lt;HTMLInputElement&gt;(null);
  
  // Fetch suggestions
  useEffect(() => {
    if (query.length &lt; 2) {
      setSuggestions([]);
      return;
    }
    
    const fetchSuggestions = async () => {
      try {
        const response = await fetch(
          `/api/search/suggestions?q=${encodeURIComponent(query)}`
        );
        const data = await response.json();
        setSuggestions(data.suggestions);
      } catch (err) {
        console.error('Failed to fetch suggestions:', err);
      }
    };
    
    const timeoutId = setTimeout(fetchSuggestions, 300);
    return () => clearTimeout(timeoutId);
  }, [query]);
  
  const handleSubmit = (searchQuery: string) => {
    const newParams = new URLSearchParams(searchParams);
    newParams.set('q', searchQuery.trim());
    newParams.set('page', '1');
    setSearchParams(newParams);
    setShowSuggestions(false);
  };
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (!showSuggestions || suggestions.length === 0) return;
    
    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev &lt; suggestions.length - 1 ? prev + 1 : prev
        );
        break;
      
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => prev &gt; 0 ? prev - 1 : -1);
        break;
      
      case 'Enter':
        e.preventDefault();
        if (selectedIndex &gt;= 0) {
          handleSubmit(suggestions[selectedIndex].text);
        } else {
          handleSubmit(query);
        }
        break;
      
      case 'Escape':
        setShowSuggestions(false);
        break;
    }
  };
  
  return (
    &lt;div className="search-with-suggestions"&gt;
      &lt;input
        ref={inputRef}
        type="search"
        value={query}
        onChange={(e) => {
          setQuery(e.target.value);
          setShowSuggestions(true);
          setSelectedIndex(-1);
        }}
        onFocus={() => setShowSuggestions(true)}
        onBlur={() => setTimeout(() => setShowSuggestions(false), 200)}
        onKeyDown={handleKeyDown}
        placeholder="Search products..."
      /&gt;
      
      {showSuggestions && suggestions.length &gt; 0 && (
        &lt;ul className="suggestions-list"&gt;
          {suggestions.map((suggestion, index) => (
            &lt;li
              key={suggestion.id}
              className={index === selectedIndex ? 'selected' : ''}
              onClick={() => handleSubmit(suggestion.text)}
            &gt;
              &lt;span className="suggestion-text"&gt;{suggestion.text}&lt;/span&gt;
              &lt;span className="suggestion-category"&gt;
                in {suggestion.category}
              &lt;/span&gt;
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Search Implementation Best Practices</h4>
                    <ul>
                        <li><strong>Debounce user input</strong> - Avoid excessive API calls</li>
                        <li><strong>Show loading states</strong> - Let users know search is happening</li>
                        <li><strong>Handle empty results</strong> - Provide helpful messaging</li>
                        <li><strong>URL encode queries</strong> - Handle special characters properly</li>
                        <li><strong>Reset pagination</strong> - Go to page 1 on new search</li>
                        <li><strong>Preserve other filters</strong> - Keep existing parameters when searching</li>
                        <li><strong>Use replace navigation</strong> - Avoid cluttering browser history</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Implementing Filters with URL State -->
            <section id="section4" aria-labelledby="section4-title">
                <h2 id="section4-title">üéõÔ∏è Implementing Filters with URL State</h2>
                <p>Filters are perfect candidates for URL state because users want to share and bookmark filtered views. Let's build a comprehensive filtering system.</p>

                <div class="mermaid">
                flowchart TD
                    A[User Selects Filter] --> B[Update URL Params]
                    B --> C[URL Changes]
                    C --> D[Component Re-renders]
                    D --> E[Read New Params]
                    E --> F[Fetch Filtered Data]
                    F --> G[Display Results]
                    
                    style A fill:#667eea,color:#fff
                    style G fill:#48bb78,color:#fff
                </div>

                <h3>Single Select Filter</h3>
                <p>A dropdown filter for selecting one option:</p>

                <pre><code class="language-typescript">// components/CategoryFilter.tsx
import { useSearchParams } from 'react-router-dom';

interface CategoryFilterProps {
  categories: string[];
}

export function CategoryFilter({ categories }: CategoryFilterProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  const currentCategory = searchParams.get('category') || 'all';
  
  const handleCategoryChange = (category: string) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (category === 'all') {
      newParams.delete('category');
    } else {
      newParams.set('category', category);
    }
    
    // Reset to page 1 when filter changes
    newParams.set('page', '1');
    
    setSearchParams(newParams, { replace: true });
  };
  
  return (
    &lt;div className="category-filter"&gt;
      &lt;label htmlFor="category"&gt;Category:&lt;/label&gt;
      &lt;select
        id="category"
        value={currentCategory}
        onChange={(e) => handleCategoryChange(e.target.value)}
      &gt;
        &lt;option value="all"&gt;All Categories&lt;/option&gt;
        {categories.map(category => (
          &lt;option key={category} value={category}&gt;
            {category}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Multi-Select Filter</h3>
                <p>Allow users to select multiple filter values:</p>

                <pre><code class="language-typescript">// components/BrandFilter.tsx
import { useSearchParams } from 'react-router-dom';

interface BrandFilterProps {
  brands: string[];
}

export function BrandFilter({ brands }: BrandFilterProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Get selected brands from URL
  const selectedBrands = searchParams.getAll('brand');
  
  const handleBrandToggle = (brand: string) => {
    const newParams = new URLSearchParams(searchParams);
    
    // Remove all existing brand params
    newParams.delete('brand');
    
    // Determine new selection
    const newSelection = selectedBrands.includes(brand)
      ? selectedBrands.filter(b => b !== brand) // Remove if selected
      : [...selectedBrands, brand]; // Add if not selected
    
    // Add updated brands
    newSelection.forEach(b => {
      newParams.append('brand', b);
    });
    
    // Reset pagination
    newParams.set('page', '1');
    
    setSearchParams(newParams, { replace: true });
  };
  
  return (
    &lt;div className="brand-filter"&gt;
      &lt;h3&gt;Brands&lt;/h3&gt;
      {brands.map(brand => (
        &lt;label key={brand} className="checkbox-label"&gt;
          &lt;input
            type="checkbox"
            checked={selectedBrands.includes(brand)}
            onChange={() => handleBrandToggle(brand)}
          /&gt;
          {brand}
        &lt;/label&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Range Filter</h3>
                <p>Filter by numeric ranges like price:</p>

                <pre><code class="language-typescript">// components/PriceRangeFilter.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

export function PriceRangeFilter() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const [minPrice, setMinPrice] = useState(
    searchParams.get('minPrice') || ''
  );
  const [maxPrice, setMaxPrice] = useState(
    searchParams.get('maxPrice') || ''
  );
  
  const applyPriceFilter = () => {
    const newParams = new URLSearchParams(searchParams);
    
    if (minPrice) {
      newParams.set('minPrice', minPrice);
    } else {
      newParams.delete('minPrice');
    }
    
    if (maxPrice) {
      newParams.set('maxPrice', maxPrice);
    } else {
      newParams.delete('maxPrice');
    }
    
    newParams.set('page', '1');
    setSearchParams(newParams, { replace: true });
  };
  
  const clearPriceFilter = () => {
    const newParams = new URLSearchParams(searchParams);
    newParams.delete('minPrice');
    newParams.delete('maxPrice');
    setSearchParams(newParams, { replace: true });
    setMinPrice('');
    setMaxPrice('');
  };
  
  return (
    &lt;div className="price-range-filter"&gt;
      &lt;h3&gt;Price Range&lt;/h3&gt;
      &lt;div className="price-inputs"&gt;
        &lt;input
          type="number"
          placeholder="Min"
          value={minPrice}
          onChange={(e) => setMinPrice(e.target.value)}
          min="0"
        /&gt;
        &lt;span&gt;to&lt;/span&gt;
        &lt;input
          type="number"
          placeholder="Max"
          value={maxPrice}
          onChange={(e) => setMaxPrice(e.target.value)}
          min="0"
        /&gt;
      &lt;/div&gt;
      
      &lt;div className="filter-actions"&gt;
        &lt;button onClick={applyPriceFilter}&gt;
          Apply
        &lt;/button&gt;
        &lt;button onClick={clearPriceFilter}&gt;
          Clear
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Boolean Filter</h3>
                <p>Simple on/off filters:</p>

                <pre><code class="language-typescript">// components/AvailabilityFilter.tsx
import { useSearchParams } from 'react-router-dom';

export function AvailabilityFilter() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const inStock = searchParams.get('inStock') === 'true';
  const onSale = searchParams.get('onSale') === 'true';
  
  const toggleFilter = (key: string, currentValue: boolean) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (currentValue) {
      // Turn off - remove parameter
      newParams.delete(key);
    } else {
      // Turn on - set to true
      newParams.set(key, 'true');
    }
    
    newParams.set('page', '1');
    setSearchParams(newParams, { replace: true });
  };
  
  return (
    &lt;div className="availability-filter"&gt;
      &lt;h3&gt;Availability&lt;/h3&gt;
      
      &lt;label className="checkbox-label"&gt;
        &lt;input
          type="checkbox"
          checked={inStock}
          onChange={() => toggleFilter('inStock', inStock)}
        /&gt;
        In Stock Only
      &lt;/label&gt;
      
      &lt;label className="checkbox-label"&gt;
        &lt;input
          type="checkbox"
          checked={onSale}
          onChange={() => toggleFilter('onSale', onSale)}
        /&gt;
        On Sale
      &lt;/label&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Active Filters Display</h3>
                <p>Show currently applied filters with ability to remove them:</p>

                <pre><code class="language-typescript">// components/ActiveFilters.tsx
import { useSearchParams } from 'react-router-dom';

export function ActiveFilters() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const removeFilter = (key: string, value?: string) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (value) {
      // For multi-value params, remove specific value
      const values = searchParams.getAll(key);
      newParams.delete(key);
      values
        .filter(v => v !== value)
        .forEach(v => newParams.append(key, v));
    } else {
      // Remove entire parameter
      newParams.delete(key);
    }
    
    setSearchParams(newParams, { replace: true });
  };
  
  const clearAllFilters = () => {
    // Keep only non-filter params (like page, limit)
    const newParams = new URLSearchParams();
    const page = searchParams.get('page');
    const limit = searchParams.get('limit');
    
    if (page) newParams.set('page', page);
    if (limit) newParams.set('limit', limit);
    
    setSearchParams(newParams, { replace: true });
  };
  
  // Build list of active filters
  const activeFilters: Array&lt;{ key: string; value: string; label: string }&gt; = [];
  
  const category = searchParams.get('category');
  if (category) {
    activeFilters.push({ 
      key: 'category', 
      value: '', 
      label: `Category: ${category}` 
    });
  }
  
  const brands = searchParams.getAll('brand');
  brands.forEach(brand => {
    activeFilters.push({ 
      key: 'brand', 
      value: brand, 
      label: `Brand: ${brand}` 
    });
  });
  
  const minPrice = searchParams.get('minPrice');
  const maxPrice = searchParams.get('maxPrice');
  if (minPrice || maxPrice) {
    const priceLabel = `Price: $${minPrice || '0'} - $${maxPrice || '‚àû'}`;
    activeFilters.push({ 
      key: 'minPrice', 
      value: '', 
      label: priceLabel 
    });
  }
  
  if (activeFilters.length === 0) {
    return null;
  }
  
  return (
    &lt;div className="active-filters"&gt;
      &lt;h3&gt;Active Filters:&lt;/h3&gt;
      &lt;div className="filter-tags"&gt;
        {activeFilters.map((filter, index) => (
          &lt;span key={index} className="filter-tag"&gt;
            {filter.label}
            &lt;button
              onClick={() => removeFilter(filter.key, filter.value)}
              aria-label={`Remove ${filter.label}`}
            &gt;
              ‚úï
            &lt;/button&gt;
          &lt;/span&gt;
        ))}
      &lt;/div&gt;
      
      &lt;button onClick={clearAllFilters} className="clear-all"&gt;
        Clear All Filters
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>


                <h3>Complete Filter Panel</h3>
                <p>Combine all filters into a cohesive filtering interface:</p>

                <pre><code class="language-typescript">// components/FilterPanel.tsx
import { useSearchParams } from 'react-router-dom';
import { CategoryFilter } from './CategoryFilter';
import { BrandFilter } from './BrandFilter';
import { PriceRangeFilter } from './PriceRangeFilter';
import { AvailabilityFilter } from './AvailabilityFilter';
import { ActiveFilters } from './ActiveFilters';

const CATEGORIES = ['Electronics', 'Books', 'Clothing', 'Home & Garden'];
const BRANDS = ['Apple', 'Samsung', 'Sony', 'Nike', 'Adidas'];

export function FilterPanel() {
  const [searchParams] = useSearchParams();
  
  // Count active filters
  const activeFilterCount = Array.from(searchParams.keys())
    .filter(key => !['page', 'limit', 'sort', 'order'].includes(key))
    .length;
  
  return (
    &lt;aside className="filter-panel"&gt;
      &lt;div className="filter-header"&gt;
        &lt;h2&gt;Filters&lt;/h2&gt;
        {activeFilterCount &gt; 0 && (
          &lt;span className="filter-count"&gt;
            {activeFilterCount} active
          &lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;ActiveFilters /&gt;
      
      &lt;div className="filter-sections"&gt;
        &lt;CategoryFilter categories={CATEGORIES} /&gt;
        &lt;BrandFilter brands={BRANDS} /&gt;
        &lt;PriceRangeFilter /&gt;
        &lt;AvailabilityFilter /&gt;
      &lt;/div&gt;
    &lt;/aside&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Filter Implementation Best Practices</h4>
                    <ul>
                        <li><strong>Reset pagination</strong> - Always set page to 1 when filters change</li>
                        <li><strong>Use replace navigation</strong> - Don't create history entries for each filter</li>
                        <li><strong>Show active filters</strong> - Let users see and remove current filters</li>
                        <li><strong>Preserve other params</strong> - Don't lose search query when filtering</li>
                        <li><strong>Handle empty states</strong> - Clear params when filter is removed</li>
                        <li><strong>Provide clear UI</strong> - Make it obvious which filters are active</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: Build Product Filter</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Create a product listing page with multiple filters that sync with URL parameters.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Add a category dropdown filter (single select)</li>
                        <li>Add a price range filter (min and max inputs)</li>
                        <li>Add an "In Stock" checkbox filter</li>
                        <li>Display active filters with ability to remove them</li>
                        <li>Show product count based on applied filters</li>
                        <li>All filters should update the URL and preserve each other</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Structure your filter updates to preserve existing parameters:</p>
                        <pre><code>const updateFilter = (key: string, value: string | null) => {
  const newParams = new URLSearchParams(searchParams);
  
  if (value) {
    newParams.set(key, value);
  } else {
    newParams.delete(key);
  }
  
  newParams.set('page', '1');
  setSearchParams(newParams, { replace: true });
};</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">// See complete implementation in downloadable course files</code></pre>
                    </details>
                </div>
            </section>

            <!-- Section 5: Pagination with Query Parameters -->
            <section id="section5" aria-labelledby="section5-title">
                <h2 id="section5-title">üìÑ Pagination with Query Parameters</h2>
                <p>Pagination is a perfect use case for URL parameters because it allows users to bookmark specific pages and share links to exact result sets.</p>

                <div class="mermaid">
                flowchart LR
                    A[Page 1] -->|?page=2| B[Page 2]
                    B -->|?page=3| C[Page 3]
                    C -->|?page=2| B
                    B -->|?page=1| A
                    
                    style B fill:#667eea,color:#fff
                </div>

                <h3>Basic Pagination Component</h3>
                <pre><code class="language-typescript">// components/Pagination.tsx
import { useSearchParams } from 'react-router-dom';

interface PaginationProps {
  totalPages: number;
  currentPage: number;
}

export function Pagination({ totalPages, currentPage }: PaginationProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const goToPage = (page: number) => {
    const newParams = new URLSearchParams(searchParams);
    newParams.set('page', page.toString());
    setSearchParams(newParams, { replace: true });
  };
  
  const goToNextPage = () => {
    if (currentPage &lt; totalPages) {
      goToPage(currentPage + 1);
    }
  };
  
  const goToPrevPage = () => {
    if (currentPage &gt; 1) {
      goToPage(currentPage - 1);
    }
  };
  
  return (
    &lt;nav className="pagination" aria-label="Pagination"&gt;
      &lt;button
        onClick={goToPrevPage}
        disabled={currentPage === 1}
        aria-label="Previous page"
      &gt;
        ‚Üê Previous
      &lt;/button&gt;
      
      &lt;span className="page-info"&gt;
        Page {currentPage} of {totalPages}
      &lt;/span&gt;
      
      &lt;button
        onClick={goToNextPage}
        disabled={currentPage === totalPages}
        aria-label="Next page"
      &gt;
        Next ‚Üí
      &lt;/button&gt;
    &lt;/nav&gt;
  );
}</code></pre>

                <h3>Advanced Pagination with Page Numbers</h3>
                <pre><code class="language-typescript">// components/AdvancedPagination.tsx
import { useSearchParams } from 'react-router-dom';

interface AdvancedPaginationProps {
  totalPages: number;
  currentPage: number;
  maxVisible?: number; // Maximum page numbers to show
}

export function AdvancedPagination({ 
  totalPages, 
  currentPage,
  maxVisible = 7
}: AdvancedPaginationProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const goToPage = (page: number) => {
    const newParams = new URLSearchParams(searchParams);
    newParams.set('page', page.toString());
    setSearchParams(newParams, { replace: true });
  };
  
  // Calculate which page numbers to show
  const getPageNumbers = () => {
    if (totalPages &lt;= maxVisible) {
      // Show all pages
      return Array.from({ length: totalPages }, (_, i) => i + 1);
    }
    
    const halfVisible = Math.floor(maxVisible / 2);
    let start = currentPage - halfVisible;
    let end = currentPage + halfVisible;
    
    // Adjust if at the beginning
    if (start &lt; 1) {
      start = 1;
      end = maxVisible;
    }
    
    // Adjust if at the end
    if (end &gt; totalPages) {
      end = totalPages;
      start = totalPages - maxVisible + 1;
    }
    
    const pages: Array&lt;number | string&gt; = [];
    
    // Add first page and ellipsis if needed
    if (start &gt; 1) {
      pages.push(1);
      if (start &gt; 2) {
        pages.push('...');
      }
    }
    
    // Add visible pages
    for (let i = start; i &lt;= end; i++) {
      pages.push(i);
    }
    
    // Add ellipsis and last page if needed
    if (end &lt; totalPages) {
      if (end &lt; totalPages - 1) {
        pages.push('...');
      }
      pages.push(totalPages);
    }
    
    return pages;
  };
  
  const pageNumbers = getPageNumbers();
  
  return (
    &lt;nav className="pagination" aria-label="Pagination"&gt;
      &lt;button
        onClick={() => goToPage(currentPage - 1)}
        disabled={currentPage === 1}
        aria-label="Previous page"
      &gt;
        ‚Üê Prev
      &lt;/button&gt;
      
      &lt;div className="page-numbers"&gt;
        {pageNumbers.map((page, index) => {
          if (page === '...') {
            return (
              &lt;span key={`ellipsis-${index}`} className="ellipsis"&gt;
                ...
              &lt;/span&gt;
            );
          }
          
          return (
            &lt;button
              key={page}
              onClick={() => goToPage(page as number)}
              className={currentPage === page ? 'active' : ''}
              aria-label={`Page ${page}`}
              aria-current={currentPage === page ? 'page' : undefined}
            &gt;
              {page}
            &lt;/button&gt;
          );
        })}
      &lt;/div&gt;
      
      &lt;button
        onClick={() => goToPage(currentPage + 1)}
        disabled={currentPage === totalPages}
        aria-label="Next page"
      &gt;
        Next ‚Üí
      &lt;/button&gt;
    &lt;/nav&gt;
  );
}</code></pre>

                <h3>Items Per Page Selector</h3>
                <pre><code class="language-typescript">// components/ItemsPerPage.tsx
import { useSearchParams } from 'react-router-dom';

const PAGE_SIZE_OPTIONS = [10, 20, 50, 100];

export function ItemsPerPage() {
  const [searchParams, setSearchParams] = useSearchParams();
  const currentLimit = parseInt(searchParams.get('limit') || '20');
  
  const handleLimitChange = (limit: number) => {
    const newParams = new URLSearchParams(searchParams);
    newParams.set('limit', limit.toString());
    newParams.set('page', '1'); // Reset to first page
    setSearchParams(newParams, { replace: true });
  };
  
  return (
    &lt;div className="items-per-page"&gt;
      &lt;label htmlFor="limit"&gt;Items per page:&lt;/label&gt;
      &lt;select
        id="limit"
        value={currentLimit}
        onChange={(e) => handleLimitChange(Number(e.target.value))}
      &gt;
        {PAGE_SIZE_OPTIONS.map(size => (
          &lt;option key={size} value={size}&gt;
            {size}
          &lt;/option&gt;
        ))}
      &lt;/select&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Paginated Results Component</h3>
                <pre><code class="language-typescript">// components/PaginatedResults.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';
import { Pagination } from './Pagination';
import { ItemsPerPage } from './ItemsPerPage';

interface Product {
  id: number;
  name: string;
  price: number;
}

interface PaginatedResponse {
  products: Product[];
  totalCount: number;
  page: number;
  limit: number;
}

export function PaginatedResults() {
  const [searchParams] = useSearchParams();
  
  // Get pagination params from URL
  const page = parseInt(searchParams.get('page') || '1');
  const limit = parseInt(searchParams.get('limit') || '20');
  
  const [data, setData] = useState&lt;PaginatedResponse | null&gt;(null);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      
      try {
        // Build query string with all params
        const queryString = searchParams.toString();
        const response = await fetch(`/api/products?${queryString}`);
        const result = await response.json();
        setData(result);
      } catch (error) {
        console.error('Failed to fetch data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchData();
  }, [searchParams]); // Re-fetch when any param changes
  
  if (isLoading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }
  
  if (!data) {
    return &lt;div&gt;No data available&lt;/div&gt;;
  }
  
  const totalPages = Math.ceil(data.totalCount / limit);
  const startItem = (page - 1) * limit + 1;
  const endItem = Math.min(page * limit, data.totalCount);
  
  return (
    &lt;div className="paginated-results"&gt;
      &lt;div className="results-header"&gt;
        &lt;p&gt;
          Showing {startItem}-{endItem} of {data.totalCount} results
        &lt;/p&gt;
        &lt;ItemsPerPage /&gt;
      &lt;/div&gt;
      
      &lt;div className="results-grid"&gt;
        {data.products.map(product => (
          &lt;div key={product.id} className="product-card"&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {totalPages &gt; 1 && (
        &lt;Pagination
          totalPages={totalPages}
          currentPage={page}
        /&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Infinite Scroll with URL State</h3>
                <p>Combine infinite scroll with URL state for the best of both worlds:</p>

                <pre><code class="language-typescript">// components/InfiniteScrollResults.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect, useRef } from 'react';

export function InfiniteScrollResults() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [items, setItems] = useState&lt;Product[]&gt;([]);
  const [hasMore, setHasMore] = useState(true);
  const [isLoading, setIsLoading] = useState(false);
  const observerRef = useRef&lt;HTMLDivElement&gt;(null);
  
  const page = parseInt(searchParams.get('page') || '1');
  
  const loadMore = () => {
    const newParams = new URLSearchParams(searchParams);
    newParams.set('page', (page + 1).toString());
    setSearchParams(newParams, { replace: true });
  };
  
  useEffect(() => {
    const fetchPage = async () => {
      setIsLoading(true);
      
      try {
        const response = await fetch(
          `/api/products?${searchParams.toString()}`
        );
        const data = await response.json();
        
        if (page === 1) {
          // First page - replace items
          setItems(data.products);
        } else {
          // Subsequent pages - append items
          setItems(prev => [...prev, ...data.products]);
        }
        
        setHasMore(data.hasMore);
      } catch (error) {
        console.error('Failed to fetch:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchPage();
  }, [searchParams]);
  
  // Intersection Observer for infinite scroll
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          loadMore();
        }
      },
      { threshold: 0.1 }
    );
    
    if (observerRef.current) {
      observer.observe(observerRef.current);
    }
    
    return () => observer.disconnect();
  }, [hasMore, isLoading, page]);
  
  return (
    &lt;div&gt;
      &lt;div className="results-grid"&gt;
        {items.map(item => (
          &lt;div key={item.id} className="product-card"&gt;
            {/* Product card content */}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
      
      {hasMore && (
        &lt;div ref={observerRef} className="loading-trigger"&gt;
          {isLoading && &lt;div&gt;Loading more...&lt;/div&gt;}
        &lt;/div&gt;
      )}
      
      {!hasMore && items.length &gt; 0 && (
        &lt;p&gt;You've reached the end!&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pagination Best Practices</h4>
                    <ul>
                        <li><strong>Use replace navigation</strong> - Don't clutter history with page changes</li>
                        <li><strong>Reset to page 1</strong> - When filters or search changes</li>
                        <li><strong>Show page info</strong> - Let users know where they are</li>
                        <li><strong>Disable invalid actions</strong> - Prev on page 1, next on last page</li>
                        <li><strong>Make pages bookmarkable</strong> - Users can share links to specific pages</li>
                        <li><strong>Handle edge cases</strong> - What if totalPages changes?</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Typing Search Parameters -->
            <section id="section6" aria-labelledby="section6-title">
                <h2 id="section6-title">üî§ Typing Search Parameters</h2>
                <p>TypeScript helps ensure type safety when working with URL parameters. Let's explore patterns for typing search parameters effectively.</p>

                <h3>Basic Type-Safe Parameter Reading</h3>
                <pre><code class="language-typescript">// Define expected parameters
interface ProductFilters {
  category?: string;
  brand?: string[];
  minPrice?: number;
  maxPrice?: number;
  inStock?: boolean;
  page?: number;
  limit?: number;
}

function useProductFilters(): ProductFilters {
  const [searchParams] = useSearchParams();
  
  return {
    category: searchParams.get('category') || undefined,
    brand: searchParams.getAll('brand'),
    minPrice: searchParams.get('minPrice') 
      ? Number(searchParams.get('minPrice')) 
      : undefined,
    maxPrice: searchParams.get('maxPrice')
      ? Number(searchParams.get('maxPrice'))
      : undefined,
    inStock: searchParams.get('inStock') === 'true' || undefined,
    page: Number(searchParams.get('page')) || 1,
    limit: Number(searchParams.get('limit')) || 20
  };
}</code></pre>

                <h3>Custom Hook for Typed Parameters</h3>
                <pre><code class="language-typescript">// hooks/useTypedSearchParams.ts
import { useSearchParams } from 'react-router-dom';

type ParamValue = string | number | boolean | string[];

interface ParamConfig {
  type: 'string' | 'number' | 'boolean' | 'array';
  default?: ParamValue;
}

type ParamConfigMap = Record&lt;string, ParamConfig&gt;;

type ParsedParams&lt;T extends ParamConfigMap&gt; = {
  [K in keyof T]: T[K]['default'] extends infer D
    ? D extends undefined
      ? T[K]['type'] extends 'string'
        ? string | undefined
        : T[K]['type'] extends 'number'
        ? number | undefined
        : T[K]['type'] extends 'boolean'
        ? boolean | undefined
        : string[]
      : NonNullable&lt;D&gt;
    : never;
};

export function useTypedSearchParams&lt;T extends ParamConfigMap&gt;(
  config: T
): [ParsedParams&lt;T&gt;, (updates: Partial&lt;ParsedParams&lt;T&gt;&gt;) => void] {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Parse parameters based on config
  const parsed = Object.entries(config).reduce((acc, [key, cfg]) => {
    const rawValue = cfg.type === 'array' 
      ? searchParams.getAll(key)
      : searchParams.get(key);
    
    let value: ParamValue | undefined;
    
    if (rawValue === null || (Array.isArray(rawValue) && rawValue.length === 0)) {
      value = cfg.default;
    } else if (cfg.type === 'number') {
      const num = Number(rawValue);
      value = isNaN(num) ? cfg.default : num;
    } else if (cfg.type === 'boolean') {
      value = rawValue === 'true';
    } else {
      value = rawValue as string | string[];
    }
    
    return { ...acc, [key]: value };
  }, {} as ParsedParams&lt;T&gt;);
  
  // Update parameters
  const updateParams = (updates: Partial&lt;ParsedParams&lt;T&gt;&gt;) => {
    const newParams = new URLSearchParams(searchParams);
    
    Object.entries(updates).forEach(([key, value]) => {
      if (value === undefined || value === null) {
        newParams.delete(key);
      } else if (Array.isArray(value)) {
        newParams.delete(key);
        value.forEach(v => newParams.append(key, String(v)));
      } else {
        newParams.set(key, String(value));
      }
    });
    
    setSearchParams(newParams, { replace: true });
  };
  
  return [parsed, updateParams];
}

// Usage
function ProductList() {
  const [filters, setFilters] = useTypedSearchParams({
    category: { type: 'string' },
    brand: { type: 'array', default: [] },
    minPrice: { type: 'number' },
    maxPrice: { type: 'number' },
    inStock: { type: 'boolean', default: false },
    page: { type: 'number', default: 1 },
    limit: { type: 'number', default: 20 }
  });
  
  // filters is fully typed!
  const { category, brand, minPrice, page } = filters;
  
  // Update with type safety
  setFilters({ category: 'electronics', page: 1 });
  
  return &lt;div&gt;Product List&lt;/div&gt;;
}</code></pre>

                <h3>Zod Schema Validation</h3>
                <p>Use Zod for runtime validation of URL parameters:</p>

                <pre><code class="language-typescript">import { z } from 'zod';
import { useSearchParams } from 'react-router-dom';

// Define schema
const ProductFilterSchema = z.object({
  category: z.string().optional(),
  brand: z.array(z.string()).optional(),
  minPrice: z.coerce.number().min(0).optional(),
  maxPrice: z.coerce.number().min(0).optional(),
  inStock: z
    .enum(['true', 'false'])
    .transform(val => val === 'true')
    .optional(),
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20)
});

type ProductFilters = z.infer&lt;typeof ProductFilterSchema&gt;;

function useValidatedFilters(): ProductFilters {
  const [searchParams] = useSearchParams();
  
  const rawParams = {
    category: searchParams.get('category') ?? undefined,
    brand: searchParams.getAll('brand'),
    minPrice: searchParams.get('minPrice') ?? undefined,
    maxPrice: searchParams.get('maxPrice') ?? undefined,
    inStock: searchParams.get('inStock') ?? undefined,
    page: searchParams.get('page') ?? undefined,
    limit: searchParams.get('limit') ?? undefined
  };
  
  // Validate and parse
  const result = ProductFilterSchema.safeParse(rawParams);
  
  if (!result.success) {
    console.error('Invalid URL parameters:', result.error);
    // Return defaults on validation failure
    return ProductFilterSchema.parse({});
  }
  
  return result.data;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Type Safety Tips</h4>
                    <ul>
                        <li><strong>Define interfaces</strong> - Create types for your parameter shapes</li>
                        <li><strong>Validate at runtime</strong> - URL params can be manipulated by users</li>
                        <li><strong>Provide defaults</strong> - Handle missing or invalid parameters</li>
                        <li><strong>Parse carefully</strong> - Convert strings to numbers/booleans safely</li>
                        <li><strong>Use Zod or similar</strong> - Runtime validation with type inference</li>
                    </ul>
                </div>


            </section>

            <!-- Section 7: Advanced URL State Patterns -->
            <section id="section7" aria-labelledby="section7-title">
                <h2 id="section7-title">üé® Advanced URL State Patterns</h2>
                <p>Let's explore sophisticated patterns for managing complex application state through URL parameters.</p>

                <h3>Sorting with URL Parameters</h3>
                <p>Implement sortable columns that sync with the URL:</p>

                <pre><code class="language-typescript">// components/SortableTable.tsx
import { useSearchParams } from 'react-router-dom';

type SortDirection = 'asc' | 'desc';

interface Column {
  key: string;
  label: string;
  sortable?: boolean;
}

interface SortableTableProps {
  columns: Column[];
  data: any[];
}

export function SortableTable({ columns, data }: SortableTableProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const sortBy = searchParams.get('sort') || '';
  const sortOrder = (searchParams.get('order') || 'asc') as SortDirection;
  
  const handleSort = (columnKey: string) => {
    const newParams = new URLSearchParams(searchParams);
    
    // Toggle order if clicking same column
    if (sortBy === columnKey) {
      const newOrder = sortOrder === 'asc' ? 'desc' : 'asc';
      newParams.set('order', newOrder);
    } else {
      // New column, default to ascending
      newParams.set('sort', columnKey);
      newParams.set('order', 'asc');
    }
    
    setSearchParams(newParams, { replace: true });
  };
  
  // Sort data based on URL params
  const sortedData = [...data].sort((a, b) => {
    if (!sortBy) return 0;
    
    const aValue = a[sortBy];
    const bValue = b[sortBy];
    
    if (aValue &lt; bValue) return sortOrder === 'asc' ? -1 : 1;
    if (aValue &gt; bValue) return sortOrder === 'asc' ? 1 : -1;
    return 0;
  });
  
  return (
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          {columns.map(column => (
            &lt;th key={column.key}&gt;
              {column.sortable ? (
                &lt;button
                  onClick={() => handleSort(column.key)}
                  className={sortBy === column.key ? 'active' : ''}
                &gt;
                  {column.label}
                  {sortBy === column.key && (
                    &lt;span&gt;{sortOrder === 'asc' ? ' ‚Üë' : ' ‚Üì'}&lt;/span&gt;
                  )}
                &lt;/button&gt;
              ) : (
                column.label
              )}
            &lt;/th&gt;
          ))}
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        {sortedData.map((row, index) => (
          &lt;tr key={index}&gt;
            {columns.map(column => (
              &lt;td key={column.key}&gt;{row[column.key]}&lt;/td&gt;
            ))}
          &lt;/tr&gt;
        ))}
      &lt;/tbody&gt;
    &lt;/table&gt;
  );
}</code></pre>

                <h3>Tab Navigation with URL State</h3>
                <p>Keep active tab in the URL for bookmarkable tab states:</p>

                <pre><code class="language-typescript">// components/TabbedInterface.tsx
import { useSearchParams } from 'react-router-dom';

interface Tab {
  id: string;
  label: string;
  content: React.ReactNode;
}

interface TabbedInterfaceProps {
  tabs: Tab[];
  defaultTab?: string;
}

export function TabbedInterface({ tabs, defaultTab }: TabbedInterfaceProps) {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const activeTab = searchParams.get('tab') || defaultTab || tabs[0].id;
  
  const setActiveTab = (tabId: string) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (tabId === defaultTab || tabId === tabs[0].id) {
      newParams.delete('tab');
    } else {
      newParams.set('tab', tabId);
    }
    
    setSearchParams(newParams, { replace: true });
  };
  
  const activeTabContent = tabs.find(tab => tab.id === activeTab)?.content;
  
  return (
    &lt;div className="tabbed-interface"&gt;
      &lt;div className="tab-buttons" role="tablist"&gt;
        {tabs.map(tab => (
          &lt;button
            key={tab.id}
            role="tab"
            aria-selected={activeTab === tab.id}
            aria-controls={`panel-${tab.id}`}
            onClick={() => setActiveTab(tab.id)}
            className={activeTab === tab.id ? 'active' : ''}
          &gt;
            {tab.label}
          &lt;/button&gt;
        ))}
      &lt;/div&gt;
      
      &lt;div
        role="tabpanel"
        id={`panel-${activeTab}`}
        className="tab-content"
      &gt;
        {activeTabContent}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Usage
function UserProfile() {
  const tabs = [
    { id: 'overview', label: 'Overview', content: &lt;Overview /&gt; },
    { id: 'posts', label: 'Posts', content: &lt;Posts /&gt; },
    { id: 'settings', label: 'Settings', content: &lt;Settings /&gt; }
  ];
  
  return &lt;TabbedInterface tabs={tabs} defaultTab="overview" /&gt;;
}</code></pre>

                <h3>View Mode Toggle</h3>
                <p>Switch between different view modes (grid/list) using URL state:</p>

                <pre><code class="language-typescript">// components/ViewModeToggle.tsx
import { useSearchParams } from 'react-router-dom';

type ViewMode = 'grid' | 'list';

export function ViewModeToggle() {
  const [searchParams, setSearchParams] = useSearchParams();
  const view = (searchParams.get('view') || 'grid') as ViewMode;
  
  const setViewMode = (mode: ViewMode) => {
    const newParams = new URLSearchParams(searchParams);
    
    if (mode === 'grid') {
      newParams.delete('view'); // Default, no need to store
    } else {
      newParams.set('view', mode);
    }
    
    setSearchParams(newParams, { replace: true });
  };
  
  return (
    &lt;div className="view-mode-toggle"&gt;
      &lt;button
        onClick={() => setViewMode('grid')}
        className={view === 'grid' ? 'active' : ''}
        aria-label="Grid view"
      &gt;
        ‚äû Grid
      &lt;/button&gt;
      &lt;button
        onClick={() => setViewMode('list')}
        className={view === 'list' ? 'active' : ''}
        aria-label="List view"
      &gt;
        ‚ò∞ List
      &lt;/button&gt;
    &lt;/div&gt;
  );
}

// Using the view mode
function ProductGrid() {
  const [searchParams] = useSearchParams();
  const view = searchParams.get('view') || 'grid';
  
  return (
    &lt;div className={`products-${view}`}&gt;
      {/* Products rendered based on view mode */}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Date Range Picker with URL State</h3>
                <pre><code class="language-typescript">// components/DateRangePicker.tsx
import { useSearchParams } from 'react-router-dom';
import { useState } from 'react';

export function DateRangePicker() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const [startDate, setStartDate] = useState(
    searchParams.get('startDate') || ''
  );
  const [endDate, setEndDate] = useState(
    searchParams.get('endDate') || ''
  );
  
  const applyDateRange = () => {
    const newParams = new URLSearchParams(searchParams);
    
    if (startDate) {
      newParams.set('startDate', startDate);
    } else {
      newParams.delete('startDate');
    }
    
    if (endDate) {
      newParams.set('endDate', endDate);
    } else {
      newParams.delete('endDate');
    }
    
    newParams.set('page', '1');
    setSearchParams(newParams, { replace: true });
  };
  
  const clearDates = () => {
    const newParams = new URLSearchParams(searchParams);
    newParams.delete('startDate');
    newParams.delete('endDate');
    setSearchParams(newParams, { replace: true });
    setStartDate('');
    setEndDate('');
  };
  
  return (
    &lt;div className="date-range-picker"&gt;
      &lt;label&gt;
        Start Date:
        &lt;input
          type="date"
          value={startDate}
          onChange={(e) => setStartDate(e.target.value)}
        /&gt;
      &lt;/label&gt;
      
      &lt;label&gt;
        End Date:
        &lt;input
          type="date"
          value={endDate}
          onChange={(e) => setEndDate(e.target.value)}
        /&gt;
      &lt;/label&gt;
      
      &lt;button onClick={applyDateRange}&gt;Apply&lt;/button&gt;
      &lt;button onClick={clearDates}&gt;Clear&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Syncing State Between URL and Component</h3>
                <p>Handle complex state synchronization patterns:</p>

                <pre><code class="language-typescript">// hooks/useSyncedState.ts
import { useState, useEffect } from 'react';
import { useSearchParams } from 'react-router-dom';

export function useSyncedState&lt;T&gt;(
  paramKey: string,
  defaultValue: T,
  serialize: (value: T) => string,
  deserialize: (value: string) => T
): [T, (value: T) => void] {
  const [searchParams, setSearchParams] = useSearchParams();
  
  // Initialize from URL or default
  const [state, setState] = useState&lt;T&gt;(() => {
    const urlValue = searchParams.get(paramKey);
    return urlValue ? deserialize(urlValue) : defaultValue;
  });
  
  // Sync URL changes back to state
  useEffect(() => {
    const urlValue = searchParams.get(paramKey);
    if (urlValue) {
      const deserialized = deserialize(urlValue);
      setState(deserialized);
    }
  }, [searchParams, paramKey]);
  
  // Update both state and URL
  const updateState = (newValue: T) => {
    setState(newValue);
    
    const newParams = new URLSearchParams(searchParams);
    const serialized = serialize(newValue);
    
    if (serialized === serialize(defaultValue)) {
      newParams.delete(paramKey);
    } else {
      newParams.set(paramKey, serialized);
    }
    
    setSearchParams(newParams, { replace: true });
  };
  
  return [state, updateState];
}

// Usage
function FilteredList() {
  // Sync array of selected items
  const [selectedItems, setSelectedItems] = useSyncedState&lt;string[]&gt;(
    'items',
    [],
    (items) => items.join(','),
    (str) => str ? str.split(',') : []
  );
  
  // Sync complex object
  const [filters, setFilters] = useSyncedState&lt;{min: number; max: number}&gt;(
    'priceRange',
    { min: 0, max: 1000 },
    (obj) => JSON.stringify(obj),
    (str) => JSON.parse(str)
  );
  
  return &lt;div&gt;Filtered List&lt;/div&gt;;
}</code></pre>

                <h3>Complete Product Listing Example</h3>
                <p>Putting it all together - a complete product listing with search, filters, sorting, and pagination:</p>

                <pre><code class="language-typescript">// pages/ProductListing.tsx
import { useSearchParams } from 'react-router-dom';
import { useState, useEffect } from 'react';

interface Product {
  id: number;
  name: string;
  category: string;
  brand: string;
  price: number;
  inStock: boolean;
}

export function ProductListing() {
  const [searchParams, setSearchParams] = useSearchParams();
  const [products, setProducts] = useState&lt;Product[]&gt;([]);
  const [totalCount, setTotalCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);
  
  // Extract all parameters
  const filters = {
    q: searchParams.get('q') || '',
    category: searchParams.get('category') || '',
    brand: searchParams.getAll('brand'),
    minPrice: Number(searchParams.get('minPrice')) || undefined,
    maxPrice: Number(searchParams.get('maxPrice')) || undefined,
    inStock: searchParams.get('inStock') === 'true',
    sort: searchParams.get('sort') || 'name',
    order: searchParams.get('order') || 'asc',
    page: Number(searchParams.get('page')) || 1,
    limit: Number(searchParams.get('limit')) || 20,
    view: searchParams.get('view') || 'grid'
  };
  
  // Fetch products when params change
  useEffect(() => {
    const fetchProducts = async () => {
      setIsLoading(true);
      
      try {
        const queryString = searchParams.toString();
        const response = await fetch(`/api/products?${queryString}`);
        const data = await response.json();
        
        setProducts(data.products);
        setTotalCount(data.totalCount);
      } catch (error) {
        console.error('Failed to fetch products:', error);
      } finally {
        setIsLoading(false);
      }
    };
    
    fetchProducts();
  }, [searchParams]);
  
  const totalPages = Math.ceil(totalCount / filters.limit);
  
  return (
    &lt;div className="product-listing"&gt;
      {/* Search Bar */}
      &lt;SearchBar /&gt;
      
      &lt;div className="listing-layout"&gt;
        {/* Sidebar with filters */}
        &lt;aside className="filters"&gt;
          &lt;FilterPanel /&gt;
        &lt;/aside&gt;
        
        {/* Main content */}
        &lt;main&gt;
          {/* Toolbar */}
          &lt;div className="toolbar"&gt;
            &lt;div className="results-info"&gt;
              {totalCount} products found
            &lt;/div&gt;
            
            &lt;div className="toolbar-controls"&gt;
              &lt;SortDropdown /&gt;
              &lt;ViewModeToggle /&gt;
              &lt;ItemsPerPage /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
          
          {/* Active filters */}
          &lt;ActiveFilters /&gt;
          
          {/* Loading state */}
          {isLoading && &lt;LoadingSpinner /&gt;}
          
          {/* Products */}
          {!isLoading && (
            &lt;div className={`products-${filters.view}`}&gt;
              {products.map(product => (
                &lt;ProductCard key={product.id} product={product} /&gt;
              ))}
            &lt;/div&gt;
          )}
          
          {/* No results */}
          {!isLoading && products.length === 0 && (
            &lt;div className="no-results"&gt;
              &lt;p&gt;No products found&lt;/p&gt;
              &lt;button onClick={() => setSearchParams({})}&gt;
                Clear all filters
              &lt;/button&gt;
            &lt;/div&gt;
          )}
          
          {/* Pagination */}
          {totalPages &gt; 1 && (
            &lt;Pagination
              currentPage={filters.page}
              totalPages={totalPages}
            /&gt;
          )}
        &lt;/main&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Advanced Pattern Best Practices</h4>
                    <ul>
                        <li><strong>Keep URLs clean</strong> - Use defaults, remove params that match defaults</li>
                        <li><strong>Handle all edge cases</strong> - Invalid values, missing params, etc.</li>
                        <li><strong>Sync carefully</strong> - Avoid infinite loops when syncing URL and state</li>
                        <li><strong>Test sharing</strong> - Verify URLs work when shared or bookmarked</li>
                        <li><strong>Consider SEO</strong> - Use meaningful parameter names</li>
                        <li><strong>Document behavior</strong> - Make it clear what params do</li>
                    </ul>
                </div>

                <h3>üèãÔ∏è Exercise: Complete Search & Filter System</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p>Build a full-featured product listing page with all URL state features.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Search input with debouncing</li>
                        <li>Category filter (single select dropdown)</li>
                        <li>Price range filter (min/max inputs)</li>
                        <li>Sort by name or price (with asc/desc)</li>
                        <li>Pagination (with items per page selector)</li>
                        <li>View mode toggle (grid/list)</li>
                        <li>Active filters display with remove buttons</li>
                        <li>All state synced to URL parameters</li>
                        <li>Proper TypeScript typing throughout</li>
                    </ol>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Break it down into components and reuse the patterns we've learned:</p>
                        <ul>
                            <li>SearchBar component with useDebounce</li>
                            <li>Filter components that update URLSearchParams</li>
                            <li>Main page component that reads all params and fetches data</li>
                        </ul>
                    </details>
                </div>
            </section>

            <!-- Section 8: Summary and Next Steps -->
            <section id="section8" aria-labelledby="section8-title">
                <h2 id="section8-title">üéØ Summary and Next Steps</h2>
                
                <h3>What You've Learned</h3>
                <p>In this lesson, you've mastered URL query parameters and state management:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìö Key Concepts Covered</h4>
                    <ul style="color: white;">
                        <li><strong>URL Query Parameters</strong> - Understanding structure and benefits</li>
                        <li><strong>useSearchParams Hook</strong> - Reading and writing URL parameters</li>
                        <li><strong>Search Implementation</strong> - Building search with debouncing and suggestions</li>
                        <li><strong>Filter Systems</strong> - Single, multi, range, and boolean filters</li>
                        <li><strong>Pagination</strong> - Page navigation and items per page</li>
                        <li><strong>TypeScript Typing</strong> - Type-safe parameter handling</li>
                        <li><strong>Advanced Patterns</strong> - Sorting, tabs, view modes, date ranges</li>
                        <li><strong>State Synchronization</strong> - Keeping URL and component state in sync</li>
                    </ul>
                </div>

                <h3>Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>URL Pattern</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Search</td>
                            <td>?q=laptop</td>
                            <td>User search queries</td>
                        </tr>
                        <tr>
                            <td>Single Filter</td>
                            <td>?category=electronics</td>
                            <td>Dropdown selections</td>
                        </tr>
                        <tr>
                            <td>Multi Filter</td>
                            <td>?brand=apple&brand=samsung</td>
                            <td>Checkbox selections</td>
                        </tr>
                        <tr>
                            <td>Range</td>
                            <td>?minPrice=100&maxPrice=500</td>
                            <td>Price, date ranges</td>
                        </tr>
                        <tr>
                            <td>Pagination</td>
                            <td>?page=2&limit=20</td>
                            <td>Paged results</td>
                        </tr>
                        <tr>
                            <td>Sorting</td>
                            <td>?sort=price&order=desc</td>
                            <td>Sortable lists</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Common Patterns Cheat Sheet</h3>
                <pre><code class="language-typescript">// Read a parameter
const query = searchParams.get('q') || '';

// Set a parameter
const newParams = new URLSearchParams(searchParams);
newParams.set('category', 'electronics');
setSearchParams(newParams, { replace: true });

// Delete a parameter
newParams.delete('category');

// Multiple values
const brands = searchParams.getAll('brand');

// Set multiple values
brands.forEach(b => newParams.append('brand', b));

// Type-safe reading
const page = Number(searchParams.get('page')) || 1;
const inStock = searchParams.get('inStock') === 'true';</code></pre>

                <h3>Best Practices Checklist</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ URL Parameter Checklist</h4>
                    <ul>
                        <li>‚úÖ Use meaningful parameter names (q, category, not x, y)</li>
                        <li>‚úÖ Validate and sanitize all URL parameters</li>
                        <li>‚úÖ Provide sensible defaults for missing params</li>
                        <li>‚úÖ Use replace: true for filters to avoid history clutter</li>
                        <li>‚úÖ Reset pagination when filters change</li>
                        <li>‚úÖ Make URLs shareable and bookmarkable</li>
                        <li>‚úÖ Remove default values from URL to keep it clean</li>
                        <li>‚úÖ Type parameters properly with TypeScript</li>
                        <li>‚úÖ Debounce rapid updates (search as you type)</li>
                        <li>‚úÖ Test URLs work when shared or refreshed</li>
                    </ul>
                </div>

                <h3>Performance Tips</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>‚ö° Optimization Strategies</h4>
                    <ul>
                        <li><strong>Debounce search input</strong> - Avoid excessive API calls</li>
                        <li><strong>Use replace navigation</strong> - Don't create history entries for filters</li>
                        <li><strong>Memoize URL parsing</strong> - Cache expensive parameter parsing</li>
                        <li><strong>Batch parameter updates</strong> - Update multiple params at once</li>
                        <li><strong>Lazy load filter options</strong> - Don't load all brands upfront</li>
                        <li><strong>Consider URL length</strong> - Very long URLs may cause issues</li>
                    </ul>
                </div>

                <h3>Next Lesson Preview</h3>
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üîú Coming Up: Lesson 6.5 - Layout Routes</h4>
                    <p style="color: white;">In the next lesson, you'll learn:</p>
                    <ul style="color: white;">
                        <li>Creating shared layouts with Outlet</li>
                        <li>Nested route structures</li>
                        <li>Persistent navigation and headers</li>
                        <li>Layout composition patterns</li>
                        <li>Multi-layout applications</li>
                        <li>Building professional app structures</li>
                    </ul>
                </div>

                <h3>Practice Projects</h3>
                <ol>
                    <li>
                        <strong>Job Board with Filters</strong>
                        <ul>
                            <li>Search by job title and keywords</li>
                            <li>Filter by location, salary range, job type</li>
                            <li>Sort by date posted, salary, relevance</li>
                            <li>Pagination with adjustable results per page</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Movie Database Browser</strong>
                        <ul>
                            <li>Search movies by title</li>
                            <li>Filter by genre, year, rating</li>
                            <li>Sort by popularity, rating, release date</li>
                            <li>Grid/list view toggle</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Real Estate Listings</strong>
                        <ul>
                            <li>Search by location</li>
                            <li>Filter by price, bedrooms, property type</li>
                            <li>Map/list view modes</li>
                            <li>Save searches with shareable URLs</li>
                        </ul>
                    </li>
                </ol>

                <h3>Additional Resources</h3>
                <ul>
                    <li><a href="https://reactrouter.com/en/main/hooks/use-search-params" target="_blank">React Router: useSearchParams</a></li>
                    <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank">MDN: URLSearchParams API</a></li>
                    <li><a href="https://web.dev/urlpattern/" target="_blank">Web.dev: URLPattern API</a></li>
                    <li><a href="https://github.com/colinhacks/zod" target="_blank">Zod: TypeScript Schema Validation</a></li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéâ Congratulations!</h4>
                    <p>You've completed Lesson 6.4 and now have comprehensive knowledge of URL state management. You can:</p>
                    <ul>
                        <li>‚úÖ Build powerful search functionality</li>
                        <li>‚úÖ Implement complex filter systems</li>
                        <li>‚úÖ Create paginated result lists</li>
                        <li>‚úÖ Handle sorting and view modes</li>
                        <li>‚úÖ Type URL parameters safely with TypeScript</li>
                        <li>‚úÖ Build shareable and bookmarkable application states</li>
                    </ul>
                    <p><strong>Ready to build professional layouts? Let's continue to the final routing lesson!</strong></p>
                </div>
            </section>

        </div>
    </main>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_6_3_route_protection_loading.html" class="prev-lesson">
            <span class="nav-label">‚Üê Previous Lesson</span>
            <span class="nav-title">Route Protection and Loading</span>
        </a>
        <a href="index.html" class="home-link">
            <span class="nav-label">Home</span>
            <span class="nav-title">All Modules</span>
        </a>
        <a href="lesson_6_5_layout_routes.html" class="next-lesson">
            <span class="nav-label">Next Lesson ‚Üí</span>
            <span class="nav-title">Layout Routes</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="#">Course Resources</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
