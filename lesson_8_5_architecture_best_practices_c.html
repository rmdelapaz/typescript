            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>üèãÔ∏è Hands-On Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Refactor a Monolithic Component</h3>
                    <p><strong>Goal:</strong> Take a component that's doing too much and refactor it using proper architectural patterns.</p>
                    
                    <p><strong>Starting Point:</strong></p>
                    <pre><code class="language-typescript">// ‚ùå This component has multiple problems
function ProductDashboard() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [cart, setCart] = useState([]);
  const [search, setSearch] = useState('');
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data);
        setLoading(false);
      });
  }, []);
  
  const addToCart = (product) => {
    const tax = product.price * 0.08;
    const total = product.price + tax;
    setCart([...cart, { ...product, tax, total }]);
    
    fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId: product.id })
    });
  };
  
  const filteredProducts = products.filter(p => 
    p.name.toLowerCase().includes(search.toLowerCase())
  );
  
  return (
    &lt;div&gt;
      &lt;input 
        value={search} 
        onChange={(e) => setSearch(e.target.value)} 
      /&gt;
      {loading ? 'Loading...' : (
        filteredProducts.map(product => (
          &lt;div key={product.id}&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
            &lt;button onClick={() => addToCart(product)}&gt;
              Add to Cart
            &lt;/button&gt;
          &lt;/div&gt;
        ))
      )}
    &lt;/div&gt;
  );
}</code></pre>

                    <p><strong>Your Task:</strong></p>
                    <ol>
                        <li>Create a service layer for API calls (<code>productService.ts</code>, <code>cartService.ts</code>)</li>
                        <li>Extract business logic into custom hooks (<code>useProducts</code>, <code>useCart</code>)</li>
                        <li>Break into smaller components (<code>ProductList</code>, <code>ProductCard</code>, <code>SearchBar</code>)</li>
                        <li>Add proper TypeScript types</li>
                        <li>Implement error handling</li>
                        <li>Use React Query for data fetching</li>
                    </ol>

                    <details>
                        <summary>üí° Hint #1: Architecture Structure</summary>
                        <pre><code class="language-typescript">// Structure to aim for:
// services/productService.ts
// services/cartService.ts
// hooks/useProducts.ts
// hooks/useCart.ts
// components/ProductDashboard.tsx (orchestrator)
// components/ProductList.tsx (presentational)
// components/ProductCard.tsx (presentational)
// components/SearchBar.tsx (presentational)</code></pre>
                    </details>

                    <details>
                        <summary>üí° Hint #2: Service Layer</summary>
                        <pre><code class="language-typescript">// services/productService.ts
export const productService = {
  async getAll(): Promise&lt;Product[]&gt; {
    const response = await apiClient.get('/api/products');
    return response.data;
  }
};

// services/cartService.ts
export const cartService = {
  async addItem(productId: string): Promise&lt;CartItem&gt; {
    const response = await apiClient.post('/api/cart', { productId });
    return response.data;
  }
};</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution Outline</summary>
                        <p>Your refactored solution should have:</p>
                        <ul>
                            <li><strong>Services:</strong> Clean API abstractions</li>
                            <li><strong>Hooks:</strong> useProducts (with React Query), useCart (with business logic)</li>
                            <li><strong>Components:</strong> ProductDashboard (orchestrator), ProductList (receives data), ProductCard (pure UI), SearchBar (controlled input)</li>
                            <li><strong>Types:</strong> Product, CartItem, AddToCartDto interfaces</li>
                            <li><strong>Error Handling:</strong> Try-catch in handlers, Error Boundary around dashboard</li>
                        </ul>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Design a Feature Module</h3>
                    <p><strong>Goal:</strong> Create a complete feature module following best practices for folder structure and organization.</p>
                    
                    <p><strong>Scenario:</strong> You're building a "Comments" feature for a blog application. Users should be able to:</p>
                    <ul>
                        <li>View comments on a post</li>
                        <li>Add new comments</li>
                        <li>Edit their own comments</li>
                        <li>Delete their own comments</li>
                        <li>Reply to comments (nested)</li>
                    </ul>

                    <p><strong>Your Task:</strong></p>
                    <ol>
                        <li>Design the folder structure for <code>features/comments/</code></li>
                        <li>Define TypeScript types and interfaces</li>
                        <li>Create the service layer</li>
                        <li>Design custom hooks</li>
                        <li>Plan component hierarchy</li>
                        <li>Create the public API (index.ts)</li>
                    </ol>

                    <details>
                        <summary>üí° Hint: Folder Structure</summary>
                        <pre><code class="language-bash">features/comments/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ CommentList/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommentList.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CommentList.test.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CommentList.module.css
‚îÇ   ‚îú‚îÄ‚îÄ CommentItem/
‚îÇ   ‚îú‚îÄ‚îÄ CommentForm/
‚îÇ   ‚îî‚îÄ‚îÄ CommentReply/
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useComments.ts
‚îÇ   ‚îú‚îÄ‚îÄ useAddComment.ts
‚îÇ   ‚îú‚îÄ‚îÄ useUpdateComment.ts
‚îÇ   ‚îî‚îÄ‚îÄ useDeleteComment.ts
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ commentService.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ comment.types.ts
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ commentHelpers.ts
‚îî‚îÄ‚îÄ index.ts</code></pre>
                    </details>

                    <details>
                        <summary>‚úÖ Solution Checklist</summary>
                        <ul>
                            <li>‚úÖ Types defined (Comment, CreateCommentDto, UpdateCommentDto)</li>
                            <li>‚úÖ Service with all CRUD operations</li>
                            <li>‚úÖ Custom hooks using React Query</li>
                            <li>‚úÖ Component hierarchy planned (List > Item > Form/Reply)</li>
                            <li>‚úÖ Error handling strategy defined</li>
                            <li>‚úÖ Public API exports only what's needed</li>
                            <li>‚úÖ Optimistic updates for better UX</li>
                        </ul>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Implement Error Handling Strategy</h3>
                    <p><strong>Goal:</strong> Add comprehensive error handling to an existing feature.</p>
                    
                    <p><strong>Scenario:</strong> You have a user authentication feature that currently has no error handling. Add proper error handling at all layers.</p>

                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create custom error classes (AuthError, ValidationError, NetworkError)</li>
                        <li>Add error interceptor to axios</li>
                        <li>Implement Error Boundary for the auth pages</li>
                        <li>Add try-catch blocks in components</li>
                        <li>Show user-friendly error messages</li>
                        <li>Log errors to console (simulate error tracking service)</li>
                    </ol>

                    <details>
                        <summary>üí° Hint: Error Class Hierarchy</summary>
                        <pre><code class="language-typescript">class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number
  ) {
    super(message);
  }
}

class AuthError extends AppError {
  constructor(message: string) {
    super(message, 'AUTH_ERROR', 401);
  }
}

// Handle in component:
try {
  await login(credentials);
} catch (error) {
  if (error instanceof AuthError) {
    setError('Invalid email or password');
  } else if (error instanceof NetworkError) {
    setError('Connection failed. Please try again.');
  } else {
    setError('An unexpected error occurred');
  }
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Quiz Section -->
            <section id="quiz">
                <h2>üß† Knowledge Check Quiz</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 1: Separation of Concerns</h3>
                    <p>What are the three main layers in a well-architected React application, and what is each responsible for?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>Presentation Layer (Components):</strong> Handles rendering UI and user interactions. Components should be focused on display logic only, not business rules or data fetching.</li>
                                <li><strong>Business Logic Layer (Custom Hooks):</strong> Contains application logic, calculations, validations, and state management. This is where you implement business rules and domain logic.</li>
                                <li><strong>Data Access Layer (Services):</strong> Handles all external communication like API calls, localStorage, or other data sources. Services provide a clean abstraction for data operations.</li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 2: Component Types</h3>
                    <p>What's the difference between Container Components and Presentational Components? When should you use each?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <p><strong>Container Components (Smart Components):</strong></p>
                            <ul>
                                <li>Manage state and side effects</li>
                                <li>Connect to data sources (hooks, context, stores)</li>
                                <li>Contain business logic</li>
                                <li>Pass data down to presentational components</li>
                                <li><strong>Use when:</strong> You need to fetch data, manage state, or implement business logic</li>
                            </ul>
                            <p><strong>Presentational Components (Dumb Components):</strong></p>
                            <ul>
                                <li>Receive data only through props</li>
                                <li>Focus purely on UI rendering</li>
                                <li>No state or side effects</li>
                                <li>Highly reusable and testable</li>
                                <li><strong>Use when:</strong> You need a reusable UI component that just displays data</li>
                            </ul>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 3: Folder Structure</h3>
                    <p>Why is a feature-based folder structure better than organizing by file type (components/, hooks/, services/)? Give at least three reasons.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>Scalability:</strong> As the app grows, feature folders don't become cluttered. Each feature is self-contained.</li>
                                <li><strong>Maintainability:</strong> All related code lives together, making it easier to understand and modify a feature.</li>
                                <li><strong>Team Collaboration:</strong> Different teams can work on different features without conflicts.</li>
                                <li><strong>Code Ownership:</strong> Clear boundaries make it obvious who owns what code.</li>
                                <li><strong>Easier Refactoring:</strong> Features can be moved, removed, or extracted as complete units.</li>
                                <li><strong>Better Imports:</strong> Features export a public API through index.ts, hiding implementation details.</li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 4: Service Layer</h3>
                    <p>What should go in a service layer, and what should NOT go there?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Should go in services:</strong></p>
                            <ul>
                                <li>API calls (GET, POST, PUT, DELETE)</li>
                                <li>Request/response transformation (if needed)</li>
                                <li>HTTP configuration (headers, auth tokens)</li>
                                <li>Basic error throwing</li>
                            </ul>
                            <p><strong>Should NOT go in services:</strong></p>
                            <ul>
                                <li>Business logic (calculations, validations)</li>
                                <li>React state updates</li>
                                <li>Component dependencies</li>
                                <li>UI logic or rendering</li>
                                <li>Direct access to React hooks</li>
                            </ul>
                            <p><strong>Principle:</strong> Services should be pure data access - they communicate with external systems and return/send data, nothing more.</p>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 5: Custom Hooks</h3>
                    <p>When should you create a custom hook? Give an example of logic that belongs in a custom hook vs logic that should stay in a component.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Create a custom hook when:</strong></p>
                            <ul>
                                <li>Logic is used in multiple components</li>
                                <li>Logic involves multiple React hooks</li>
                                <li>Logic contains business rules</li>
                                <li>You want to test logic independently</li>
                                <li>Logic manages complex state</li>
                            </ul>
                            <p><strong>Example - Belongs in Custom Hook:</strong></p>
                            <pre><code>// useShoppingCart.ts
- Calculate cart totals
- Add/remove items logic
- Cart state management
- Business rules (max items, etc.)</code></pre>
                            <p><strong>Example - Stay in Component:</strong></p>
                            <pre><code>// Component
- Button click handlers that just call hooks
- Simple UI state (modal open/closed)
- Navigation after actions
- Direct prop transformations for rendering</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 6: Error Handling</h3>
                    <p>What are the different layers where you should handle errors in a React application? What type of errors should be handled at each layer?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>API Layer (Axios Interceptors):</strong>
                                    <ul>
                                        <li>HTTP status code errors</li>
                                        <li>Network errors</li>
                                        <li>Transform to custom error classes</li>
                                        <li>Handle auth token refresh</li>
                                    </ul>
                                </li>
                                <li><strong>Service Layer:</strong>
                                    <ul>
                                        <li>Throw custom errors</li>
                                        <li>Add context to errors</li>
                                        <li>No catching (let them bubble up)</li>
                                    </ul>
                                </li>
                                <li><strong>Hook Layer:</strong>
                                    <ul>
                                        <li>React Query onError callbacks</li>
                                        <li>Error state management</li>
                                        <li>Some errors may be caught here</li>
                                    </ul>
                                </li>
                                <li><strong>Component Layer:</strong>
                                    <ul>
                                        <li>Show error UI to users</li>
                                        <li>Try-catch for async actions</li>
                                        <li>User-friendly error messages</li>
                                        <li>Error Boundaries for unexpected errors</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 7: Type Organization</h3>
                    <p>Where should you put type definitions in a feature-based architecture? Give examples of feature-specific vs shared types.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Type Locations:</strong></p>
                            <ul>
                                <li><strong>Feature-specific types:</strong> <code>features/{feature}/types/</code></li>
                                <li><strong>Shared types:</strong> <code>shared/types/</code></li>
                            </ul>
                            <p><strong>Feature-Specific Types (features/users/types/):</strong></p>
                            <pre><code>- User
- CreateUserDto
- UpdateUserDto
- UserFilters
- UserRole (enum)</code></pre>
                            <p><strong>Shared Types (shared/types/):</strong></p>
                            <pre><code>- ApiResponse&lt;T&gt;
- PaginatedResponse&lt;T&gt;
- ApiError
- ID (type alias)
- Nullable&lt;T&gt;
- Common utility types</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 8: Architecture Principles</h3>
                    <p>Explain the SOLID principle that's most important in React: Single Responsibility Principle. How does it apply to React components?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Single Responsibility Principle:</strong></p>
                            <p>Each component, function, or module should have one reason to change - one well-defined responsibility.</p>
                            
                            <p><strong>In React Components:</strong></p>
                            <ul>
                                <li>A component should do ONE thing (display user data, OR fetch it, OR validate it - not all three)</li>
                                <li>If you can't describe what a component does in one sentence, it's doing too much</li>
                                <li>Changes to business logic shouldn't require changes to UI components</li>
                                <li>Changes to API structure shouldn't require changes to components</li>
                            </ul>
                            
                            <p><strong>Example:</strong></p>
                            <ul>
                                <li>‚ùå BAD: <code>UserProfile</code> fetches data, validates form, handles submission, and renders UI</li>
                                <li>‚úÖ GOOD: <code>UserProfile</code> just orchestrates. Data fetching is in <code>useUser</code> hook, form logic in <code>useForm</code>, validation in <code>validators</code>, and UI in presentational components</li>
                            </ul>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2>üìù Lesson Summary</h2>
                
                <div class="card">
                    <h3>üéâ Congratulations on Completing Lesson 8.5!</h3>
                    <p>You've just completed the final lesson of Module 8! You now have a comprehensive understanding of React architecture patterns that will serve you throughout your career as a professional React developer.</p>
                    
                    <h3>What You've Learned</h3>
                    <ul>
                        <li>‚úÖ <strong>Architecture Principles:</strong> Separation of Concerns, DRY, KISS, Single Responsibility, and Composition Over Inheritance</li>
                        <li>‚úÖ <strong>Feature-Based Structure:</strong> How to organize large codebases by feature instead of file type</li>
                        <li>‚úÖ <strong>Component Organization:</strong> Page, Layout, Container, Presentational, and Shared component patterns</li>
                        <li>‚úÖ <strong>Separation of Concerns:</strong> Dividing code into Presentation, Business Logic, and Data Access layers</li>
                        <li>‚úÖ <strong>Custom Hooks:</strong> Extracting business logic into reusable, testable hooks</li>
                        <li>‚úÖ <strong>Service Layer:</strong> Creating a clean abstraction for API communication</li>
                        <li>‚úÖ <strong>Type Organization:</strong> Structuring TypeScript types for maintainability</li>
                        <li>‚úÖ <strong>Error Handling:</strong> Implementing comprehensive error handling at every layer</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Key Architectural Takeaways</h3>
                    <ol style="color: white;">
                        <li><strong>Components should be simple:</strong> If a component is hard to understand or test, it's doing too much. Break it down.</li>
                        <li><strong>Business logic belongs in hooks:</strong> Not in components, not in services - custom hooks are the perfect place.</li>
                        <li><strong>Services only handle data access:</strong> No business logic, no state management - just API calls.</li>
                        <li><strong>Feature-based structure scales:</strong> Organize by feature, not by file type, especially as your app grows.</li>
                        <li><strong>Types should be close to usage:</strong> Feature-specific types in feature folders, shared types in shared folder.</li>
                        <li><strong>Error handling is multi-layered:</strong> Handle errors at the appropriate level - API, service, hook, or component.</li>
                        <li><strong>Test your architecture:</strong> If something is hard to test, it needs better separation of concerns.</li>
                        <li><strong>Start simple, refactor as needed:</strong> Don't over-engineer early. The "Rule of Three" applies - abstract when you need it the third time.</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üèÜ Module 8 Complete!</h3>
                    <p>You've now completed all five lessons in <strong>Module 8: State Management and Architecture</strong>:</p>
                    <ul>
                        <li>‚úÖ Lesson 8.1: State Management Overview</li>
                        <li>‚úÖ Lesson 8.2: Zustand Basics</li>
                        <li>‚úÖ Lesson 8.3: Redux Toolkit</li>
                        <li>‚úÖ Lesson 8.4: React Query (TanStack Query)</li>
                        <li>‚úÖ Lesson 8.5: Architecture Best Practices</li>
                    </ul>
                    <p><strong>You've learned how to build production-ready, scalable React applications!</strong></p>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üöÄ What's Next?</h3>
                    <p>You're ready to apply everything you've learned in Module 8!</p>
                    
                    <h4>Immediate Next Step:</h4>
                    <p><strong>Module 8 Project: Social Media Feed</strong></p>
                    <p>Build a complete social media feed application that demonstrates:</p>
                    <ul>
                        <li>Feature-based folder structure</li>
                        <li>React Query for data fetching</li>
                        <li>Zustand or Redux Toolkit for client state</li>
                        <li>Proper component organization</li>
                        <li>Custom hooks for business logic</li>
                        <li>Service layer for API calls</li>
                        <li>Comprehensive error handling</li>
                        <li>TypeScript throughout</li>
                    </ul>

                    <h4>Coming Up Next: Module 9 - Testing React Applications</h4>
                    <p>After completing your Module 8 project, you'll learn:</p>
                    <ul>
                        <li>Testing fundamentals and the testing pyramid</li>
                        <li>React Testing Library</li>
                        <li>Testing user interactions and async code</li>
                        <li>Integration and E2E testing</li>
                        <li>Testing best practices</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h3>üí° Applying What You've Learned</h3>
                    <p><strong>In Your Next Project:</strong></p>
                    <ol>
                        <li><strong>Start with structure:</strong> Set up feature folders before writing code</li>
                        <li><strong>Identify layers:</strong> Decide what goes in services, hooks, and components</li>
                        <li><strong>Type everything:</strong> Define TypeScript interfaces before implementing</li>
                        <li><strong>Separate concerns:</strong> Keep components focused on UI</li>
                        <li><strong>Plan error handling:</strong> Set up error classes and boundaries early</li>
                        <li><strong>Refactor regularly:</strong> As patterns emerge, extract and organize</li>
                    </ol>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üìö Additional Resources</h3>
                    <ul>
                        <li><a href="https://react.dev/learn/thinking-in-react" target="_blank">Thinking in React - Official React Docs</a></li>
                        <li><a href="https://kentcdodds.com/blog/application-state-management-with-react" target="_blank">Application State Management with React - Kent C. Dodds</a></li>
                        <li><a href="https://www.patterns.dev/" target="_blank">Patterns.dev - React Design Patterns</a></li>
                        <li><a href="https://github.com/alan2207/bulletproof-react" target="_blank">Bulletproof React - Scalable Architecture Guide</a></li>
                        <li><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank">The Practical Test Pyramid - Martin Fowler</a></li>
                    </ul>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson navigation">
                <a href="lesson_8_4_react_query_b.html" class="nav-button prev-lesson">
                    <span class="arrow">‚Üê</span>
                    <span class="label">Previous</span>
                    <span class="title">Lesson 8.4: React Query (Part B)</span>
                </a>
                <a href="index.html" class="nav-button home">
                    <span class="label">Course Home</span>
                </a>
                <a href="module_project_8_social_media_feed.html" class="nav-button next-lesson">
                    <span class="label">Next</span>
                    <span class="title">Module 8 Project: Social Media Feed</span>
                    <span class="arrow">‚Üí</span>
                </a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="mailto:support@example.com">Contact</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>