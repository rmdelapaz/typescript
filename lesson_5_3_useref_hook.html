<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React's useRef Hook - Learn how to access DOM elements, store mutable values, understand refs vs state, and use refs effectively with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>useRef Hook - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.3: useRef Hook</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üéØ useRef Hook</h1>
                <p class="lead">Welcome to one of React's most versatile hooks! You've learned about useState for state that triggers re-renders, but what about values that need to persist between renders WITHOUT causing re-renders? Or when you need to directly access a DOM element to focus an input, measure its size, or integrate with a third-party library? That's where useRef comes in! Think of useRef as a special container that can hold a value that "remembers" across renders, like a box that stays in the same spot while everything else around it changes. It's your secret weapon for working with the DOM and storing mutable values. Let's unlock this superpower! üîÆ</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what refs are and when to use them</li>
                        <li>Access DOM elements directly with useRef</li>
                        <li>Store mutable values that persist across renders</li>
                        <li>Understand the difference between refs and state</li>
                        <li>Type refs correctly with TypeScript</li>
                        <li>Implement common ref patterns (focus, scroll, animation)</li>
                        <li>Forward refs to child components</li>
                        <li>Avoid common ref mistakes and anti-patterns</li>
                        <li>Combine refs with other hooks effectively</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build focus management, auto-scroll, and animation controls</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Introduction to Refs</a></li>
                        <li><a href="#section2" class="toc-link">Understanding useRef</a></li>
                        <li><a href="#section3" class="toc-link">Accessing DOM Elements</a></li>
                        <li><a href="#section4" class="toc-link">Refs vs State</a></li>
                        <li><a href="#section5" class="toc-link">Typing Refs with TypeScript</a></li>
                        <li><a href="#section6" class="toc-link">Storing Mutable Values</a></li>
                        <li><a href="#section7" class="toc-link">Common Ref Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Forwarding Refs</a></li>
                        <li><a href="#section9" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section10" class="toc-link">Best Practices</a></li>
                        <li><a href="#section11" class="toc-link">Common Mistakes</a></li>
                        <li><a href="#section12" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction to Refs -->
            <section id="section1" class="lesson-section">
                <h2>üéØ Introduction to Refs</h2>
                <p>Before we dive into useRef, let's understand what refs are and why React needs them.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Ref (Reference):</strong> A ref is a plain JavaScript object with a single property called <code>current</code> that you can read and modify. Unlike state, updating a ref does NOT trigger a re-render. Refs "escape" React's rendering cycle.</p>
                </div>

                <h3>When Do You Need Refs?</h3>
                <p>React is declarative - you describe what the UI should look like, and React figures out how to make it happen. But sometimes you need to "escape" this declarative world and work imperatively with the DOM or store values. That's when refs shine.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use Refs When You Need To:</h4>
                    <ul>
                        <li><strong>Access DOM elements</strong> - Focus inputs, measure sizes, scroll positions</li>
                        <li><strong>Store mutable values</strong> - Values that don't affect rendering (timers, IDs)</li>
                        <li><strong>Integrate with non-React code</strong> - Third-party libraries, animations</li>
                        <li><strong>Avoid re-renders</strong> - Store values without triggering updates</li>
                        <li><strong>Track previous values</strong> - Remember the last state or props</li>
                        <li><strong>Imperatively control things</strong> - Play/pause video, trigger animations</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Don't Use Refs For:</h4>
                    <ul>
                        <li><strong>Rendering data</strong> - Use state for that</li>
                        <li><strong>Triggering re-renders</strong> - That's what setState is for</li>
                        <li><strong>Replacing state</strong> - State is better when UI depends on the value</li>
                        <li><strong>Storing derived values</strong> - Calculate them during render instead</li>
                    </ul>
                </div>

                <h3>The Two Main Use Cases</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Example</th>
                            <th>Why Ref?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>DOM Access</strong></td>
                            <td>Focus an input, scroll to element</td>
                            <td>Need direct access to DOM node</td>
                        </tr>
                        <tr>
                            <td><strong>Mutable Values</strong></td>
                            <td>Store timer ID, previous value</td>
                            <td>Value changes, but doesn't affect UI</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Real-World Scenarios</h3>
                <div class="card">
                    <h4>When Refs Solve Real Problems</h4>
                    <ul>
                        <li>üé• <strong>Video Player</strong> - Control playback imperatively</li>
                        <li>üìù <strong>Form Focus</strong> - Focus first invalid field on submit</li>
                        <li>üìú <strong>Infinite Scroll</strong> - Detect when user scrolls to bottom</li>
                        <li>üé® <strong>Canvas Drawing</strong> - Get canvas context for drawing</li>
                        <li>‚è±Ô∏è <strong>Timers</strong> - Store interval/timeout IDs for cleanup</li>
                        <li>üìè <strong>Measurements</strong> - Get element width/height</li>
                        <li>üîä <strong>Audio Control</strong> - Play/pause audio programmatically</li>
                        <li>üì∏ <strong>Camera Access</strong> - Control camera stream</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Understanding useRef -->
            <section id="section2" class="lesson-section">
                <h2>üîç Understanding useRef</h2>
                <p>Let's explore how useRef works at a fundamental level. Understanding this will help you use it effectively.</p>

                <h3>The Basic Syntax</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useRef } from 'react';

function MyComponent() {
    // Create a ref
    const myRef = useRef(initialValue);
    
    // Access the current value
    console.log(myRef.current); // initialValue
    
    // Modify the current value
    myRef.current = newValue;
    
    return &lt;div&gt;Hello&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>What useRef Returns</h3>
                <p>useRef returns an object with a single property:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// This is what useRef returns:
{
    current: yourInitialValue
}

// You can think of it like this simple object:
const ref = { current: 0 };
ref.current = 5; // You can change it
console.log(ref.current); // 5</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>The ref object itself NEVER changes - it's the same object on every render. Only <code>ref.current</code> can be modified. This is why refs don't trigger re-renders - React doesn't track changes to the <code>current</code> property!</p>
                </div>

                <h3>Refs Persist Across Renders</h3>
                <p>Unlike regular variables, refs maintain their value across component re-renders:</p>
                
                <!-- Interactive Ref vs Variable Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">‚ö° Interactive: Refs vs Variables Across Renders</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Watch how refs persist while regular variables reset on each render</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="refVsVarViz" viewBox="0 0 750 320" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="refGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#48bb78"/>
                                    <stop offset="100%" style="stop-color:#38a169"/>
                                </linearGradient>
                                <linearGradient id="varGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#f56565"/>
                                    <stop offset="100%" style="stop-color:#c53030"/>
                                </linearGradient>
                                <filter id="refGlow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="375" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">What Happens When Component Re-renders?</text>
                            
                            <!-- Render Counter -->
                            <rect x="300" y="40" width="150" height="40" rx="8" fill="#f5f5f5" stroke="#ddd" stroke-width="1"/>
                            <text x="375" y="55" text-anchor="middle" font-size="10" fill="#888">Render Count</text>
                            <text id="render-count" x="375" y="72" text-anchor="middle" font-size="16" font-weight="bold" fill="#333">1</text>
                            
                            <!-- Left Side: Regular Variable -->
                            <text x="190" y="110" text-anchor="middle" font-size="13" font-weight="600" fill="#c53030">‚ùå Regular Variable</text>
                            <text x="190" y="128" text-anchor="middle" font-size="10" fill="#888">let count = 0</text>
                            
                            <!-- Variable box -->
                            <rect id="var-box" x="90" y="145" width="200" height="80" rx="10" fill="#fff5f5" stroke="#f56565" stroke-width="2"/>
                            <text x="190" y="175" text-anchor="middle" font-size="11" fill="#c53030">Variable Value:</text>
                            <text id="var-value" x="190" y="205" text-anchor="middle" font-size="28" font-weight="bold" fill="#c53030">0</text>
                            
                            <!-- Variable explanation -->
                            <text id="var-status" x="190" y="250" text-anchor="middle" font-size="10" fill="#f56565">Resets to 0 on every render!</text>
                            
                            <!-- Right Side: useRef -->
                            <text x="560" y="110" text-anchor="middle" font-size="13" font-weight="600" fill="#38a169">‚úÖ useRef</text>
                            <text x="560" y="128" text-anchor="middle" font-size="10" fill="#888">const ref = useRef(0)</text>
                            
                            <!-- Ref box -->
                            <rect id="ref-box" x="460" y="145" width="200" height="80" rx="10" fill="#f0fff4" stroke="#48bb78" stroke-width="2"/>
                            <text x="560" y="175" text-anchor="middle" font-size="11" fill="#38a169">ref.current:</text>
                            <text id="ref-value" x="560" y="205" text-anchor="middle" font-size="28" font-weight="bold" fill="#38a169">0</text>
                            
                            <!-- Ref explanation -->
                            <text id="ref-status" x="560" y="250" text-anchor="middle" font-size="10" fill="#48bb78">Persists across renders!</text>
                            
                            <!-- Flash overlays -->
                            <rect id="var-flash" x="90" y="145" width="200" height="80" rx="10" fill="#f56565" opacity="0"/>
                            <rect id="ref-flash" x="460" y="145" width="200" height="80" rx="10" fill="#48bb78" opacity="0"/>
                            
                            <!-- Arrow indicators for render -->
                            <path id="render-arrow" d="M 375 85 L 375 100" fill="none" stroke="#667eea" stroke-width="2" marker-end="url(#arrowhead)" opacity="0"/>
                            
                            <!-- Status message -->
                            <text id="viz-message" x="375" y="300" text-anchor="middle" font-size="11" fill="#666">Click buttons to simulate renders and increments</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="incrementBoth()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Increment Both</button>
                            <button onclick="simulateRerender()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Trigger Re-render</button>
                            <button onclick="resetRefVarDemo()" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset</button>
                        </div>
                    </div>
                </div>
                
                <script>
                let demoRenderCount = 1;
                let demoVarValue = 0;
                let demoRefValue = 0;
                
                function incrementBoth() {
                    demoVarValue++;
                    demoRefValue++;
                    
                    document.getElementById('var-value').textContent = demoVarValue;
                    document.getElementById('ref-value').textContent = demoRefValue;
                    document.getElementById('viz-message').textContent = `Both incremented! Variable: ${demoVarValue}, Ref: ${demoRefValue}`;
                    
                    // Flash both
                    flashElement('var-flash');
                    flashElement('ref-flash');
                }
                
                function simulateRerender() {
                    demoRenderCount++;
                    document.getElementById('render-count').textContent = demoRenderCount;
                    
                    // Variable resets!
                    demoVarValue = 0;
                    document.getElementById('var-value').textContent = '0';
                    document.getElementById('var-status').textContent = '‚ö†Ô∏è RESET to 0!';
                    
                    // Ref stays the same
                    document.getElementById('ref-status').textContent = `‚úÖ Still ${demoRefValue}!`;
                    
                    document.getElementById('viz-message').textContent = `Render #${demoRenderCount}: Variable reset to 0, Ref kept its value!`;
                    
                    // Flash variable red
                    const varFlash = document.getElementById('var-flash');
                    varFlash.setAttribute('opacity', '0.5');
                    setTimeout(() => varFlash.setAttribute('opacity', '0'), 500);
                    
                    // Highlight ref green
                    const refBox = document.getElementById('ref-box');
                    refBox.setAttribute('filter', 'url(#refGlow)');
                    setTimeout(() => refBox.removeAttribute('filter'), 1000);
                }
                
                function flashElement(id) {
                    const el = document.getElementById(id);
                    el.setAttribute('opacity', '0.4');
                    setTimeout(() => el.setAttribute('opacity', '0'), 300);
                }
                
                function resetRefVarDemo() {
                    demoRenderCount = 1;
                    demoVarValue = 0;
                    demoRefValue = 0;
                    
                    document.getElementById('render-count').textContent = '1';
                    document.getElementById('var-value').textContent = '0';
                    document.getElementById('ref-value').textContent = '0';
                    document.getElementById('var-status').textContent = 'Resets to 0 on every render!';
                    document.getElementById('ref-status').textContent = 'Persists across renders!';
                    document.getElementById('viz-message').textContent = 'Click buttons to simulate renders and increments';
                }
                </script>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function Counter() {
    // Regular variable - resets to 0 on every render
    let count = 0;
    
    // Ref - persists across renders
    const countRef = useRef(0);
    
    const handleClick = () => {
        count++; // This resets on next render!
        countRef.current++; // This persists!
        
        console.log('Regular:', count); // Always 1
        console.log('Ref:', countRef.current); // 1, 2, 3, 4...
    };
    
    return &lt;button onClick={handleClick}&gt;Click me&lt;/button&gt;;
}</code></pre>
                </div>

                <h3>The Ref Lifecycle</h3>
                <div class="mermaid">
                sequenceDiagram
                    participant Component
                    participant useRef
                    participant RefObject
                    
                    Component->>useRef: Call useRef(initialValue)
                    useRef->>RefObject: Create { current: initialValue }
                    RefObject->>Component: Return ref object
                    
                    Note over Component: Component re-renders...
                    
                    Component->>RefObject: Read/write ref.current
                    RefObject->>Component: Same ref object
                    
                    Note over RefObject: Ref persists<br/>between renders
                </div>

                <h3>Comparing Ref to State</h3>
                <p>Let's see the key differences side by side:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function Example() {
    // State - triggers re-render when changed
    const [count, setCount] = useState(0);
    
    // Ref - does NOT trigger re-render when changed
    const countRef = useRef(0);
    
    const handleStateClick = () => {
        setCount(count + 1); // Component re-renders
        console.log('State updated:', count); // Still shows old value!
    };
    
    const handleRefClick = () => {
        countRef.current++; // No re-render
        console.log('Ref updated:', countRef.current); // Shows new value immediately
    };
    
    return (
        &lt;div&gt;
            &lt;p&gt;State: {count}&lt;/p&gt;
            &lt;p&gt;Ref: {countRef.current}&lt;/p&gt; {/* Won't update on screen! */}
            &lt;button onClick={handleStateClick}&gt;Update State&lt;/button&gt;
            &lt;button onClick={handleRefClick}&gt;Update Ref&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>useState</th>
                            <th>useRef</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Triggers Re-render</strong></td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td><strong>Value Persists</strong></td>
                            <td>‚úÖ Yes</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Mutable</strong></td>
                            <td>‚ùå No (use setState)</td>
                            <td>‚úÖ Yes (change .current)</td>
                        </tr>
                        <tr>
                            <td><strong>Synchronous</strong></td>
                            <td>‚ùå No (batched updates)</td>
                            <td>‚úÖ Yes (immediate)</td>
                        </tr>
                        <tr>
                            <td><strong>Use for Rendering</strong></td>
                            <td>‚úÖ Yes</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td><strong>Use for DOM Access</strong></td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Important Rule</h4>
                    <p>Never read or write <code>ref.current</code> during rendering! Refs are meant for side effects (event handlers, useEffect), not rendering logic.</p>
                    <pre><code>// ‚ùå Bad - reading ref during render
function BadComponent() {
    const countRef = useRef(0);
    return &lt;div&gt;{countRef.current}&lt;/div&gt;; // Don't do this!
}

// ‚úÖ Good - using ref in event handler
function GoodComponent() {
    const countRef = useRef(0);
    const handleClick = () => {
        console.log(countRef.current); // Perfect!
    };
    return &lt;button onClick={handleClick}&gt;Click&lt;/button&gt;;
}</code></pre>
                </div>
            </section>

            <!-- Section 3: Accessing DOM Elements -->
            <section id="section3" class="lesson-section">
                <h2>üéØ Accessing DOM Elements</h2>
                <p>One of the most common uses of refs is to access DOM elements directly. This is how you "break out" of React's declarative world when you need to.</p>

                <h3>Basic DOM Ref Example</h3>
                <p>To attach a ref to a DOM element, pass it to the <code>ref</code> attribute:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useRef } from 'react';

function FocusInput() {
    // Create a ref for the input element
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    const handleFocus = () => {
        // Access the DOM element via ref.current
        inputRef.current?.focus();
    };
    
    return (
        &lt;div&gt;
            &lt;input ref={inputRef} type="text" /&gt;
            &lt;button onClick={handleFocus}&gt;Focus Input&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° How It Works</h4>
                    <ol>
                        <li>Create a ref with <code>useRef&lt;HTMLInputElement&gt;(null)</code></li>
                        <li>React sets <code>inputRef.current</code> to the DOM node when it mounts</li>
                        <li>You can access the DOM node via <code>inputRef.current</code></li>
                        <li>React sets <code>inputRef.current</code> back to null when it unmounts</li>
                    </ol>
                </div>

                <h3>The ref Lifecycle with DOM</h3>
                
                <!-- Interactive DOM Ref Lifecycle Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üé¨ Interactive: DOM Ref Lifecycle</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">Watch what happens to ref.current during component mount and unmount</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="domRefLifecycleViz" viewBox="0 0 750 350" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="lifecycleGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#4facfe"/>
                                    <stop offset="100%" style="stop-color:#00f2fe"/>
                                </linearGradient>
                                <filter id="domGlow">
                                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="375" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">DOM Ref Lifecycle: null ‚Üí element ‚Üí null</text>
                            
                            <!-- Timeline -->
                            <line x1="75" y1="180" x2="675" y2="180" stroke="#ddd" stroke-width="3"/>
                            
                            <!-- Phase 1: Initial -->
                            <g id="phase-initial">
                                <circle cx="125" cy="180" r="15" fill="#f5f5f5" stroke="#ccc" stroke-width="2"/>
                                <text x="125" y="185" text-anchor="middle" font-size="12" fill="#999">1</text>
                                <text x="125" y="215" text-anchor="middle" font-size="10" fill="#666">Create Ref</text>
                                <text x="125" y="230" text-anchor="middle" font-size="9" fill="#999">useRef(null)</text>
                            </g>
                            
                            <!-- Phase 2: Render -->
                            <g id="phase-render">
                                <circle cx="275" cy="180" r="15" fill="#f5f5f5" stroke="#ccc" stroke-width="2"/>
                                <text x="275" y="185" text-anchor="middle" font-size="12" fill="#999">2</text>
                                <text x="275" y="215" text-anchor="middle" font-size="10" fill="#666">Render JSX</text>
                                <text x="275" y="230" text-anchor="middle" font-size="9" fill="#999">&lt;input ref={ref}/&gt;</text>
                            </g>
                            
                            <!-- Phase 3: Mount -->
                            <g id="phase-mount">
                                <circle cx="425" cy="180" r="15" fill="#f5f5f5" stroke="#ccc" stroke-width="2"/>
                                <text x="425" y="185" text-anchor="middle" font-size="12" fill="#999">3</text>
                                <text x="425" y="215" text-anchor="middle" font-size="10" fill="#666">DOM Created</text>
                                <text x="425" y="230" text-anchor="middle" font-size="9" fill="#999">ref.current = element</text>
                            </g>
                            
                            <!-- Phase 4: Use -->
                            <g id="phase-use">
                                <circle cx="525" cy="180" r="15" fill="#f5f5f5" stroke="#ccc" stroke-width="2"/>
                                <text x="525" y="185" text-anchor="middle" font-size="12" fill="#999">4</text>
                                <text x="525" y="215" text-anchor="middle" font-size="10" fill="#666">Use Ref</text>
                                <text x="525" y="230" text-anchor="middle" font-size="9" fill="#999">ref.current.focus()</text>
                            </g>
                            
                            <!-- Phase 5: Unmount -->
                            <g id="phase-unmount">
                                <circle cx="625" cy="180" r="15" fill="#f5f5f5" stroke="#ccc" stroke-width="2"/>
                                <text x="625" y="185" text-anchor="middle" font-size="12" fill="#999">5</text>
                                <text x="625" y="215" text-anchor="middle" font-size="10" fill="#666">Unmount</text>
                                <text x="625" y="230" text-anchor="middle" font-size="9" fill="#999">ref.current = null</text>
                            </g>
                            
                            <!-- Ref Value Display -->
                            <rect x="225" y="70" width="300" height="60" rx="10" fill="#f8f9fa" stroke="#e0e0e0" stroke-width="1"/>
                            <text x="375" y="95" text-anchor="middle" font-size="11" font-weight="600" fill="#333">ref.current =</text>
                            <text id="ref-current-value" x="375" y="118" text-anchor="middle" font-size="16" font-weight="bold" fill="#4facfe">null</text>
                            
                            <!-- DOM Element Visual -->
                            <g id="dom-element-visual" opacity="0">
                                <rect x="275" y="260" width="200" height="40" rx="6" fill="#e3f2fd" stroke="#2196f3" stroke-width="2"/>
                                <text x="375" y="285" text-anchor="middle" font-size="11" fill="#1976d2">&lt;input type="text" /&gt;</text>
                            </g>
                            
                            <!-- Animated connection line -->
                            <path id="ref-connection" d="M 375 128 L 375 260" fill="none" stroke="#4facfe" stroke-width="2" stroke-dasharray="6,3" opacity="0"/>
                            
                            <!-- Current phase indicator -->
                            <circle id="phase-indicator" cx="125" cy="180" r="20" fill="none" stroke="#4facfe" stroke-width="3" opacity="0"/>
                            
                            <!-- Status -->
                            <text id="lifecycle-status" x="375" y="335" text-anchor="middle" font-size="11" fill="#666">Click "Play Lifecycle" to see the animation</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="playLifecycle()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">‚ñ∂Ô∏è Play Lifecycle</button>
                            <button onclick="resetLifecycle()" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset</button>
                        </div>
                    </div>
                </div>
                
                <script>
                let lifecycleAnimating = false;
                
                function playLifecycle() {
                    if (lifecycleAnimating) return;
                    lifecycleAnimating = true;
                    resetLifecycle();
                    
                    const phases = [
                        { x: 125, value: 'null', status: 'üì¶ Step 1: Create ref with useRef(null) - ref.current starts as null', showDom: false },
                        { x: 275, value: 'null', status: 'üé® Step 2: Render JSX with ref attribute - still null during render', showDom: false },
                        { x: 425, value: '<input>', status: '‚úÖ Step 3: React creates DOM and sets ref.current to the element!', showDom: true, connect: true },
                        { x: 525, value: '<input>', status: 'üéØ Step 4: Now you can use ref.current.focus(), .value, etc.', showDom: true, connect: true, glow: true },
                        { x: 625, value: 'null', status: 'üëã Step 5: Component unmounts - ref.current set back to null', showDom: false }
                    ];
                    
                    const indicator = document.getElementById('phase-indicator');
                    const refValue = document.getElementById('ref-current-value');
                    const status = document.getElementById('lifecycle-status');
                    const domElement = document.getElementById('dom-element-visual');
                    const connection = document.getElementById('ref-connection');
                    
                    indicator.setAttribute('opacity', '1');
                    
                    let phaseIndex = 0;
                    
                    function nextPhase() {
                        if (phaseIndex < phases.length) {
                            const phase = phases[phaseIndex];
                            
                            // Move indicator
                            indicator.setAttribute('cx', phase.x);
                            
                            // Highlight phase circle
                            const phaseCircles = ['phase-initial', 'phase-render', 'phase-mount', 'phase-use', 'phase-unmount'];
                            phaseCircles.forEach((id, i) => {
                                const circle = document.querySelector(`#${id} circle`);
                                const text = document.querySelector(`#${id} text`);
                                if (i === phaseIndex) {
                                    circle.setAttribute('fill', '#4facfe');
                                    circle.setAttribute('stroke', '#0288d1');
                                    text.setAttribute('fill', 'white');
                                } else if (i < phaseIndex) {
                                    circle.setAttribute('fill', '#e8f5e9');
                                    circle.setAttribute('stroke', '#4caf50');
                                    text.setAttribute('fill', '#4caf50');
                                }
                            });
                            
                            // Update value display
                            refValue.textContent = phase.value;
                            refValue.setAttribute('fill', phase.value === 'null' ? '#999' : '#4facfe');
                            
                            // Show/hide DOM element
                            domElement.setAttribute('opacity', phase.showDom ? '1' : '0');
                            
                            // Show/hide connection line
                            connection.setAttribute('opacity', phase.connect ? '1' : '0');
                            
                            // Glow effect
                            if (phase.glow) {
                                domElement.querySelector('rect').setAttribute('filter', 'url(#domGlow)');
                            } else {
                                domElement.querySelector('rect').removeAttribute('filter');
                            }
                            
                            // Update status
                            status.textContent = phase.status;
                            
                            phaseIndex++;
                            setTimeout(nextPhase, 1500);
                        } else {
                            lifecycleAnimating = false;
                            status.textContent = 'üéâ Lifecycle complete! The ref went from null ‚Üí element ‚Üí null';
                        }
                    }
                    
                    nextPhase();
                }
                
                function resetLifecycle() {
                    const phaseCircles = ['phase-initial', 'phase-render', 'phase-mount', 'phase-use', 'phase-unmount'];
                    phaseCircles.forEach(id => {
                        const circle = document.querySelector(`#${id} circle`);
                        const text = document.querySelector(`#${id} text`);
                        circle.setAttribute('fill', '#f5f5f5');
                        circle.setAttribute('stroke', '#ccc');
                        text.setAttribute('fill', '#999');
                    });
                    
                    document.getElementById('phase-indicator').setAttribute('opacity', '0');
                    document.getElementById('ref-current-value').textContent = 'null';
                    document.getElementById('ref-current-value').setAttribute('fill', '#4facfe');
                    document.getElementById('dom-element-visual').setAttribute('opacity', '0');
                    document.getElementById('ref-connection').setAttribute('opacity', '0');
                    document.getElementById('lifecycle-status').textContent = 'Click "Play Lifecycle" to see the animation';
                }
                </script>
                
                <div class="mermaid">
                sequenceDiagram
                    participant React
                    participant Ref
                    participant DOM
                    
                    React->>Ref: Create ref (current: null)
                    React->>DOM: Create DOM element
                    React->>Ref: Set ref.current = DOM element
                    
                    Note over Ref,DOM: Component is mounted<br/>ref.current points to DOM
                    
                    React->>Ref: Set ref.current = null
                    React->>DOM: Remove DOM element
                    
                    Note over Ref: Component unmounted<br/>ref.current is null again
                </div>

                <h3>Common DOM Operations</h3>
                <p>Here are the most common things you'll do with DOM refs:</p>

                <h4>1. Focus Management</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function LoginForm() {
    const emailRef = useRef&lt;HTMLInputElement&gt;(null);
    const passwordRef = useRef&lt;HTMLInputElement&gt;(null);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        
        // Focus first empty field
        if (!emailRef.current?.value) {
            emailRef.current?.focus();
        } else if (!passwordRef.current?.value) {
            passwordRef.current?.focus();
        }
    };
    
    // Focus email on mount
    useEffect(() => {
        emailRef.current?.focus();
    }, []);
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input ref={emailRef} type="email" placeholder="Email" /&gt;
            &lt;input ref={passwordRef} type="password" placeholder="Password" /&gt;
            &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>

                <h4>2. Scrolling</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ChatRoom() {
    const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);
    
    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };
    
    // Scroll to bottom when new message arrives
    useEffect(() => {
        scrollToBottom();
    }, [messages]);
    
    return (
        &lt;div className="chat-container"&gt;
            {messages.map(msg => (
                &lt;div key={msg.id}&gt;{msg.text}&lt;/div&gt;
            ))}
            &lt;div ref={messagesEndRef} /&gt; {/* Invisible anchor */}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h4>3. Measuring Elements</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function MeasureBox() {
    const boxRef = useRef&lt;HTMLDivElement&gt;(null);
    const [dimensions, setDimensions] = useState({ width: 0, height: 0 });
    
    const measureBox = () => {
        if (boxRef.current) {
            const { width, height } = boxRef.current.getBoundingClientRect();
            setDimensions({ width, height });
        }
    };
    
    useEffect(() => {
        measureBox();
        window.addEventListener('resize', measureBox);
        return () => window.removeEventListener('resize', measureBox);
    }, []);
    
    return (
        &lt;div&gt;
            &lt;div ref={boxRef} className="box"&gt;
                Resize the window!
            &lt;/div&gt;
            &lt;p&gt;Width: {dimensions.width}px&lt;/p&gt;
            &lt;p&gt;Height: {dimensions.height}px&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h4>4. Video/Audio Control</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function VideoPlayer() {
    const videoRef = useRef&lt;HTMLVideoElement&gt;(null);
    const [isPlaying, setIsPlaying] = useState(false);
    
    const togglePlay = () => {
        if (videoRef.current) {
            if (isPlaying) {
                videoRef.current.pause();
            } else {
                videoRef.current.play();
            }
            setIsPlaying(!isPlaying);
        }
    };
    
    return (
        &lt;div&gt;
            &lt;video ref={videoRef} src="video.mp4" /&gt;
            &lt;button onClick={togglePlay}&gt;
                {isPlaying ? 'Pause' : 'Play'}
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ DOM Ref Best Practices</h4>
                    <ul>
                        <li>Always use optional chaining (<code>?.</code>) when accessing ref.current</li>
                        <li>Check if ref.current exists before using it</li>
                        <li>Initialize DOM refs with <code>null</code></li>
                        <li>Type your refs with the correct HTML element type</li>
                        <li>Clean up event listeners and timers in useEffect</li>
                    </ul>
                </div>

            <!-- Section 4: Refs vs State -->
            <section id="section4" class="lesson-section">
                <h2>‚öñÔ∏è Refs vs State</h2>
                <p>Understanding when to use refs versus state is crucial for writing good React code. Let's explore the differences in depth and learn when to use each.</p>

                <h3>The Fundamental Difference</h3>
                
                <!-- Interactive Ref vs State Re-render Visualization -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üîÑ Interactive: Ref vs State Re-render Behavior</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">See how state triggers re-renders while refs don't update the UI</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <svg id="refVsStateViz" viewBox="0 0 750 400" style="width: 100%; max-width: 750px; display: block; margin: 0 auto; font-family: system-ui, sans-serif;">
                            <defs>
                                <linearGradient id="stateGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" style="stop-color:#667eea"/>
                                    <stop offset="100%" style="stop-color:#764ba2"/>
                                </linearGradient>
                                <filter id="renderFlash">
                                    <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                                    <feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>
                                </filter>
                            </defs>
                            
                            <!-- Title -->
                            <text x="375" y="25" text-anchor="middle" font-size="15" font-weight="bold" fill="#333">State vs Ref: What Triggers Re-renders?</text>
                            
                            <!-- Component box -->
                            <rect id="component-box" x="200" y="45" width="350" height="180" rx="12" fill="#fafafa" stroke="#ddd" stroke-width="2"/>
                            <text x="375" y="68" text-anchor="middle" font-size="12" font-weight="600" fill="#333">MyComponent</text>
                            
                            <!-- Render indicator -->
                            <rect id="render-indicator" x="450" y="52" width="90" height="24" rx="12" fill="#e8f5e9" stroke="#4caf50" stroke-width="1" opacity="0"/>
                            <text id="render-text" x="495" y="68" text-anchor="middle" font-size="10" fill="#4caf50" opacity="0">Re-rendering!</text>
                            
                            <!-- Left side: useState -->
                            <rect x="220" y="85" width="150" height="120" rx="8" fill="#e8eaf6" stroke="#5c6bc0" stroke-width="2"/>
                            <text x="295" y="105" text-anchor="middle" font-size="11" font-weight="600" fill="#3949ab">useState</text>
                            
                            <text x="295" y="130" text-anchor="middle" font-size="10" fill="#666">count:</text>
                            <text id="state-value" x="295" y="155" text-anchor="middle" font-size="24" font-weight="bold" fill="#3949ab">0</text>
                            
                            <text x="295" y="180" text-anchor="middle" font-size="9" fill="#5c6bc0">Displayed in UI ‚úÖ</text>
                            <text x="295" y="195" text-anchor="middle" font-size="9" fill="#5c6bc0">Triggers re-render ‚úÖ</text>
                            
                            <!-- Right side: useRef -->
                            <rect x="390" y="85" width="150" height="120" rx="8" fill="#e8f5e9" stroke="#66bb6a" stroke-width="2"/>
                            <text x="465" y="105" text-anchor="middle" font-size="11" font-weight="600" fill="#43a047">useRef</text>
                            
                            <text x="465" y="130" text-anchor="middle" font-size="10" fill="#666">ref.current:</text>
                            <text id="ref-actual-value" x="465" y="155" text-anchor="middle" font-size="24" font-weight="bold" fill="#43a047">0</text>
                            
                            <text x="465" y="180" text-anchor="middle" font-size="9" fill="#66bb6a">Actual value ‚úî</text>
                            <text x="465" y="195" text-anchor="middle" font-size="9" fill="#66bb6a">No re-render ‚ùå</text>
                            
                            <!-- Screen representation -->
                            <text x="375" y="250" text-anchor="middle" font-size="12" font-weight="600" fill="#333">What User Sees on Screen:</text>
                            
                            <rect x="200" y="265" width="350" height="80" rx="8" fill="#fff" stroke="#333" stroke-width="2"/>
                            <text x="375" y="290" text-anchor="middle" font-size="10" fill="#888">MyComponent Output</text>
                            
                            <text x="280" y="320" text-anchor="middle" font-size="11" fill="#666">State Count:</text>
                            <text id="screen-state" x="335" y="320" font-size="14" font-weight="bold" fill="#3949ab">0</text>
                            
                            <text x="430" y="320" text-anchor="middle" font-size="11" fill="#666">Ref Count:</text>
                            <text id="screen-ref" x="485" y="320" font-size="14" font-weight="bold" fill="#999">0</text>
                            <text id="ref-stale-warning" x="530" y="320" font-size="9" fill="#f57c00" opacity="0">‚Üê stale!</text>
                            
                            <!-- Render count -->
                            <text x="375" y="375" text-anchor="middle" font-size="11" fill="#666">Total Renders: <tspan id="total-renders" font-weight="bold">1</tspan></text>
                            
                            <!-- Status -->
                            <text id="state-vs-ref-status" x="375" y="395" text-anchor="middle" font-size="10" fill="#888">Click buttons to see the difference</text>
                        </svg>
                        
                        <div style="display: flex; gap: 0.75rem; justify-content: center; margin-top: 1rem; flex-wrap: wrap;">
                            <button onclick="incrementState()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Increment State</button>
                            <button onclick="incrementRef()" style="padding: 0.6rem 1.25rem; background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.9rem;">Increment Ref</button>
                            <button onclick="resetStateRefDemo()" style="padding: 0.6rem 1rem; background: #f5f5f5; color: #666; border: 1px solid #ddd; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Reset</button>
                        </div>
                        
                        <div class="card" style="background: #fff3e0; border-left: 4px solid #ff9800; margin-top: 1rem; padding: 1rem;">
                            <p style="margin: 0; font-size: 0.9rem;"><strong>üí° Key Insight:</strong> The ref value changes but the screen doesn't update because refs don't trigger re-renders. Only when state changes does React update the UI!</p>
                        </div>
                    </div>
                </div>
                
                <script>
                let stateCount = 0;
                let refCount = 0;
                let totalRenders = 1;
                
                function incrementState() {
                    stateCount++;
                    totalRenders++;
                    
                    // Update internal display
                    document.getElementById('state-value').textContent = stateCount;
                    document.getElementById('total-renders').textContent = totalRenders;
                    
                    // Update screen (state change = re-render = UI updates)
                    document.getElementById('screen-state').textContent = stateCount;
                    document.getElementById('screen-ref').textContent = refCount; // Screen also updates ref display now
                    document.getElementById('ref-stale-warning').setAttribute('opacity', '0');
                    
                    // Flash re-render indicator
                    showRenderIndicator();
                    
                    document.getElementById('state-vs-ref-status').textContent = `State changed ‚Üí Re-render triggered! Screen shows current values.`;
                }
                
                function incrementRef() {
                    refCount++;
                    
                    // Update internal display (ref value changes)
                    document.getElementById('ref-actual-value').textContent = refCount;
                    
                    // BUT screen doesn't update! That's the point.
                    // The screen-ref stays at old value
                    document.getElementById('ref-stale-warning').setAttribute('opacity', '1');
                    
                    document.getElementById('state-vs-ref-status').textContent = `Ref changed to ${refCount}, but NO re-render! Screen still shows old value.`;
                }
                
                function showRenderIndicator() {
                    const indicator = document.getElementById('render-indicator');
                    const text = document.getElementById('render-text');
                    const box = document.getElementById('component-box');
                    
                    indicator.setAttribute('opacity', '1');
                    text.setAttribute('opacity', '1');
                    box.setAttribute('filter', 'url(#renderFlash)');
                    
                    setTimeout(() => {
                        indicator.setAttribute('opacity', '0');
                        text.setAttribute('opacity', '0');
                        box.removeAttribute('filter');
                    }, 800);
                }
                
                function resetStateRefDemo() {
                    stateCount = 0;
                    refCount = 0;
                    totalRenders = 1;
                    
                    document.getElementById('state-value').textContent = '0';
                    document.getElementById('ref-actual-value').textContent = '0';
                    document.getElementById('screen-state').textContent = '0';
                    document.getElementById('screen-ref').textContent = '0';
                    document.getElementById('total-renders').textContent = '1';
                    document.getElementById('ref-stale-warning').setAttribute('opacity', '0');
                    document.getElementById('state-vs-ref-status').textContent = 'Click buttons to see the difference';
                }
                </script>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ComparisonDemo() {
    const [stateCount, setStateCount] = useState(0);
    const refCount = useRef(0);
    
    console.log('Component rendered');
    
    return (
        &lt;div&gt;
            {/* State - displays on screen, triggers re-render */}
            &lt;p&gt;State Count: {stateCount}&lt;/p&gt;
            &lt;button onClick={() => setStateCount(stateCount + 1)}&gt;
                Increment State (re-renders)
            &lt;/button&gt;
            
            {/* Ref - won't update on screen, no re-render */}
            &lt;p&gt;Ref Count: {refCount.current}&lt;/p&gt;
            &lt;button onClick={() => refCount.current++}&gt;
                Increment Ref (no re-render)
            &lt;/button&gt;
        &lt;/div&gt;
    );
    // Click state button: "Component rendered" logs
    // Click ref button: Nothing logs!
}</code></pre>
                </div>

                <h3>Decision Tree: When to Use What?</h3>
                <div class="mermaid">
                graph TD
                    A[Need to store a value?] --> B{Does it affect what user sees?}
                    B -->|Yes| C[Use useState]
                    B -->|No| D{Does it need to persist across renders?}
                    D -->|Yes| E[Use useRef]
                    D -->|No| F[Use regular variable]
                    
                    C --> G[Examples: form data, UI state, counts displayed on screen]
                    E --> H[Examples: DOM refs, timer IDs, previous values]
                    F --> I[Examples: temporary calculations, loop counters]
                    
                    style C fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style E fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style F fill:#f093fb,stroke:#333,stroke-width:2px,color:#fff
                </graph>
                </div>

                <h3>Side-by-Side Examples</h3>

                <h4>Example 1: Click Counter (Use State)</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Use state - user needs to see the count
function ClickCounter() {
    const [count, setCount] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Clicks: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Click me
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h4>Example 2: Render Counter (Use Ref)</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Use ref - tracking renders, not displaying to user
function RenderCounter() {
    const renderCount = useRef(0);
    
    useEffect(() => {
        renderCount.current++;
        console.log(`Rendered ${renderCount.current} times`);
    });
    
    const [name, setName] = useState('');
    
    return (
        &lt;div&gt;
            &lt;input 
                value={name} 
                onChange={(e) => setName(e.target.value)} 
            /&gt;
            {/* Don't try to display ref.current in JSX! */}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h4>Example 3: Timer ID (Use Ref)</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Use ref - timer ID doesn't affect UI
function Timer() {
    const [seconds, setSeconds] = useState(0);
    const intervalRef = useRef&lt;number | null&gt;(null);
    
    const startTimer = () => {
        intervalRef.current = setInterval(() => {
            setSeconds(s => s + 1);
        }, 1000);
    };
    
    const stopTimer = () => {
        if (intervalRef.current) {
            clearInterval(intervalRef.current);
        }
    };
    
    useEffect(() => {
        return () => stopTimer(); // Cleanup
    }, []);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Seconds: {seconds}&lt;/p&gt;
            &lt;button onClick={startTimer}&gt;Start&lt;/button&gt;
            &lt;button onClick={stopTimer}&gt;Stop&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Common Patterns Compared</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Use State</th>
                            <th>Use Ref</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Form input value</td>
                            <td>‚úÖ Yes - display in UI</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>Toggle button state</td>
                            <td>‚úÖ Yes - affects UI</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>Modal open/closed</td>
                            <td>‚úÖ Yes - conditionally render</td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>DOM element reference</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes - access DOM</td>
                        </tr>
                        <tr>
                            <td>Previous props/state</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes - track history</td>
                        </tr>
                        <tr>
                            <td>setInterval/setTimeout ID</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes - for cleanup</td>
                        </tr>
                        <tr>
                            <td>WebSocket connection</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes - persist connection</td>
                        </tr>
                        <tr>
                            <td>Animation frame ID</td>
                            <td>‚ùå No</td>
                            <td>‚úÖ Yes - for cancellation</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Quick Decision Guide</h4>
                    <p><strong>Use State when:</strong></p>
                    <ul>
                        <li>The value is displayed in the UI</li>
                        <li>Changes should trigger a re-render</li>
                        <li>The component's output depends on the value</li>
                    </ul>
                    <p><strong>Use Ref when:</strong></p>
                    <ul>
                        <li>You need to access a DOM element</li>
                        <li>Value changes but UI doesn't depend on it</li>
                        <li>You need to store something without triggering re-renders</li>
                    </ul>
                </div>

                <h3>The "Previous Value" Pattern</h3>
                <p>A common use case: tracking the previous value of state or props.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function usePrevious&lt;T&gt;(value: T): T | undefined {
    const ref = useRef&lt;T&gt;();
    
    useEffect(() => {
        ref.current = value;
    }, [value]);
    
    return ref.current;
}

// Usage
function Counter() {
    const [count, setCount] = useState(0);
    const prevCount = usePrevious(count);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Current: {count}&lt;/p&gt;
            &lt;p&gt;Previous: {prevCount}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;
                Increment
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>
            </section>

            <!-- Section 5: Typing Refs with TypeScript -->
            <section id="section5" class="lesson-section">
                <h2>üî∑ Typing Refs with TypeScript</h2>
                <p>TypeScript makes refs much safer by ensuring you use the correct types. Let's master ref typing!</p>

                <h3>Basic Ref Typing</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Generic syntax: useRef&lt;Type&gt;(initialValue)

// DOM element refs - always start with null
const inputRef = useRef&lt;HTMLInputElement&gt;(null);
const divRef = useRef&lt;HTMLDivElement&gt;(null);
const buttonRef = useRef&lt;HTMLButtonElement&gt;(null);

// Value refs - can start with any value
const countRef = useRef&lt;number&gt;(0);
const nameRef = useRef&lt;string&gt;('');
const dataRef = useRef&lt;User | null&gt;(null);</code></pre>
                </div>

                <h3>Common HTML Element Types</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Element</th>
                            <th>TypeScript Type</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>&lt;input&gt;</td>
                            <td><code>HTMLInputElement</code></td>
                            <td><code>useRef&lt;HTMLInputElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;button&gt;</td>
                            <td><code>HTMLButtonElement</code></td>
                            <td><code>useRef&lt;HTMLButtonElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;div&gt;</td>
                            <td><code>HTMLDivElement</code></td>
                            <td><code>useRef&lt;HTMLDivElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;form&gt;</td>
                            <td><code>HTMLFormElement</code></td>
                            <td><code>useRef&lt;HTMLFormElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;video&gt;</td>
                            <td><code>HTMLVideoElement</code></td>
                            <td><code>useRef&lt;HTMLVideoElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;canvas&gt;</td>
                            <td><code>HTMLCanvasElement</code></td>
                            <td><code>useRef&lt;HTMLCanvasElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>&lt;img&gt;</td>
                            <td><code>HTMLImageElement</code></td>
                            <td><code>useRef&lt;HTMLImageElement&gt;(null)</code></td>
                        </tr>
                        <tr>
                            <td>Generic element</td>
                            <td><code>HTMLElement</code></td>
                            <td><code>useRef&lt;HTMLElement&gt;(null)</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Why null for DOM Refs?</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Correct - DOM refs start as null
const inputRef = useRef&lt;HTMLInputElement&gt;(null);

// TypeScript knows ref.current might be null
inputRef.current?.focus(); // Use optional chaining

// ‚ùå Wrong - TypeScript error!
const inputRef = useRef&lt;HTMLInputElement&gt;();
// Error: Argument of type 'undefined' is not assignable to parameter of type 'HTMLInputElement | null'</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Why null?</h4>
                    <p>DOM elements don't exist until React creates them during render. So refs that hold DOM elements must start as <code>null</code>. React will set <code>ref.current</code> to the actual DOM node after mounting.</p>
                </div>

                <h3>Typing Value Refs</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Simple types
const countRef = useRef&lt;number&gt;(0);
const nameRef = useRef&lt;string&gt;('John');
const isActiveRef = useRef&lt;boolean&gt;(false);

// Complex types
interface User {
    id: number;
    name: string;
}

const userRef = useRef&lt;User | null&gt;(null);
const usersRef = useRef&lt;User[]&gt;([]);

// Timer IDs (number or NodeJS.Timeout depending on environment)
const timerRef = useRef&lt;number | null&gt;(null);

// WebSocket or other APIs
const socketRef = useRef&lt;WebSocket | null&gt;(null);</code></pre>
                </div>

                <h3>Optional Chaining with Refs</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function SafeRefAccess() {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    const focusInput = () => {
        // ‚úÖ Safe - won't crash if ref.current is null
        inputRef.current?.focus();
        
        // ‚úÖ Safe - check with if statement
        if (inputRef.current) {
            inputRef.current.focus();
        }
        
        // ‚ùå Unsafe - could crash!
        // inputRef.current.focus(); // TypeScript error
    };
    
    return &lt;input ref={inputRef} /&gt;;
}</code></pre>
                </div>

                <h3>Mutable vs Immutable Refs</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Mutable ref (default) - you can change .current
const mutableRef = useRef&lt;number&gt;(0);
mutableRef.current = 5; // ‚úÖ Allowed

// Read-only ref (rare, but possible)
const readonlyRef = useRef&lt;number&gt;(0) as { readonly current: number };
// readonlyRef.current = 5; // ‚ùå TypeScript error</code></pre>
                </div>

                <h3>Generic Ref Typing</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Generic function that works with any ref type
function useLatest&lt;T&gt;(value: T) {
    const ref = useRef&lt;T&gt;(value);
    
    useEffect(() => {
        ref.current = value;
    }, [value]);
    
    return ref;
}

// Usage with different types
const nameLatest = useLatest('John'); // RefObject&lt;string&gt;
const countLatest = useLatest(42); // RefObject&lt;number&gt;
const userLatest = useLatest({ id: 1, name: 'Alice' }); // RefObject&lt;User&gt;</code></pre>
                </div>

                <h3>Ref Type Patterns</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Pattern 1: Union type for multiple possibilities
const elementRef = useRef&lt;HTMLDivElement | HTMLSpanElement&gt;(null);

// Pattern 2: Nullable ref
const optionalRef = useRef&lt;string | null&gt;(null);

// Pattern 3: Array of refs
const itemRefs = useRef&lt;HTMLDivElement[]&gt;([]);

// Pattern 4: Ref to custom component (we'll cover this later)
const customRef = useRef&lt;CustomComponentHandle&gt;(null);</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Ref Best Practices</h4>
                    <ul>
                        <li>Always specify the type parameter: <code>useRef&lt;Type&gt;</code></li>
                        <li>Use <code>null</code> as initial value for DOM refs</li>
                        <li>Use optional chaining (<code>?.</code>) when accessing DOM refs</li>
                        <li>Use the most specific HTML element type available</li>
                        <li>For union types, use type guards to narrow</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Storing Mutable Values -->
            <section id="section6" class="lesson-section">
                <h2>üì¶ Storing Mutable Values</h2>
                <p>Beyond DOM access, refs are perfect for storing mutable values that don't affect rendering. Let's explore common patterns.</p>

                <h3>Pattern 1: Timer IDs</h3>
                <p>Store timer IDs to clean them up later:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function Stopwatch() {
    const [time, setTime] = useState(0);
    const [isRunning, setIsRunning] = useState(false);
    const intervalRef = useRef&lt;number | null&gt;(null);
    
    const start = () => {
        if (!isRunning) {
            setIsRunning(true);
            intervalRef.current = setInterval(() => {
                setTime(t => t + 10);
            }, 10);
        }
    };
    
    const stop = () => {
        if (intervalRef.current) {
            clearInterval(intervalRef.current);
            setIsRunning(false);
        }
    };
    
    const reset = () => {
        stop();
        setTime(0);
    };
    
    // Cleanup on unmount
    useEffect(() => {
        return () => {
            if (intervalRef.current) {
                clearInterval(intervalRef.current);
            }
        };
    }, []);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Time: {(time / 1000).toFixed(2)}s&lt;/p&gt;
            &lt;button onClick={start}&gt;Start&lt;/button&gt;
            &lt;button onClick={stop}&gt;Stop&lt;/button&gt;
            &lt;button onClick={reset}&gt;Reset&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 2: Previous Values</h3>
                <p>Track previous state or props:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ValueChangeDetector({ value }: { value: number }) {
    const prevValueRef = useRef&lt;number&gt;(value);
    
    useEffect(() => {
        const prev = prevValueRef.current;
        
        if (prev !== value) {
            console.log(`Value changed from ${prev} to ${value}`);
        }
        
        // Update ref for next render
        prevValueRef.current = value;
    }, [value]);
    
    return &lt;div&gt;Current value: {value}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Pattern 3: Instance Variables</h3>
                <p>Store class-like instance variables in functional components:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function DataFetcher() {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(false);
    
    // Track if component is mounted to prevent setState on unmounted component
    const isMountedRef = useRef(true);
    
    useEffect(() => {
        return () => {
            isMountedRef.current = false;
        };
    }, []);
    
    const fetchData = async () => {
        setLoading(true);
        
        try {
            const response = await fetch('/api/data');
            const result = await response.json();
            
            // Only update state if still mounted
            if (isMountedRef.current) {
                setData(result);
            }
        } finally {
            if (isMountedRef.current) {
                setLoading(false);
            }
        }
    };
    
    return (
        &lt;div&gt;
            &lt;button onClick={fetchData}&gt;Fetch Data&lt;/button&gt;
            {loading && &lt;p&gt;Loading...&lt;/p&gt;}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 4: Callback Refs</h3>
                <p>Store the latest version of a callback:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function useLatestCallback&lt;T extends (...args: any[]) => any&gt;(callback: T) {
    const callbackRef = useRef(callback);
    
    // Update ref whenever callback changes
    useEffect(() => {
        callbackRef.current = callback;
    }, [callback]);
    
    // Return stable callback that always calls the latest version
    const stableCallback = useCallback(
        (...args: Parameters&lt;T&gt;) => callbackRef.current(...args),
        []
    );
    
    return stableCallback;
}

// Usage
function SearchBox({ onSearch }: { onSearch: (query: string) => void }) {
    const [query, setQuery] = useState('');
    
    // onSearch might change, but we want stable reference for useEffect
    const stableOnSearch = useLatestCallback(onSearch);
    
    useEffect(() => {
        const timer = setTimeout(() => {
            stableOnSearch(query);
        }, 500);
        
        return () => clearTimeout(timer);
    }, [query]); // Only query in deps, not onSearch!
    
    return &lt;input value={query} onChange={(e) => setQuery(e.target.value)} /&gt;;
}</code></pre>
                </div>

                <h3>Pattern 5: Web APIs</h3>
                <p>Store references to web APIs:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function WebSocketChat() {
    const [messages, setMessages] = useState&lt;string[]&gt;([]);
    const socketRef = useRef&lt;WebSocket | null&gt;(null);
    
    useEffect(() => {
        // Create WebSocket connection
        socketRef.current = new WebSocket('ws://localhost:8080');
        
        socketRef.current.onmessage = (event) => {
            setMessages(prev => [...prev, event.data]);
        };
        
        // Cleanup on unmount
        return () => {
            socketRef.current?.close();
        };
    }, []);
    
    const sendMessage = (message: string) => {
        socketRef.current?.send(message);
    };
    
    return (
        &lt;div&gt;
            {messages.map((msg, i) => (
                &lt;p key={i}&gt;{msg}&lt;/p&gt;
            ))}
            &lt;button onClick={() => sendMessage('Hello')}&gt;
                Send Hello
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Mutable Refs</h4>
                    <p>Use refs for mutable values when:</p>
                    <ul>
                        <li>The value needs to persist across renders</li>
                        <li>Changing it shouldn't trigger a re-render</li>
                        <li>You need to store IDs for cleanup (timers, subscriptions)</li>
                        <li>You're tracking component mount status</li>
                        <li>You need the latest value of a prop/callback in an effect</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't use refs to avoid re-renders when state is the right choice:</p>
                    <pre><code>// ‚ùå Bad - using ref when state is needed
const countRef = useRef(0);
return &lt;p&gt;{countRef.current}&lt;/p&gt;; // Won't update!

// ‚úÖ Good - use state for UI
const [count, setCount] = useState(0);
return &lt;p&gt;{count}&lt;/p&gt;; // Updates correctly</code></pre>
                </div>
            </section>

            <!-- Section 7: Common Ref Patterns -->
            <section id="section7" class="lesson-section">
                <h2>üé® Common Ref Patterns</h2>
                <p>Let's explore the most common and useful patterns for using refs in real applications. These patterns solve everyday problems you'll encounter.</p>

                <h3>Pattern 1: Focus Management</h3>
                <p>One of the most common uses of refs is managing focus - automatically focusing inputs, moving focus between fields, or focusing on errors.</p>
                
                <!-- Interactive Focus Management Demo -->
                <div class="card" style="padding: 0; overflow: hidden; margin: 2rem 0;">
                    <div style="background: linear-gradient(135deg, #48bb78 0%, #38a169 100%); color: white; padding: 1rem 1.5rem;">
                        <h4 style="color: white; margin: 0;">üéØ Interactive: Focus Management with Refs</h4>
                        <p style="color: rgba(255,255,255,0.9); margin: 0.5rem 0 0 0; font-size: 0.9rem;">See how refs enable programmatic focus control</p>
                    </div>
                    <div style="padding: 1.5rem;">
                        <div style="max-width: 400px; margin: 0 auto;">
                            <!-- Demo Form -->
                            <div style="background: #f8f9fa; border-radius: 12px; padding: 1.5rem; border: 1px solid #e0e0e0;">
                                <h5 style="margin: 0 0 1rem 0; color: #333;">Login Form Demo</h5>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Email</label>
                                    <input id="demo-email" type="email" placeholder="Enter email" style="width: 100%; padding: 0.6rem; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95rem; box-sizing: border-box; transition: border-color 0.2s, box-shadow 0.2s;" onfocus="highlightField('email')" onblur="unhighlightField('email')">
                                    <span id="email-indicator" style="display: none; font-size: 0.75rem; color: #4caf50; margin-top: 0.25rem;">‚úî Focused via ref</span>
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Password</label>
                                    <input id="demo-password" type="password" placeholder="Enter password" style="width: 100%; padding: 0.6rem; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95rem; box-sizing: border-box; transition: border-color 0.2s, box-shadow 0.2s;" onfocus="highlightField('password')" onblur="unhighlightField('password')">
                                    <span id="password-indicator" style="display: none; font-size: 0.75rem; color: #4caf50; margin-top: 0.25rem;">‚úî Focused via ref</span>
                                </div>
                                
                                <div style="margin-bottom: 1rem;">
                                    <label style="display: block; font-size: 0.85rem; color: #666; margin-bottom: 0.25rem;">Confirm Password</label>
                                    <input id="demo-confirm" type="password" placeholder="Confirm password" style="width: 100%; padding: 0.6rem; border: 2px solid #e0e0e0; border-radius: 6px; font-size: 0.95rem; box-sizing: border-box; transition: border-color 0.2s, box-shadow 0.2s;" onfocus="highlightField('confirm')" onblur="unhighlightField('confirm')">
                                    <span id="confirm-indicator" style="display: none; font-size: 0.75rem; color: #4caf50; margin-top: 0.25rem;">‚úî Focused via ref</span>
                                </div>
                            </div>
                            
                            <!-- Control Buttons -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-top: 1rem;">
                                <button onclick="focusField('email')" style="padding: 0.6rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Focus Email</button>
                                <button onclick="focusField('password')" style="padding: 0.6rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Focus Password</button>
                                <button onclick="focusField('confirm')" style="padding: 0.6rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Focus Confirm</button>
                                <button onclick="focusFirstEmpty()" style="padding: 0.6rem; background: #f093fb; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; font-size: 0.85rem;">Focus First Empty</button>
                            </div>
                            
                            <div style="margin-top: 1rem; padding: 0.75rem; background: #e8f5e9; border-radius: 6px; border-left: 3px solid #4caf50;">
                                <p id="focus-status" style="margin: 0; font-size: 0.85rem; color: #2e7d32;">Click buttons above to programmatically focus inputs using refs!</p>
                            </div>
                        </div>
                        
                        <!-- Code representation -->
                        <div style="margin-top: 1.5rem; padding: 1rem; background: #1e1e1e; border-radius: 8px; overflow-x: auto;">
                            <pre style="margin: 0; color: #d4d4d4; font-size: 0.8rem; line-height: 1.5;"><code><span style="color: #569cd6;">const</span> <span style="color: #9cdcfe;">emailRef</span> = <span style="color: #dcdcaa;">useRef</span>&lt;<span style="color: #4ec9b0;">HTMLInputElement</span>&gt;(<span style="color: #569cd6;">null</span>);
<span style="color: #569cd6;">const</span> <span style="color: #9cdcfe;">passwordRef</span> = <span style="color: #dcdcaa;">useRef</span>&lt;<span style="color: #4ec9b0;">HTMLInputElement</span>&gt;(<span style="color: #569cd6;">null</span>);

<span style="color: #6a9955;">// Focus email on mount</span>
<span style="color: #dcdcaa;">useEffect</span>(() =&gt; {
  <span style="color: #9cdcfe;">emailRef</span>.<span style="color: #9cdcfe;">current</span>?.<span style="color: #dcdcaa;">focus</span>();
}, []);

<span style="color: #6a9955;">// Focus first invalid field on submit</span>
<span style="color: #569cd6;">const</span> <span style="color: #dcdcaa;">focusFirstEmpty</span> = () =&gt; {
  <span style="color: #c586c0;">if</span> (!<span style="color: #9cdcfe;">emailRef</span>.<span style="color: #9cdcfe;">current</span>?.<span style="color: #9cdcfe;">value</span>) {
    <span style="color: #9cdcfe;">emailRef</span>.<span style="color: #9cdcfe;">current</span>?.<span style="color: #dcdcaa;">focus</span>();
  } <span style="color: #c586c0;">else if</span> (!<span style="color: #9cdcfe;">passwordRef</span>.<span style="color: #9cdcfe;">current</span>?.<span style="color: #9cdcfe;">value</span>) {
    <span style="color: #9cdcfe;">passwordRef</span>.<span style="color: #9cdcfe;">current</span>?.<span style="color: #dcdcaa;">focus</span>();
  }
};</code></pre>
                        </div>
                    </div>
                </div>
                
                <script>
                function focusField(field) {
                    const input = document.getElementById(`demo-${field}`);
                    input.focus();
                    document.getElementById('focus-status').textContent = `üéØ emailRef.current?.focus() called - ${field} input focused!`;
                }
                
                function focusFirstEmpty() {
                    const email = document.getElementById('demo-email');
                    const password = document.getElementById('demo-password');
                    const confirm = document.getElementById('demo-confirm');
                    
                    if (!email.value) {
                        email.focus();
                        document.getElementById('focus-status').textContent = 'üîç Email was empty - focused it first!';
                    } else if (!password.value) {
                        password.focus();
                        document.getElementById('focus-status').textContent = 'üîç Password was empty - focused it!';
                    } else if (!confirm.value) {
                        confirm.focus();
                        document.getElementById('focus-status').textContent = 'üîç Confirm was empty - focused it!';
                    } else {
                        document.getElementById('focus-status').textContent = '‚úÖ All fields filled! Form ready to submit.';
                    }
                }
                
                function highlightField(field) {
                    const input = document.getElementById(`demo-${field}`);
                    const indicator = document.getElementById(`${field}-indicator`);
                    input.style.borderColor = '#4caf50';
                    input.style.boxShadow = '0 0 0 3px rgba(76, 175, 80, 0.2)';
                    indicator.style.display = 'block';
                }
                
                function unhighlightField(field) {
                    const input = document.getElementById(`demo-${field}`);
                    const indicator = document.getElementById(`${field}-indicator`);
                    input.style.borderColor = '#e0e0e0';
                    input.style.boxShadow = 'none';
                    indicator.style.display = 'none';
                }
                </script>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface LoginFormProps {
    onSubmit: (credentials: { email: string; password: string }) => void;
}

function LoginForm({ onSubmit }: LoginFormProps) {
    const emailRef = useRef&lt;HTMLInputElement&gt;(null);
    const passwordRef = useRef&lt;HTMLInputElement&gt;(null);
    const [errors, setErrors] = useState&lt;{ email?: string; password?: string }&gt;({});
    
    // Focus email input when component mounts
    useEffect(() => {
        emailRef.current?.focus();
    }, []);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        
        const email = emailRef.current?.value || '';
        const password = passwordRef.current?.value || '';
        
        // Validate
        const newErrors: { email?: string; password?: string } = {};
        
        if (!email.includes('@')) {
            newErrors.email = 'Invalid email';
            emailRef.current?.focus(); // Focus first error
            setErrors(newErrors);
            return;
        }
        
        if (password.length < 8) {
            newErrors.password = 'Password must be 8+ characters';
            passwordRef.current?.focus();
            setErrors(newErrors);
            return;
        }
        
        setErrors({});
        onSubmit({ email, password });
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;div&gt;
                &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
                &lt;input
                    id="email"
                    ref={emailRef}
                    type="email"
                    aria-invalid={!!errors.email}
                    aria-describedby={errors.email ? 'email-error' : undefined}
                /&gt;
                {errors.email && (
                    &lt;span id="email-error" role="alert"&gt;{errors.email}&lt;/span&gt;
                )}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
                &lt;input
                    id="password"
                    ref={passwordRef}
                    type="password"
                    aria-invalid={!!errors.password}
                /&gt;
                {errors.password && (
                    &lt;span role="alert"&gt;{errors.password}&lt;/span&gt;
                )}
            &lt;/div&gt;
            
            &lt;button type="submit"&gt;Login&lt;/button&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Focus Management Best Practices</h4>
                    <ul>
                        <li>Focus first input on mount for better UX</li>
                        <li>Focus first invalid field on validation error</li>
                        <li>Use <code>aria-invalid</code> and <code>aria-describedby</code> for accessibility</li>
                        <li>Consider keyboard navigation (Tab order)</li>
                        <li>Don't steal focus unexpectedly - only on user action or mount</li>
                    </ul>
                </div>

                <h3>Pattern 2: Scroll Management</h3>
                <p>Scrolling to specific elements is another common use case - like scrolling to new messages, jumping to sections, or creating "back to top" buttons.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Message {
    id: string;
    text: string;
    sender: string;
    timestamp: Date;
}

interface ChatMessagesProps {
    messages: Message[];
}

function ChatMessages({ messages }: ChatMessagesProps) {
    const messagesEndRef = useRef&lt;HTMLDivElement&gt;(null);
    const containerRef = useRef&lt;HTMLDivElement&gt;(null);
    const [showScrollButton, setShowScrollButton] = useState(false);
    
    // Auto-scroll to bottom when new messages arrive
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);
    
    // Show/hide scroll-to-bottom button based on scroll position
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;
        
        const handleScroll = () => {
            const { scrollTop, scrollHeight, clientHeight } = container;
            const isNearBottom = scrollHeight - scrollTop - clientHeight < 100;
            setShowScrollButton(!isNearBottom);
        };
        
        container.addEventListener('scroll', handleScroll);
        return () => container.removeEventListener('scroll', handleScroll);
    }, []);
    
    const scrollToBottom = () => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    };
    
    return (
        &lt;div className="chat-container"&gt;
            &lt;div ref={containerRef} className="messages-list"&gt;
                {messages.map(msg => (
                    &lt;div key={msg.id} className="message"&gt;
                        &lt;strong&gt;{msg.sender}:&lt;/strong&gt; {msg.text}
                    &lt;/div&gt;
                ))}
                &lt;div ref={messagesEndRef} /&gt;
            &lt;/div&gt;
            
            {showScrollButton && (
                &lt;button 
                    className="scroll-to-bottom"
                    onClick={scrollToBottom}
                    aria-label="Scroll to latest messages"
                &gt;
                    ‚Üì New messages
                &lt;/button&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 3: Measuring Elements</h3>
                <p>Sometimes you need to know an element's size or position to make layout decisions or create responsive components.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ResponsiveDropdown() {
    const triggerRef = useRef&lt;HTMLButtonElement&gt;(null);
    const dropdownRef = useRef&lt;HTMLDivElement&gt;(null);
    const [isOpen, setIsOpen] = useState(false);
    const [dropdownPosition, setDropdownPosition] = useState&lt;'bottom' | 'top'&gt;('bottom');
    
    useEffect(() => {
        if (!isOpen || !triggerRef.current || !dropdownRef.current) return;
        
        const triggerRect = triggerRef.current.getBoundingClientRect();
        const dropdownRect = dropdownRef.current.getBoundingClientRect();
        
        // Check if dropdown would overflow viewport
        const spaceBelow = window.innerHeight - triggerRect.bottom;
        const spaceAbove = triggerRect.top;
        
        if (spaceBelow < dropdownRect.height && spaceAbove > dropdownRect.height) {
            setDropdownPosition('top');
        } else {
            setDropdownPosition('bottom');
        }
    }, [isOpen]);
    
    return (
        &lt;div className="dropdown-container"&gt;
            &lt;button
                ref={triggerRef}
                onClick={() => setIsOpen(!isOpen)}
                aria-expanded={isOpen}
                aria-haspopup="true"
            &gt;
                Open Menu
            &lt;/button&gt;
            
            {isOpen && (
                &lt;div
                    ref={dropdownRef}
                    className={`dropdown-menu dropdown-${dropdownPosition}`}
                    role="menu"
                &gt;
                    &lt;button role="menuitem"&gt;Option 1&lt;/button&gt;
                    &lt;button role="menuitem"&gt;Option 2&lt;/button&gt;
                    &lt;button role="menuitem"&gt;Option 3&lt;/button&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 4: Integrating Third-Party Libraries</h3>
                <p>Many libraries need direct DOM access. Refs are perfect for integrating them with React.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import Chart from 'chart.js/auto'; // Example: Chart.js

interface ChartData {
    labels: string[];
    values: number[];
}

interface ChartComponentProps {
    data: ChartData;
    type: 'bar' | 'line' | 'pie';
}

function ChartComponent({ data, type }: ChartComponentProps) {
    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null);
    const chartRef = useRef&lt;Chart | null&gt;(null);
    
    useEffect(() => {
        if (!canvasRef.current) return;
        
        // Destroy previous chart instance if it exists
        if (chartRef.current) {
            chartRef.current.destroy();
        }
        
        // Create new chart
        chartRef.current = new Chart(canvasRef.current, {
            type,
            data: {
                labels: data.labels,
                datasets: [{
                    label: 'Dataset',
                    data: data.values,
                    backgroundColor: 'rgba(102, 126, 234, 0.5)',
                    borderColor: 'rgba(102, 126, 234, 1)',
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false
            }
        });
        
        // Cleanup: destroy chart when component unmounts
        return () => {
            if (chartRef.current) {
                chartRef.current.destroy();
            }
        };
    }, [data, type]);
    
    return (
        &lt;div style={{ height: '400px', width: '100%' }}&gt;
            &lt;canvas ref={canvasRef} /&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Third-Party Library Integration Tips</h4>
                    <ul>
                        <li>Always clean up library instances in useEffect return</li>
                        <li>Store the library instance in a ref (not state)</li>
                        <li>Destroy and recreate when dependencies change</li>
                        <li>Check for null before accessing DOM elements</li>
                        <li>Consider creating custom hooks to encapsulate library logic</li>
                    </ul>
                </div>

                <h3>Pattern 5: Previous Value Tracking</h3>
                <p>Sometimes you need to know what a value was in the previous render to detect changes or revert to old values.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Custom hook to track previous value
function usePrevious&lt;T&gt;(value: T): T | undefined {
    const ref = useRef&lt;T&gt;();
    
    useEffect(() => {
        ref.current = value;
    }, [value]);
    
    return ref.current;
}

// Usage example
function CounterWithHistory() {
    const [count, setCount] = useState(0);
    const previousCount = usePrevious(count);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Current: {count}&lt;/p&gt;
            &lt;p&gt;Previous: {previousCount ?? 'N/A'}&lt;/p&gt;
            &lt;p&gt;
                {previousCount !== undefined && count > previousCount && 'üìà Increased!'}
                {previousCount !== undefined && count < previousCount && 'üìâ Decreased!'}
            &lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
            &lt;button onClick={() => setCount(count - 1)}&gt;-&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Pattern 6: Imperative Handles with Videos/Audio</h3>
                <p>Media elements often need imperative control - play, pause, seek. Refs make this straightforward.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface VideoPlayerProps {
    src: string;
    poster?: string;
}

function VideoPlayer({ src, poster }: VideoPlayerProps) {
    const videoRef = useRef&lt;HTMLVideoElement&gt;(null);
    const [isPlaying, setIsPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState(0);
    const [duration, setDuration] = useState(0);
    
    const togglePlayPause = () => {
        if (!videoRef.current) return;
        
        if (isPlaying) {
            videoRef.current.pause();
        } else {
            videoRef.current.play();
        }
        setIsPlaying(!isPlaying);
    };
    
    const handleSeek = (time: number) => {
        if (!videoRef.current) return;
        videoRef.current.currentTime = time;
        setCurrentTime(time);
    };
    
    const handleTimeUpdate = () => {
        if (!videoRef.current) return;
        setCurrentTime(videoRef.current.currentTime);
    };
    
    const handleLoadedMetadata = () => {
        if (!videoRef.current) return;
        setDuration(videoRef.current.duration);
    };
    
    const handleSkip = (seconds: number) => {
        if (!videoRef.current) return;
        const newTime = Math.max(0, Math.min(duration, currentTime + seconds));
        handleSeek(newTime);
    };
    
    return (
        &lt;div className="video-player"&gt;
            &lt;video
                ref={videoRef}
                src={src}
                poster={poster}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onEnded={() => setIsPlaying(false)}
            /&gt;
            
            &lt;div className="controls"&gt;
                &lt;button onClick={togglePlayPause}&gt;
                    {isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play'}
                &lt;/button&gt;
                
                &lt;button onClick={() => handleSkip(-10)}&gt;‚è™ -10s&lt;/button&gt;
                &lt;button onClick={() => handleSkip(10)}&gt;‚è© +10s&lt;/button&gt;
                
                &lt;input
                    type="range"
                    min="0"
                    max={duration}
                    value={currentTime}
                    onChange={(e) => handleSeek(Number(e.target.value))}
                    aria-label="Seek video"
                /&gt;
                
                &lt;span&gt;
                    {Math.floor(currentTime)}s / {Math.floor(duration)}s
                &lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>
            </section>

            <!-- Section 8: Forwarding Refs -->
            <section id="section8" class="lesson-section">
                <h2>üîÑ Forwarding Refs</h2>
                <p>Sometimes you need to pass a ref from a parent component down to a child component. This is called "ref forwarding" and it's essential for creating reusable components that need DOM access.</p>

                <h3>The Problem: Refs Don't Pass Like Props</h3>
                <p>Unlike regular props, refs are handled specially by React. You can't just pass a ref as a prop - you need to use <code>forwardRef</code>.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå This doesn't work - ref is not a prop
interface InputProps {
    label: string;
    ref: React.RefObject&lt;HTMLInputElement&gt;; // Won't work!
}

function CustomInput({ label, ref }: InputProps) {
    return (
        &lt;div&gt;
            &lt;label&gt;{label}&lt;/label&gt;
            &lt;input ref={ref} /&gt; {/* ref is undefined! */}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>The Solution: forwardRef</h3>
                <p><code>forwardRef</code> is a special function that lets your component receive a ref and pass it down to a child element.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { forwardRef } from 'react';

interface CustomInputProps {
    label: string;
    error?: string;
}

// ‚úÖ Correct way: use forwardRef
const CustomInput = forwardRef&lt;HTMLInputElement, CustomInputProps&gt;(
    ({ label, error }, ref) => {
        return (
            &lt;div className="input-group"&gt;
                &lt;label&gt;{label}&lt;/label&gt;
                &lt;input
                    ref={ref}
                    className={error ? 'input-error' : ''}
                    aria-invalid={!!error}
                /&gt;
                {error && &lt;span className="error-message"&gt;{error}&lt;/span&gt;}
            &lt;/div&gt;
        );
    }
);

CustomInput.displayName = 'CustomInput'; // Good practice for debugging

// Usage
function LoginForm() {
    const emailRef = useRef&lt;HTMLInputElement&gt;(null);
    
    useEffect(() => {
        emailRef.current?.focus();
    }, []);
    
    return (
        &lt;form&gt;
            &lt;CustomInput ref={emailRef} label="Email" /&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ forwardRef Syntax</h4>
                    <pre style="color: white; background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 4px;"><code>const Component = forwardRef&lt;RefType, PropsType&gt;(
    (props, ref) => {
        // Component logic
        return &lt;element ref={ref} /&gt;
    }
);</code></pre>
                </div>

                <h3>Advanced: useImperativeHandle</h3>
                <p>Sometimes you don't want to expose the entire DOM element - you only want to expose specific methods. <code>useImperativeHandle</code> lets you customize what the parent sees.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { forwardRef, useImperativeHandle, useRef } from 'react';

// Define what methods we expose to parent
interface VideoPlayerHandle {
    play: () => void;
    pause: () => void;
    seek: (time: number) => void;
    getCurrentTime: () => number;
}

interface VideoPlayerProps {
    src: string;
}

const VideoPlayer = forwardRef&lt;VideoPlayerHandle, VideoPlayerProps&gt;(
    ({ src }, ref) => {
        const videoRef = useRef&lt;HTMLVideoElement&gt;(null);
        
        // Expose only these methods to parent
        useImperativeHandle(ref, () => ({
            play() {
                videoRef.current?.play();
            },
            pause() {
                videoRef.current?.pause();
            },
            seek(time: number) {
                if (videoRef.current) {
                    videoRef.current.currentTime = time;
                }
            },
            getCurrentTime() {
                return videoRef.current?.currentTime ?? 0;
            }
        }), []);
        
        return &lt;video ref={videoRef} src={src} /&gt;;
    }
);

VideoPlayer.displayName = 'VideoPlayer';

// Usage in parent
function VideoApp() {
    const playerRef = useRef&lt;VideoPlayerHandle&gt;(null);
    
    return (
        &lt;div&gt;
            &lt;VideoPlayer ref={playerRef} src="video.mp4" /&gt;
            
            &lt;button onClick={() => playerRef.current?.play()}&gt;
                Play
            &lt;/button&gt;
            &lt;button onClick={() => playerRef.current?.pause()}&gt;
                Pause
            &lt;/button&gt;
            &lt;button onClick={() => playerRef.current?.seek(30)}&gt;
                Skip to 30s
            &lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use useImperativeHandle</h4>
                    <ul>
                        <li>Creating library-like components with specific APIs</li>
                        <li>Hiding implementation details from parent</li>
                        <li>Providing controlled access to child functionality</li>
                        <li>Building form components with validate/reset methods</li>
                        <li>Creating media player components with playback controls</li>
                    </ul>
                </div>

                <h3>Real-World Example: Form Field Component</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface FormFieldHandle {
    focus: () => void;
    getValue: () => string;
    setValue: (value: string) => void;
    validate: () => boolean;
}

interface FormFieldProps {
    label: string;
    type?: 'text' | 'email' | 'password';
    required?: boolean;
    pattern?: string;
    errorMessage?: string;
}

const FormField = forwardRef&lt;FormFieldHandle, FormFieldProps&gt;(
    ({ label, type = 'text', required, pattern, errorMessage }, ref) => {
        const inputRef = useRef&lt;HTMLInputElement&gt;(null);
        const [error, setError] = useState('');
        
        useImperativeHandle(ref, () => ({
            focus() {
                inputRef.current?.focus();
            },
            getValue() {
                return inputRef.current?.value ?? '';
            },
            setValue(value: string) {
                if (inputRef.current) {
                    inputRef.current.value = value;
                }
            },
            validate() {
                const value = inputRef.current?.value ?? '';
                
                if (required && !value) {
                    setError('This field is required');
                    return false;
                }
                
                if (pattern && !new RegExp(pattern).test(value)) {
                    setError(errorMessage ?? 'Invalid format');
                    return false;
                }
                
                setError('');
                return true;
            }
        }), [required, pattern, errorMessage]);
        
        return (
            &lt;div className="form-field"&gt;
                &lt;label&gt;{label} {required && &lt;span&gt;*&lt;/span&gt;}&lt;/label&gt;
                &lt;input
                    ref={inputRef}
                    type={type}
                    aria-required={required}
                    aria-invalid={!!error}
                /&gt;
                {error && &lt;span className="error"&gt;{error}&lt;/span&gt;}
            &lt;/div&gt;
        );
    }
);

FormField.displayName = 'FormField';

// Usage
function RegistrationForm() {
    const emailRef = useRef&lt;FormFieldHandle&gt;(null);
    const passwordRef = useRef&lt;FormFieldHandle&gt;(null);
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        
        const emailValid = emailRef.current?.validate();
        const passwordValid = passwordRef.current?.validate();
        
        if (!emailValid) {
            emailRef.current?.focus();
            return;
        }
        
        if (!passwordValid) {
            passwordRef.current?.focus();
            return;
        }
        
        // Submit form
        const email = emailRef.current?.getValue();
        const password = passwordRef.current?.getValue();
        console.log('Submitting:', { email, password });
    };
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;FormField
                ref={emailRef}
                label="Email"
                type="email"
                required
                pattern="^[^\s@]+@[^\s@]+\.[^\s@]+$"
                errorMessage="Please enter a valid email"
            /&gt;
            
            &lt;FormField
                ref={passwordRef}
                label="Password"
                type="password"
                required
                pattern=".{8,}"
                errorMessage="Password must be at least 8 characters"
            /&gt;
            
            &lt;button type="submit"&gt;Register&lt;/button&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>
            </section>

            <!-- Section 9: Hands-on Practice -->
            <section id="section9" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Let's apply what you've learned with practical exercises. Try to complete each one before looking at the solution!</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Image Gallery with Keyboard Navigation</h3>
                    <p><strong>Goal:</strong> Build an image gallery where arrow keys navigate between images and the current image is always in view.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Display a list of images with thumbnails</li>
                        <li>Use Left/Right arrow keys to navigate</li>
                        <li>Automatically scroll selected image into view</li>
                        <li>Highlight the currently selected image</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>You'll need:</p>
                        <ul>
                            <li>An array of refs (one for each image)</li>
                            <li>State to track current index</li>
                            <li>useEffect to add keyboard event listener</li>
                            <li>scrollIntoView() when index changes</li>
                        </ul>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">interface Image {
    id: string;
    url: string;
    alt: string;
}

interface ImageGalleryProps {
    images: Image[];
}

function ImageGallery({ images }: ImageGalleryProps) {
    const [selectedIndex, setSelectedIndex] = useState(0);
    const imageRefs = useRef&lt;(HTMLDivElement | null)[]&gt;([]);
    
    // Initialize refs array
    useEffect(() => {
        imageRefs.current = imageRefs.current.slice(0, images.length);
    }, [images]);
    
    // Keyboard navigation
    useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'ArrowLeft') {
                setSelectedIndex(prev => 
                    prev > 0 ? prev - 1 : images.length - 1
                );
            } else if (e.key === 'ArrowRight') {
                setSelectedIndex(prev => 
                    prev < images.length - 1 ? prev + 1 : 0
                );
            }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [images.length]);
    
    // Scroll selected image into view
    useEffect(() => {
        imageRefs.current[selectedIndex]?.scrollIntoView({
            behavior: 'smooth',
            block: 'nearest',
            inline: 'center'
        });
    }, [selectedIndex]);
    
    return (
        &lt;div className="gallery"&gt;
            &lt;div className="thumbnails"&gt;
                {images.map((image, index) => (
                    &lt;div
                        key={image.id}
                        ref={el => imageRefs.current[index] = el}
                        className={`thumbnail ${index === selectedIndex ? 'selected' : ''}`}
                        onClick={() => setSelectedIndex(index)}
                        role="button"
                        tabIndex={0}
                        aria-label={`View ${image.alt}`}
                    &gt;
                        &lt;img src={image.url} alt={image.alt} /&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
            
            &lt;div className="main-image"&gt;
                &lt;img 
                    src={images[selectedIndex].url} 
                    alt={images[selectedIndex].alt} 
                /&gt;
                &lt;p&gt;{selectedIndex + 1} / {images.length}&lt;/p&gt;
            &lt;/div&gt;
            
            &lt;p className="hint"&gt;Use ‚Üê ‚Üí keys to navigate&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Click-Outside to Close</h3>
                    <p><strong>Goal:</strong> Create a modal or dropdown that closes when you click outside of it.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Show/hide a dropdown on button click</li>
                        <li>Close dropdown when clicking outside</li>
                        <li>Don't close when clicking inside the dropdown</li>
                        <li>Clean up event listeners properly</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>useRef</code> for the dropdown element and <code>useEffect</code> to add a document click listener that checks if the click target is inside the ref.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">function Dropdown() {
    const [isOpen, setIsOpen] = useState(false);
    const dropdownRef = useRef&lt;HTMLDivElement&gt;(null);
    
    useEffect(() => {
        if (!isOpen) return;
        
        const handleClickOutside = (event: MouseEvent) => {
            if (
                dropdownRef.current && 
                !dropdownRef.current.contains(event.target as Node)
            ) {
                setIsOpen(false);
            }
        };
        
        // Add listener after a brief delay to avoid immediate close
        const timeoutId = setTimeout(() => {
            document.addEventListener('mousedown', handleClickOutside);
        }, 0);
        
        return () => {
            clearTimeout(timeoutId);
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isOpen]);
    
    return (
        &lt;div className="dropdown-container" ref={dropdownRef}&gt;
            &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
                Toggle Menu
            &lt;/button&gt;
            
            {isOpen && (
                &lt;div className="dropdown-menu"&gt;
                    &lt;button&gt;Option 1&lt;/button&gt;
                    &lt;button&gt;Option 2&lt;/button&gt;
                    &lt;button&gt;Option 3&lt;/button&gt;
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Debounced Search with Auto-focus</h3>
                    <p><strong>Goal:</strong> Create a search input that auto-focuses on mount and debounces the search query.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Auto-focus the input when component mounts</li>
                        <li>Debounce the search (wait 500ms after typing stops)</li>
                        <li>Display search results</li>
                        <li>Clear timeout on unmount</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>You'll need a ref for the input element and another ref to store the timeout ID so you can clear it.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">interface SearchResult {
    id: string;
    title: string;
}

function SearchComponent() {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState&lt;SearchResult[]&gt;([]);
    const [isSearching, setIsSearching] = useState(false);
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    const timeoutRef = useRef&lt;NodeJS.Timeout&gt;();
    
    // Auto-focus on mount
    useEffect(() => {
        inputRef.current?.focus();
    }, []);
    
    // Debounced search
    useEffect(() => {
        // Clear previous timeout
        if (timeoutRef.current) {
            clearTimeout(timeoutRef.current);
        }
        
        if (!query) {
            setResults([]);
            return;
        }
        
        setIsSearching(true);
        
        // Set new timeout
        timeoutRef.current = setTimeout(() => {
            // Simulate API call
            const mockResults: SearchResult[] = [
                { id: '1', title: `Result for "${query}" 1` },
                { id: '2', title: `Result for "${query}" 2` },
                { id: '3', title: `Result for "${query}" 3` }
            ];
            
            setResults(mockResults);
            setIsSearching(false);
        }, 500);
        
        // Cleanup
        return () => {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
        };
    }, [query]);
    
    return (
        &lt;div className="search-container"&gt;
            &lt;input
                ref={inputRef}
                type="search"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Search..."
                aria-label="Search"
            /&gt;
            
            {isSearching && &lt;p&gt;Searching...&lt;/p&gt;}
            
            &lt;ul className="results"&gt;
                {results.map(result => (
                    &lt;li key={result.id}&gt;{result.title}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
            
            {query && !isSearching && results.length === 0 && (
                &lt;p&gt;No results found&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: Infinite Scroll</h3>
                    <p><strong>Goal:</strong> Implement infinite scroll that loads more items when user scrolls near the bottom.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Display a list of items</li>
                        <li>Detect when user scrolls near bottom (within 100px)</li>
                        <li>Load more items automatically</li>
                        <li>Show loading indicator</li>
                        <li>Prevent multiple simultaneous loads</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">interface Item {
    id: number;
    title: string;
}

function InfiniteScrollList() {
    const [items, setItems] = useState&lt;Item[]&gt;(
        Array.from({ length: 20 }, (_, i) => ({
            id: i,
            title: `Item ${i + 1}`
        }))
    );
    const [isLoading, setIsLoading] = useState(false);
    const [hasMore, setHasMore] = useState(true);
    const containerRef = useRef&lt;HTMLDivElement&gt;(null);
    const loadingRef = useRef(false);
    
    const loadMore = async () => {
        if (loadingRef.current || !hasMore) return;
        
        loadingRef.current = true;
        setIsLoading(true);
        
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        const newItems = Array.from({ length: 20 }, (_, i) => ({
            id: items.length + i,
            title: `Item ${items.length + i + 1}`
        }));
        
        setItems(prev => [...prev, ...newItems]);
        setIsLoading(false);
        loadingRef.current = false;
        
        // Stop after 100 items
        if (items.length >= 80) {
            setHasMore(false);
        }
    };
    
    useEffect(() => {
        const container = containerRef.current;
        if (!container) return;
        
        const handleScroll = () => {
            const { scrollTop, scrollHeight, clientHeight } = container;
            
            // Load more when within 100px of bottom
            if (scrollHeight - scrollTop - clientHeight < 100) {
                loadMore();
            }
        };
        
        container.addEventListener('scroll', handleScroll);
        return () => container.removeEventListener('scroll', handleScroll);
    }, [items, hasMore]);
    
    return (
        &lt;div 
            ref={containerRef} 
            className="scroll-container"
            style={{ height: '500px', overflow: 'auto' }}
        &gt;
            &lt;h2&gt;Infinite Scroll Demo&lt;/h2&gt;
            &lt;ul&gt;
                {items.map(item => (
                    &lt;li key={item.id} style={{ padding: '1rem', borderBottom: '1px solid #ccc' }}&gt;
                        {item.title}
                    &lt;/li&gt;
                ))}
            &lt;/ul&gt;
            
            {isLoading && (
                &lt;div style={{ textAlign: 'center', padding: '1rem' }}&gt;
                    Loading more items...
                &lt;/div&gt;
            )}
            
            {!hasMore && (
                &lt;div style={{ textAlign: 'center', padding: '1rem' }}&gt;
                    No more items to load
                &lt;/div&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="section10" class="lesson-section">
                <h2>‚úÖ Best Practices</h2>
                <p>Follow these guidelines to use refs effectively and avoid common pitfalls.</p>

                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Use refs for DOM access:</strong> Focus inputs, measure elements, scroll positions - these are perfect ref use cases</li>
                    <li><strong>Store mutable values that don't affect rendering:</strong> Timer IDs, subscription objects, previous values</li>
                    <li><strong>Always check for null:</strong> Use optional chaining (<code>ref.current?.</code>) since refs can be null</li>
                    <li><strong>Clean up in useEffect:</strong> Clear intervals, close connections, destroy library instances</li>
                    <li><strong>Use TypeScript generics:</strong> <code>useRef&lt;HTMLInputElement&gt;(null)</code> for proper typing</li>
                    <li><strong>Initialize DOM refs with null:</strong> <code>useRef&lt;HTMLElement&gt;(null)</code> is the convention</li>
                    <li><strong>Use forwardRef for reusable components:</strong> Makes your components more flexible</li>
                    <li><strong>Set displayName on forwarded refs:</strong> Helps with debugging in React DevTools</li>
                    <li><strong>Combine with other hooks:</strong> Refs work great with useState, useEffect, useCallback</li>
                    <li><strong>Document imperative APIs:</strong> When using useImperativeHandle, document what methods are exposed</li>
                </ul>

                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't use refs instead of state for rendering:</strong> If it affects what the user sees, it should be state</li>
                    <li><strong>Don't read/write refs during rendering:</strong> Refs should be accessed in event handlers or effects, not during render</li>
                    <li><strong>Don't forget cleanup:</strong> Always clear intervals, timeouts, and subscriptions stored in refs</li>
                    <li><strong>Don't mutate ref.current during render:</strong> This can cause confusing bugs and inconsistent renders</li>
                    <li><strong>Don't use refs to pass data between components:</strong> Use props or context instead</li>
                    <li><strong>Don't expose entire DOM nodes unnecessarily:</strong> Use useImperativeHandle to expose only what's needed</li>
                    <li><strong>Don't forget about accessibility:</strong> Just because you can control focus doesn't mean you should abuse it</li>
                    <li><strong>Don't use refs for derived values:</strong> Calculate them during render instead</li>
                    <li><strong>Don't create refs in loops without keys:</strong> Use useRef inside map callbacks carefully</li>
                    <li><strong>Don't rely on ref updates for re-renders:</strong> Changing ref.current doesn't trigger re-renders</li>
                </ul>

                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Create custom hooks with refs:</strong> Encapsulate common ref patterns like usePrevious, useClickOutside</li>
                    <li><strong>Use callback refs for dynamic lists:</strong> When you need refs to array items, callback refs are more flexible</li>
                    <li><strong>Combine refs with Intersection Observer:</strong> Great for lazy loading and infinite scroll</li>
                    <li><strong>Store instances of classes in refs:</strong> Perfect for third-party library instances</li>
                    <li><strong>Use refs to prevent stale closures:</strong> Store latest values in refs when using setInterval</li>
                    <li><strong>Memoize callback refs:</strong> Use useCallback for callback refs to avoid unnecessary recreations</li>
                    <li><strong>Debug with ref.current in DevTools:</strong> Set a breakpoint and inspect ref values</li>
                    <li><strong>Create ref-based animations:</strong> Use refs with requestAnimationFrame for smooth animations</li>
                    <li><strong>Batch DOM operations with refs:</strong> Make multiple DOM changes efficiently outside React's render cycle</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéØ Quick Decision Guide</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Scenario</th>
                                <th>Use This</th>
                                <th>Not This</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Value displayed to user</td>
                                <td>useState</td>
                                <td>useRef</td>
                            </tr>
                            <tr>
                                <td>Timer ID for cleanup</td>
                                <td>useRef</td>
                                <td>useState</td>
                            </tr>
                            <tr>
                                <td>Focus an input</td>
                                <td>useRef</td>
                                <td>document.querySelector</td>
                            </tr>
                            <tr>
                                <td>Passing data down</td>
                                <td>Props/Context</td>
                                <td>useRef</td>
                            </tr>
                            <tr>
                                <td>Tracking previous value</td>
                                <td>useRef</td>
                                <td>useState</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Section 11: Common Mistakes -->
            <section id="section11" class="lesson-section">
                <h2>‚ö†Ô∏è Common Mistakes to Avoid</h2>
                <p>Learn from these common mistakes so you don't have to make them yourself!</p>

                <h3>Mistake 1: Reading Refs During Render</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - reading ref during render
function BadComponent() {
    const countRef = useRef(0);
    countRef.current++; // Don't do this!
    
    return &lt;div&gt;Renders: {countRef.current}&lt;/div&gt;;
}

// ‚úÖ Good - use state for values shown to user
function GoodComponent() {
    const [count, setCount] = useState(0);
    
    useEffect(() => {
        setCount(prev => prev + 1);
    });
    
    return &lt;div&gt;Renders: {count}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Mistake 2: Expecting Refs to Trigger Re-renders</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - expecting ref change to update UI
function BadCounter() {
    const countRef = useRef(0);
    
    const increment = () => {
        countRef.current++; // UI won't update!
    };
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {countRef.current}&lt;/p&gt; {/* Stuck at 0 */}
            &lt;button onClick={increment}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ Good - use state for UI updates
function GoodCounter() {
    const [count, setCount] = useState(0);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 3: Forgetting Cleanup</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - no cleanup, memory leak!
function BadTimer() {
    const timerRef = useRef&lt;NodeJS.Timeout&gt;();
    
    useEffect(() => {
        timerRef.current = setInterval(() => {
            console.log('tick');
        }, 1000);
        // Missing cleanup!
    }, []);
    
    return &lt;div&gt;Timer running&lt;/div&gt;;
}

// ‚úÖ Good - proper cleanup
function GoodTimer() {
    const timerRef = useRef&lt;NodeJS.Timeout&gt;();
    
    useEffect(() => {
        timerRef.current = setInterval(() => {
            console.log('tick');
        }, 1000);
        
        return () => {
            if (timerRef.current) {
                clearInterval(timerRef.current);
            }
        };
    }, []);
    
    return &lt;div&gt;Timer running&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Mistake 4: Not Checking for Null</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - might crash!
function BadFocus() {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    useEffect(() => {
        inputRef.current.focus(); // Might be null!
    }, []);
    
    return &lt;input ref={inputRef} /&gt;;
}

// ‚úÖ Good - null check
function GoodFocus() {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null);
    
    useEffect(() => {
        inputRef.current?.focus(); // Safe with optional chaining
    }, []);
    
    return &lt;input ref={inputRef} /&gt;;
}</code></pre>
                </div>

                <h3>Mistake 5: Using Wrong Initial Value</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - DOM ref initialized with undefined
function BadRef() {
    const inputRef = useRef&lt;HTMLInputElement&gt;(); // Type error!
    return &lt;input ref={inputRef} /&gt;;
}

// ‚ùå Also bad - mutable value initialized incorrectly
function AlsoBad() {
    const countRef = useRef&lt;number&gt;(); // undefined, not 0!
    countRef.current++; // NaN!
}

// ‚úÖ Good - proper initialization
function GoodRefs() {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null); // DOM refs start as null
    const countRef = useRef(0); // Mutable values have initial value
    
    return &lt;input ref={inputRef} /&gt;;
}</code></pre>
                </div>

                <h3>Mistake 6: Stale Closures with Refs</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - stale closure captures old value
function BadCallback({ onSave }: { onSave: (data: string) => void }) {
    const [data, setData] = useState('');
    
    useEffect(() => {
        const interval = setInterval(() => {
            onSave(data); // Always uses initial data value!
        }, 1000);
        
        return () => clearInterval(interval);
    }, []); // Empty deps = stale closure
    
    return &lt;input value={data} onChange={e => setData(e.target.value)} /&gt;;
}

// ‚úÖ Good - ref always has latest value
function GoodCallback({ onSave }: { onSave: (data: string) => void }) {
    const [data, setData] = useState('');
    const dataRef = useRef(data);
    
    // Keep ref in sync
    useEffect(() => {
        dataRef.current = data;
    }, [data]);
    
    useEffect(() => {
        const interval = setInterval(() => {
            onSave(dataRef.current); // Always uses latest data!
        }, 1000);
        
        return () => clearInterval(interval);
    }, [onSave]);
    
    return &lt;input value={data} onChange={e => setData(e.target.value)} /&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Remember</h4>
                    <ul>
                        <li>Refs are for DOM access and mutable values, not UI state</li>
                        <li>Changing refs doesn't trigger re-renders</li>
                        <li>Always clean up subscriptions, timers, and connections</li>
                        <li>Use optional chaining with refs to avoid crashes</li>
                        <li>Initialize DOM refs with null, mutable values with actual values</li>
                        <li>Use refs to solve stale closure problems in effects</li>
                    </ul>
                </div>
            </section>

            <!-- Section 12: Summary -->
            <section id="section12" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>useRef creates a mutable container</strong> that persists across renders without triggering re-renders</li>
                        <li><strong>Two main use cases:</strong> accessing DOM elements and storing mutable values</li>
                        <li><strong>Refs vs State:</strong> Use state for UI, refs for everything else that needs to persist</li>
                        <li><strong>Always check for null</strong> when accessing refs (use optional chaining)</li>
                        <li><strong>TypeScript typing:</strong> <code>useRef&lt;Type&gt;(initialValue)</code> for proper type safety</li>
                        <li><strong>Common patterns:</strong> Focus management, scroll control, measuring elements, integrating libraries</li>
                        <li><strong>forwardRef</strong> lets you pass refs to child components</li>
                        <li><strong>useImperativeHandle</strong> customizes what parent components can access</li>
                        <li><strong>Clean up subscriptions</strong> stored in refs to prevent memory leaks</li>
                        <li><strong>Don't read/write refs during render</strong> - use effects or event handlers instead</li>
                    </ul>
                </div>

                <h3>üéØ When to Use useRef</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>DOM Access</strong></td>
                            <td>Focus inputs, scroll to elements, measure sizes</td>
                        </tr>
                        <tr>
                            <td><strong>Timers</strong></td>
                            <td>Store setInterval/setTimeout IDs for cleanup</td>
                        </tr>
                        <tr>
                            <td><strong>Previous Values</strong></td>
                            <td>Track what props/state was in last render</td>
                        </tr>
                        <tr>
                            <td><strong>Library Integration</strong></td>
                            <td>Store Chart.js instances, WebSocket connections</td>
                        </tr>
                        <tr>
                            <td><strong>Avoiding Re-renders</strong></td>
                            <td>Store values that don't affect UI</td>
                        </tr>
                        <tr>
                            <td><strong>Mutable Trackers</strong></td>
                            <td>Count renders, track component mount status</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üîÑ The Complete Picture</h3>
                <div class="mermaid">
                graph LR
                    A[useRef] --> B[DOM Refs]
                    A --> C[Mutable Values]
                    
                    B --> D[Focus Management]
                    B --> E[Scroll Control]
                    B --> F[Measurements]
                    
                    C --> G[Timer IDs]
                    C --> H[Previous Values]
                    C --> I[Library Instances]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style B fill:#48bb78,stroke:#333,stroke-width:2px
                    style C fill:#48bb78,stroke:#333,stroke-width:2px
                </graph>
                </div>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://react.dev/reference/react/useRef" target="_blank" rel="noopener">React useRef Documentation</a></li>
                    <li><a href="https://react.dev/reference/react/forwardRef" target="_blank" rel="noopener">React forwardRef Documentation</a></li>
                    <li><a href="https://react.dev/reference/react/useImperativeHandle" target="_blank" rel="noopener">React useImperativeHandle Documentation</a></li>
                    <li><a href="https://www.patterns.dev/posts/refs-pattern" target="_blank" rel="noopener">Refs Pattern - Patterns.dev</a></li>
                    <li><a href="https://kentcdodds.com/blog/useeffect-vs-uselayouteffect" target="_blank" rel="noopener">Kent C. Dodds - When to Use Refs</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>useMemo and useCallback</strong> - React's performance optimization hooks. You'll learn when and how to memoize values and functions to prevent unnecessary re-renders and expensive calculations. These hooks work great alongside useRef for building highly performant React applications!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Practice Challenge</h3>
                    <p style="color: white;">Before moving on, try building one of these projects using useRef:</p>
                    <ul style="color: white;">
                        <li><strong>Custom Video Player:</strong> Build a complete video player with play/pause, seek, volume, and fullscreen controls</li>
                        <li><strong>Drawing Canvas:</strong> Create a canvas where users can draw with mouse/touch, with undo/redo functionality</li>
                        <li><strong>Auto-Save Form:</strong> Build a form that auto-saves draft to localStorage every 5 seconds using refs</li>
                        <li><strong>Notification System:</strong> Create toast notifications that auto-dismiss and can be manually closed</li>
                    </ul>
                </div>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've mastered one of React's most powerful hooks! You now understand how to work with the DOM imperatively, store mutable values, forward refs to child components, and avoid common pitfalls. Refs are your secret weapon for scenarios where React's declarative approach needs a little imperative help. Keep practicing and you'll find refs invaluable in your React toolkit! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_5_2_usecontext_hook.html" class="prev-lesson">‚Üê Previous: Lesson 5.2 - useContext Hook</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_5_4_usememo_usecallback.html" class="next-lesson">Next: Lesson 5.4 - useMemo and useCallback ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to build amazing React applications with TypeScript.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
