<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Module 9 Project: Add comprehensive test coverage to the E-commerce Product Catalog. Learn to write unit, integration, and E2E tests for a real-world React application with TypeScript.">
    <meta name="author" content="Ray">
    <title>Module 9 Project: Testing E-commerce Application - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                â˜°
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">ğŸŒ™</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 9: Testing React Applications</a></li>
            <li aria-current="page">Module Project: Testing E-commerce Application</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Project Header -->
            <header>
                <h1>ğŸ§ª Module 9 Project: Testing E-commerce Application</h1>
                <p class="lead">Welcome to your capstone project for Module 9! You're about to add comprehensive test coverage to a real-world e-commerce application. This project brings together everything you've learned about testing: unit tests for utilities and hooks, component tests with React Testing Library, integration tests for complex interactions, and E2E tests for critical user workflows. Think of this as building a safety net that gives you confidence to refactor and add features without fear. By the end, you'll have professional-grade tests that catch bugs early and document how your application works. Let's make this codebase bulletproof! ğŸ›¡ï¸</p>
                
                <!-- Project Overview -->
                <div class="card">
                    <h2>ğŸ¯ Project Overview</h2>
                    <p><strong>What You'll Build:</strong> Comprehensive test coverage for the e-commerce product catalog from Module 5</p>
                    
                    <h3>Testing Coverage:</h3>
                    <ul>
                        <li>âœ… Unit tests for utility functions and calculations</li>
                        <li>âœ… Component tests for product cards, cart items, filters</li>
                        <li>âœ… Integration tests for cart functionality and state management</li>
                        <li>âœ… Hook tests for custom hooks (useCart, useFilters)</li>
                        <li>âœ… Reducer tests for cart state logic</li>
                        <li>âœ… E2E tests for complete shopping workflows</li>
                        <li>âœ… API mocking with MSW</li>
                        <li>âœ… Accessibility testing</li>
                    </ul>
                    
                    <p><strong>Estimated Time:</strong> 4-5 hours</p>
                    <p><strong>Difficulty:</strong> Advanced</p>
                </div>

                <!-- Learning Objectives -->
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h2>ğŸ“ Learning Objectives</h2>
                    <p>By completing this project, you will:</p>
                    <ul>
                        <li>âœ… Write unit tests for business logic and utilities</li>
                        <li>âœ… Test React components with Testing Library</li>
                        <li>âœ… Write integration tests for component interactions</li>
                        <li>âœ… Test Context providers and reducers</li>
                        <li>âœ… Mock API calls with MSW</li>
                        <li>âœ… Write E2E tests with Playwright</li>
                        <li>âœ… Set up test infrastructure and CI/CD</li>
                        <li>âœ… Achieve meaningful test coverage</li>
                        <li>âœ… Follow testing best practices</li>
                    </ul>
                </div>

                <!-- Prerequisites -->
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h2>ğŸ“‹ Prerequisites</h2>
                    <p>Before starting this project, you should have:</p>
                    <ul>
                        <li>Completed Module 5 e-commerce project (or have similar codebase)</li>
                        <li>Completed all Module 9 lessons (9.1 - 9.5)</li>
                        <li>Understanding of Vitest and React Testing Library</li>
                        <li>Basic knowledge of Playwright or Cypress</li>
                        <li>Node.js and npm installed</li>
                    </ul>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">ğŸ“‘ Project Guide</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#setup" class="toc-link">Test Setup and Configuration</a></li>
                        <li><a href="#unit-tests" class="toc-link">Unit Tests: Utilities and Calculations</a></li>
                        <li><a href="#component-tests" class="toc-link">Component Tests: UI Components</a></li>
                        <li><a href="#reducer-tests" class="toc-link">Testing the Cart Reducer</a></li>
                        <li><a href="#hook-tests" class="toc-link">Testing Custom Hooks</a></li>
                        <li><a href="#integration-tests" class="toc-link">Integration Tests: Cart Functionality</a></li>
                        <li><a href="#context-tests" class="toc-link">Testing Context Providers</a></li>
                        <li><a href="#api-tests" class="toc-link">Testing with API Mocks</a></li>
                        <li><a href="#e2e-tests" class="toc-link">E2E Tests: Complete Workflows</a></li>
                        <li><a href="#ci-setup" class="toc-link">CI/CD Setup</a></li>
                        <li><a href="#coverage" class="toc-link">Test Coverage Analysis</a></li>
                        <li><a href="#summary" class="toc-link">Summary and Next Steps</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Test Setup and Configuration -->
            <section id="setup" class="lesson-section">
                <h2>âš™ï¸ Test Setup and Configuration</h2>
                
                <p>Let's start by setting up our testing infrastructure. We'll install all necessary testing libraries and configure them properly.</p>

                <h3>Installing Testing Dependencies</h3>
                <pre><code class="language-bash">
# Core testing libraries
npm install -D vitest @vitest/ui
npm install -D @testing-library/react @testing-library/jest-dom
npm install -D @testing-library/user-event
npm install -D jsdom

# MSW for API mocking
npm install -D msw

# Playwright for E2E tests
npm install -D @playwright/test
npx playwright install

# Additional utilities
npm install -D @vitest/coverage-v8
                </code></pre>

                <h3>Vitest Configuration</h3>
                <p>Create or update your <code>vite.config.ts</code> file:</p>
                
                <pre><code class="language-typescript">
// vite.config.ts
import { defineConfig } from 'vitest/config';
import react from '@vitejs/plugin-react';
import path from 'path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  test: {
    globals: true,
    environment: 'jsdom',
    setupFiles: './src/test/setup.ts',
    css: true,
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.spec.ts',
        '**/*.test.ts',
      ],
    },
  },
});
                </code></pre>

                <h3>Test Setup File</h3>
                <p>Create <code>src/test/setup.ts</code> for global test configuration:</p>

                <pre><code class="language-typescript">
// src/test/setup.ts
import '@testing-library/jest-dom';
import { cleanup } from '@testing-library/react';
import { afterEach, beforeAll, afterAll } from 'vitest';
import { server } from './mocks/server';

// Start MSW server before all tests
beforeAll(() => server.listen({ onUnhandledRequest: 'error' }));

// Reset handlers after each test
afterEach(() => {
  server.resetHandlers();
  cleanup();
});

// Clean up after all tests
afterAll(() => server.close());
                </code></pre>

                <h3>MSW Setup</h3>
                <p>Create MSW handlers for API mocking:</p>

                <pre><code class="language-typescript">
// src/test/mocks/handlers.ts
import { rest } from 'msw';
import { products } from '../../data/products';

export const handlers = [
  // Get all products
  rest.get('/api/products', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json(products)
    );
  }),
  
  // Get single product
  rest.get('/api/products/:id', (req, res, ctx) => {
    const { id } = req.params;
    const product = products.find(p => p.id === id);
    
    if (!product) {
      return res(ctx.status(404), ctx.json({ message: 'Product not found' }));
    }
    
    return res(ctx.status(200), ctx.json(product));
  }),
  
  // Search products
  rest.get('/api/products/search', (req, res, ctx) => {
    const query = req.url.searchParams.get('q');
    const filtered = products.filter(p =>
      p.name.toLowerCase().includes(query?.toLowerCase() || '')
    );
    
    return res(ctx.status(200), ctx.json(filtered));
  }),
];

// src/test/mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);
                </code></pre>

                <h3>Test Utilities</h3>
                <p>Create reusable test helpers:</p>

                <pre><code class="language-typescript">
// src/test/utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement } from 'react';
import { CartProvider } from '../context/CartContext';

interface AllTheProvidersProps {
  children: React.ReactNode;
}

function AllTheProviders({ children }: AllTheProvidersProps) {
  return (
    &lt;CartProvider&gt;
      {children}
    &lt;/CartProvider&gt;
  );
}

function renderWithProviders(
  ui: ReactElement,
  options?: Omit&lt;RenderOptions, 'wrapper'&gt;
) {
  return render(ui, { wrapper: AllTheProviders, ...options });
}

// Re-export everything
export * from '@testing-library/react';
export { renderWithProviders as render };
                </code></pre>

                <h3>Playwright Configuration</h3>
                <p>Create <code>playwright.config.ts</code>:</p>

                <pre><code class="language-typescript">
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  
  use: {
    baseURL: 'http://localhost:5173',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
  },
  
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
  ],
  
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});
                </code></pre>

                <h3>Package.json Scripts</h3>
                <p>Add testing scripts to your <code>package.json</code>:</p>

                <pre><code class="language-json">
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui"
  }
}
                </code></pre>

                <h3>Project Structure for Tests</h3>
                <pre><code class="language-text">
src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Cart/
â”‚   â”‚   â”œâ”€â”€ Cart.tsx
â”‚   â”‚   â”œâ”€â”€ Cart.test.tsx           â† Component test
â”‚   â”‚   â”œâ”€â”€ CartItem.tsx
â”‚   â”‚   â””â”€â”€ CartItem.test.tsx
â”‚   â””â”€â”€ Product/
â”‚       â”œâ”€â”€ ProductCard.tsx
â”‚       â””â”€â”€ ProductCard.test.tsx
â”œâ”€â”€ context/
â”‚   â”œâ”€â”€ CartContext.tsx
â”‚   â”œâ”€â”€ CartContext.test.tsx        â† Context test
â”‚   â”œâ”€â”€ CartReducer.ts
â”‚   â””â”€â”€ CartReducer.test.ts         â† Reducer test
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useCart.ts
â”‚   â””â”€â”€ useCart.test.ts             â† Hook test
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ calculations.ts
â”‚   â””â”€â”€ calculations.test.ts        â† Unit test
â”œâ”€â”€ test/
â”‚   â”œâ”€â”€ setup.ts
â”‚   â”œâ”€â”€ utils.tsx
â”‚   â””â”€â”€ mocks/
â”‚       â”œâ”€â”€ handlers.ts
â”‚       â””â”€â”€ server.ts
â””â”€â”€ e2e/
    â”œâ”€â”€ shopping-flow.spec.ts       â† E2E test
    â””â”€â”€ checkout.spec.ts
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Testing Infrastructure Checklist</h4>
                    <ul>
                        <li>âœ… Vitest installed and configured</li>
                        <li>âœ… React Testing Library set up</li>
                        <li>âœ… MSW configured for API mocking</li>
                        <li>âœ… Playwright installed for E2E tests</li>
                        <li>âœ… Test utilities and helpers created</li>
                        <li>âœ… Package scripts added</li>
                        <li>âœ… Test folder structure organized</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Verify Setup</h4>
                    <p>Run these commands to verify everything is working:</p>
                    <pre><code class="language-bash">
# Test Vitest is working
npm test

# Open Vitest UI
npm run test:ui

# Test Playwright is working
npm run test:e2e
                    </code></pre>
                </div>
            </section>

            <!-- Section 2: Unit Tests -->
            <section id="unit-tests" class="lesson-section">
                <h2>ğŸ”¬ Unit Tests: Utilities and Calculations</h2>
                
                <p>Let's start with unit tests for our utility functions. These are the foundation of our test suiteâ€”they're fast, focused, and test pure logic.</p>

                <h3>Testing Price Calculations</h3>
                <p>First, let's create the utility functions we'll test:</p>

                <pre><code class="language-typescript">
// src/utils/calculations.ts
export function calculateSubtotal(items: CartItem[]): number {
  return items.reduce((total, item) => {
    return total + (item.price * item.quantity);
  }, 0);
}

export function calculateTax(subtotal: number, taxRate: number = 0.08): number {
  return subtotal * taxRate;
}

export function calculateShipping(subtotal: number): number {
  if (subtotal >= 100) return 0;
  if (subtotal >= 50) return 5.99;
  return 9.99;
}

export function calculateTotal(items: CartItem[], taxRate?: number): number {
  const subtotal = calculateSubtotal(items);
  const tax = calculateTax(subtotal, taxRate);
  const shipping = calculateShipping(subtotal);
  
  return subtotal + tax + shipping;
}

export function formatCurrency(amount: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
  }).format(amount);
}

export function calculateDiscount(
  price: number,
  discountPercent: number
): number {
  return price * (discountPercent / 100);
}

export function applyDiscount(
  price: number,
  discountPercent: number
): number {
  return price - calculateDiscount(price, discountPercent);
}
                </code></pre>

                <h3>Unit Tests for Calculations</h3>
                <pre><code class="language-typescript">
// src/utils/calculations.test.ts
import { describe, it, expect } from 'vitest';
import {
  calculateSubtotal,
  calculateTax,
  calculateShipping,
  calculateTotal,
  formatCurrency,
  calculateDiscount,
  applyDiscount,
} from './calculations';

describe('calculateSubtotal', () => {
  it('calculates subtotal for single item', () => {
    const items = [{ id: '1', name: 'Product', price: 10, quantity: 2 }];
    expect(calculateSubtotal(items)).toBe(20);
  });
  
  it('calculates subtotal for multiple items', () => {
    const items = [
      { id: '1', name: 'Product 1', price: 10, quantity: 2 },
      { id: '2', name: 'Product 2', price: 15, quantity: 1 },
    ];
    expect(calculateSubtotal(items)).toBe(35);
  });
  
  it('returns 0 for empty cart', () => {
    expect(calculateSubtotal([])).toBe(0);
  });
  
  it('handles decimal prices correctly', () => {
    const items = [{ id: '1', name: 'Product', price: 9.99, quantity: 3 }];
    expect(calculateSubtotal(items)).toBeCloseTo(29.97);
  });
});

describe('calculateTax', () => {
  it('calculates tax with default rate (8%)', () => {
    expect(calculateTax(100)).toBe(8);
  });
  
  it('calculates tax with custom rate', () => {
    expect(calculateTax(100, 0.10)).toBe(10);
  });
  
  it('returns 0 for zero subtotal', () => {
    expect(calculateTax(0)).toBe(0);
  });
  
  it('handles decimal amounts correctly', () => {
    expect(calculateTax(49.99, 0.08)).toBeCloseTo(3.9992);
  });
});

describe('calculateShipping', () => {
  it('returns free shipping for orders $100 or more', () => {
    expect(calculateShipping(100)).toBe(0);
    expect(calculateShipping(150)).toBe(0);
  });
  
  it('returns $5.99 for orders between $50 and $99.99', () => {
    expect(calculateShipping(50)).toBe(5.99);
    expect(calculateShipping(75)).toBe(5.99);
    expect(calculateShipping(99.99)).toBe(5.99);
  });
  
  it('returns $9.99 for orders under $50', () => {
    expect(calculateShipping(0)).toBe(9.99);
    expect(calculateShipping(25)).toBe(9.99);
    expect(calculateShipping(49.99)).toBe(9.99);
  });
});

describe('calculateTotal', () => {
  const items = [
    { id: '1', name: 'Product 1', price: 50, quantity: 1 },
    { id: '2', name: 'Product 2', price: 30, quantity: 1 },
  ];
  
  it('calculates total with tax and shipping', () => {
    // Subtotal: 80
    // Tax (8%): 6.40
    // Shipping: 5.99 (between 50-100)
    // Total: 92.39
    const total = calculateTotal(items);
    expect(total).toBeCloseTo(92.39);
  });
  
  it('uses custom tax rate', () => {
    const total = calculateTotal(items, 0.10);
    // Subtotal: 80
    // Tax (10%): 8.00
    // Shipping: 5.99
    // Total: 93.99
    expect(total).toBeCloseTo(93.99);
  });
  
  it('includes free shipping for large orders', () => {
    const largeOrder = [
      { id: '1', name: 'Expensive Item', price: 100, quantity: 1 },
    ];
    const total = calculateTotal(largeOrder);
    // Subtotal: 100
    // Tax (8%): 8.00
    // Shipping: 0
    // Total: 108.00
    expect(total).toBe(108);
  });
});

describe('formatCurrency', () => {
  it('formats whole numbers', () => {
    expect(formatCurrency(100)).toBe('$100.00');
  });
  
  it('formats decimal numbers', () => {
    expect(formatCurrency(99.99)).toBe('$99.99');
  });
  
  it('formats zero', () => {
    expect(formatCurrency(0)).toBe('$0.00');
  });
  
  it('formats large numbers with commas', () => {
    expect(formatCurrency(1234.56)).toBe('$1,234.56');
  });
  
  it('handles negative numbers', () => {
    expect(formatCurrency(-50)).toBe('-$50.00');
  });
});

describe('discount calculations', () => {
  describe('calculateDiscount', () => {
    it('calculates discount amount', () => {
      expect(calculateDiscount(100, 10)).toBe(10);
      expect(calculateDiscount(50, 20)).toBe(10);
    });
    
    it('handles zero discount', () => {
      expect(calculateDiscount(100, 0)).toBe(0);
    });
    
    it('handles 100% discount', () => {
      expect(calculateDiscount(100, 100)).toBe(100);
    });
  });
  
  describe('applyDiscount', () => {
    it('applies discount to price', () => {
      expect(applyDiscount(100, 10)).toBe(90);
      expect(applyDiscount(50, 20)).toBe(40);
    });
    
    it('returns original price for zero discount', () => {
      expect(applyDiscount(100, 0)).toBe(100);
    });
    
    it('returns zero for 100% discount', () => {
      expect(applyDiscount(100, 100)).toBe(0);
    });
  });
});
                </code></pre>

                <h3>Testing Product Filtering Logic</h3>
                <pre><code class="language-typescript">
// src/utils/filters.ts
export interface FilterOptions {
  searchQuery: string;
  category: string;
  minPrice: number;
  maxPrice: number;
  inStock: boolean;
}

export function filterProducts(
  products: Product[],
  filters: Partial&lt;FilterOptions&gt;
): Product[] {
  return products.filter(product => {
    // Search by name or description
    if (filters.searchQuery) {
      const query = filters.searchQuery.toLowerCase();
      const matchesName = product.name.toLowerCase().includes(query);
      const matchesDesc = product.description?.toLowerCase().includes(query);
      if (!matchesName && !matchesDesc) return false;
    }
    
    // Filter by category
    if (filters.category && filters.category !== 'all') {
      if (product.category !== filters.category) return false;
    }
    
    // Filter by price range
    if (filters.minPrice !== undefined && product.price < filters.minPrice) {
      return false;
    }
    if (filters.maxPrice !== undefined && product.price > filters.maxPrice) {
      return false;
    }
    
    // Filter by stock status
    if (filters.inStock && product.stock === 0) {
      return false;
    }
    
    return true;
  });
}

export function sortProducts(
  products: Product[],
  sortBy: 'name' | 'price-low' | 'price-high' | 'newest'
): Product[] {
  const sorted = [...products];
  
  switch (sortBy) {
    case 'name':
      return sorted.sort((a, b) => a.name.localeCompare(b.name));
    case 'price-low':
      return sorted.sort((a, b) => a.price - b.price);
    case 'price-high':
      return sorted.sort((a, b) => b.price - a.price);
    case 'newest':
      return sorted.sort((a, b) => 
        new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
      );
    default:
      return sorted;
  }
}
                </code></pre>

                <h3>Unit Tests for Filters</h3>
                <pre><code class="language-typescript">
// src/utils/filters.test.ts
import { describe, it, expect } from 'vitest';
import { filterProducts, sortProducts } from './filters';

const mockProducts = [
  {
    id: '1',
    name: 'Laptop',
    description: 'Powerful laptop',
    category: 'electronics',
    price: 999,
    stock: 5,
    createdAt: '2024-01-01',
  },
  {
    id: '2',
    name: 'Mouse',
    description: 'Wireless mouse',
    category: 'electronics',
    price: 29,
    stock: 0,
    createdAt: '2024-01-15',
  },
  {
    id: '3',
    name: 'Desk',
    description: 'Standing desk',
    category: 'furniture',
    price: 300,
    stock: 3,
    createdAt: '2024-01-10',
  },
];

describe('filterProducts', () => {
  it('returns all products with empty filters', () => {
    const result = filterProducts(mockProducts, {});
    expect(result).toHaveLength(3);
  });
  
  it('filters by search query in name', () => {
    const result = filterProducts(mockProducts, { searchQuery: 'laptop' });
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Laptop');
  });
  
  it('filters by search query in description', () => {
    const result = filterProducts(mockProducts, { searchQuery: 'wireless' });
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Mouse');
  });
  
  it('filters by category', () => {
    const result = filterProducts(mockProducts, { category: 'electronics' });
    expect(result).toHaveLength(2);
  });
  
  it('filters by price range', () => {
    const result = filterProducts(mockProducts, { 
      minPrice: 50, 
      maxPrice: 500 
    });
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Desk');
  });
  
  it('filters by stock status', () => {
    const result = filterProducts(mockProducts, { inStock: true });
    expect(result).toHaveLength(2);
    expect(result.every(p => p.stock > 0)).toBe(true);
  });
  
  it('applies multiple filters together', () => {
    const result = filterProducts(mockProducts, {
      category: 'electronics',
      minPrice: 100,
      inStock: true,
    });
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe('Laptop');
  });
});

describe('sortProducts', () => {
  it('sorts by name alphabetically', () => {
    const result = sortProducts(mockProducts, 'name');
    expect(result[0].name).toBe('Desk');
    expect(result[1].name).toBe('Laptop');
    expect(result[2].name).toBe('Mouse');
  });
  
  it('sorts by price low to high', () => {
    const result = sortProducts(mockProducts, 'price-low');
    expect(result[0].price).toBe(29);
    expect(result[2].price).toBe(999);
  });
  
  it('sorts by price high to low', () => {
    const result = sortProducts(mockProducts, 'price-high');
    expect(result[0].price).toBe(999);
    expect(result[2].price).toBe(29);
  });
  
  it('sorts by newest first', () => {
    const result = sortProducts(mockProducts, 'newest');
    expect(result[0].id).toBe('2'); // Created Jan 15
    expect(result[1].id).toBe('3'); // Created Jan 10
    expect(result[2].id).toBe('1'); // Created Jan 1
  });
  
  it('does not mutate original array', () => {
    const original = [...mockProducts];
    sortProducts(mockProducts, 'price-low');
    expect(mockProducts).toEqual(original);
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Unit Testing Best Practices</h4>
                    <ul>
                        <li><strong>Test one thing:</strong> Each test should verify one specific behavior</li>
                        <li><strong>Use descriptive names:</strong> Test names should clearly state what's being tested</li>
                        <li><strong>Test edge cases:</strong> Zero values, empty arrays, boundaries</li>
                        <li><strong>Don't test implementation:</strong> Test inputs and outputs, not how it works</li>
                        <li><strong>Keep tests independent:</strong> Each test should run in isolation</li>
                        <li><strong>Use appropriate matchers:</strong> <code>toBe</code> for primitives, <code>toEqual</code> for objects</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Running Unit Tests</h4>
                    <pre><code class="language-bash">
# Run all tests
npm test

# Run specific test file
npm test calculations.test

# Run with coverage
npm run test:coverage

# Watch mode during development
npm test -- --watch
                    </code></pre>
                </div>
            </section>

            <!-- Section 3: Component Tests -->
            <section id="component-tests" class="lesson-section">
                <h2>ğŸ§© Component Tests: UI Components</h2>
                
                <p>Now let's test our React components using React Testing Library. We'll focus on testing user-facing behavior, not implementation details.</p>

                <h3>Testing ProductCard Component</h3>
                <p>First, let's look at the component we're testing:</p>

                <pre><code class="language-typescript">
// src/components/Product/ProductCard.tsx
interface ProductCardProps {
  product: Product;
  onAddToCart: (product: Product) => void;
}

export function ProductCard({ product, onAddToCart }: ProductCardProps) {
  const [isAdding, setIsAdding] = React.useState(false);
  
  const handleAddToCart = async () => {
    setIsAdding(true);
    await new Promise(resolve => setTimeout(resolve, 300)); // Simulate async
    onAddToCart(product);
    setIsAdding(false);
  };
  
  return (
    &lt;article className="product-card"&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p className="description"&gt;{product.description}&lt;/p&gt;
      &lt;p className="price"&gt;{formatCurrency(product.price)}&lt;/p&gt;
      
      {product.stock === 0 ? (
        &lt;p className="out-of-stock"&gt;Out of Stock&lt;/p&gt;
      ) : (
        &lt;button
          onClick={handleAddToCart}
          disabled={isAdding}
          aria-label={`Add ${product.name} to cart`}
        &gt;
          {isAdding ? 'Adding...' : 'Add to Cart'}
        &lt;/button&gt;
      )}
      
      {product.stock > 0 && product.stock < 5 && (
        &lt;p className="low-stock"&gt;Only {product.stock} left!&lt;/p&gt;
      )}
    &lt;/article&gt;
  );
}
                </code></pre>

                <h3>ProductCard Component Tests</h3>
                <pre><code class="language-typescript">
// src/components/Product/ProductCard.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ProductCard } from './ProductCard';

const mockProduct = {
  id: '1',
  name: 'Gaming Laptop',
  description: 'High-performance laptop for gaming',
  price: 999.99,
  image: '/images/laptop.jpg',
  category: 'electronics',
  stock: 10,
};

describe('ProductCard', () => {
  it('renders product information', () => {
    const onAddToCart = vi.fn();
    
    render(&lt;ProductCard product={mockProduct} onAddToCart={onAddToCart} /&gt;);
    
    expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByText('High-performance laptop for gaming')).toBeInTheDocument();
    expect(screen.getByText('$999.99')).toBeInTheDocument();
    expect(screen.getByAltText('Gaming Laptop')).toBeInTheDocument();
  });
  
  it('calls onAddToCart when button is clicked', async () => {
    const user = userEvent.setup();
    const onAddToCart = vi.fn();
    
    render(&lt;ProductCard product={mockProduct} onAddToCart={onAddToCart} /&gt;);
    
    const button = screen.getByRole('button', { name: /add.*to cart/i });
    await user.click(button);
    
    expect(onAddToCart).toHaveBeenCalledWith(mockProduct);
    expect(onAddToCart).toHaveBeenCalledTimes(1);
  });
  
  it('shows loading state while adding to cart', async () => {
    const user = userEvent.setup();
    const onAddToCart = vi.fn();
    
    render(&lt;ProductCard product={mockProduct} onAddToCart={onAddToCart} /&gt;);
    
    const button = screen.getByRole('button', { name: /add.*to cart/i });
    
    // Click button
    await user.click(button);
    
    // Should show loading text
    expect(screen.getByText('Adding...')).toBeInTheDocument();
    
    // Button should be disabled
    expect(button).toBeDisabled();
  });
  
  it('shows "Out of Stock" when stock is 0', () => {
    const onAddToCart = vi.fn();
    const outOfStockProduct = { ...mockProduct, stock: 0 };
    
    render(&lt;ProductCard product={outOfStockProduct} onAddToCart={onAddToCart} /&gt;);
    
    expect(screen.getByText('Out of Stock')).toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /add.*to cart/i })).not.toBeInTheDocument();
  });
  
  it('shows low stock warning when stock is less than 5', () => {
    const onAddToCart = vi.fn();
    const lowStockProduct = { ...mockProduct, stock: 3 };
    
    render(&lt;ProductCard product={lowStockProduct} onAddToCart={onAddToCart} /&gt;);
    
    expect(screen.getByText('Only 3 left!')).toBeInTheDocument();
  });
  
  it('does not show low stock warning when stock is 5 or more', () => {
    const onAddToCart = vi.fn();
    
    render(&lt;ProductCard product={mockProduct} onAddToCart={onAddToCart} /&gt;);
    
    expect(screen.queryByText(/only.*left/i)).not.toBeInTheDocument();
  });
  
  it('has accessible add to cart button', () => {
    const onAddToCart = vi.fn();
    
    render(&lt;ProductCard product={mockProduct} onAddToCart={onAddToCart} /&gt;);
    
    const button = screen.getByRole('button', { name: 'Add Gaming Laptop to cart' });
    expect(button).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing CartItem Component</h3>
                <pre><code class="language-typescript">
// src/components/Cart/CartItem.tsx
interface CartItemProps {
  item: CartItem;
  onUpdateQuantity: (id: string, quantity: number) => void;
  onRemove: (id: string) => void;
}

export function CartItem({ item, onUpdateQuantity, onRemove }: CartItemProps) {
  const handleQuantityChange = (delta: number) => {
    const newQuantity = item.quantity + delta;
    if (newQuantity > 0) {
      onUpdateQuantity(item.id, newQuantity);
    }
  };
  
  const subtotal = item.price * item.quantity;
  
  return (
    &lt;div className="cart-item"&gt;
      &lt;img src={item.image} alt={item.name} /&gt;
      
      &lt;div className="item-details"&gt;
        &lt;h4&gt;{item.name}&lt;/h4&gt;
        &lt;p className="price"&gt;{formatCurrency(item.price)}&lt;/p&gt;
      &lt;/div&gt;
      
      &lt;div className="quantity-controls"&gt;
        &lt;button
          onClick={() => handleQuantityChange(-1)}
          aria-label="Decrease quantity"
          disabled={item.quantity === 1}
        &gt;
          -
        &lt;/button&gt;
        
        &lt;span aria-label="Quantity"&gt;{item.quantity}&lt;/span&gt;
        
        &lt;button
          onClick={() => handleQuantityChange(1)}
          aria-label="Increase quantity"
        &gt;
          +
        &lt;/button&gt;
      &lt;/div&gt;
      
      &lt;p className="subtotal"&gt;{formatCurrency(subtotal)}&lt;/p&gt;
      
      &lt;button
        onClick={() => onRemove(item.id)}
        aria-label={`Remove ${item.name} from cart`}
        className="remove-button"
      &gt;
        Remove
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>CartItem Component Tests</h3>
                <pre><code class="language-typescript">
// src/components/Cart/CartItem.test.tsx
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CartItem } from './CartItem';

const mockItem = {
  id: '1',
  name: 'Gaming Laptop',
  price: 999.99,
  quantity: 2,
  image: '/images/laptop.jpg',
};

describe('CartItem', () => {
  it('renders item information', () => {
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    
    render(
      &lt;CartItem
        item={mockItem}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByText('$999.99')).toBeInTheDocument();
    expect(screen.getByLabelText('Quantity')).toHaveTextContent('2');
    expect(screen.getByText('$1,999.98')).toBeInTheDocument(); // Subtotal
  });
  
  it('increases quantity when + button is clicked', async () => {
    const user = userEvent.setup();
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    
    render(
      &lt;CartItem
        item={mockItem}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    await user.click(screen.getByLabelText('Increase quantity'));
    
    expect(onUpdateQuantity).toHaveBeenCalledWith('1', 3);
  });
  
  it('decreases quantity when - button is clicked', async () => {
    const user = userEvent.setup();
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    
    render(
      &lt;CartItem
        item={mockItem}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    await user.click(screen.getByLabelText('Decrease quantity'));
    
    expect(onUpdateQuantity).toHaveBeenCalledWith('1', 1);
  });
  
  it('disables decrease button when quantity is 1', () => {
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    const singleItem = { ...mockItem, quantity: 1 };
    
    render(
      &lt;CartItem
        item={singleItem}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    const decreaseButton = screen.getByLabelText('Decrease quantity');
    expect(decreaseButton).toBeDisabled();
  });
  
  it('calls onRemove when remove button is clicked', async () => {
    const user = userEvent.setup();
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    
    render(
      &lt;CartItem
        item={mockItem}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    await user.click(screen.getByLabelText('Remove Gaming Laptop from cart'));
    
    expect(onRemove).toHaveBeenCalledWith('1');
  });
  
  it('calculates subtotal correctly', () => {
    const onUpdateQuantity = vi.fn();
    const onRemove = vi.fn();
    const item = { ...mockItem, price: 50, quantity: 3 };
    
    render(
      &lt;CartItem
        item={item}
        onUpdateQuantity={onUpdateQuantity}
        onRemove={onRemove}
      /&gt;
    );
    
    expect(screen.getByText('$150.00')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing SearchBar Component</h3>
                <pre><code class="language-typescript">
// src/components/Filters/SearchBar.tsx
interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
}

export function SearchBar({ 
  value, 
  onChange, 
  placeholder = 'Search products...' 
}: SearchBarProps) {
  const [localValue, setLocalValue] = React.useState(value);
  const timeoutRef = React.useRef&lt;NodeJS.Timeout&gt;();
  
  React.useEffect(() => {
    setLocalValue(value);
  }, [value]);
  
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const newValue = e.target.value;
    setLocalValue(newValue);
    
    // Debounce the onChange callback
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
    }
    
    timeoutRef.current = setTimeout(() => {
      onChange(newValue);
    }, 300);
  };
  
  const handleClear = () => {
    setLocalValue('');
    onChange('');
  };
  
  return (
    &lt;div className="search-bar"&gt;
      &lt;label htmlFor="search-input" className="sr-only"&gt;
        Search products
      &lt;/label&gt;
      
      &lt;input
        id="search-input"
        type="text"
        value={localValue}
        onChange={handleChange}
        placeholder={placeholder}
        aria-label="Search products"
      /&gt;
      
      {localValue && (
        &lt;button
          onClick={handleClear}
          aria-label="Clear search"
          className="clear-button"
        &gt;
          âœ•
        &lt;/button&gt;
      )}
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>SearchBar Component Tests</h3>
                <pre><code class="language-typescript">
// src/components/Filters/SearchBar.test.tsx
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { SearchBar } from './SearchBar';

describe('SearchBar', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });
  
  afterEach(() => {
    vi.useRealTimers();
  });
  
  it('renders with initial value', () => {
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="laptop" onChange={onChange} /&gt;);
    
    const input = screen.getByRole('textbox', { name: 'Search products' });
    expect(input).toHaveValue('laptop');
  });
  
  it('calls onChange after debounce delay', async () => {
    const user = userEvent.setup({ delay: null });
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="" onChange={onChange} /&gt;);
    
    const input = screen.getByRole('textbox');
    await user.type(input, 'laptop');
    
    // Should not call immediately
    expect(onChange).not.toHaveBeenCalled();
    
    // Advance timers past debounce delay
    vi.advanceTimersByTime(300);
    
    // Should have been called once with final value
    await waitFor(() => {
      expect(onChange).toHaveBeenCalledWith('laptop');
      expect(onChange).toHaveBeenCalledTimes(1);
    });
  });
  
  it('debounces multiple rapid changes', async () => {
    const user = userEvent.setup({ delay: null });
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="" onChange={onChange} /&gt;);
    
    const input = screen.getByRole('textbox');
    
    // Type quickly
    await user.type(input, 'l');
    vi.advanceTimersByTime(100);
    await user.type(input, 'a');
    vi.advanceTimersByTime(100);
    await user.type(input, 'p');
    
    // Should not have called yet
    expect(onChange).not.toHaveBeenCalled();
    
    // Advance past debounce delay
    vi.advanceTimersByTime(300);
    
    // Should have been called only once with final value
    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith('lap');
    });
  });
  
  it('shows clear button when input has value', async () => {
    const user = userEvent.setup({ delay: null });
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="" onChange={onChange} /&gt;);
    
    // Initially no clear button
    expect(screen.queryByLabelText('Clear search')).not.toBeInTheDocument();
    
    // Type something
    await user.type(screen.getByRole('textbox'), 'laptop');
    
    // Clear button should appear
    expect(screen.getByLabelText('Clear search')).toBeInTheDocument();
  });
  
  it('clears input when clear button is clicked', async () => {
    const user = userEvent.setup();
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="laptop" onChange={onChange} /&gt;);
    
    const clearButton = screen.getByLabelText('Clear search');
    await user.click(clearButton);
    
    expect(screen.getByRole('textbox')).toHaveValue('');
    expect(onChange).toHaveBeenCalledWith('');
  });
  
  it('uses custom placeholder', () => {
    const onChange = vi.fn();
    
    render(
      &lt;SearchBar
        value=""
        onChange={onChange}
        placeholder="Find your product..."
      /&gt;
    );
    
    expect(screen.getByPlaceholderText('Find your product...')).toBeInTheDocument();
  });
  
  it('is accessible', () => {
    const onChange = vi.fn();
    
    render(&lt;SearchBar value="" onChange={onChange} /&gt;);
    
    const input = screen.getByLabelText('Search products');
    expect(input).toBeInTheDocument();
    expect(input).toHaveAttribute('type', 'text');
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Component Testing Best Practices</h4>
                    <ul>
                        <li><strong>Test user behavior:</strong> Focus on what users see and do</li>
                        <li><strong>Use accessible queries:</strong> getByRole, getByLabelText, getByText</li>
                        <li><strong>Avoid implementation details:</strong> Don't test state or props directly</li>
                        <li><strong>Test all states:</strong> Loading, success, error, empty</li>
                        <li><strong>Mock callbacks:</strong> Use vi.fn() to verify function calls</li>
                        <li><strong>Test accessibility:</strong> Ensure components are accessible</li>
                        <li><strong>Use userEvent:</strong> More realistic than fireEvent</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Testing the Cart Reducer -->
            <section id="reducer-tests" class="lesson-section">
                <h2>âš™ï¸ Testing the Cart Reducer</h2>
                
                <p>Reducers contain critical business logic and should be thoroughly tested. The good news is they're pure functions, making them easy to test!</p>

                <h3>Cart Reducer Implementation</h3>
                <pre><code class="language-typescript">
// src/context/CartReducer.ts
export interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
  image: string;
}

export interface CartState {
  items: CartItem[];
}

export type CartAction =
  | { type: 'ADD_ITEM'; payload: CartItem }
  | { type: 'REMOVE_ITEM'; payload: string }
  | { type: 'UPDATE_QUANTITY'; payload: { id: string; quantity: number } }
  | { type: 'CLEAR_CART' };

export function cartReducer(state: CartState, action: CartAction): CartState {
  switch (action.type) {
    case 'ADD_ITEM': {
      const existingItem = state.items.find(
        item => item.id === action.payload.id
      );
      
      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =>
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + action.payload.quantity }
              : item
          ),
        };
      }
      
      return {
        ...state,
        items: [...state.items, action.payload],
      };
    }
    
    case 'REMOVE_ITEM': {
      return {
        ...state,
        items: state.items.filter(item => item.id !== action.payload),
      };
    }
    
    case 'UPDATE_QUANTITY': {
      return {
        ...state,
        items: state.items.map(item =>
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        ),
      };
    }
    
    case 'CLEAR_CART': {
      return {
        ...state,
        items: [],
      };
    }
    
    default:
      return state;
  }
}
                </code></pre>

                <h3>Reducer Tests</h3>
                <pre><code class="language-typescript">
// src/context/CartReducer.test.ts
import { describe, it, expect } from 'vitest';
import { cartReducer, CartState, CartItem } from './CartReducer';

const mockItem: CartItem = {
  id: '1',
  name: 'Laptop',
  price: 999,
  quantity: 1,
  image: '/laptop.jpg',
};

const mockItem2: CartItem = {
  id: '2',
  name: 'Mouse',
  price: 29,
  quantity: 1,
  image: '/mouse.jpg',
};

describe('cartReducer', () => {
  describe('ADD_ITEM', () => {
    it('adds new item to empty cart', () => {
      const initialState: CartState = { items: [] };
      
      const newState = cartReducer(initialState, {
        type: 'ADD_ITEM',
        payload: mockItem,
      });
      
      expect(newState.items).toHaveLength(1);
      expect(newState.items[0]).toEqual(mockItem);
    });
    
    it('adds new item to cart with existing items', () => {
      const initialState: CartState = { items: [mockItem] };
      
      const newState = cartReducer(initialState, {
        type: 'ADD_ITEM',
        payload: mockItem2,
      });
      
      expect(newState.items).toHaveLength(2);
      expect(newState.items[1]).toEqual(mockItem2);
    });
    
    it('increases quantity when adding existing item', () => {
      const initialState: CartState = { items: [mockItem] };
      
      const newState = cartReducer(initialState, {
        type: 'ADD_ITEM',
        payload: { ...mockItem, quantity: 2 },
      });
      
      expect(newState.items).toHaveLength(1);
      expect(newState.items[0].quantity).toBe(3); // 1 + 2
    });
    
    it('does not mutate original state', () => {
      const initialState: CartState = { items: [mockItem] };
      const originalItems = [...initialState.items];
      
      cartReducer(initialState, {
        type: 'ADD_ITEM',
        payload: mockItem2,
      });
      
      expect(initialState.items).toEqual(originalItems);
    });
  });
  
  describe('REMOVE_ITEM', () => {
    it('removes item from cart', () => {
      const initialState: CartState = {
        items: [mockItem, mockItem2],
      };
      
      const newState = cartReducer(initialState, {
        type: 'REMOVE_ITEM',
        payload: '1',
      });
      
      expect(newState.items).toHaveLength(1);
      expect(newState.items[0].id).toBe('2');
    });
    
    it('handles removing non-existent item', () => {
      const initialState: CartState = { items: [mockItem] };
      
      const newState = cartReducer(initialState, {
        type: 'REMOVE_ITEM',
        payload: 'non-existent',
      });
      
      expect(newState.items).toHaveLength(1);
      expect(newState.items[0]).toEqual(mockItem);
    });
    
    it('handles removing from empty cart', () => {
      const initialState: CartState = { items: [] };
      
      const newState = cartReducer(initialState, {
        type: 'REMOVE_ITEM',
        payload: '1',
      });
      
      expect(newState.items).toHaveLength(0);
    });
  });
  
  describe('UPDATE_QUANTITY', () => {
    it('updates quantity of existing item', () => {
      const initialState: CartState = { items: [mockItem] };
      
      const newState = cartReducer(initialState, {
        type: 'UPDATE_QUANTITY',
        payload: { id: '1', quantity: 5 },
      });
      
      expect(newState.items[0].quantity).toBe(5);
    });
    
    it('does not affect other items', () => {
      const initialState: CartState = {
        items: [mockItem, mockItem2],
      };
      
      const newState = cartReducer(initialState, {
        type: 'UPDATE_QUANTITY',
        payload: { id: '1', quantity: 3 },
      });
      
      expect(newState.items[0].quantity).toBe(3);
      expect(newState.items[1].quantity).toBe(1);
    });
    
    it('handles updating non-existent item', () => {
      const initialState: CartState = { items: [mockItem] };
      
      const newState = cartReducer(initialState, {
        type: 'UPDATE_QUANTITY',
        payload: { id: 'non-existent', quantity: 5 },
      });
      
      expect(newState.items).toEqual(initialState.items);
    });
  });
  
  describe('CLEAR_CART', () => {
    it('removes all items from cart', () => {
      const initialState: CartState = {
        items: [mockItem, mockItem2],
      };
      
      const newState = cartReducer(initialState, {
        type: 'CLEAR_CART',
      });
      
      expect(newState.items).toHaveLength(0);
    });
    
    it('handles clearing empty cart', () => {
      const initialState: CartState = { items: [] };
      
      const newState = cartReducer(initialState, {
        type: 'CLEAR_CART',
      });
      
      expect(newState.items).toHaveLength(0);
    });
  });
  
  describe('Complex scenarios', () => {
    it('handles multiple operations in sequence', () => {
      let state: CartState = { items: [] };
      
      // Add first item
      state = cartReducer(state, {
        type: 'ADD_ITEM',
        payload: mockItem,
      });
      expect(state.items).toHaveLength(1);
      
      // Add second item
      state = cartReducer(state, {
        type: 'ADD_ITEM',
        payload: mockItem2,
      });
      expect(state.items).toHaveLength(2);
      
      // Update quantity of first item
      state = cartReducer(state, {
        type: 'UPDATE_QUANTITY',
        payload: { id: '1', quantity: 3 },
      });
      expect(state.items[0].quantity).toBe(3);
      
      // Remove second item
      state = cartReducer(state, {
        type: 'REMOVE_ITEM',
        payload: '2',
      });
      expect(state.items).toHaveLength(1);
      
      // Clear cart
      state = cartReducer(state, {
        type: 'CLEAR_CART',
      });
      expect(state.items).toHaveLength(0);
    });
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Reducer Testing Tips</h4>
                    <ul>
                        <li><strong>Test all action types:</strong> Every case in the switch statement</li>
                        <li><strong>Test immutability:</strong> Verify state isn't mutated</li>
                        <li><strong>Test edge cases:</strong> Empty arrays, non-existent IDs, etc.</li>
                        <li><strong>Test sequences:</strong> Multiple operations in a row</li>
                        <li><strong>Keep tests simple:</strong> One action per test (usually)</li>
                        <li><strong>Use descriptive names:</strong> Clear what scenario is being tested</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Testing Custom Hooks -->
            <section id="hook-tests" class="lesson-section">
                <h2>ğŸª Testing Custom Hooks</h2>
                
                <p>Custom hooks contain reusable logic and should be tested independently. We'll use the <code>renderHook</code> utility from Testing Library.</p>

                <h3>Custom Hook: useCart</h3>
                <pre><code class="language-typescript">
// src/hooks/useCart.ts
export function useCart() {
  const context = React.useContext(CartContext);
  
  if (!context) {
    throw new Error('useCart must be used within CartProvider');
  }
  
  const { state, dispatch } = context;
  
  const addItem = React.useCallback((product: Product) => {
    dispatch({
      type: 'ADD_ITEM',
      payload: {
        id: product.id,
        name: product.name,
        price: product.price,
        quantity: 1,
        image: product.image,
      },
    });
  }, [dispatch]);
  
  const removeItem = React.useCallback((id: string) => {
    dispatch({ type: 'REMOVE_ITEM', payload: id });
  }, [dispatch]);
  
  const updateQuantity = React.useCallback((id: string, quantity: number) => {
    dispatch({ type: 'UPDATE_QUANTITY', payload: { id, quantity } });
  }, [dispatch]);
  
  const clearCart = React.useCallback(() => {
    dispatch({ type: 'CLEAR_CART' });
  }, [dispatch]);
  
  const itemCount = state.items.reduce((sum, item) => sum + item.quantity, 0);
  const subtotal = calculateSubtotal(state.items);
  
  return {
    items: state.items,
    itemCount,
    subtotal,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
  };
}
                </code></pre>

                <h3>Hook Tests</h3>
                <pre><code class="language-typescript">
// src/hooks/useCart.test.tsx
import { describe, it, expect } from 'vitest';
import { renderHook, act } from '@testing-library/react';
import { CartProvider } from '../context/CartContext';
import { useCart } from './useCart';

const wrapper = ({ children }: { children: React.ReactNode }) => (
  &lt;CartProvider&gt;{children}&lt;/CartProvider&gt;
);

const mockProduct = {
  id: '1',
  name: 'Laptop',
  price: 999,
  image: '/laptop.jpg',
  description: 'A laptop',
  category: 'electronics',
  stock: 10,
};

describe('useCart', () => {
  it('starts with empty cart', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    expect(result.current.items).toHaveLength(0);
    expect(result.current.itemCount).toBe(0);
    expect(result.current.subtotal).toBe(0);
  });
  
  it('adds item to cart', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
    });
    
    expect(result.current.items).toHaveLength(1);
    expect(result.current.items[0].name).toBe('Laptop');
    expect(result.current.itemCount).toBe(1);
  });
  
  it('calculates itemCount correctly with multiple items', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
      result.current.addItem(mockProduct); // Add same item twice
      result.current.addItem({ ...mockProduct, id: '2', name: 'Mouse' });
    });
    
    expect(result.current.itemCount).toBe(3); // 2 laptops + 1 mouse
  });
  
  it('calculates subtotal correctly', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
      result.current.addItem(mockProduct);
    });
    
    expect(result.current.subtotal).toBe(1998); // 999 * 2
  });
  
  it('removes item from cart', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
    });
    
    expect(result.current.items).toHaveLength(1);
    
    act(() => {
      result.current.removeItem('1');
    });
    
    expect(result.current.items).toHaveLength(0);
  });
  
  it('updates item quantity', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
    });
    
    expect(result.current.items[0].quantity).toBe(1);
    
    act(() => {
      result.current.updateQuantity('1', 5);
    });
    
    expect(result.current.items[0].quantity).toBe(5);
    expect(result.current.itemCount).toBe(5);
  });
  
  it('clears entire cart', () => {
    const { result } = renderHook(() => useCart(), { wrapper });
    
    act(() => {
      result.current.addItem(mockProduct);
      result.current.addItem({ ...mockProduct, id: '2' });
    });
    
    expect(result.current.items).toHaveLength(2);
    
    act(() => {
      result.current.clearCart();
    });
    
    expect(result.current.items).toHaveLength(0);
    expect(result.current.itemCount).toBe(0);
    expect(result.current.subtotal).toBe(0);
  });
  
  it('throws error when used outside CartProvider', () => {
    // Suppress console.error for this test
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    expect(() => {
      renderHook(() => useCart());
    }).toThrow('useCart must be used within CartProvider');
    
    spy.mockRestore();
  });
});
                </code></pre>

                <h3>Testing Custom Hook with Dependencies</h3>
                <pre><code class="language-typescript">
// src/hooks/useLocalStorage.ts
export function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = React.useState&lt;T&gt;(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue] as const;
}

// src/hooks/useLocalStorage.test.ts
describe('useLocalStorage', () => {
  beforeEach(() => {
    window.localStorage.clear();
  });
  
  it('returns initial value when no stored value', () => {
    const { result } = renderHook(() => useLocalStorage('test-key', 'initial'));
    
    expect(result.current[0]).toBe('initial');
  });
  
  it('stores and retrieves value', () => {
    const { result } = renderHook(() => useLocalStorage('test-key', 'initial'));
    
    act(() => {
      result.current[1]('new value');
    });
    
    expect(result.current[0]).toBe('new value');
    expect(window.localStorage.getItem('test-key')).toBe('"new value"');
  });
  
  it('reads existing value from localStorage', () => {
    window.localStorage.setItem('test-key', JSON.stringify('existing'));
    
    const { result } = renderHook(() => useLocalStorage('test-key', 'initial'));
    
    expect(result.current[0]).toBe('existing');
  });
  
  it('handles complex objects', () => {
    const { result } = renderHook(() => 
      useLocalStorage('test-key', { count: 0, name: 'test' })
    );
    
    act(() => {
      result.current[1]({ count: 5, name: 'updated' });
    });
    
    expect(result.current[0]).toEqual({ count: 5, name: 'updated' });
  });
  
  it('handles function updater', () => {
    const { result } = renderHook(() => useLocalStorage('test-key', 0));
    
    act(() => {
      result.current[1](prev => prev + 1);
    });
    
    expect(result.current[0]).toBe(1);
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Hook Testing Best Practices</h4>
                    <ul>
                        <li><strong>Use renderHook:</strong> Properly render hooks in test environment</li>
                        <li><strong>Wrap in act():</strong> All state updates must be in act()</li>
                        <li><strong>Test with providers:</strong> Provide necessary context</li>
                        <li><strong>Test return values:</strong> Verify hook returns expected data</li>
                        <li><strong>Test side effects:</strong> localStorage, API calls, etc.</li>
                        <li><strong>Test error cases:</strong> Missing providers, invalid inputs</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Integration Tests -->
            <section id="integration-tests" class="lesson-section">
                <h2>ğŸ”— Integration Tests: Cart Functionality</h2>
                
                <p>Integration tests verify that multiple components work together correctly. Let's test the complete shopping cart flow from adding products to calculating totals.</p>

                <h3>Testing Complete Cart Flow</h3>
                <pre><code class="language-typescript">
// src/components/Cart/Cart.integration.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@/test/utils'; // Our custom render with providers
import userEvent from '@testing-library/user-event';
import { ProductCard } from '../Product/ProductCard';
import { Cart } from './Cart';

const mockProducts = [
  {
    id: '1',
    name: 'Gaming Laptop',
    description: 'High-performance laptop',
    price: 999.99,
    image: '/laptop.jpg',
    category: 'electronics',
    stock: 10,
  },
  {
    id: '2',
    name: 'Wireless Mouse',
    description: 'Ergonomic mouse',
    price: 29.99,
    image: '/mouse.jpg',
    category: 'electronics',
    stock: 15,
  },
];

describe('Cart Integration', () => {
  it('adds product to cart and displays in cart component', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Initially cart is empty
    expect(screen.getByText(/cart is empty/i)).toBeInTheDocument();
    
    // Add product to cart
    await user.click(screen.getByRole('button', { name: /add.*to cart/i }));
    
    // Product appears in cart
    expect(await screen.findByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByText('$999.99')).toBeInTheDocument();
    
    // Cart shows item count
    expect(screen.getByText(/1 item/i)).toBeInTheDocument();
  });
  
  it('adds multiple products and calculates total correctly', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;ProductCard product={mockProducts[1]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Add laptop
    const addButtons = screen.getAllByRole('button', { name: /add.*to cart/i });
    await user.click(addButtons[0]);
    
    // Add mouse
    await user.click(addButtons[1]);
    
    // Both products in cart
    expect(await screen.findByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
    
    // Item count is 2
    expect(screen.getByText(/2 items/i)).toBeInTheDocument();
    
    // Subtotal is correct (999.99 + 29.99 = 1029.98)
    expect(screen.getByText('$1,029.98')).toBeInTheDocument();
  });
  
  it('increases quantity when same product added twice', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    const addButton = screen.getByRole('button', { name: /add.*to cart/i });
    
    // Add product twice
    await user.click(addButton);
    await user.click(addButton);
    
    // Should have 1 product line with quantity 2
    expect(await screen.findByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByLabelText('Quantity')).toHaveTextContent('2');
    
    // Item count is 2
    expect(screen.getByText(/2 items/i)).toBeInTheDocument();
    
    // Subtotal reflects quantity (999.99 * 2)
    expect(screen.getByText('$1,999.98')).toBeInTheDocument();
  });
  
  it('updates quantity using cart controls', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Add product
    await user.click(screen.getByRole('button', { name: /add.*to cart/i }));
    
    // Wait for product in cart
    await screen.findByText('Gaming Laptop');
    
    // Increase quantity
    await user.click(screen.getByLabelText('Increase quantity'));
    
    expect(screen.getByLabelText('Quantity')).toHaveTextContent('2');
    expect(screen.getByText(/2 items/i)).toBeInTheDocument();
    
    // Decrease quantity
    await user.click(screen.getByLabelText('Decrease quantity'));
    
    expect(screen.getByLabelText('Quantity')).toHaveTextContent('1');
    expect(screen.getByText(/1 item/i)).toBeInTheDocument();
  });
  
  it('removes product from cart', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;ProductCard product={mockProducts[1]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Add both products
    const addButtons = screen.getAllByRole('button', { name: /add.*to cart/i });
    await user.click(addButtons[0]);
    await user.click(addButtons[1]);
    
    // Both in cart
    await screen.findByText('Gaming Laptop');
    expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
    
    // Remove laptop
    const removeButtons = screen.getAllByLabelText(/remove.*from cart/i);
    await user.click(removeButtons[0]);
    
    // Laptop gone, mouse remains
    expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument();
    expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
    
    // Item count updated
    expect(screen.getByText(/1 item/i)).toBeInTheDocument();
  });
  
  it('clears entire cart', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;ProductCard product={mockProducts[1]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    // Add products
    const addButtons = screen.getAllByRole('button', { name: /add.*to cart/i });
    await user.click(addButtons[0]);
    await user.click(addButtons[1]);
    
    await screen.findByText('Gaming Laptop');
    
    // Clear cart
    await user.click(screen.getByRole('button', { name: /clear cart/i }));
    
    // Cart is empty
    expect(screen.getByText(/cart is empty/i)).toBeInTheDocument();
    expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument();
    expect(screen.queryByText('Wireless Mouse')).not.toBeInTheDocument();
  });
  
  it('calculates tax and shipping correctly', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;&gt;
        &lt;ProductCard product={mockProducts[0]} /&gt;
        &lt;Cart /&gt;
      &lt;/&gt;
    );
    
    await user.click(screen.getByRole('button', { name: /add.*to cart/i }));
    
    await screen.findByText('Gaming Laptop');
    
    // Subtotal: $999.99
    expect(screen.getByText(/subtotal.*\$999.99/i)).toBeInTheDocument();
    
    // Tax (8%): $80.00
    expect(screen.getByText(/tax.*\$80.00/i)).toBeInTheDocument();
    
    // Shipping: Free (over $100)
    expect(screen.getByText(/shipping.*free/i)).toBeInTheDocument();
    
    // Total: $1,079.99
    expect(screen.getByText(/total.*\$1,079.99/i)).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Product Filtering Integration</h3>
                <pre><code class="language-typescript">
// src/components/Product/ProductList.integration.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { ProductList } from './ProductList';

describe('Product Filtering Integration', () => {
  it('filters products by search query', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    // Initially shows all products
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
      expect(screen.getByText('Standing Desk')).toBeInTheDocument();
    });
    
    // Search for "laptop"
    await user.type(screen.getByPlaceholderText(/search/i), 'laptop');
    
    // Wait for debounce
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.queryByText('Wireless Mouse')).not.toBeInTheDocument();
      expect(screen.queryByText('Standing Desk')).not.toBeInTheDocument();
    });
  });
  
  it('filters by category', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    await screen.findByText('Gaming Laptop');
    
    // Select electronics category
    await user.selectOptions(
      screen.getByLabelText(/category/i),
      'electronics'
    );
    
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
      expect(screen.queryByText('Standing Desk')).not.toBeInTheDocument();
    });
  });
  
  it('filters by price range', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    await screen.findByText('Gaming Laptop');
    
    // Set price range: $0-$100
    await user.clear(screen.getByLabelText(/min price/i));
    await user.type(screen.getByLabelText(/min price/i), '0');
    await user.clear(screen.getByLabelText(/max price/i));
    await user.type(screen.getByLabelText(/max price/i), '100');
    
    await waitFor(() => {
      expect(screen.getByText('Wireless Mouse')).toBeInTheDocument(); // $29.99
      expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument(); // $999.99
    });
  });
  
  it('combines multiple filters', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    await screen.findByText('Gaming Laptop');
    
    // Search + category + price
    await user.type(screen.getByPlaceholderText(/search/i), 'gaming');
    await user.selectOptions(screen.getByLabelText(/category/i), 'electronics');
    await user.type(screen.getByLabelText(/min price/i), '500');
    
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.queryByText('Wireless Mouse')).not.toBeInTheDocument();
    });
  });
  
  it('shows "no results" when filters match nothing', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    await screen.findByText('Gaming Laptop');
    
    // Search for non-existent product
    await user.type(screen.getByPlaceholderText(/search/i), 'xyznonexistent');
    
    await waitFor(() => {
      expect(screen.getByText(/no products found/i)).toBeInTheDocument();
      expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument();
    });
  });
  
  it('clears all filters', async () => {
    const user = userEvent.setup();
    
    render(&lt;ProductList /&gt;);
    
    await screen.findByText('Gaming Laptop');
    
    // Apply filters
    await user.type(screen.getByPlaceholderText(/search/i), 'laptop');
    await user.selectOptions(screen.getByLabelText(/category/i), 'electronics');
    
    // Verify filtered
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.queryByText('Standing Desk')).not.toBeInTheDocument();
    });
    
    // Clear filters
    await user.click(screen.getByRole('button', { name: /clear filters/i }));
    
    // All products visible again
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.getByText('Standing Desk')).toBeInTheDocument();
    });
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Integration Testing Tips</h4>
                    <ul>
                        <li><strong>Test realistic workflows:</strong> Simulate actual user behavior</li>
                        <li><strong>Test data flow:</strong> Verify data passes correctly between components</li>
                        <li><strong>Test state updates:</strong> Ensure changes propagate everywhere</li>
                        <li><strong>Use waitFor:</strong> Handle async operations properly</li>
                        <li><strong>Test edge cases:</strong> Empty states, errors, boundary conditions</li>
                        <li><strong>Keep tests focused:</strong> One workflow per test</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Testing Context Providers -->
            <section id="context-tests" class="lesson-section">
                <h2>ğŸŒ Testing Context Providers</h2>
                
                <p>Context providers manage global state. Let's test that they properly share state across components.</p>

                <h3>CartContext Provider Tests</h3>
                <pre><code class="language-typescript">
// src/context/CartContext.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CartProvider, useCart } from './CartContext';

// Test component that uses the context
function TestComponent() {
  const { items, itemCount, subtotal, addItem, clearCart } = useCart();
  
  const handleAdd = () => {
    addItem({
      id: '1',
      name: 'Test Product',
      description: 'A test',
      price: 100,
      image: '/test.jpg',
      category: 'test',
      stock: 10,
    });
  };
  
  return (
    &lt;div&gt;
      &lt;p&gt;Items: {itemCount}&lt;/p&gt;
      &lt;p&gt;Subtotal: ${subtotal}&lt;/p&gt;
      &lt;button onClick={handleAdd}&gt;Add Item&lt;/button&gt;
      &lt;button onClick={clearCart}&gt;Clear&lt;/button&gt;
      &lt;ul&gt;
        {items.map(item => (
          &lt;li key={item.id}&gt;{item.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

describe('CartContext', () => {
  it('provides initial empty cart state', () => {
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    expect(screen.getByText('Items: 0')).toBeInTheDocument();
    expect(screen.getByText('Subtotal: $0')).toBeInTheDocument();
  });
  
  it('updates state when items are added', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    await user.click(screen.getByText('Add Item'));
    
    expect(screen.getByText('Items: 1')).toBeInTheDocument();
    expect(screen.getByText('Subtotal: $100')).toBeInTheDocument();
    expect(screen.getByText('Test Product')).toBeInTheDocument();
  });
  
  it('shares state across multiple consumers', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    const addButtons = screen.getAllByText('Add Item');
    
    // Add from first component
    await user.click(addButtons[0]);
    
    // Both components see the update
    const itemCounts = screen.getAllByText('Items: 1');
    expect(itemCounts).toHaveLength(2);
    
    const subtotals = screen.getAllByText('Subtotal: $100');
    expect(subtotals).toHaveLength(2);
  });
  
  it('clears cart from any consumer', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    // Add item from first component
    await user.click(screen.getAllByText('Add Item')[0]);
    
    expect(screen.getAllByText('Items: 1')).toHaveLength(2);
    
    // Clear from second component
    await user.click(screen.getAllByText('Clear')[1]);
    
    // Both see empty cart
    expect(screen.getAllByText('Items: 0')).toHaveLength(2);
  });
});
                </code></pre>

                <h3>Testing Provider with localStorage Persistence</h3>
                <pre><code class="language-typescript">
// src/context/CartContext.tsx (with persistence)
export function CartProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = React.useReducer(
    cartReducer,
    { items: [] },
    (initial) => {
      // Load from localStorage on init
      const saved = localStorage.getItem('cart');
      return saved ? JSON.parse(saved) : initial;
    }
  );
  
  // Save to localStorage on every change
  React.useEffect(() => {
    localStorage.setItem('cart', JSON.stringify(state));
  }, [state]);
  
  return (
    &lt;CartContext.Provider value={{ state, dispatch }}&gt;
      {children}
    &lt;/CartContext.Provider&gt;
  );
}

// Test with localStorage
describe('CartContext with localStorage', () => {
  beforeEach(() => {
    localStorage.clear();
  });
  
  it('loads initial state from localStorage', () => {
    // Pre-populate localStorage
    const savedCart = {
      items: [
        { id: '1', name: 'Saved Item', price: 50, quantity: 1, image: '/test.jpg' }
      ]
    };
    localStorage.setItem('cart', JSON.stringify(savedCart));
    
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    expect(screen.getByText('Items: 1')).toBeInTheDocument();
    expect(screen.getByText('Saved Item')).toBeInTheDocument();
  });
  
  it('persists state to localStorage', async () => {
    const user = userEvent.setup();
    
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    await user.click(screen.getByText('Add Item'));
    
    // Check localStorage
    const saved = localStorage.getItem('cart');
    expect(saved).toBeTruthy();
    
    const parsed = JSON.parse(saved!);
    expect(parsed.items).toHaveLength(1);
    expect(parsed.items[0].name).toBe('Test Product');
  });
  
  it('maintains state across provider remounts', async () => {
    const user = userEvent.setup();
    
    const { unmount } = render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    await user.click(screen.getByText('Add Item'));
    
    // Unmount
    unmount();
    
    // Remount - should restore from localStorage
    render(
      &lt;CartProvider&gt;
        &lt;TestComponent /&gt;
      &lt;/CartProvider&gt;
    );
    
    expect(screen.getByText('Items: 1')).toBeInTheDocument();
    expect(screen.getByText('Test Product')).toBeInTheDocument();
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Context Testing Best Practices</h4>
                    <ul>
                        <li><strong>Test the provider:</strong> Not just individual components</li>
                        <li><strong>Test multiple consumers:</strong> Verify state is shared</li>
                        <li><strong>Test persistence:</strong> If using localStorage/sessionStorage</li>
                        <li><strong>Test initialization:</strong> Verify initial state is correct</li>
                        <li><strong>Test error handling:</strong> Missing providers, invalid state</li>
                        <li><strong>Clean up:</strong> Clear localStorage between tests</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Testing with API Mocks -->
            <section id="api-tests" class="lesson-section">
                <h2>ğŸŒ Testing with API Mocks (MSW)</h2>
                
                <p>Let's test components that fetch data from APIs using Mock Service Worker.</p>

                <h3>Testing Data Fetching Component</h3>
                <pre><code class="language-typescript">
// src/components/Product/ProductList.tsx
export function ProductList() {
  const [products, setProducts] = React.useState&lt;Product[]&gt;([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState&lt;string | null&gt;(null);
  
  React.useEffect(() => {
    fetch('/api/products')
      .then(res => {
        if (!res.ok) throw new Error('Failed to fetch products');
        return res.json();
      })
      .then(data => {
        setProducts(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, []);
  
  if (loading) return &lt;div&gt;Loading products...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error}&lt;/div&gt;;
  if (products.length === 0) return &lt;div&gt;No products available&lt;/div&gt;;
  
  return (
    &lt;div className="product-grid"&gt;
      {products.map(product => (
        &lt;ProductCard key={product.id} product={product} /&gt;
      ))}
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>Tests with MSW</h3>
                <pre><code class="language-typescript">
// src/components/Product/ProductList.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import { rest } from 'msw';
import { server } from '@/test/mocks/server';
import { ProductList } from './ProductList';

describe('ProductList with API', () => {
  it('displays loading state initially', () => {
    render(&lt;ProductList /&gt;);
    
    expect(screen.getByText('Loading products...')).toBeInTheDocument();
  });
  
  it('displays products after successful fetch', async () => {
    render(&lt;ProductList /&gt;);
    
    // Wait for products to load
    await waitFor(() => {
      expect(screen.queryByText('Loading products...')).not.toBeInTheDocument();
    });
    
    // Products should be visible
    expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
    expect(screen.getByText('Wireless Mouse')).toBeInTheDocument();
  });
  
  it('displays error message on fetch failure', async () => {
    // Override default handler to return error
    server.use(
      rest.get('/api/products', (req, res, ctx) => {
        return res(ctx.status(500));
      })
    );
    
    render(&lt;ProductList /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText(/error.*failed to fetch/i)).toBeInTheDocument();
    });
    
    expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument();
  });
  
  it('displays empty state when no products', async () => {
    server.use(
      rest.get('/api/products', (req, res, ctx) => {
        return res(ctx.json([]));
      })
    );
    
    render(&lt;ProductList /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText('No products available')).toBeInTheDocument();
    });
  });
  
  it('handles network errors', async () => {
    server.use(
      rest.get('/api/products', (req, res, ctx) => {
        return res.networkError('Failed to connect');
      })
    );
    
    render(&lt;ProductList /&gt;);
    
    await waitFor(() => {
      expect(screen.getByText(/error/i)).toBeInTheDocument();
    });
  });
});
                </code></pre>

                <h3>Testing Search with API</h3>
                <pre><code class="language-typescript">
// src/components/Product/ProductSearch.tsx
export function ProductSearch() {
  const [query, setQuery] = React.useState('');
  const [results, setResults] = React.useState&lt;Product[]&gt;([]);
  const [searching, setSearching] = React.useState(false);
  
  const handleSearch = React.useMemo(
    () => debounce(async (searchQuery: string) => {
      if (!searchQuery) {
        setResults([]);
        return;
      }
      
      setSearching(true);
      
      try {
        const res = await fetch(`/api/products/search?q=${searchQuery}`);
        const data = await res.json();
        setResults(data);
      } catch (error) {
        console.error('Search failed:', error);
        setResults([]);
      } finally {
        setSearching(false);
      }
    }, 300),
    []
  );
  
  React.useEffect(() => {
    handleSearch(query);
  }, [query, handleSearch]);
  
  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Search products..."
      /&gt;
      
      {searching && &lt;p&gt;Searching...&lt;/p&gt;}
      
      &lt;div&gt;
        {results.map(product => (
          &lt;ProductCard key={product.id} product={product} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Test
describe('ProductSearch with API', () => {
  beforeEach(() => {
    vi.useFakeTimers();
  });
  
  afterEach(() => {
    vi.useRealTimers();
  });
  
  it('searches products via API', async () => {
    const user = userEvent.setup({ delay: null });
    
    server.use(
      rest.get('/api/products/search', (req, res, ctx) => {
        const query = req.url.searchParams.get('q');
        
        const allProducts = [
          { id: '1', name: 'Gaming Laptop', price: 999 },
          { id: '2', name: 'Wireless Mouse', price: 29 },
        ];
        
        const filtered = allProducts.filter(p =>
          p.name.toLowerCase().includes(query?.toLowerCase() || '')
        );
        
        return res(ctx.json(filtered));
      })
    );
    
    render(&lt;ProductSearch /&gt;);
    
    const input = screen.getByPlaceholderText('Search products...');
    await user.type(input, 'laptop');
    
    // Advance timers past debounce
    vi.advanceTimersByTime(300);
    
    // Wait for results
    await waitFor(() => {
      expect(screen.getByText('Gaming Laptop')).toBeInTheDocument();
      expect(screen.queryByText('Wireless Mouse')).not.toBeInTheDocument();
    });
  });
  
  it('shows loading state while searching', async () => {
    const user = userEvent.setup({ delay: null });
    
    server.use(
      rest.get('/api/products/search', async (req, res, ctx) => {
        await ctx.delay(100);
        return res(ctx.json([]));
      })
    );
    
    render(&lt;ProductSearch /&gt;);
    
    await user.type(screen.getByPlaceholderText('Search products...'), 'test');
    vi.advanceTimersByTime(300);
    
    // Should show searching state
    expect(await screen.findByText('Searching...')).toBeInTheDocument();
  });
  
  it('clears results when search is empty', async () => {
    const user = userEvent.setup({ delay: null });
    
    render(&lt;ProductSearch /&gt;);
    
    const input = screen.getByPlaceholderText('Search products...');
    
    // Search for something
    await user.type(input, 'laptop');
    vi.advanceTimersByTime(300);
    
    await screen.findByText('Gaming Laptop');
    
    // Clear search
    await user.clear(input);
    vi.advanceTimersByTime(300);
    
    // Results should be gone
    await waitFor(() => {
      expect(screen.queryByText('Gaming Laptop')).not.toBeInTheDocument();
    });
  });
});
                </code></pre>

                <h3>Testing Optimistic Updates</h3>
                <pre><code class="language-typescript">
// Component with optimistic update
export function AddToCartButton({ product }: { product: Product }) {
  const [isAdded, setIsAdded] = React.useState(false);
  const { addItem } = useCart();
  
  const handleClick = async () => {
    // Optimistic update
    setIsAdded(true);
    addItem(product);
    
    try {
      // Send to API
      await fetch('/api/cart', {
        method: 'POST',
        body: JSON.stringify({ productId: product.id }),
      });
    } catch (error) {
      // Rollback on error
      setIsAdded(false);
      removeItem(product.id);
    }
  };
  
  return (
    &lt;button onClick={handleClick} disabled={isAdded}&gt;
      {isAdded ? 'Added âœ“' : 'Add to Cart'}
    &lt;/button&gt;
  );
}

// Test
it('shows immediate feedback with optimistic update', async () => {
  const user = userEvent.setup();
  
  server.use(
    rest.post('/api/cart', async (req, res, ctx) => {
      await ctx.delay(500); // Slow API
      return res(ctx.status(200));
    })
  );
  
  render(&lt;AddToCartButton product={mockProduct} /&gt;);
  
  const button = screen.getByRole('button');
  
  // Initially shows "Add to Cart"
  expect(button).toHaveTextContent('Add to Cart');
  
  await user.click(button);
  
  // Immediately shows "Added" (optimistic)
  expect(button).toHaveTextContent('Added âœ“');
  expect(button).toBeDisabled();
  
  // Wait for API call
  await waitFor(() => {
    expect(button).toHaveTextContent('Added âœ“');
  }, { timeout: 1000 });
});

it('rolls back on API error', async () => {
  const user = userEvent.setup();
  
  server.use(
    rest.post('/api/cart', (req, res, ctx) => {
      return res(ctx.status(500));
    })
  );
  
  render(&lt;AddToCartButton product={mockProduct} /&gt;);
  
  const button = screen.getByRole('button');
  
  await user.click(button);
  
  // Initially optimistic
  expect(button).toHaveTextContent('Added âœ“');
  
  // Rolls back after error
  await waitFor(() => {
    expect(button).toHaveTextContent('Add to Cart');
    expect(button).not.toBeDisabled();
  });
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ API Testing with MSW Tips</h4>
                    <ul>
                        <li><strong>Set up global handlers:</strong> Default responses for all tests</li>
                        <li><strong>Override per test:</strong> Use server.use() for specific scenarios</li>
                        <li><strong>Test all states:</strong> Loading, success, error, empty</li>
                        <li><strong>Use realistic delays:</strong> Test loading states properly</li>
                        <li><strong>Test error scenarios:</strong> Network errors, timeouts, 4xx/5xx</li>
                        <li><strong>Verify request data:</strong> Check what's sent to the API</li>
                        <li><strong>Test optimistic updates:</strong> Immediate feedback + rollback</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: E2E Tests -->
            <section id="e2e-tests" class="lesson-section">
                <h2>ğŸŒ E2E Tests: Complete Shopping Workflows</h2>
                
                <p>Now let's write end-to-end tests that verify complete user workflows in a real browser using Playwright.</p>

                <h3>Complete Shopping Journey Test</h3>
                <pre><code class="language-typescript">
// e2e/shopping-flow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Complete Shopping Flow', () => {
  test('user can browse, add to cart, and checkout', async ({ page }) => {
    // 1. Visit homepage
    await page.goto('/');
    
    // Verify homepage loaded
    await expect(page.getByRole('heading', { name: /products/i })).toBeVisible();
    
    // 2. Browse products
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Wireless Mouse')).toBeVisible();
    
    // 3. Search for a product
    await page.getByPlaceholder('Search products...').fill('laptop');
    
    // Wait for search results
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Wireless Mouse')).not.toBeVisible();
    
    // 4. View product details
    await page.getByText('Gaming Laptop').click();
    
    await expect(page).toHaveURL(/\/products\/\d+/);
    await expect(page.getByRole('heading', { name: 'Gaming Laptop' })).toBeVisible();
    await expect(page.getByText('$999.99')).toBeVisible();
    
    // 5. Add to cart
    await page.getByRole('button', { name: /add to cart/i }).click();
    
    // Verify added notification or cart update
    await expect(page.getByText(/added to cart/i)).toBeVisible();
    
    // 6. View cart
    await page.getByRole('link', { name: /cart/i }).click();
    
    await expect(page).toHaveURL(/\/cart/);
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('1 item')).toBeVisible();
    
    // 7. Update quantity
    await page.getByLabel('Increase quantity').click();
    
    await expect(page.getByText('2 items')).toBeVisible();
    await expect(page.getByText('$1,999.98')).toBeVisible(); // Subtotal
    
    // 8. Proceed to checkout
    await page.getByRole('button', { name: /checkout/i }).click();
    
    await expect(page).toHaveURL(/\/checkout/);
    
    // 9. Fill shipping information
    await page.getByLabel('Full Name').fill('John Doe');
    await page.getByLabel('Email').fill('john@example.com');
    await page.getByLabel('Address').fill('123 Main St');
    await page.getByLabel('City').fill('New York');
    await page.getByLabel('State').selectOption('NY');
    await page.getByLabel('Zip Code').fill('10001');
    
    // 10. Fill payment information
    await page.getByLabel('Card Number').fill('4111111111111111');
    await page.getByLabel('Expiry Date').fill('12/25');
    await page.getByLabel('CVV').fill('123');
    
    // 11. Review order summary
    await expect(page.getByText('Order Summary')).toBeVisible();
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Quantity: 2')).toBeVisible();
    
    // Verify totals
    await expect(page.getByText(/subtotal.*\$1,999.98/i)).toBeVisible();
    await expect(page.getByText(/tax.*\$160.00/i)).toBeVisible();
    await expect(page.getByText(/shipping.*free/i)).toBeVisible();
    await expect(page.getByText(/total.*\$2,159.98/i)).toBeVisible();
    
    // 12. Place order
    await page.getByRole('button', { name: /place order/i }).click();
    
    // 13. Verify order confirmation
    await expect(page).toHaveURL(/\/order-confirmation/);
    await expect(page.getByText(/order confirmed/i)).toBeVisible();
    await expect(page.getByText(/order #/i)).toBeVisible();
    
    // Verify order details
    await expect(page.getByText('John Doe')).toBeVisible();
    await expect(page.getByText('john@example.com')).toBeVisible();
  });
});
                </code></pre>

                <h3>Testing Product Filtering</h3>
                <pre><code class="language-typescript">
// e2e/product-filtering.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Product Filtering', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });
  
  test('filters by search query', async ({ page }) => {
    // Type in search
    await page.getByPlaceholder('Search products...').fill('mouse');
    
    // Should show only matching products
    await expect(page.getByText('Wireless Mouse')).toBeVisible();
    await expect(page.getByText('Gaming Laptop')).not.toBeVisible();
  });
  
  test('filters by category', async ({ page }) => {
    // Select category
    await page.getByLabel('Category').selectOption('electronics');
    
    // Should show only electronics
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Wireless Mouse')).toBeVisible();
    await expect(page.getByText('Standing Desk')).not.toBeVisible();
  });
  
  test('filters by price range', async ({ page }) => {
    // Set price range
    await page.getByLabel('Min Price').fill('0');
    await page.getByLabel('Max Price').fill('100');
    
    // Should show only products in range
    await expect(page.getByText('Wireless Mouse')).toBeVisible(); // $29.99
    await expect(page.getByText('Gaming Laptop')).not.toBeVisible(); // $999.99
  });
  
  test('combines multiple filters', async ({ page }) => {
    // Apply multiple filters
    await page.getByPlaceholder('Search products...').fill('gaming');
    await page.getByLabel('Category').selectOption('electronics');
    await page.getByLabel('Min Price').fill('500');
    
    // Should show only products matching all filters
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Wireless Mouse')).not.toBeVisible();
    await expect(page.getByText('Standing Desk')).not.toBeVisible();
  });
  
  test('clears all filters', async ({ page }) => {
    // Apply filters
    await page.getByPlaceholder('Search products...').fill('laptop');
    await page.getByLabel('Category').selectOption('electronics');
    
    // Verify filtered
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Standing Desk')).not.toBeVisible();
    
    // Clear filters
    await page.getByRole('button', { name: /clear filters/i }).click();
    
    // All products should be visible
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('Wireless Mouse')).toBeVisible();
    await expect(page.getByText('Standing Desk')).toBeVisible();
  });
  
  test('shows no results message', async ({ page }) => {
    await page.getByPlaceholder('Search products...').fill('nonexistentproduct');
    
    await expect(page.getByText(/no products found/i)).toBeVisible();
  });
});
                </code></pre>

                <h3>Testing Cart Management</h3>
                <pre><code class="language-typescript">
// e2e/cart-management.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Cart Management', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });
  
  test('adds and removes items from cart', async ({ page }) => {
    // Add item
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    
    // Go to cart
    await page.getByRole('link', { name: /cart/i }).click();
    
    // Verify item in cart
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('1 item')).toBeVisible();
    
    // Remove item
    await page.getByLabel(/remove.*from cart/i).click();
    
    // Cart should be empty
    await expect(page.getByText(/cart is empty/i)).toBeVisible();
  });
  
  test('updates item quantity', async ({ page }) => {
    // Add item to cart
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    await page.getByRole('link', { name: /cart/i }).click();
    
    // Initial quantity
    await expect(page.getByLabelText('Quantity')).toHaveText('1');
    
    // Increase quantity
    await page.getByLabel('Increase quantity').click();
    await expect(page.getByLabelText('Quantity')).toHaveText('2');
    
    await page.getByLabel('Increase quantity').click();
    await expect(page.getByLabelText('Quantity')).toHaveText('3');
    
    // Decrease quantity
    await page.getByLabel('Decrease quantity').click();
    await expect(page.getByLabelText('Quantity')).toHaveText('2');
  });
  
  test('maintains cart across page navigation', async ({ page }) => {
    // Add item
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    
    // Navigate away
    await page.getByRole('link', { name: /home/i }).click();
    await expect(page).toHaveURL('/');
    
    // Go back to cart
    await page.getByRole('link', { name: /cart/i }).click();
    
    // Item should still be there
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('1 item')).toBeVisible();
  });
  
  test('persists cart after page reload', async ({ page }) => {
    // Add item
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    await page.getByRole('link', { name: /cart/i }).click();
    
    // Verify item in cart
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    
    // Reload page
    await page.reload();
    
    // Item should still be there
    await expect(page.getByText('Gaming Laptop')).toBeVisible();
    await expect(page.getByText('1 item')).toBeVisible();
  });
  
  test('calculates totals correctly', async ({ page }) => {
    // Add laptop ($999.99)
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    
    // Go back and add mouse ($29.99)
    await page.goBack();
    await page.getByText('Wireless Mouse').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    
    // Go to cart
    await page.getByRole('link', { name: /cart/i }).click();
    
    // Verify totals
    // Subtotal: $1,029.98
    await expect(page.getByText(/subtotal.*\$1,029.98/i)).toBeVisible();
    
    // Tax (8%): $82.40
    await expect(page.getByText(/tax.*\$82.40/i)).toBeVisible();
    
    // Shipping: Free (over $100)
    await expect(page.getByText(/shipping.*free/i)).toBeVisible();
    
    // Total: $1,112.38
    await expect(page.getByText(/total.*\$1,112.38/i)).toBeVisible();
  });
});
                </code></pre>

                <h3>Testing Responsive Design</h3>
                <pre><code class="language-typescript">
// e2e/responsive.spec.ts
import { test, expect, devices } from '@playwright/test';

test.describe('Responsive Design', () => {
  test('desktop navigation', async ({ page }) => {
    await page.goto('/');
    
    // Desktop menu should be visible
    await expect(page.getByRole('navigation')).toBeVisible();
    await expect(page.getByRole('link', { name: /products/i })).toBeVisible();
    await expect(page.getByRole('link', { name: /cart/i })).toBeVisible();
    
    // Mobile menu button should not be visible
    await expect(page.getByLabel('Open menu')).not.toBeVisible();
  });
  
  test('mobile navigation', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    // Mobile menu button should be visible
    const menuButton = page.getByLabel('Open menu');
    await expect(menuButton).toBeVisible();
    
    // Navigation links hidden initially
    const nav = page.getByRole('navigation');
    await expect(nav.getByRole('link', { name: /products/i })).not.toBeVisible();
    
    // Open menu
    await menuButton.click();
    
    // Navigation links now visible
    await expect(nav.getByRole('link', { name: /products/i })).toBeVisible();
    await expect(nav.getByRole('link', { name: /cart/i })).toBeVisible();
  });
  
  test('product grid on mobile', async ({ page }) => {
    await page.setViewportSize({ width: 375, height: 667 });
    await page.goto('/');
    
    // Products should stack vertically on mobile
    const products = page.getByRole('article');
    const firstProduct = products.first();
    const secondProduct = products.nth(1);
    
    const firstBox = await firstProduct.boundingBox();
    const secondBox = await secondProduct.boundingBox();
    
    // Second product should be below first (greater Y coordinate)
    expect(secondBox!.y).toBeGreaterThan(firstBox!.y + firstBox!.height);
  });
});
                </code></pre>

                <h3>Testing Error Scenarios</h3>
                <pre><code class="language-typescript">
// e2e/error-handling.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Error Handling', () => {
  test('handles out of stock products', async ({ page }) => {
    await page.goto('/products/out-of-stock-item');
    
    // Add to cart button should be disabled or not present
    const addButton = page.getByRole('button', { name: /add to cart/i });
    
    if (await addButton.isVisible()) {
      await expect(addButton).toBeDisabled();
    }
    
    // Should show out of stock message
    await expect(page.getByText(/out of stock/i)).toBeVisible();
  });
  
  test('validates checkout form', async ({ page }) => {
    // Add item and go to checkout
    await page.goto('/');
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    await page.getByRole('link', { name: /cart/i }).click();
    await page.getByRole('button', { name: /checkout/i }).click();
    
    // Try to submit without filling required fields
    await page.getByRole('button', { name: /place order/i }).click();
    
    // Should show validation errors
    await expect(page.getByText(/name is required/i)).toBeVisible();
    await expect(page.getByText(/email is required/i)).toBeVisible();
    await expect(page.getByText(/address is required/i)).toBeVisible();
  });
  
  test('handles invalid payment information', async ({ page }) => {
    // Add item and go to checkout
    await page.goto('/');
    await page.getByText('Gaming Laptop').click();
    await page.getByRole('button', { name: /add to cart/i }).click();
    await page.getByRole('link', { name: /cart/i }).click();
    await page.getByRole('button', { name: /checkout/i }).click();
    
    // Fill shipping info
    await page.getByLabel('Full Name').fill('John Doe');
    await page.getByLabel('Email').fill('john@example.com');
    await page.getByLabel('Address').fill('123 Main St');
    await page.getByLabel('City').fill('New York');
    await page.getByLabel('State').selectOption('NY');
    await page.getByLabel('Zip Code').fill('10001');
    
    // Enter invalid card number
    await page.getByLabel('Card Number').fill('1234');
    await page.getByLabel('Expiry Date').fill('12/20'); // Expired
    await page.getByLabel('CVV').fill('12'); // Too short
    
    // Try to submit
    await page.getByRole('button', { name: /place order/i }).click();
    
    // Should show payment errors
    await expect(page.getByText(/invalid card number/i)).toBeVisible();
    await expect(page.getByText(/card has expired/i)).toBeVisible();
    await expect(page.getByText(/invalid cvv/i)).toBeVisible();
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… E2E Testing Best Practices</h4>
                    <ul>
                        <li><strong>Test critical paths:</strong> Focus on main user workflows</li>
                        <li><strong>Use accessible selectors:</strong> getByRole, getByLabel, getByText</li>
                        <li><strong>Wait for elements:</strong> Use expect().toBeVisible() not manual waits</li>
                        <li><strong>Test responsive design:</strong> Multiple viewport sizes</li>
                        <li><strong>Test error scenarios:</strong> Validation, out of stock, network errors</li>
                        <li><strong>Keep tests independent:</strong> Each test should run alone</li>
                        <li><strong>Use page object model:</strong> For larger test suites</li>
                        <li><strong>Run in CI:</strong> Automate E2E tests in pipeline</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: CI/CD Setup -->
            <section id="ci-setup" class="lesson-section">
                <h2>ğŸ”„ CI/CD Setup</h2>
                
                <p>Let's set up automated testing in a CI/CD pipeline using GitHub Actions.</p>

                <h3>GitHub Actions Workflow</h3>
                <pre><code class="language-yaml">
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  unit-and-integration:
    name: Unit & Integration Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run unit tests
        run: npm run test -- --run
      
      - name: Generate coverage report
        run: npm run test:coverage
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json
      
      - name: Comment coverage on PR
        if: github.event_name == 'pull_request'
        uses: romeovs/lcov-reporter-action@v0.3.1
        with:
          lcov-file: ./coverage/lcov.info
          github-token: ${{ secrets.GITHUB_TOKEN }}
  
  e2e:
    name: E2E Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Install Playwright browsers
        run: npx playwright install --with-deps
      
      - name: Build application
        run: npm run build
      
      - name: Run E2E tests
        run: npm run test:e2e
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30
      
      - name: Upload test videos
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-videos
          path: test-results/
          retention-days: 7
  
  lint:
    name: Lint & Type Check
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run ESLint
        run: npm run lint
      
      - name: Run TypeScript check
        run: npm run type-check
                </code></pre>

                <h3>Package.json Scripts for CI</h3>
                <pre><code class="language-json">
{
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview",
    "test": "vitest",
    "test:coverage": "vitest --coverage",
    "test:e2e": "playwright test",
    "test:e2e:ui": "playwright test --ui",
    "lint": "eslint . --ext .ts,.tsx",
    "type-check": "tsc --noEmit"
  }
}
                </code></pre>

                <h3>Test Coverage Requirements</h3>
                <pre><code class="language-typescript">
// vitest.config.ts
export default defineConfig({
  test: {
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.spec.ts',
        '**/*.test.ts',
        '**/*.test.tsx',
        '**/types.ts',
      ],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 75,
        statements: 80,
      },
    },
  },
});
                </code></pre>

                <h3>Parallel Test Execution</h3>
                <pre><code class="language-typescript">
// playwright.config.ts
export default defineConfig({
  // Run tests in parallel
  fullyParallel: true,
  
  // Use 2 workers on CI, unlimited locally
  workers: process.env.CI ? 2 : undefined,
  
  // Retry failed tests on CI
  retries: process.env.CI ? 2 : 0,
  
  // Fail fast on CI
  maxFailures: process.env.CI ? 10 : undefined,
  
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    // Only run other browsers on CI
    ...(process.env.CI ? [
      {
        name: 'firefox',
        use: { ...devices['Desktop Firefox'] },
      },
      {
        name: 'webkit',
        use: { ...devices['Desktop Safari'] },
      },
    ] : []),
  ],
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ CI/CD Best Practices</h4>
                    <ul>
                        <li><strong>Run tests on every PR:</strong> Catch issues before merge</li>
                        <li><strong>Cache dependencies:</strong> Speed up pipeline</li>
                        <li><strong>Parallel execution:</strong> Run tests faster</li>
                        <li><strong>Retry flaky tests:</strong> But fix the root cause</li>
                        <li><strong>Upload artifacts:</strong> Screenshots, videos, reports</li>
                        <li><strong>Block merges:</strong> Require passing tests</li>
                        <li><strong>Track coverage:</strong> Maintain or improve over time</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Test Coverage Analysis -->
            <section id="coverage" class="lesson-section">
                <h2>ğŸ“Š Test Coverage Analysis</h2>
                
                <p>Let's analyze test coverage and ensure we're testing the right things.</p>

                <h3>Generating Coverage Reports</h3>
                <pre><code class="language-bash">
# Generate coverage report
npm run test:coverage

# Open HTML report in browser
open coverage/index.html
                </code></pre>

                <h3>Understanding Coverage Metrics</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Description</th>
                            <th>Target</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Line Coverage</strong></td>
                            <td>Percentage of code lines executed</td>
                            <td>80%+</td>
                        </tr>
                        <tr>
                            <td><strong>Function Coverage</strong></td>
                            <td>Percentage of functions called</td>
                            <td>80%+</td>
                        </tr>
                        <tr>
                            <td><strong>Branch Coverage</strong></td>
                            <td>Percentage of if/else branches taken</td>
                            <td>75%+</td>
                        </tr>
                        <tr>
                            <td><strong>Statement Coverage</strong></td>
                            <td>Percentage of statements executed</td>
                            <td>80%+</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Coverage Goals</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Good Coverage Strategy</h4>
                    <ul>
                        <li><strong>Utilities: 95%+</strong> - Pure functions are easy to test</li>
                        <li><strong>Business logic: 90%+</strong> - Critical app logic</li>
                        <li><strong>Components: 80%+</strong> - Focus on user-facing behavior</li>
                        <li><strong>Integration tests:</strong> Cover main user workflows</li>
                        <li><strong>E2E tests:</strong> Cover critical business paths</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>âš ï¸ Coverage Anti-Patterns</h4>
                    <ul>
                        <li><strong>Chasing 100%:</strong> Diminishing returns, focus on value</li>
                        <li><strong>Testing implementation:</strong> High coverage but brittle tests</li>
                        <li><strong>Ignoring integration:</strong> All unit tests, no integration</li>
                        <li><strong>No E2E tests:</strong> Missing critical user workflows</li>
                        <li><strong>Testing trivial code:</strong> Getters, setters, constants</li>
                    </ul>
                </div>

                <h3>Identifying Coverage Gaps</h3>
                <pre><code class="language-bash">
# Run coverage and identify uncovered code
npm run test:coverage

# Look for red/yellow highlights in HTML report
# Focus on:
# - Uncovered error handling
# - Uncovered edge cases
# - Uncovered conditional branches
                </code></pre>

                <h3>Test Quality Over Quantity</h3>
                <div class="mermaid">
                    graph TB
                    A[Test Quality] --> B[Tests User Behavior]
                    A --> C[Catches Real Bugs]
                    A --> D[Easy to Maintain]
                    A --> E[Fast Execution]
                    
                    F[High Coverage] -.->|Doesn't Guarantee| A
                    
                    style A fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style F fill:#ffc107,stroke:#e67700,stroke-width:2px,color:#333
                </div>

                <blockquote>
                    <strong>ğŸ’¡ Remember:</strong> "Coverage tells you what you haven't tested, not what you have tested well. Focus on testing behavior that matters to users."
                </blockquote>
            </section>

            <!-- Section 12: Summary -->
            <section id="summary" class="lesson-section">
                <h2>ğŸ“š Summary and Next Steps</h2>
                
                <p>Congratulations! You've built comprehensive test coverage for a real-world e-commerce application. Let's recap what you've learned and accomplished.</p>

                <h3>What You've Built</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>ğŸ‰ Project Achievements</h4>
                    <ul>
                        <li>âœ… Complete test infrastructure with Vitest, RTL, MSW, and Playwright</li>
                        <li>âœ… Unit tests for calculations, filters, and utilities</li>
                        <li>âœ… Component tests for UI components</li>
                        <li>âœ… Reducer tests for state management logic</li>
                        <li>âœ… Custom hook tests with renderHook</li>
                        <li>âœ… Integration tests for complete features</li>
                        <li>âœ… Context provider tests with persistence</li>
                        <li>âœ… API mocking with MSW</li>
                        <li>âœ… E2E tests for critical user workflows</li>
                        <li>âœ… CI/CD pipeline configuration</li>
                        <li>âœ… Coverage analysis and reporting</li>
                    </ul>
                </div>

                <h3>Testing Pyramid Recap</h3>
                <div class="mermaid">
                    graph TB
                    A[Your Test Suite]
                    
                    A --> B[Unit Tests<br/>70-80%<br/>âœ“ Calculations<br/>âœ“ Utilities<br/>âœ“ Filters]
                    A --> C[Integration Tests<br/>15-25%<br/>âœ“ Cart Flow<br/>âœ“ Context<br/>âœ“ API]
                    A --> D[E2E Tests<br/>5-10%<br/>âœ“ Shopping Flow<br/>âœ“ Checkout<br/>âœ“ Errors]
                    
                    style B fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style C fill:#339af0,stroke:#1971c2,stroke-width:2px,color:#fff
                    style D fill:#f59f00,stroke:#e67700,stroke-width:2px,color:#fff
                </div>

                <h3>Key Takeaways</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Key Learning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Test Infrastructure</strong></td>
                            <td>Proper setup is critical - invest time in configuration</td>
                        </tr>
                        <tr>
                            <td><strong>Unit Tests</strong></td>
                            <td>Fast, focused tests for pure logic and calculations</td>
                        </tr>
                        <tr>
                            <td><strong>Component Tests</strong></td>
                            <td>Test user behavior, not implementation details</td>
                        </tr>
                        <tr>
                            <td><strong>Integration Tests</strong></td>
                            <td>Verify components work together correctly</td>
                        </tr>
                        <tr>
                            <td><strong>E2E Tests</strong></td>
                            <td>Test critical paths in real browsers</td>
                        </tr>
                        <tr>
                            <td><strong>MSW</strong></td>
                            <td>Mock APIs at network level for realistic tests</td>
                        </tr>
                        <tr>
                            <td><strong>CI/CD</strong></td>
                            <td>Automate tests to catch issues early</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Next Steps</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸš€ Continue Your Testing Journey</h4>
                    <ol>
                        <li><strong>Add more tests:</strong> Increase coverage where needed</li>
                        <li><strong>Refactor with confidence:</strong> Your tests enable safe refactoring</li>
                        <li><strong>Monitor test health:</strong> Fix flaky tests immediately</li>
                        <li><strong>Review test failures:</strong> Every failure is a learning opportunity</li>
                        <li><strong>Share knowledge:</strong> Help teammates write better tests</li>
                        <li><strong>Improve performance:</strong> Keep tests fast</li>
                        <li><strong>Update tests:</strong> When requirements change, update tests first</li>
                    </ol>
                </div>

                <h3>Additional Resources</h3>
                <ul>
                    <li><a href="https://vitest.dev/" target="_blank" rel="noopener">Vitest Documentation</a></li>
                    <li><a href="https://testing-library.com/react" target="_blank" rel="noopener">React Testing Library</a></li>
                    <li><a href="https://mswjs.io/" target="_blank" rel="noopener">Mock Service Worker (MSW)</a></li>
                    <li><a href="https://playwright.dev/" target="_blank" rel="noopener">Playwright Documentation</a></li>
                    <li><a href="https://kentcdodds.com/blog/common-mistakes-with-react-testing-library" target="_blank" rel="noopener">Common Testing Mistakes</a></li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>ğŸ“ Module 9 Complete!</h4>
                    <p style="color: white;">You've successfully completed the Testing React Applications module! You now have:</p>
                    <ul style="color: white;">
                        <li>A production-ready testing infrastructure</li>
                        <li>Comprehensive test coverage for a real application</li>
                        <li>Skills to test any React + TypeScript application</li>
                        <li>Automated testing in CI/CD</li>
                        <li>Confidence to ship quality code</li>
                    </ul>
                    <p style="color: white;"><strong>What's Next:</strong> Module 10 - Advanced Topics and Deployment!</p>
                </div>

                <blockquote>
                    <strong>ğŸ’¬ Final Thought:</strong> "Testing isn't about achieving 100% coverageâ€”it's about building confidence that your application works correctly and giving yourself the freedom to improve it fearlessly."
                </blockquote>
            </section>

            <!-- Lesson Navigation -->
            <nav aria-label="Lesson Navigation">
                <div class="lesson-nav">
                    <a href="lesson_9_5_integration_testing.html" class="nav-button prev-lesson">
                        â† Previous: Integration and E2E Testing
                    </a>
                    <a href="index.html" class="nav-button home">
                        âŒ‚ Home
                    </a>
                    <a href="index.html#modules" class="nav-button next-lesson">
                        Next: Module 10 â†’
                    </a>
                </div>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="#">Terms of Use</a> |
                <a href="#">Privacy Policy</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
