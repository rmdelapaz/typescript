<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master complex form handling in React with TypeScript. Learn form state management, validation strategies, error messaging, field arrays, dynamic forms, and form performance optimization.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 7.1: Complex Form Handling - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module7">Module 7: Forms and Validation</a></li>
            <li aria-current="page">Lesson 7.1: Complex Form Handling</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üìù Lesson 7.1: Complex Form Handling</h1>
                <p class="lead">Forms are the backbone of user interaction in web applications. While simple forms are straightforward, real-world applications often require handling complex scenarios like multiple steps, dynamic fields, conditional validation, and nested data structures. In this lesson, you'll master the patterns and techniques needed to build robust, user-friendly forms in React with TypeScript.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Manage complex form state with multiple fields and nested data structures</li>
                        <li>Implement comprehensive validation strategies with real-time feedback</li>
                        <li>Build dynamic forms with field arrays and conditional fields</li>
                        <li>Create clear, accessible error messaging for users</li>
                        <li>Optimize form performance to prevent unnecessary re-renders</li>
                        <li>Handle advanced form scenarios like multi-step wizards and dependent fields</li>
                        <li>Type form data and handlers properly with TypeScript</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a comprehensive job application form with validation, dynamic fields, and multi-step flow</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Introduction to Complex Forms</a></li>
                        <li><a href="#section2" class="toc-link">Form State Management Patterns</a></li>
                        <li><a href="#section3" class="toc-link">Validation Strategies</a></li>
                        <li><a href="#section4" class="toc-link">Error Messaging</a></li>
                        <li><a href="#section5" class="toc-link">Dynamic Forms & Field Arrays</a></li>
                        <li><a href="#section6" class="toc-link">Form Performance Optimization</a></li>
                        <li><a href="#section7" class="toc-link">Advanced Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Complete Example</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction to Complex Forms -->
            <section id="section1" aria-labelledby="section1-title">
                <h2 id="section1-title">üìã Introduction to Complex Forms</h2>
                <p>Forms are everywhere in web applications‚Äîuser registration, profile editing, checkout flows, search filters, content creation, and much more. While simple forms with a few fields are straightforward, real-world applications often need to handle much more complex scenarios.</p>

                <h3>What Makes a Form "Complex"?</h3>
                <p>A form becomes complex when it involves one or more of these challenges:</p>

                <div class="card">
                    <ul>
                        <li><strong>Many fields</strong> - 10+ inputs that need to be managed and validated</li>
                        <li><strong>Nested data</strong> - Form data with multiple levels of nesting (address.city, user.profile.bio)</li>
                        <li><strong>Dynamic fields</strong> - Fields that can be added/removed (multiple phone numbers, education history)</li>
                        <li><strong>Conditional logic</strong> - Fields that appear based on other field values</li>
                        <li><strong>Multi-step flows</strong> - Forms spread across multiple pages or steps</li>
                        <li><strong>Complex validation</strong> - Rules that depend on multiple fields or external data</li>
                        <li><strong>Async validation</strong> - Checking username availability, validating addresses</li>
                        <li><strong>File uploads</strong> - Handling images, documents, or multiple files</li>
                        <li><strong>Performance concerns</strong> - Preventing re-renders on every keystroke</li>
                    </ul>
                </div>

                <h3>Common Complex Form Scenarios</h3>
                
                <div class="mermaid">
                graph TB
                    A[Complex Forms] --> B[Job Applications]
                    A --> C[E-commerce Checkout]
                    A --> D[User Onboarding]
                    A --> E[Admin Panels]
                    A --> F[Survey Forms]
                    
                    B --> B1[Personal Info]
                    B --> B2[Work History Array]
                    B --> B3[Education Array]
                    B --> B4[References]
                    
                    C --> C1[Shipping Address]
                    C --> C2[Billing Address]
                    C --> C3[Payment Info]
                    C --> C4[Order Review]
                    
                    D --> D1[Account Setup]
                    D --> D2[Profile Building]
                    D --> D3[Preferences]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#48bb78,color:#fff
                    style C fill:#48bb78,color:#fff
                    style D fill:#48bb78,color:#fff
                </graph>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Real-World Example: Job Application Form</h4>
                    <p>Consider a job application form that includes:</p>
                    <ul>
                        <li>Personal information (name, email, phone, address)</li>
                        <li>Multiple work experiences (each with company, position, dates, description)</li>
                        <li>Multiple education entries (school, degree, year)</li>
                        <li>Skills and certifications</li>
                        <li>Reference contacts</li>
                        <li>Resume upload</li>
                        <li>Cover letter (optional based on position)</li>
                    </ul>
                    <p>This form needs to handle dynamic arrays, validation across sections, conditional fields, file uploads, and a multi-step flow. That's complexity!</p>
                </div>

                <h3>The Challenges We'll Address</h3>
                <p>Throughout this lesson, we'll tackle these key challenges:</p>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Form Complexity Challenges</h4>
                    <ol>
                        <li><strong>State Management</strong> - How do we efficiently manage state for dozens of fields?</li>
                        <li><strong>Validation</strong> - When and how do we validate? Real-time, on blur, on submit?</li>
                        <li><strong>Error Display</strong> - How do we show errors clearly without overwhelming users?</li>
                        <li><strong>TypeScript</strong> - How do we type complex, nested form data?</li>
                        <li><strong>Performance</strong> - How do we prevent the entire form from re-rendering on every keystroke?</li>
                        <li><strong>User Experience</strong> - How do we keep complex forms feeling simple and intuitive?</li>
                        <li><strong>Accessibility</strong> - How do we ensure screen readers announce errors properly?</li>
                    </ol>
                </div>

                <h3>Our Approach</h3>
                <p>In this lesson, we'll start with vanilla React form handling to understand the fundamentals. This foundation will help you appreciate why form libraries exist and how they solve these problems. In the next lessons, we'll introduce React Hook Form and Zod, which make complex forms much easier to manage.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Learn the Hard Way First?</h4>
                    <p>Understanding how to build forms with vanilla React teaches you:</p>
                    <ul>
                        <li>The underlying principles that all form libraries use</li>
                        <li>How to debug form issues when they arise</li>
                        <li>When you actually need a form library vs. when vanilla React is sufficient</li>
                        <li>How to build custom solutions for unique requirements</li>
                        <li>What problems form libraries solve (so you appreciate them more!)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Form State Management Patterns -->
            <section id="section2" aria-labelledby="section2-title">
                <h2 id="section2-title">üóÇÔ∏è Form State Management Patterns</h2>
                <p>Managing form state is the foundation of form handling. Let's explore different patterns, from simple to sophisticated, and understand when to use each approach.</p>

                <h3>Pattern 1: Individual useState for Each Field</h3>
                <p>The simplest approach is to create separate state variables for each form field:</p>

                <pre><code class="language-typescript">// Simple but doesn't scale well
function SimpleForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [phone, setPhone] = useState('');
  const [address, setAddress] = useState('');
  // ... imagine 20 more fields

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log({ name, email, phone, address });
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input 
        value={name} 
        onChange={(e) => setName(e.target.value)} 
      /&gt;
      &lt;input 
        value={email} 
        onChange={(e) => setEmail(e.target.value)} 
      /&gt;
      {/* More inputs... */}
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Problems with This Approach</h4>
                    <ul>
                        <li><strong>Doesn't scale</strong> - Imagine 30 fields with 30 useState calls!</li>
                        <li><strong>Verbose</strong> - Lots of repetitive code</li>
                        <li><strong>Hard to validate</strong> - Where do validation errors go?</li>
                        <li><strong>Difficult to submit</strong> - Must manually gather all values</li>
                        <li><strong>No structure</strong> - Can't represent nested data easily</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use This Pattern</h4>
                    <p>This approach is fine for:</p>
                    <ul>
                        <li>Very simple forms with 2-3 fields</li>
                        <li>Forms where each field has very different handling logic</li>
                        <li>Temporary prototypes</li>
                    </ul>
                </div>

                <h3>Pattern 2: Single Object State</h3>
                <p>A better approach is to use a single state object that holds all form data:</p>

                <pre><code class="language-typescript">// Better: Single object for all form data
interface FormData {
  name: string;
  email: string;
  phone: string;
  address: {
    street: string;
    city: string;
    state: string;
    zip: string;
  };
}

function BetterForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    name: '',
    email: '',
    phone: '',
    address: {
      street: '',
      city: '',
      state: '',
      zip: ''
    }
  });

  // Generic handler for simple fields
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  // Handler for nested fields
  const handleAddressChange = (field: keyof FormData['address']) => 
    (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
      setFormData(prev => ({
        ...prev,
        address: {
          ...prev.address,
          [field]: e.target.value
        }
      }));
    };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log(formData); // All data in one object
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input 
        name="name"
        value={formData.name} 
        onChange={handleChange} 
      /&gt;
      &lt;input 
        name="email"
        value={formData.email} 
        onChange={handleChange} 
      /&gt;
      
      {/* Nested fields */}
      &lt;input 
        value={formData.address.street} 
        onChange={handleAddressChange('street')} 
      /&gt;
      &lt;input 
        value={formData.address.city} 
        onChange={handleAddressChange('city')} 
      /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Advantages of Object State</h4>
                    <ul>
                        <li><strong>Scalable</strong> - Easily add more fields</li>
                        <li><strong>Type-safe</strong> - TypeScript knows your data structure</li>
                        <li><strong>Structured</strong> - Supports nested data naturally</li>
                        <li><strong>Easy submission</strong> - Data is already in the right format</li>
                        <li><strong>Reusable handlers</strong> - Generic functions work for many fields</li>
                    </ul>
                </div>


                <h3>Pattern 3: useReducer for Complex State</h3>
                <p>For very complex forms, useReducer can provide better structure and maintainability:</p>

                <pre><code class="language-typescript">// Advanced: useReducer for complex form logic
interface FormState {
  formData: {
    name: string;
    email: string;
    phone: string;
  };
  errors: {
    name?: string;
    email?: string;
    phone?: string;
  };
  isSubmitting: boolean;
  isSubmitted: boolean;
}

type FormAction =
  | { type: 'SET_FIELD'; field: string; value: string }
  | { type: 'SET_ERROR'; field: string; error: string }
  | { type: 'CLEAR_ERROR'; field: string }
  | { type: 'START_SUBMIT' }
  | { type: 'SUBMIT_SUCCESS' }
  | { type: 'SUBMIT_FAILURE'; errors: Record&lt;string, string&gt; }
  | { type: 'RESET' };

function formReducer(state: FormState, action: FormAction): FormState {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        formData: {
          ...state.formData,
          [action.field]: action.value
        },
        // Clear error when user starts typing
        errors: {
          ...state.errors,
          [action.field]: undefined
        }
      };
    
    case 'SET_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: action.error
        }
      };
    
    case 'CLEAR_ERROR':
      return {
        ...state,
        errors: {
          ...state.errors,
          [action.field]: undefined
        }
      };
    
    case 'START_SUBMIT':
      return {
        ...state,
        isSubmitting: true
      };
    
    case 'SUBMIT_SUCCESS':
      return {
        ...state,
        isSubmitting: false,
        isSubmitted: true,
        errors: {}
      };
    
    case 'SUBMIT_FAILURE':
      return {
        ...state,
        isSubmitting: false,
        errors: action.errors
      };
    
    case 'RESET':
      return initialFormState;
    
    default:
      return state;
  }
}

const initialFormState: FormState = {
  formData: { name: '', email: '', phone: '' },
  errors: {},
  isSubmitting: false,
  isSubmitted: false
};

function AdvancedForm() {
  const [state, dispatch] = useReducer(formReducer, initialFormState);

  const handleChange = (field: string) => 
    (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
      dispatch({ 
        type: 'SET_FIELD', 
        field, 
        value: e.target.value 
      });
    };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    const validationErrors = validateForm(state.formData);
    if (Object.keys(validationErrors).length > 0) {
      dispatch({ type: 'SUBMIT_FAILURE', errors: validationErrors });
      return;
    }

    dispatch({ type: 'START_SUBMIT' });
    
    try {
      await submitToAPI(state.formData);
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (error) {
      dispatch({ 
        type: 'SUBMIT_FAILURE', 
        errors: { submit: 'Failed to submit form' } 
      });
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        value={state.formData.name}
        onChange={handleChange('name')}
        disabled={state.isSubmitting}
      /&gt;
      {state.errors.name && &lt;span&gt;{state.errors.name}&lt;/span&gt;}
      {/* More fields... */}
      
      &lt;button type="submit" disabled={state.isSubmitting}&gt;
        {state.isSubmitting ? 'Submitting...' : 'Submit'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use useReducer</h4>
                    <ul>
                        <li><strong>Complex state logic</strong> - Multiple related state updates</li>
                        <li><strong>State transitions</strong> - Clear state machine patterns</li>
                        <li><strong>Error handling</strong> - Need to track errors alongside data</li>
                        <li><strong>Submission states</strong> - Managing loading, success, failure states</li>
                        <li><strong>Testability</strong> - Reducer functions are easy to unit test</li>
                        <li><strong>Team collaboration</strong> - Explicit actions document possible state changes</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Pattern Comparison Summary</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Pattern</th>
                                <th>Best For</th>
                                <th>Pros</th>
                                <th>Cons</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Individual useState</strong></td>
                                <td>2-3 fields</td>
                                <td>Simple, straightforward</td>
                                <td>Doesn't scale, verbose</td>
                            </tr>
                            <tr>
                                <td><strong>Object State</strong></td>
                                <td>Most forms (5-20 fields)</td>
                                <td>Scalable, type-safe, structured</td>
                                <td>Nested updates can be tricky</td>
                            </tr>
                            <tr>
                                <td><strong>useReducer</strong></td>
                                <td>Complex forms (20+ fields)</td>
                                <td>Predictable, testable, clear actions</td>
                                <td>More boilerplate, learning curve</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 1: Refactor to Object State</strong></summary>
                    <p><strong>Task:</strong> Refactor this form to use a single object state instead of individual useState calls.</p>
                    
                    <pre><code class="language-typescript">// Starting code (refactor this!)
function UserForm() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [email, setEmail] = useState('');
  const [age, setAge] = useState('');
  const [country, setCountry] = useState('');

  return (
    &lt;form&gt;
      &lt;input value={firstName} onChange={e => setFirstName(e.target.value)} /&gt;
      &lt;input value={lastName} onChange={e => setLastName(e.target.value)} /&gt;
      &lt;input value={email} onChange={e => setEmail(e.target.value)} /&gt;
      &lt;input value={age} onChange={e => setAge(e.target.value)} /&gt;
      &lt;select value={country} onChange={e => setCountry(e.target.value)}&gt;
        &lt;option value=""&gt;Select country&lt;/option&gt;
        &lt;option value="us"&gt;United States&lt;/option&gt;
        &lt;option value="uk"&gt;United Kingdom&lt;/option&gt;
      &lt;/select&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create an interface for the form data, then use a single useState with that interface. Create a generic handleChange function that uses the input's name attribute.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">interface UserFormData {
  firstName: string;
  lastName: string;
  email: string;
  age: string;
  country: string;
}

function UserForm() {
  const [formData, setFormData] = useState&lt;UserFormData&gt;({
    firstName: '',
    lastName: '',
    email: '',
    age: '',
    country: ''
  });

  const handleChange = (
    e: React.ChangeEvent&lt;HTMLInputElement | HTMLSelectElement&gt;
  ) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
  };

  return (
    &lt;form&gt;
      &lt;input 
        name="firstName"
        value={formData.firstName} 
        onChange={handleChange} 
      /&gt;
      &lt;input 
        name="lastName"
        value={formData.lastName} 
        onChange={handleChange} 
      /&gt;
      &lt;input 
        name="email"
        type="email"
        value={formData.email} 
        onChange={handleChange} 
      /&gt;
      &lt;input 
        name="age"
        type="number"
        value={formData.age} 
        onChange={handleChange} 
      /&gt;
      &lt;select 
        name="country"
        value={formData.country} 
        onChange={handleChange}
      &gt;
        &lt;option value=""&gt;Select country&lt;/option&gt;
        &lt;option value="us"&gt;United States&lt;/option&gt;
        &lt;option value="uk"&gt;United Kingdom&lt;/option&gt;
      &lt;/select&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 3: Validation Strategies -->
            <section id="section3" aria-labelledby="section3-title">
                <h2 id="section3-title">‚úÖ Validation Strategies</h2>
                <p>Validation is crucial for ensuring data quality and providing helpful feedback to users. Let's explore different validation strategies and when to apply each one.</p>

                <h3>Types of Validation</h3>
                
                <div class="mermaid">
                graph LR
                    A[Form Validation] --> B[Client-Side]
                    A --> C[Server-Side]
                    
                    B --> B1[Real-time]
                    B --> B2[On Blur]
                    B --> B3[On Submit]
                    
                    B1 --> B1a[Keystroke validation]
                    B1 --> B1b[Format checking]
                    
                    B2 --> B2a[Field complete]
                    B2 --> B2b[User moved away]
                    
                    B3 --> B3a[All fields at once]
                    B3 --> B3b[Before API call]
                    
                    C --> C1[Database constraints]
                    C --> C2[Business rules]
                    C --> C3[Unique checks]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#48bb78,color:#fff
                    style C fill:#ed8936,color:#fff
                </graph>
                </div>

                <h3>When to Validate?</h3>
                <p>Different validation timing strategies serve different purposes:</p>

                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Strategy</th>
                                <th>When It Runs</th>
                                <th>Best For</th>
                                <th>User Experience</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Real-time (onChange)</strong></td>
                                <td>Every keystroke</td>
                                <td>Format validation (email, phone), password strength</td>
                                <td>Immediate feedback, but can be annoying</td>
                            </tr>
                            <tr>
                                <td><strong>On Blur</strong></td>
                                <td>When field loses focus</td>
                                <td>Most validations (required, length, format)</td>
                                <td>Good balance - validates after user finishes</td>
                            </tr>
                            <tr>
                                <td><strong>On Submit</strong></td>
                                <td>When form is submitted</td>
                                <td>Cross-field validation, server-side checks</td>
                                <td>Least intrusive, but user finds errors late</td>
                            </tr>
                            <tr>
                                <td><strong>Debounced</strong></td>
                                <td>After user stops typing (300-500ms)</td>
                                <td>Async checks (username availability)</td>
                                <td>Best for expensive validations</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Validation Pattern: Multi-Strategy Approach</h3>
                <p>The best user experience often combines multiple validation strategies:</p>

                <pre><code class="language-typescript">interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
  username: string;
}

interface FormErrors {
  email?: string;
  password?: string;
  confirmPassword?: string;
  username?: string;
}

function RegistrationForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    email: '',
    password: '',
    confirmPassword: '',
    username: ''
  });

  const [errors, setErrors] = useState&lt;FormErrors&gt;({});
  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});

  // Validation functions
  const validateEmail = (email: string): string | undefined => {
    if (!email) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return 'Invalid email format';
    }
    return undefined;
  };

  const validatePassword = (password: string): string | undefined => {
    if (!password) return 'Password is required';
    if (password.length < 8) return 'Password must be at least 8 characters';
    if (!/[A-Z]/.test(password)) return 'Password must contain uppercase letter';
    if (!/[a-z]/.test(password)) return 'Password must contain lowercase letter';
    if (!/[0-9]/.test(password)) return 'Password must contain a number';
    return undefined;
  };

  const validateConfirmPassword = (
    password: string, 
    confirmPassword: string
  ): string | undefined => {
    if (!confirmPassword) return 'Please confirm your password';
    if (password !== confirmPassword) return 'Passwords do not match';
    return undefined;
  };

  // Real-time validation for password strength
  const handlePasswordChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const newPassword = e.target.value;
    setFormData(prev => ({ ...prev, password: newPassword }));
    
    // Real-time validation shows password strength immediately
    if (touched.password) {
      const error = validatePassword(newPassword);
      setErrors(prev => ({ ...prev, password: error }));
    }
  };

  // On blur validation for most fields
  const handleBlur = (field: keyof FormData) => () => {
    setTouched(prev => ({ ...prev, [field]: true }));
    
    let error: string | undefined;
    
    switch (field) {
      case 'email':
        error = validateEmail(formData.email);
        break;
      case 'password':
        error = validatePassword(formData.password);
        break;
      case 'confirmPassword':
        error = validateConfirmPassword(formData.password, formData.confirmPassword);
        break;
    }
    
    setErrors(prev => ({ ...prev, [field]: error }));
  };

  // On submit validation (validates everything)
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Mark all fields as touched
    setTouched({
      email: true,
      password: true,
      confirmPassword: true,
      username: true
    });

    // Run all validations
    const newErrors: FormErrors = {
      email: validateEmail(formData.email),
      password: validatePassword(formData.password),
      confirmPassword: validateConfirmPassword(
        formData.password, 
        formData.confirmPassword
      )
    };

    // Remove undefined errors
    Object.keys(newErrors).forEach(key => {
      if (newErrors[key as keyof FormErrors] === undefined) {
        delete newErrors[key as keyof FormErrors];
      }
    });

    setErrors(newErrors);

    // If there are errors, don't submit
    if (Object.keys(newErrors).length > 0) {
      return;
    }

    // Submit form
    try {
      await submitRegistration(formData);
      alert('Registration successful!');
    } catch (error) {
      setErrors({ email: 'Registration failed. Please try again.' });
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
        &lt;input
          id="email"
          type="email"
          name="email"
          value={formData.email}
          onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
          onBlur={handleBlur('email')}
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
        /&gt;
        {errors.email && touched.email && (
          &lt;span id="email-error" role="alert" style={{ color: 'red' }}&gt;
            {errors.email}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
        &lt;input
          id="password"
          type="password"
          name="password"
          value={formData.password}
          onChange={handlePasswordChange}
          onBlur={handleBlur('password')}
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? 'password-error' : undefined}
        /&gt;
        {errors.password && (
          &lt;span id="password-error" role="alert" style={{ color: 'red' }}&gt;
            {errors.password}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password&lt;/label&gt;
        &lt;input
          id="confirmPassword"
          type="password"
          name="confirmPassword"
          value={formData.confirmPassword}
          onChange={(e) => setFormData(prev => ({ ...prev, confirmPassword: e.target.value }))}
          onBlur={handleBlur('confirmPassword')}
          aria-invalid={!!errors.confirmPassword}
          aria-describedby={errors.confirmPassword ? 'confirm-password-error' : undefined}
        /&gt;
        {errors.confirmPassword && touched.confirmPassword && (
          &lt;span id="confirm-password-error" role="alert" style={{ color: 'red' }}&gt;
            {errors.confirmPassword}
          &lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Register&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Validation Concepts</h4>
                    <ul>
                        <li><strong>Touched tracking</strong> - Only show errors after user has interacted with a field</li>
                        <li><strong>Multiple strategies</strong> - Real-time for password strength, on blur for most fields</li>
                        <li><strong>Submit validation</strong> - Final check before sending data</li>
                        <li><strong>Accessibility</strong> - Use aria-invalid and aria-describedby for screen readers</li>
                        <li><strong>Clear errors</strong> - Remove error when user starts fixing it</li>
                    </ul>
                </div>

                <h3>Async Validation</h3>
                <p>Some validations require checking with the server (e.g., username availability). These need special handling:</p>

                <pre><code class="language-typescript">function UsernameField() {
  const [username, setUsername] = useState('');
  const [error, setError] = useState&lt;string&gt;();
  const [isChecking, setIsChecking] = useState(false);

  // Debounced validation check
  useEffect(() => {
    if (!username) {
      setError(undefined);
      return;
    }

    // Don't check immediately - wait for user to stop typing
    const timeoutId = setTimeout(async () => {
      setIsChecking(true);
      
      try {
        const available = await checkUsernameAvailability(username);
        if (!available) {
          setError('Username is already taken');
        } else {
          setError(undefined);
        }
      } catch (err) {
        setError('Could not check username availability');
      } finally {
        setIsChecking(false);
      }
    }, 500); // Wait 500ms after user stops typing

    // Cleanup function cancels the previous timeout
    return () => clearTimeout(timeoutId);
  }, [username]);

  return (
    &lt;div&gt;
      &lt;label htmlFor="username"&gt;Username&lt;/label&gt;
      &lt;input
        id="username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        aria-invalid={!!error}
        aria-describedby={error ? 'username-error' : undefined}
      /&gt;
      {isChecking && &lt;span&gt;Checking availability...&lt;/span&gt;}
      {error && !isChecking && (
        &lt;span id="username-error" role="alert" style={{ color: 'red' }}&gt;
          {error}
        &lt;/span&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Async Validation Best Practices</h4>
                    <ul>
                        <li><strong>Debounce</strong> - Wait for user to stop typing (300-500ms)</li>
                        <li><strong>Show loading state</strong> - Let user know check is in progress</li>
                        <li><strong>Handle errors</strong> - Network failures shouldn't block form</li>
                        <li><strong>Cancel previous requests</strong> - Use cleanup functions to avoid race conditions</li>
                        <li><strong>Cache results</strong> - Don't recheck the same value twice</li>
                    </ul>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 2: Add Validation</strong></summary>
                    <p><strong>Task:</strong> Add validation to this form with the following rules:</p>
                    <ul>
                        <li>Name: Required, min 2 characters</li>
                        <li>Email: Required, valid email format</li>
                        <li>Age: Required, must be 18 or older</li>
                        <li>Use on-blur validation</li>
                        <li>Show errors only after field is touched</li>
                    </ul>
                    
                    <pre><code class="language-typescript">// Add validation to this form!
interface FormData {
  name: string;
  email: string;
  age: string;
}

function SignupForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    name: '',
    email: '',
    age: ''
  });

  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('Submit:', formData);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input name="name" value={formData.name} onChange={handleChange} /&gt;
      &lt;input name="email" type="email" value={formData.email} onChange={handleChange} /&gt;
      &lt;input name="age" type="number" value={formData.age} onChange={handleChange} /&gt;
      &lt;button type="submit"&gt;Sign Up&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create an errors state and a touched state. Write validation functions for each field. Add onBlur handlers that validate and set errors. Only show errors if the field has been touched.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">interface FormData {
  name: string;
  email: string;
  age: string;
}

interface FormErrors {
  name?: string;
  email?: string;
  age?: string;
}

function SignupForm() {
  const [formData, setFormData] = useState&lt;FormData&gt;({
    name: '',
    email: '',
    age: ''
  });

  const [errors, setErrors] = useState&lt;FormErrors&gt;({});
  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});

  // Validation functions
  const validateName = (name: string): string | undefined => {
    if (!name) return 'Name is required';
    if (name.length < 2) return 'Name must be at least 2 characters';
    return undefined;
  };

  const validateEmail = (email: string): string | undefined => {
    if (!email) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return 'Invalid email format';
    }
    return undefined;
  };

  const validateAge = (age: string): string | undefined => {
    if (!age) return 'Age is required';
    const ageNum = parseInt(age);
    if (isNaN(ageNum)) return 'Age must be a number';
    if (ageNum < 18) return 'You must be at least 18 years old';
    return undefined;
  };

  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Clear error when user starts typing (if field was touched)
    if (touched[name]) {
      setErrors(prev => ({ ...prev, [name]: undefined }));
    }
  };

  const handleBlur = (field: keyof FormData) => () => {
    setTouched(prev => ({ ...prev, [field]: true }));
    
    let error: string | undefined;
    switch (field) {
      case 'name':
        error = validateName(formData.name);
        break;
      case 'email':
        error = validateEmail(formData.email);
        break;
      case 'age':
        error = validateAge(formData.age);
        break;
    }
    
    setErrors(prev => ({ ...prev, [field]: error }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Mark all as touched
    setTouched({ name: true, email: true, age: true });
    
    // Validate all fields
    const newErrors: FormErrors = {
      name: validateName(formData.name),
      email: validateEmail(formData.email),
      age: validateAge(formData.age)
    };
    
    // Remove undefined errors
    Object.keys(newErrors).forEach(key => {
      if (!newErrors[key as keyof FormErrors]) {
        delete newErrors[key as keyof FormErrors];
      }
    });
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Submit:', formData);
      alert('Form submitted successfully!');
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="name"&gt;Name&lt;/label&gt;
        &lt;input 
          id="name"
          name="name" 
          value={formData.name} 
          onChange={handleChange}
          onBlur={handleBlur('name')}
          aria-invalid={!!errors.name}
        /&gt;
        {errors.name && touched.name && (
          &lt;span role="alert" style={{ color: 'red' }}&gt;{errors.name}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
        &lt;input 
          id="email"
          name="email" 
          type="email" 
          value={formData.email} 
          onChange={handleChange}
          onBlur={handleBlur('email')}
          aria-invalid={!!errors.email}
        /&gt;
        {errors.email && touched.email && (
          &lt;span role="alert" style={{ color: 'red' }}&gt;{errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;div&gt;
        &lt;label htmlFor="age"&gt;Age&lt;/label&gt;
        &lt;input 
          id="age"
          name="age" 
          type="number" 
          value={formData.age} 
          onChange={handleChange}
          onBlur={handleBlur('age')}
          aria-invalid={!!errors.age}
        /&gt;
        {errors.age && touched.age && (
          &lt;span role="alert" style={{ color: 'red' }}&gt;{errors.age}&lt;/span&gt;
        )}
      &lt;/div&gt;

      &lt;button type="submit"&gt;Sign Up&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 4: Error Messaging -->
            <section id="section4" aria-labelledby="section4-title">
                <h2 id="section4-title">‚ùó Error Messaging</h2>
                <p>Good error messages help users fix problems quickly. Bad error messages frustrate users and increase abandonment. Let's explore how to provide helpful, accessible error feedback.</p>

                <h3>Principles of Good Error Messages</h3>
                
                <div class="card">
                    <h4>‚úÖ Do's</h4>
                    <ul>
                        <li><strong>Be specific</strong> - "Email must include @" not "Invalid input"</li>
                        <li><strong>Be helpful</strong> - Tell users how to fix the problem</li>
                        <li><strong>Be human</strong> - Use friendly, conversational language</li>
                        <li><strong>Be visible</strong> - Use color, icons, and position errors near the field</li>
                        <li><strong>Be accessible</strong> - Use ARIA labels and role="alert"</li>
                        <li><strong>Be timely</strong> - Show errors at the right moment</li>
                    </ul>
                </div>

                <div class="card" style="background: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Don'ts</h4>
                    <ul>
                        <li><strong>Don't be vague</strong> - "Error" tells users nothing</li>
                        <li><strong>Don't blame</strong> - "You entered..." sounds accusatory</li>
                        <li><strong>Don't use jargon</strong> - "Invalid regex pattern" confuses users</li>
                        <li><strong>Don't overwhelm</strong> - Show one error at a time if possible</li>
                        <li><strong>Don't hide errors</strong> - Make them easy to see</li>
                    </ul>
                </div>

                <h3>Error Message Examples</h3>
                
                <div class="card">
                    <table>
                        <thead>
                            <tr>
                                <th>Scenario</th>
                                <th>‚ùå Bad</th>
                                <th>‚úÖ Good</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Empty required field</td>
                                <td>"Required"</td>
                                <td>"Please enter your email address"</td>
                            </tr>
                            <tr>
                                <td>Invalid email</td>
                                <td>"Invalid"</td>
                                <td>"Email must include @ and a domain (e.g., user@example.com)"</td>
                            </tr>
                            <tr>
                                <td>Password too short</td>
                                <td>"Invalid password"</td>
                                <td>"Password must be at least 8 characters long"</td>
                            </tr>
                            <tr>
                                <td>Passwords don't match</td>
                                <td>"Error"</td>
                                <td>"Passwords don't match. Please try again."</td>
                            </tr>
                            <tr>
                                <td>Age restriction</td>
                                <td>"Invalid age"</td>
                                <td>"You must be at least 18 years old to register"</td>
                            </tr>
                            <tr>
                                <td>Username taken</td>
                                <td>"Unavailable"</td>
                                <td>"This username is already taken. Try adding numbers or your name."</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Error Display Patterns</h3>
                <p>There are several ways to display errors. Choose based on form complexity and user needs:</p>

                <h4>Pattern 1: Inline Errors (Most Common)</h4>
                <pre><code class="language-typescript">function InlineErrorExample() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState&lt;string&gt;();

  return (
    &lt;div style={{ marginBottom: '1rem' }}&gt;
      &lt;label htmlFor="email" style={{ display: 'block', marginBottom: '0.5rem' }}&gt;
        Email
      &lt;/label&gt;
      &lt;input
        id="email"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        aria-invalid={!!error}
        aria-describedby={error ? 'email-error' : undefined}
        style={{
          borderColor: error ? '#f44336' : '#ddd',
          padding: '0.5rem',
          width: '100%'
        }}
      /&gt;
      {error && (
        &lt;div
          id="email-error"
          role="alert"
          style={{
            color: '#f44336',
            fontSize: '0.875rem',
            marginTop: '0.25rem'
          }}
        &gt;
          ‚ö†Ô∏è {error}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h4>Pattern 2: Error Summary (Complex Forms)</h4>
                <pre><code class="language-typescript">function ErrorSummaryExample() {
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});

  return (
    &lt;form&gt;
      {Object.keys(errors).length > 0 && (
        &lt;div
          role="alert"
          aria-live="polite"
          style={{
            backgroundColor: '#ffebee',
            border: '1px solid #f44336',
            borderRadius: '4px',
            padding: '1rem',
            marginBottom: '1rem'
          }}
        &gt;
          &lt;h3 style={{ margin: '0 0 0.5rem 0', color: '#f44336' }}&gt;
            ‚ö†Ô∏è Please fix the following errors:
          &lt;/h3&gt;
          &lt;ul style={{ margin: 0, paddingLeft: '1.5rem' }}&gt;
            {Object.entries(errors).map(([field, error]) => (
              &lt;li key={field}&gt;
                &lt;strong&gt;{field}:&lt;/strong&gt; {error}
              &lt;/li&gt;
            ))}
          &lt;/ul&gt;
        &lt;/div&gt;
      )}
      
      {/* Form fields... */}
    &lt;/form&gt;
  );
}</code></pre>

                <h4>Pattern 3: Toast Notifications (Submission Errors)</h4>
                <pre><code class="language-typescript">function ToastErrorExample() {
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      await submitForm();
    } catch (error) {
      setToastMessage('Failed to submit form. Please try again.');
      setShowToast(true);
      setTimeout(() => setShowToast(false), 5000);
    }
  };

  return (
    &lt;&gt;
      {showToast && (
        &lt;div
          role="alert"
          style={{
            position: 'fixed',
            top: '1rem',
            right: '1rem',
            backgroundColor: '#f44336',
            color: 'white',
            padding: '1rem',
            borderRadius: '4px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.2)'
          }}
        &gt;
          ‚ö†Ô∏è {toastMessage}
        &lt;/div&gt;
      )}
      
      &lt;form onSubmit={handleSubmit}&gt;
        {/* Form fields... */}
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Each Pattern</h4>
                    <ul>
                        <li><strong>Inline errors</strong> - Best for most forms, show errors right next to the field</li>
                        <li><strong>Error summary</strong> - Good for long forms (10+ fields) or when errors span multiple sections</li>
                        <li><strong>Toast notifications</strong> - Best for server errors or actions that happen after form submission</li>
                        <li><strong>Combination</strong> - Use inline + summary for complex forms</li>
                    </ul>
                </div>

                <h3>Accessibility in Error Messages</h3>
                <p>Error messages must be accessible to screen reader users:</p>

                <pre><code class="language-typescript">function AccessibleErrorExample() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState&lt;string&gt;();
  const [touched, setTouched] = useState(false);

  return (
    &lt;div&gt;
      {/* Label is properly associated with input */}
      &lt;label htmlFor="email-input"&gt;Email Address&lt;/label&gt;
      
      &lt;input
        id="email-input"
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        onBlur={() => setTouched(true)}
        
        {/* aria-invalid tells screen readers the field has an error */}
        aria-invalid={!!error && touched}
        
        {/* aria-describedby links the input to the error message */}
        aria-describedby={error && touched ? 'email-error' : undefined}
        
        {/* aria-required tells screen readers this is required */}
        aria-required="true"
      /&gt;
      
      {error && touched && (
        &lt;div
          id="email-error"
          
          {/* role="alert" makes screen readers announce the error immediately */}
          role="alert"
          
          {/* aria-live="polite" announces changes without interrupting */}
          aria-live="polite"
          
          style={{ color: '#f44336', marginTop: '0.25rem' }}
        &gt;
          {error}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Accessibility Checklist</h4>
                    <ul>
                        <li>‚úÖ Use <code>aria-invalid</code> on inputs with errors</li>
                        <li>‚úÖ Use <code>aria-describedby</code> to link inputs to error messages</li>
                        <li>‚úÖ Use <code>role="alert"</code> on error messages</li>
                        <li>‚úÖ Use <code>aria-live="polite"</code> for dynamic error updates</li>
                        <li>‚úÖ Use <code>aria-required</code> for required fields</li>
                        <li>‚úÖ Ensure error messages have sufficient color contrast (4.5:1)</li>
                        <li>‚úÖ Don't rely on color alone - use icons and text</li>
                        <li>‚úÖ Make sure error messages are keyboard accessible</li>
                    </ul>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 3: Improve Error Messages</strong></summary>
                    <p><strong>Task:</strong> Improve the error messages in this form to be more helpful and accessible.</p>
                    
                    <pre><code class="language-typescript">// Current implementation (needs improvement!)
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    const newErrors: Record&lt;string, string&gt; = {};
    
    if (!email) newErrors.email = 'Required';
    if (!password) newErrors.password = 'Required';
    if (password && password.length < 8) newErrors.password = 'Too short';
    
    setErrors(newErrors);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input 
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      /&gt;
      {errors.email && &lt;span&gt;{errors.email}&lt;/span&gt;}
      
      &lt;input 
        type="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      /&gt;
      {errors.password && &lt;span&gt;{errors.password}&lt;/span&gt;}
      
      &lt;button type="submit"&gt;Login&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Improve: 1) Error message text to be more helpful, 2) Add proper labels, 3) Add ARIA attributes for accessibility, 4) Style errors to be more visible, 5) Add icons to errors</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">function ImprovedLoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});
  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});

  const handleBlur = (field: string) => () => {
    setTouched(prev => ({ ...prev, [field]: true }));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    // Mark all as touched
    setTouched({ email: true, password: true });
    
    const newErrors: Record&lt;string, string&gt; = {};
    
    // Improved error messages - specific and helpful
    if (!email) {
      newErrors.email = 'Please enter your email address';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      newErrors.email = 'Please enter a valid email address (e.g., user@example.com)';
    }
    
    if (!password) {
      newErrors.password = 'Please enter your password';
    } else if (password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters long';
    }
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      console.log('Login successful!');
    }
  };

  return (
    &lt;form onSubmit={handleSubmit} style={{ maxWidth: '400px' }}&gt;
      &lt;div style={{ marginBottom: '1rem' }}&gt;
        {/* Proper label */}
        &lt;label 
          htmlFor="email-input" 
          style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}
        &gt;
          Email Address
        &lt;/label&gt;
        
        &lt;input 
          id="email-input"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          onBlur={handleBlur('email')}
          
          {/* Accessibility attributes */}
          aria-invalid={!!errors.email && touched.email}
          aria-describedby={errors.email && touched.email ? 'email-error' : undefined}
          aria-required="true"
          
          {/* Visual styling */}
          style={{
            width: '100%',
            padding: '0.5rem',
            border: `2px solid ${errors.email && touched.email ? '#f44336' : '#ddd'}`,
            borderRadius: '4px',
            fontSize: '1rem'
          }}
        /&gt;
        
        {/* Improved error display */}
        {errors.email && touched.email && (
          &lt;div
            id="email-error"
            role="alert"
            aria-live="polite"
            style={{
              color: '#f44336',
              fontSize: '0.875rem',
              marginTop: '0.25rem',
              display: 'flex',
              alignItems: 'center',
              gap: '0.25rem'
            }}
          &gt;
            &lt;span aria-hidden="true"&gt;‚ö†Ô∏è&lt;/span&gt;
            {errors.email}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;div style={{ marginBottom: '1rem' }}&gt;
        &lt;label 
          htmlFor="password-input" 
          style={{ display: 'block', marginBottom: '0.5rem', fontWeight: '500' }}
        &gt;
          Password
        &lt;/label&gt;
        
        &lt;input 
          id="password-input"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          onBlur={handleBlur('password')}
          aria-invalid={!!errors.password && touched.password}
          aria-describedby={errors.password && touched.password ? 'password-error' : undefined}
          aria-required="true"
          style={{
            width: '100%',
            padding: '0.5rem',
            border: `2px solid ${errors.password && touched.password ? '#f44336' : '#ddd'}`,
            borderRadius: '4px',
            fontSize: '1rem'
          }}
        /&gt;
        
        {errors.password && touched.password && (
          &lt;div
            id="password-error"
            role="alert"
            aria-live="polite"
            style={{
              color: '#f44336',
              fontSize: '0.875rem',
              marginTop: '0.25rem',
              display: 'flex',
              alignItems: 'center',
              gap: '0.25rem'
            }}
          &gt;
            &lt;span aria-hidden="true"&gt;‚ö†Ô∏è&lt;/span&gt;
            {errors.password}
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      &lt;button 
        type="submit"
        style={{
          width: '100%',
          padding: '0.75rem',
          backgroundColor: '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          fontSize: '1rem',
          fontWeight: '500',
          cursor: 'pointer'
        }}
      &gt;
        Login
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </details>
                </details>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Error Message Checklist</h4>
                    <ul>
                        <li>‚úÖ Specific - Explains exactly what's wrong</li>
                        <li>‚úÖ Helpful - Tells user how to fix it</li>
                        <li>‚úÖ Friendly - Uses conversational, positive language</li>
                        <li>‚úÖ Visible - Easy to see with color and icons</li>
                        <li>‚úÖ Accessible - Works with screen readers</li>
                        <li>‚úÖ Timely - Appears at the right moment</li>
                        <li>‚úÖ Consistent - Same style throughout form</li>
                    </ul>
                </div>
            </section>


            <!-- Section 5: Dynamic Forms & Field Arrays -->
            <section id="section5" aria-labelledby="section5-title">
                <h2 id="section5-title">üîÑ Dynamic Forms & Field Arrays</h2>
                <p>Many real-world forms need dynamic fields‚Äîallowing users to add or remove items like phone numbers, work experiences, or family members. Let's learn how to handle these dynamic field arrays effectively.</p>

                <h3>The Challenge of Dynamic Fields</h3>
                <p>Consider a job application where users can add multiple work experiences. Each experience has several fields (company, position, dates, description), and users should be able to add or remove experiences as needed.</p>

                <div class="mermaid">
                graph TB
                    A[Dynamic Form] --> B[Add Item]
                    A --> C[Remove Item]
                    A --> D[Edit Item]
                    A --> E[Reorder Items]
                    
                    B --> B1[Push to array]
                    B --> B2[Generate unique ID]
                    
                    C --> C1[Filter array]
                    C --> C2[Update indices]
                    
                    D --> D1[Update at index]
                    D --> D2[Validate item]
                    
                    E --> E1[Drag and drop]
                    E --> E2[Move up/down buttons]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#48bb78,color:#fff
                    style C fill:#f56565,color:#fff
                    style D fill:#ed8936,color:#fff
                </graph>
                </div>

                <h3>Basic Field Array Implementation</h3>
                <p>Let's start with a simple example‚Äîmanaging multiple phone numbers:</p>

                <pre><code class="language-typescript">interface PhoneNumber {
  id: string;
  type: 'mobile' | 'home' | 'work';
  number: string;
}

function PhoneNumbersForm() {
  const [phones, setPhones] = useState&lt;PhoneNumber[]&gt;([
    { id: crypto.randomUUID(), type: 'mobile', number: '' }
  ]);

  // Add a new phone number
  const addPhone = () => {
    setPhones(prev => [
      ...prev,
      { id: crypto.randomUUID(), type: 'mobile', number: '' }
    ]);
  };

  // Remove a phone number by ID
  const removePhone = (id: string) => {
    setPhones(prev => prev.filter(phone => phone.id !== id));
  };

  // Update a specific phone number
  const updatePhone = (id: string, field: keyof PhoneNumber, value: string) => {
    setPhones(prev => prev.map(phone =>
      phone.id === id
        ? { ...phone, [field]: value }
        : phone
    ));
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('Phones:', phones);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h3&gt;Phone Numbers&lt;/h3&gt;
      
      {phones.map((phone, index) => (
        &lt;div 
          key={phone.id}
          style={{
            border: '1px solid #ddd',
            padding: '1rem',
            marginBottom: '1rem',
            borderRadius: '4px'
          }}
        &gt;
          &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}&gt;
            &lt;strong&gt;Phone {index + 1}&lt;/strong&gt;
            {phones.length > 1 && (
              &lt;button
                type="button"
                onClick={() => removePhone(phone.id)}
                style={{
                  background: '#f56565',
                  color: 'white',
                  border: 'none',
                  padding: '0.25rem 0.5rem',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              &gt;
                Remove
              &lt;/button&gt;
            )}
          &lt;/div&gt;

          &lt;div style={{ display: 'grid', gap: '0.5rem' }}&gt;
            &lt;select
              value={phone.type}
              onChange={(e) => updatePhone(phone.id, 'type', e.target.value)}
              style={{ padding: '0.5rem' }}
            &gt;
              &lt;option value="mobile"&gt;Mobile&lt;/option&gt;
              &lt;option value="home"&gt;Home&lt;/option&gt;
              &lt;option value="work"&gt;Work&lt;/option&gt;
            &lt;/select&gt;

            &lt;input
              type="tel"
              value={phone.number}
              onChange={(e) => updatePhone(phone.id, 'number', e.target.value)}
              placeholder="(555) 123-4567"
              style={{ padding: '0.5rem' }}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ))}

      &lt;button
        type="button"
        onClick={addPhone}
        style={{
          background: '#48bb78',
          color: 'white',
          border: 'none',
          padding: '0.5rem 1rem',
          borderRadius: '4px',
          cursor: 'pointer',
          marginBottom: '1rem'
        }}
      &gt;
        + Add Phone Number
      &lt;/button&gt;

      &lt;button type="submit" style={{ marginLeft: '1rem' }}&gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Concepts in Field Arrays</h4>
                    <ul>
                        <li><strong>Unique IDs</strong> - Use crypto.randomUUID() or nanoid, never array index</li>
                        <li><strong>Immutable updates</strong> - Always create new arrays with map/filter/concat</li>
                        <li><strong>Map over arrays</strong> - Render each item with its data</li>
                        <li><strong>Partial updates</strong> - Update only the changed item, not the entire array</li>
                        <li><strong>Key prop</strong> - Use stable ID, not index, for React reconciliation</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistakes with Field Arrays</h4>
                    <ul>
                        <li><strong>Using array index as key</strong> - Causes bugs when items are reordered or removed</li>
                        <li><strong>Mutating arrays directly</strong> - push(), splice() etc. won't trigger re-renders</li>
                        <li><strong>Not preventing minimum items</strong> - Allow users to remove all items accidentally</li>
                        <li><strong>Poor UX for empty state</strong> - Show helpful message when array is empty</li>
                    </ul>
                </div>

                <h3>Complex Field Array: Work Experience</h3>
                <p>Let's build a more complex example with nested data and validation:</p>

                <pre><code class="language-typescript">interface WorkExperience {
  id: string;
  company: string;
  position: string;
  startDate: string;
  endDate: string;
  current: boolean;
  description: string;
}

interface WorkExperienceErrors {
  company?: string;
  position?: string;
  startDate?: string;
  endDate?: string;
}

function WorkExperienceForm() {
  const [experiences, setExperiences] = useState&lt;WorkExperience[]&gt;([
    {
      id: crypto.randomUUID(),
      company: '',
      position: '',
      startDate: '',
      endDate: '',
      current: false,
      description: ''
    }
  ]);

  const [errors, setErrors] = useState&lt;Record&lt;string, WorkExperienceErrors&gt;&gt;({});

  // Add new experience
  const addExperience = () => {
    const newExp: WorkExperience = {
      id: crypto.randomUUID(),
      company: '',
      position: '',
      startDate: '',
      endDate: '',
      current: false,
      description: ''
    };
    setExperiences(prev => [...prev, newExp]);
  };

  // Remove experience
  const removeExperience = (id: string) => {
    setExperiences(prev => prev.filter(exp => exp.id !== id));
    // Also remove errors for this experience
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[id];
      return newErrors;
    });
  };

  // Update experience field
  const updateExperience = (
    id: string, 
    field: keyof WorkExperience, 
    value: string | boolean
  ) => {
    setExperiences(prev => prev.map(exp =>
      exp.id === id ? { ...exp, [field]: value } : exp
    ));

    // Clear error when user starts typing
    if (errors[id]?.[field as keyof WorkExperienceErrors]) {
      setErrors(prev => ({
        ...prev,
        [id]: {
          ...prev[id],
          [field]: undefined
        }
      }));
    }
  };

  // Validate a single experience
  const validateExperience = (exp: WorkExperience): WorkExperienceErrors => {
    const expErrors: WorkExperienceErrors = {};

    if (!exp.company.trim()) {
      expErrors.company = 'Company name is required';
    }

    if (!exp.position.trim()) {
      expErrors.position = 'Position is required';
    }

    if (!exp.startDate) {
      expErrors.startDate = 'Start date is required';
    }

    if (!exp.current && !exp.endDate) {
      expErrors.endDate = 'End date is required (or mark as current position)';
    }

    if (exp.startDate && exp.endDate && exp.startDate > exp.endDate) {
      expErrors.endDate = 'End date must be after start date';
    }

    return expErrors;
  };

  // Validate all experiences
  const validateAll = (): boolean => {
    const allErrors: Record&lt;string, WorkExperienceErrors&gt; = {};
    let hasErrors = false;

    experiences.forEach(exp => {
      const expErrors = validateExperience(exp);
      if (Object.keys(expErrors).length > 0) {
        allErrors[exp.id] = expErrors;
        hasErrors = true;
      }
    });

    setErrors(allErrors);
    return !hasErrors;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (validateAll()) {
      console.log('Valid experiences:', experiences);
      alert('Form submitted successfully!');
    } else {
      alert('Please fix the errors before submitting');
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h2&gt;Work Experience&lt;/h2&gt;
      
      {experiences.map((exp, index) => (
        &lt;div
          key={exp.id}
          style={{
            border: '2px solid #ddd',
            padding: '1.5rem',
            marginBottom: '1.5rem',
            borderRadius: '8px',
            backgroundColor: '#f9f9f9'
          }}
        &gt;
          &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem' }}&gt;
            &lt;h3 style={{ margin: 0 }}&gt;Experience {index + 1}&lt;/h3&gt;
            {experiences.length > 1 && (
              &lt;button
                type="button"
                onClick={() => removeExperience(exp.id)}
                style={{
                  background: '#f56565',
                  color: 'white',
                  border: 'none',
                  padding: '0.5rem 1rem',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              &gt;
                Remove
              &lt;/button&gt;
            )}
          &lt;/div&gt;

          &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
            {/* Company */}
            &lt;div&gt;
              &lt;label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500' }}&gt;
                Company *
              &lt;/label&gt;
              &lt;input
                type="text"
                value={exp.company}
                onChange={(e) => updateExperience(exp.id, 'company', e.target.value)}
                placeholder="Acme Corp"
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: `1px solid ${errors[exp.id]?.company ? '#f56565' : '#ddd'}`,
                  borderRadius: '4px'
                }}
              /&gt;
              {errors[exp.id]?.company && (
                &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                  {errors[exp.id].company}
                &lt;/span&gt;
              )}
            &lt;/div&gt;

            {/* Position */}
            &lt;div&gt;
              &lt;label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500' }}&gt;
                Position *
              &lt;/label&gt;
              &lt;input
                type="text"
                value={exp.position}
                onChange={(e) => updateExperience(exp.id, 'position', e.target.value)}
                placeholder="Software Engineer"
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: `1px solid ${errors[exp.id]?.position ? '#f56565' : '#ddd'}`,
                  borderRadius: '4px'
                }}
              /&gt;
              {errors[exp.id]?.position && (
                &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                  {errors[exp.id].position}
                &lt;/span&gt;
              )}
            &lt;/div&gt;

            {/* Date range */}
            &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}&gt;
              &lt;div&gt;
                &lt;label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500' }}&gt;
                  Start Date *
                &lt;/label&gt;
                &lt;input
                  type="month"
                  value={exp.startDate}
                  onChange={(e) => updateExperience(exp.id, 'startDate', e.target.value)}
                  style={{
                    width: '100%',
                    padding: '0.5rem',
                    border: `1px solid ${errors[exp.id]?.startDate ? '#f56565' : '#ddd'}`,
                    borderRadius: '4px'
                  }}
                /&gt;
                {errors[exp.id]?.startDate && (
                  &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                    {errors[exp.id].startDate}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;

              &lt;div&gt;
                &lt;label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500' }}&gt;
                  End Date {!exp.current && '*'}
                &lt;/label&gt;
                &lt;input
                  type="month"
                  value={exp.endDate}
                  onChange={(e) => updateExperience(exp.id, 'endDate', e.target.value)}
                  disabled={exp.current}
                  style={{
                    width: '100%',
                    padding: '0.5rem',
                    border: `1px solid ${errors[exp.id]?.endDate ? '#f56565' : '#ddd'}`,
                    borderRadius: '4px',
                    opacity: exp.current ? 0.5 : 1
                  }}
                /&gt;
                {errors[exp.id]?.endDate && (
                  &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                    {errors[exp.id].endDate}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;

            {/* Current position checkbox */}
            &lt;div&gt;
              &lt;label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}&gt;
                &lt;input
                  type="checkbox"
                  checked={exp.current}
                  onChange={(e) => {
                    updateExperience(exp.id, 'current', e.target.checked);
                    if (e.target.checked) {
                      updateExperience(exp.id, 'endDate', '');
                    }
                  }}
                /&gt;
                &lt;span&gt;I currently work here&lt;/span&gt;
              &lt;/label&gt;
            &lt;/div&gt;

            {/* Description */}
            &lt;div&gt;
              &lt;label style={{ display: 'block', marginBottom: '0.25rem', fontWeight: '500' }}&gt;
                Description (Optional)
              &lt;/label&gt;
              &lt;textarea
                value={exp.description}
                onChange={(e) => updateExperience(exp.id, 'description', e.target.value)}
                placeholder="Describe your responsibilities and achievements..."
                rows={3}
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: '1px solid #ddd',
                  borderRadius: '4px',
                  fontFamily: 'inherit',
                  resize: 'vertical'
                }}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ))}

      &lt;button
        type="button"
        onClick={addExperience}
        style={{
          background: '#48bb78',
          color: 'white',
          border: 'none',
          padding: '0.75rem 1.5rem',
          borderRadius: '4px',
          cursor: 'pointer',
          fontSize: '1rem',
          fontWeight: '500',
          marginRight: '1rem'
        }}
      &gt;
        + Add Work Experience
      &lt;/button&gt;

      &lt;button
        type="submit"
        style={{
          background: '#667eea',
          color: 'white',
          border: 'none',
          padding: '0.75rem 1.5rem',
          borderRadius: '4px',
          cursor: 'pointer',
          fontSize: '1rem',
          fontWeight: '500'
        }}
      &gt;
        Submit Application
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Advanced Field Array Techniques</h4>
                    <ul>
                        <li><strong>Per-item validation</strong> - Track errors for each item separately</li>
                        <li><strong>Conditional fields</strong> - End date disabled when "current" is checked</li>
                        <li><strong>Cross-field validation</strong> - Start date must be before end date</li>
                        <li><strong>Minimum items</strong> - Always keep at least one experience</li>
                        <li><strong>Clear feedback</strong> - Show which experience has errors</li>
                        <li><strong>Good UX</strong> - Clear add/remove buttons, numbered items</li>
                    </ul>
                </div>

                <h3>Field Array with Drag and Drop Reordering</h3>
                <p>For even better UX, allow users to reorder items:</p>

                <pre><code class="language-typescript">function ReorderableList() {
  const [items, setItems] = useState([
    { id: '1', text: 'First item' },
    { id: '2', text: 'Second item' },
    { id: '3', text: 'Third item' }
  ]);

  // Move item up
  const moveUp = (index: number) => {
    if (index === 0) return; // Already at top
    
    setItems(prev => {
      const newItems = [...prev];
      [newItems[index - 1], newItems[index]] = [newItems[index], newItems[index - 1]];
      return newItems;
    });
  };

  // Move item down
  const moveDown = (index: number) => {
    if (index === items.length - 1) return; // Already at bottom
    
    setItems(prev => {
      const newItems = [...prev];
      [newItems[index], newItems[index + 1]] = [newItems[index + 1], newItems[index]];
      return newItems;
    });
  };

  return (
    &lt;div&gt;
      {items.map((item, index) => (
        &lt;div
          key={item.id}
          style={{
            display: 'flex',
            alignItems: 'center',
            gap: '1rem',
            padding: '0.5rem',
            border: '1px solid #ddd',
            marginBottom: '0.5rem',
            borderRadius: '4px'
          }}
        &gt;
          &lt;div style={{ display: 'flex', flexDirection: 'column', gap: '0.25rem' }}&gt;
            &lt;button
              onClick={() => moveUp(index)}
              disabled={index === 0}
              style={{
                padding: '0.25rem 0.5rem',
                fontSize: '0.75rem',
                cursor: index === 0 ? 'not-allowed' : 'pointer',
                opacity: index === 0 ? 0.5 : 1
              }}
            &gt;
              ‚ñ≤
            &lt;/button&gt;
            &lt;button
              onClick={() => moveDown(index)}
              disabled={index === items.length - 1}
              style={{
                padding: '0.25rem 0.5rem',
                fontSize: '0.75rem',
                cursor: index === items.length - 1 ? 'not-allowed' : 'pointer',
                opacity: index === items.length - 1 ? 0.5 : 1
              }}
            &gt;
              ‚ñº
            &lt;/button&gt;
          &lt;/div&gt;
          
          &lt;span&gt;{item.text}&lt;/span&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 4: Build an Education Field Array</strong></summary>
                    <p><strong>Task:</strong> Create a dynamic field array for education history with these requirements:</p>
                    <ul>
                        <li>Fields: School, Degree, Field of Study, Graduation Year</li>
                        <li>Allow adding/removing education entries (minimum 1)</li>
                        <li>Validate that all required fields are filled</li>
                        <li>Graduation year must be between 1950 and current year + 10</li>
                        <li>Show clear error messages for each field</li>
                    </ul>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Start with the work experience example above. Create an Education interface with id, school, degree, field, and year. Create validation functions for each field. Map over the array to render each entry with its own set of inputs and error messages.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">interface Education {
  id: string;
  school: string;
  degree: string;
  field: string;
  year: string;
}

interface EducationErrors {
  school?: string;
  degree?: string;
  field?: string;
  year?: string;
}

function EducationForm() {
  const [education, setEducation] = useState&lt;Education[]&gt;([
    {
      id: crypto.randomUUID(),
      school: '',
      degree: '',
      field: '',
      year: ''
    }
  ]);

  const [errors, setErrors] = useState&lt;Record&lt;string, EducationErrors&gt;&gt;({});

  const addEducation = () => {
    setEducation(prev => [
      ...prev,
      {
        id: crypto.randomUUID(),
        school: '',
        degree: '',
        field: '',
        year: ''
      }
    ]);
  };

  const removeEducation = (id: string) => {
    setEducation(prev => prev.filter(edu => edu.id !== id));
    setErrors(prev => {
      const newErrors = { ...prev };
      delete newErrors[id];
      return newErrors;
    });
  };

  const updateEducation = (id: string, field: keyof Education, value: string) => {
    setEducation(prev => prev.map(edu =>
      edu.id === id ? { ...edu, [field]: value } : edu
    ));

    // Clear error when user types
    if (errors[id]?.[field as keyof EducationErrors]) {
      setErrors(prev => ({
        ...prev,
        [id]: {
          ...prev[id],
          [field]: undefined
        }
      }));
    }
  };

  const validateEducation = (edu: Education): EducationErrors => {
    const eduErrors: EducationErrors = {};
    const currentYear = new Date().getFullYear();

    if (!edu.school.trim()) {
      eduErrors.school = 'School name is required';
    }

    if (!edu.degree.trim()) {
      eduErrors.degree = 'Degree is required';
    }

    if (!edu.field.trim()) {
      eduErrors.field = 'Field of study is required';
    }

    if (!edu.year) {
      eduErrors.year = 'Graduation year is required';
    } else {
      const year = parseInt(edu.year);
      if (isNaN(year)) {
        eduErrors.year = 'Year must be a number';
      } else if (year < 1950) {
        eduErrors.year = 'Year must be 1950 or later';
      } else if (year > currentYear + 10) {
        eduErrors.year = `Year cannot be more than ${currentYear + 10}`;
      }
    }

    return eduErrors;
  };

  const validateAll = (): boolean => {
    const allErrors: Record&lt;string, EducationErrors&gt; = {};
    let hasErrors = false;

    education.forEach(edu => {
      const eduErrors = validateEducation(edu);
      if (Object.keys(eduErrors).length > 0) {
        allErrors[edu.id] = eduErrors;
        hasErrors = true;
      }
    });

    setErrors(allErrors);
    return !hasErrors;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    if (validateAll()) {
      console.log('Valid education:', education);
      alert('Form submitted successfully!');
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;h2&gt;Education History&lt;/h2&gt;

      {education.map((edu, index) => (
        &lt;div
          key={edu.id}
          style={{
            border: '2px solid #ddd',
            padding: '1.5rem',
            marginBottom: '1.5rem',
            borderRadius: '8px'
          }}
        &gt;
          &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem' }}&gt;
            &lt;h3&gt;Education {index + 1}&lt;/h3&gt;
            {education.length > 1 && (
              &lt;button
                type="button"
                onClick={() => removeEducation(edu.id)}
                style={{
                  background: '#f56565',
                  color: 'white',
                  border: 'none',
                  padding: '0.5rem 1rem',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              &gt;
                Remove
              &lt;/button&gt;
            )}
          &lt;/div&gt;

          &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
            &lt;div&gt;
              &lt;label&gt;School *&lt;/label&gt;
              &lt;input
                type="text"
                value={edu.school}
                onChange={(e) => updateEducation(edu.id, 'school', e.target.value)}
                placeholder="University of Example"
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: `1px solid ${errors[edu.id]?.school ? '#f56565' : '#ddd'}`
                }}
              /&gt;
              {errors[edu.id]?.school && (
                &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                  {errors[edu.id].school}
                &lt;/span&gt;
              )}
            &lt;/div&gt;

            &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}&gt;
              &lt;div&gt;
                &lt;label&gt;Degree *&lt;/label&gt;
                &lt;input
                  type="text"
                  value={edu.degree}
                  onChange={(e) => updateEducation(edu.id, 'degree', e.target.value)}
                  placeholder="Bachelor of Science"
                  style={{
                    width: '100%',
                    padding: '0.5rem',
                    border: `1px solid ${errors[edu.id]?.degree ? '#f56565' : '#ddd'}`
                  }}
                /&gt;
                {errors[edu.id]?.degree && (
                  &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                    {errors[edu.id].degree}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;

              &lt;div&gt;
                &lt;label&gt;Field of Study *&lt;/label&gt;
                &lt;input
                  type="text"
                  value={edu.field}
                  onChange={(e) => updateEducation(edu.id, 'field', e.target.value)}
                  placeholder="Computer Science"
                  style={{
                    width: '100%',
                    padding: '0.5rem',
                    border: `1px solid ${errors[edu.id]?.field ? '#f56565' : '#ddd'}`
                  }}
                /&gt;
                {errors[edu.id]?.field && (
                  &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                    {errors[edu.id].field}
                  &lt;/span&gt;
                )}
              &lt;/div&gt;
            &lt;/div&gt;

            &lt;div&gt;
              &lt;label&gt;Graduation Year *&lt;/label&gt;
              &lt;input
                type="number"
                value={edu.year}
                onChange={(e) => updateEducation(edu.id, 'year', e.target.value)}
                placeholder="2020"
                min="1950"
                max={new Date().getFullYear() + 10}
                style={{
                  width: '100%',
                  padding: '0.5rem',
                  border: `1px solid ${errors[edu.id]?.year ? '#f56565' : '#ddd'}`
                }}
              /&gt;
              {errors[edu.id]?.year && (
                &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                  {errors[edu.id].year}
                &lt;/span&gt;
              )}
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      ))}

      &lt;button
        type="button"
        onClick={addEducation}
        style={{
          background: '#48bb78',
          color: 'white',
          padding: '0.75rem 1.5rem',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
          marginRight: '1rem'
        }}
      &gt;
        + Add Education
      &lt;/button&gt;

      &lt;button
        type="submit"
        style={{
          background: '#667eea',
          color: 'white',
          padding: '0.75rem 1.5rem',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      &gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </details>
                </details>
            </section>

            <!-- Section 6: Form Performance Optimization -->
            <section id="section6" aria-labelledby="section6-title">
                <h2 id="section6-title">‚ö° Form Performance Optimization</h2>
                <p>Large forms can become slow if every keystroke causes the entire form to re-render. Let's explore techniques to keep forms fast and responsive.</p>

                <h3>The Performance Problem</h3>
                <p>In a typical form, every input change triggers a state update, which causes the entire form component to re-render. With many fields, this can feel sluggish:</p>

                <pre><code class="language-typescript">// Every keystroke in ANY field re-renders ENTIRE form
function SlowForm() {
  const [formData, setFormData] = useState({ 
    field1: '', 
    field2: '', 
    /* ... 20 more fields */ 
  });

  return (
    &lt;form&gt;
      &lt;input value={formData.field1} onChange={...} /&gt;
      &lt;input value={formData.field2} onChange={...} /&gt;
      {/* ... 20 more inputs all re-render on every change */}
    &lt;/form&gt;
  );
}</code></pre>

                <div class="mermaid">
                graph LR
                    A[User types in field 1] --> B[State updates]
                    B --> C[Entire form re-renders]
                    C --> D[All 20+ inputs re-render]
                    D --> E[React reconciles DOM]
                    E --> F[Browser repaints]
                    
                    style A fill:#667eea,color:#fff
                    style D fill:#f56565,color:#fff
                    style F fill:#48bb78,color:#fff
                </graph>
                </div>

                <h3>Solution 1: Split into Smaller Components</h3>
                <p>Break the form into smaller components so only the changed field re-renders:</p>

                <pre><code class="language-typescript">// Each field is isolated in its own component
interface FieldProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
  error?: string;
}

// This component only re-renders when ITS value changes
const FormField = React.memo(({ label, value, onChange, error }: FieldProps) => {
  console.log(`Rendering ${label}`);
  
  return (
    &lt;div&gt;
      &lt;label&gt;{label}&lt;/label&gt;
      &lt;input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        style={{ border: error ? '1px solid red' : '1px solid #ddd' }}
      /&gt;
      {error && &lt;span style={{ color: 'red' }}&gt;{error}&lt;/span&gt;}
    &lt;/div&gt;
  );
});

function OptimizedForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: ''
  });

  const handleChange = (field: keyof typeof formData) => (value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    &lt;form&gt;
      &lt;FormField
        label="First Name"
        value={formData.firstName}
        onChange={handleChange('firstName')}
      /&gt;
      &lt;FormField
        label="Last Name"
        value={formData.lastName}
        onChange={handleChange('lastName')}
      /&gt;
      &lt;FormField
        label="Email"
        value={formData.email}
        onChange={handleChange('email')}
      /&gt;
      &lt;FormField
        label="Phone"
        value={formData.phone}
        onChange={handleChange('phone')}
      /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° How React.memo Helps</h4>
                    <p><code>React.memo</code> prevents re-renders if props haven't changed. When you type in "First Name":</p>
                    <ul>
                        <li>‚úÖ Only FirstName's FormField re-renders</li>
                        <li>‚ùå LastName, Email, Phone FormFields do NOT re-render</li>
                        <li>Result: 75% fewer component renders!</li>
                    </ul>
                </div>

                <h3>Solution 2: Uncontrolled Inputs with useRef</h3>
                <p>For some forms, you don't need the value in state until submission. Use refs instead:</p>

                <pre><code class="language-typescript">function UncontrolledForm() {
  const nameRef = useRef&lt;HTMLInputElement&gt;(null);
  const emailRef = useRef&lt;HTMLInputElement&gt;(null);
  const phoneRef = useRef&lt;HTMLInputElement&gt;(null);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();

    const formData = {
      name: nameRef.current?.value || '',
      email: emailRef.current?.value || '',
      phone: phoneRef.current?.value || ''
    };

    console.log('Form data:', formData);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input 
        ref={nameRef} 
        defaultValue="" 
        placeholder="Name"
      /&gt;
      &lt;input 
        ref={emailRef} 
        defaultValue="" 
        placeholder="Email"
      /&gt;
      &lt;input 
        ref={phoneRef} 
        defaultValue="" 
        placeholder="Phone"
      /&gt;
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Uncontrolled Inputs</h4>
                    <ul>
                        <li>Simple forms where you only need data on submit</li>
                        <li>Forms with many fields where real-time validation isn't needed</li>
                        <li>Integration with non-React libraries</li>
                        <li>File inputs (which must be uncontrolled)</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Limitations of Uncontrolled Inputs</h4>
                    <ul>
                        <li>Cannot show real-time validation</li>
                        <li>Cannot conditionally enable/disable submit based on values</li>
                        <li>Cannot show character counts or format as user types</li>
                        <li>Cannot implement field dependencies easily</li>
                    </ul>
                </div>

                <h3>Solution 3: Debounced State Updates</h3>
                <p>Update state only after the user stops typing, not on every keystroke:</p>

                <pre><code class="language-typescript">import { useState, useEffect } from 'react';

function useDebouncedValue&lt;T&gt;(value: T, delay: number = 500): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

function DebouncedSearchForm() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearch = useDebouncedValue(searchTerm, 300);

  // This only runs when user stops typing for 300ms
  useEffect(() => {
    if (debouncedSearch) {
      console.log('Searching for:', debouncedSearch);
      // Perform expensive search/validation here
    }
  }, [debouncedSearch]);

  return (
    &lt;div&gt;
      &lt;input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="Search..."
      /&gt;
      &lt;p&gt;Searching for: {debouncedSearch}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use Debouncing</h4>
                    <ul>
                        <li>Search inputs that trigger API calls</li>
                        <li>Username availability checks</li>
                        <li>Address autocomplete</li>
                        <li>Expensive validation (e.g., checking against large lists)</li>
                        <li>Any operation where real-time is nice but not critical</li>
                    </ul>
                </div>

                <h3>Solution 4: useCallback for Stable Function References</h3>
                <p>Prevent child components from re-rendering by memoizing callback functions:</p>

                <pre><code class="language-typescript">import { useCallback, memo } from 'react';

interface FieldProps {
  value: string;
  onChange: (value: string) => void;
}

const ExpensiveField = memo(({ value, onChange }: FieldProps) => {
  console.log('ExpensiveField render');
  // Imagine this has expensive rendering logic
  return &lt;input value={value} onChange={(e) => onChange(e.target.value)} /&gt;;
});

function FormWithCallback() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  // Without useCallback, this creates a NEW function on every render
  // causing ExpensiveField to re-render even with memo
  const handleNameChange = useCallback((value: string) => {
    setName(value);
  }, []); // Empty deps = function never changes

  // This one DOES change when email changes (if needed for validation)
  const handleEmailChange = useCallback((value: string) => {
    setEmail(value);
  }, [email]);

  return (
    &lt;form&gt;
      &lt;ExpensiveField value={name} onChange={handleNameChange} /&gt;
      &lt;ExpensiveField value={email} onChange={handleEmailChange} /&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Performance Optimization Checklist</h4>
                    <ul>
                        <li>‚úÖ Split large forms into smaller components</li>
                        <li>‚úÖ Use React.memo on field components</li>
                        <li>‚úÖ Use useCallback for event handlers passed to memoized components</li>
                        <li>‚úÖ Consider uncontrolled inputs for simple forms</li>
                        <li>‚úÖ Debounce expensive operations (API calls, validation)</li>
                        <li>‚úÖ Avoid inline object/function creation in render</li>
                        <li>‚úÖ Use keys properly in field arrays (ID, not index)</li>
                        <li>‚úÖ Profile with React DevTools to find actual bottlenecks</li>
                    </ul>
                </div>

                <details class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <summary><strong>üèãÔ∏è Exercise 5: Optimize a Slow Form</strong></summary>
                    <p><strong>Task:</strong> This form re-renders all fields on every keystroke. Optimize it using React.memo and useCallback.</p>
                    
                    <pre><code class="language-typescript">// This form is slow! Optimize it.
function SlowRegistrationForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    address: '',
    city: '',
    state: '',
    zip: ''
  });

  const handleChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    &lt;form&gt;
      {Object.keys(formData).map(field => (
        &lt;div key={field}&gt;
          &lt;label&gt;{field}&lt;/label&gt;
          &lt;input
            value={formData[field as keyof typeof formData]}
            onChange={(e) => handleChange(field, e.target.value)}
          /&gt;
        &lt;/div&gt;
      ))}
      &lt;button type="submit"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Create a memoized FormField component. Use useCallback for the handleChange function to ensure it doesn't create a new function on every render.</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">import { useState, useCallback, memo } from 'react';

interface FormFieldProps {
  label: string;
  value: string;
  onChange: (value: string) => void;
}

// Memoized field component
const FormField = memo(({ label, value, onChange }: FormFieldProps) => {
  console.log(`Rendering ${label}`);
  
  return (
    &lt;div style={{ marginBottom: '1rem' }}&gt;
      &lt;label style={{ display: 'block', marginBottom: '0.25rem' }}&gt;
        {label}
      &lt;/label&gt;
      &lt;input
        value={value}
        onChange={(e) => onChange(e.target.value)}
        style={{ width: '100%', padding: '0.5rem' }}
      /&gt;
    &lt;/div&gt;
  );
});

function OptimizedRegistrationForm() {
  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    address: '',
    city: '',
    state: '',
    zip: ''
  });

  // Create stable change handler for each field
  const createChangeHandler = useCallback((field: keyof typeof formData) => {
    return (value: string) => {
      setFormData(prev => ({ ...prev, [field]: value }));
    };
  }, []); // Empty deps - this function never changes

  // Create all handlers once
  const handlers = {
    firstName: createChangeHandler('firstName'),
    lastName: createChangeHandler('lastName'),
    email: createChangeHandler('email'),
    phone: createChangeHandler('phone'),
    address: createChangeHandler('address'),
    city: createChangeHandler('city'),
    state: createChangeHandler('state'),
    zip: createChangeHandler('zip')
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('Form data:', formData);
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;FormField
        label="First Name"
        value={formData.firstName}
        onChange={handlers.firstName}
      /&gt;
      &lt;FormField
        label="Last Name"
        value={formData.lastName}
        onChange={handlers.lastName}
      /&gt;
      &lt;FormField
        label="Email"
        value={formData.email}
        onChange={handlers.email}
      /&gt;
      &lt;FormField
        label="Phone"
        value={formData.phone}
        onChange={handlers.phone}
      /&gt;
      &lt;FormField
        label="Address"
        value={formData.address}
        onChange={handlers.address}
      /&gt;
      &lt;FormField
        label="City"
        value={formData.city}
        onChange={handlers.city}
      /&gt;
      &lt;FormField
        label="State"
        value={formData.state}
        onChange={handlers.state}
      /&gt;
      &lt;FormField
        label="Zip"
        value={formData.zip}
        onChange={handlers.zip}
      /&gt;

      &lt;button 
        type="submit"
        style={{
          padding: '0.75rem 1.5rem',
          background: '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      &gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>
                    </details>
                </details>
            </section>


            <!-- Section 7: Advanced Patterns -->
            <section id="section7" aria-labelledby="section7-title">
                <h2 id="section7-title">üöÄ Advanced Patterns</h2>
                <p>Now that we've covered the fundamentals, let's explore some advanced patterns that solve specific complex form scenarios.</p>

                <h3>Multi-Step Forms (Wizards)</h3>
                <p>Multi-step forms break complex forms into manageable chunks. Users complete one step at a time, with the ability to go back and forth:</p>

                <pre><code class="language-typescript">type Step = 'personal' | 'contact' | 'preferences' | 'review';

interface FormData {
  // Personal
  firstName: string;
  lastName: string;
  birthDate: string;
  
  // Contact
  email: string;
  phone: string;
  address: string;
  
  // Preferences
  newsletter: boolean;
  notifications: boolean;
  theme: 'light' | 'dark';
}

function MultiStepForm() {
  const [currentStep, setCurrentStep] = useState&lt;Step&gt;('personal');
  const [formData, setFormData] = useState&lt;FormData&gt;({
    firstName: '',
    lastName: '',
    birthDate: '',
    email: '',
    phone: '',
    address: '',
    newsletter: false,
    notifications: true,
    theme: 'light'
  });

  const [errors, setErrors] = useState&lt;Partial&lt;Record&lt;keyof FormData, string&gt;&gt;&gt;({});

  const steps: Step[] = ['personal', 'contact', 'preferences', 'review'];
  const currentStepIndex = steps.indexOf(currentStep);

  // Validation for each step
  const validateStep = (step: Step): boolean => {
    const newErrors: Partial&lt;Record&lt;keyof FormData, string&gt;&gt; = {};

    switch (step) {
      case 'personal':
        if (!formData.firstName) newErrors.firstName = 'First name is required';
        if (!formData.lastName) newErrors.lastName = 'Last name is required';
        if (!formData.birthDate) newErrors.birthDate = 'Birth date is required';
        break;
      
      case 'contact':
        if (!formData.email) newErrors.email = 'Email is required';
        if (!formData.phone) newErrors.phone = 'Phone is required';
        if (!formData.address) newErrors.address = 'Address is required';
        break;
      
      // Preferences step has no required fields
      case 'preferences':
        break;
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleNext = () => {
    if (validateStep(currentStep)) {
      const nextIndex = currentStepIndex + 1;
      if (nextIndex < steps.length) {
        setCurrentStep(steps[nextIndex]);
      }
    }
  };

  const handleBack = () => {
    const prevIndex = currentStepIndex - 1;
    if (prevIndex >= 0) {
      setCurrentStep(steps[prevIndex]);
    }
  };

  const handleSubmit = () => {
    console.log('Final form data:', formData);
    alert('Form submitted successfully!');
  };

  const updateField = (field: keyof FormData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    // Clear error when user types
    if (errors[field]) {
      setErrors(prev => ({ ...prev, [field]: undefined }));
    }
  };

  return (
    &lt;div style={{ maxWidth: '600px', margin: '0 auto' }}&gt;
      {/* Progress indicator */}
      &lt;div style={{ marginBottom: '2rem' }}&gt;
        &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}&gt;
          {steps.map((step, index) => (
            &lt;div
              key={step}
              style={{
                flex: 1,
                height: '4px',
                backgroundColor: index <= currentStepIndex ? '#667eea' : '#ddd',
                marginRight: index < steps.length - 1 ? '0.5rem' : 0
              }}
            /&gt;
          ))}
        &lt;/div&gt;
        &lt;div style={{ display: 'flex', justifyContent: 'space-between' }}&gt;
          {steps.map((step, index) => (
            &lt;span
              key={step}
              style={{
                fontSize: '0.875rem',
                color: index <= currentStepIndex ? '#667eea' : '#999',
                fontWeight: index === currentStepIndex ? 'bold' : 'normal'
              }}
            &gt;
              {step.charAt(0).toUpperCase() + step.slice(1)}
            &lt;/span&gt;
          ))}
        &lt;/div&gt;
      &lt;/div&gt;

      {/* Step content */}
      &lt;div style={{ minHeight: '300px', marginBottom: '2rem' }}&gt;
        {currentStep === 'personal' && (
          &lt;div&gt;
            &lt;h2&gt;Personal Information&lt;/h2&gt;
            &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
              &lt;div&gt;
                &lt;label&gt;First Name *&lt;/label&gt;
                &lt;input
                  type="text"
                  value={formData.firstName}
                  onChange={(e) => updateField('firstName', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.firstName && &lt;span style={{ color: 'red' }}&gt;{errors.firstName}&lt;/span&gt;}
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label&gt;Last Name *&lt;/label&gt;
                &lt;input
                  type="text"
                  value={formData.lastName}
                  onChange={(e) => updateField('lastName', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.lastName && &lt;span style={{ color: 'red' }}&gt;{errors.lastName}&lt;/span&gt;}
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label&gt;Birth Date *&lt;/label&gt;
                &lt;input
                  type="date"
                  value={formData.birthDate}
                  onChange={(e) => updateField('birthDate', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.birthDate && &lt;span style={{ color: 'red' }}&gt;{errors.birthDate}&lt;/span&gt;}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        {currentStep === 'contact' && (
          &lt;div&gt;
            &lt;h2&gt;Contact Information&lt;/h2&gt;
            &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
              &lt;div&gt;
                &lt;label&gt;Email *&lt;/label&gt;
                &lt;input
                  type="email"
                  value={formData.email}
                  onChange={(e) => updateField('email', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.email && &lt;span style={{ color: 'red' }}&gt;{errors.email}&lt;/span&gt;}
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label&gt;Phone *&lt;/label&gt;
                &lt;input
                  type="tel"
                  value={formData.phone}
                  onChange={(e) => updateField('phone', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.phone && &lt;span style={{ color: 'red' }}&gt;{errors.phone}&lt;/span&gt;}
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;label&gt;Address *&lt;/label&gt;
                &lt;input
                  type="text"
                  value={formData.address}
                  onChange={(e) => updateField('address', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                /&gt;
                {errors.address && &lt;span style={{ color: 'red' }}&gt;{errors.address}&lt;/span&gt;}
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        {currentStep === 'preferences' && (
          &lt;div&gt;
            &lt;h2&gt;Your Preferences&lt;/h2&gt;
            &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
              &lt;label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}&gt;
                &lt;input
                  type="checkbox"
                  checked={formData.newsletter}
                  onChange={(e) => updateField('newsletter', e.target.checked)}
                /&gt;
                Subscribe to newsletter
              &lt;/label&gt;
              
              &lt;label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}&gt;
                &lt;input
                  type="checkbox"
                  checked={formData.notifications}
                  onChange={(e) => updateField('notifications', e.target.checked)}
                /&gt;
                Enable notifications
              &lt;/label&gt;
              
              &lt;div&gt;
                &lt;label&gt;Theme&lt;/label&gt;
                &lt;select
                  value={formData.theme}
                  onChange={(e) => updateField('theme', e.target.value)}
                  style={{ width: '100%', padding: '0.5rem' }}
                &gt;
                  &lt;option value="light"&gt;Light&lt;/option&gt;
                  &lt;option value="dark"&gt;Dark&lt;/option&gt;
                &lt;/select&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}

        {currentStep === 'review' && (
          &lt;div&gt;
            &lt;h2&gt;Review Your Information&lt;/h2&gt;
            &lt;div style={{ display: 'grid', gap: '1rem' }}&gt;
              &lt;div&gt;
                &lt;h3&gt;Personal Information&lt;/h3&gt;
                &lt;p&gt;&lt;strong&gt;Name:&lt;/strong&gt; {formData.firstName} {formData.lastName}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Birth Date:&lt;/strong&gt; {formData.birthDate}&lt;/p&gt;
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;h3&gt;Contact Information&lt;/h3&gt;
                &lt;p&gt;&lt;strong&gt;Email:&lt;/strong&gt; {formData.email}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Phone:&lt;/strong&gt; {formData.phone}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Address:&lt;/strong&gt; {formData.address}&lt;/p&gt;
              &lt;/div&gt;
              
              &lt;div&gt;
                &lt;h3&gt;Preferences&lt;/h3&gt;
                &lt;p&gt;&lt;strong&gt;Newsletter:&lt;/strong&gt; {formData.newsletter ? 'Yes' : 'No'}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Notifications:&lt;/strong&gt; {formData.notifications ? 'Yes' : 'No'}&lt;/p&gt;
                &lt;p&gt;&lt;strong&gt;Theme:&lt;/strong&gt; {formData.theme}&lt;/p&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        )}
      &lt;/div&gt;

      {/* Navigation buttons */}
      &lt;div style={{ display: 'flex', justifyContent: 'space-between' }}&gt;
        &lt;button
          onClick={handleBack}
          disabled={currentStepIndex === 0}
          style={{
            padding: '0.75rem 1.5rem',
            background: currentStepIndex === 0 ? '#ddd' : '#6c757d',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            cursor: currentStepIndex === 0 ? 'not-allowed' : 'pointer'
          }}
        &gt;
          Back
        &lt;/button&gt;

        {currentStep === 'review' ? (
          &lt;button
            onClick={handleSubmit}
            style={{
              padding: '0.75rem 1.5rem',
              background: '#48bb78',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          &gt;
            Submit
          &lt;/button&gt;
        ) : (
          &lt;button
            onClick={handleNext}
            style={{
              padding: '0.75rem 1.5rem',
              background: '#667eea',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          &gt;
            Next
          &lt;/button&gt;
        )}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Multi-Step Form Best Practices</h4>
                    <ul>
                        <li><strong>Show progress</strong> - Visual indicator of current step</li>
                        <li><strong>Allow navigation</strong> - Users should be able to go back</li>
                        <li><strong>Validate per step</strong> - Don't let users proceed with errors</li>
                        <li><strong>Save progress</strong> - Persist data in localStorage for long forms</li>
                        <li><strong>Review step</strong> - Let users review before final submit</li>
                        <li><strong>Clear labeling</strong> - Name each step clearly</li>
                    </ul>
                </div>

                <h3>Conditional Fields</h3>
                <p>Show or hide fields based on other field values:</p>

                <pre><code class="language-typescript">function ConditionalFieldsForm() {
  const [employmentStatus, setEmploymentStatus] = useState&lt;'employed' | 'unemployed' | 'student'&gt;('employed');
  const [companyName, setCompanyName] = useState('');
  const [schoolName, setSchoolName] = useState('');

  return (
    &lt;form&gt;
      &lt;div&gt;
        &lt;label&gt;Employment Status&lt;/label&gt;
        &lt;select
          value={employmentStatus}
          onChange={(e) => setEmploymentStatus(e.target.value as any)}
          style={{ width: '100%', padding: '0.5rem' }}
        &gt;
          &lt;option value="employed"&gt;Employed&lt;/option&gt;
          &lt;option value="unemployed"&gt;Unemployed&lt;/option&gt;
          &lt;option value="student"&gt;Student&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      {/* Show company field only if employed */}
      {employmentStatus === 'employed' && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;label&gt;Company Name *&lt;/label&gt;
          &lt;input
            type="text"
            value={companyName}
            onChange={(e) => setCompanyName(e.target.value)}
            style={{ width: '100%', padding: '0.5rem' }}
          /&gt;
        &lt;/div&gt;
      )}

      {/* Show school field only if student */}
      {employmentStatus === 'student' && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;label&gt;School Name *&lt;/label&gt;
          &lt;input
            type="text"
            value={schoolName}
            onChange={(e) => setSchoolName(e.target.value)}
            style={{ width: '100%', padding: '0.5rem' }}
          /&gt;
        &lt;/div&gt;
      )}

      &lt;button type="submit" style={{ marginTop: '1rem' }}&gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h3>Dependent Validation</h3>
                <p>Validation rules that depend on multiple fields:</p>

                <pre><code class="language-typescript">interface DateRangeForm {
  startDate: string;
  endDate: string;
  type: 'sameDay' | 'dateRange';
}

function DependentValidationForm() {
  const [formData, setFormData] = useState&lt;DateRangeForm&gt;({
    startDate: '',
    endDate: '',
    type: 'dateRange'
  });

  const [errors, setErrors] = useState&lt;Partial&lt;Record&lt;keyof DateRangeForm, string&gt;&gt;&gt;({});

  const validate = (): boolean => {
    const newErrors: Partial&lt;Record&lt;keyof DateRangeForm, string&gt;&gt; = {};

    if (!formData.startDate) {
      newErrors.startDate = 'Start date is required';
    }

    if (formData.type === 'dateRange') {
      if (!formData.endDate) {
        newErrors.endDate = 'End date is required for date range';
      } else if (formData.startDate && formData.endDate < formData.startDate) {
        newErrors.endDate = 'End date must be after start date';
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (validate()) {
      console.log('Valid form data:', formData);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label&gt;Type&lt;/label&gt;
        &lt;select
          value={formData.type}
          onChange={(e) => setFormData(prev => ({ ...prev, type: e.target.value as any }))}
          style={{ width: '100%', padding: '0.5rem' }}
        &gt;
          &lt;option value="sameDay"&gt;Same Day&lt;/option&gt;
          &lt;option value="dateRange"&gt;Date Range&lt;/option&gt;
        &lt;/select&gt;
      &lt;/div&gt;

      &lt;div style={{ marginTop: '1rem' }}&gt;
        &lt;label&gt;Start Date *&lt;/label&gt;
        &lt;input
          type="date"
          value={formData.startDate}
          onChange={(e) => setFormData(prev => ({ ...prev, startDate: e.target.value }))}
          style={{ width: '100%', padding: '0.5rem' }}
        /&gt;
        {errors.startDate && &lt;span style={{ color: 'red' }}&gt;{errors.startDate}&lt;/span&gt;}
      &lt;/div&gt;

      {formData.type === 'dateRange' && (
        &lt;div style={{ marginTop: '1rem' }}&gt;
          &lt;label&gt;End Date *&lt;/label&gt;
          &lt;input
            type="date"
            value={formData.endDate}
            onChange={(e) => setFormData(prev => ({ ...prev, endDate: e.target.value }))}
            style={{ width: '100%', padding: '0.5rem' }}
          /&gt;
          {errors.endDate && &lt;span style={{ color: 'red' }}&gt;{errors.endDate}&lt;/span&gt;}
        &lt;/div&gt;
      )}

      &lt;button type="submit" style={{ marginTop: '1rem' }}&gt;
        Submit
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h3>Form State Persistence</h3>
                <p>Save form progress to localStorage so users don't lose their work:</p>

                <pre><code class="language-typescript">function useFormPersistence&lt;T&gt;(key: string, initialValue: T) {
  // Load from localStorage on mount
  const [value, setValue] = useState&lt;T&gt;(() => {
    try {
      const stored = localStorage.getItem(key);
      return stored ? JSON.parse(stored) : initialValue;
    } catch {
      return initialValue;
    }
  });

  // Save to localStorage whenever value changes
  useEffect(() => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error('Failed to save to localStorage:', error);
    }
  }, [key, value]);

  // Clear localStorage
  const clearStorage = () => {
    localStorage.removeItem(key);
    setValue(initialValue);
  };

  return [value, setValue, clearStorage] as const;
}

function PersistentForm() {
  const [formData, setFormData, clearFormData] = useFormPersistence('job-application', {
    name: '',
    email: '',
    resume: ''
  });

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    console.log('Submitting:', formData);
    // Clear saved data after successful submission
    clearFormData();
  };

  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div style={{ marginBottom: '1rem', padding: '1rem', background: '#e3f2fd' }}&gt;
        üíæ Your progress is automatically saved
      &lt;/div&gt;

      &lt;input
        type="text"
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        placeholder="Name"
        style={{ width: '100%', padding: '0.5rem', marginBottom: '1rem' }}
      /&gt;

      &lt;input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData(prev => ({ ...prev, email: e.target.value }))}
        placeholder="Email"
        style={{ width: '100%', padding: '0.5rem', marginBottom: '1rem' }}
      /&gt;

      &lt;textarea
        value={formData.resume}
        onChange={(e) => setFormData(prev => ({ ...prev, resume: e.target.value }))}
        placeholder="Resume/Cover Letter"
        rows={5}
        style={{ width: '100%', padding: '0.5rem', marginBottom: '1rem' }}
      /&gt;

      &lt;div style={{ display: 'flex', gap: '1rem' }}&gt;
        &lt;button type="submit"&gt;Submit&lt;/button&gt;
        &lt;button type="button" onClick={clearFormData}&gt;Clear Form&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Persist Form Data</h4>
                    <ul>
                        <li>Long forms (10+ fields)</li>
                        <li>Multi-step wizards</li>
                        <li>Forms with file uploads or heavy content</li>
                        <li>Job applications, surveys, registrations</li>
                    </ul>
                    <p><strong>Remember:</strong> Clear localStorage after successful submission and don't store sensitive data!</p>
                </div>
            </section>

            <!-- Section 8: Complete Example -->
            <section id="section8" aria-labelledby="section8-title">
                <h2 id="section8-title">üéØ Complete Example: Job Application Form</h2>
                <p>Let's put everything together in a comprehensive job application form that demonstrates all the patterns we've learned:</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üìã Features Demonstrated</h4>
                    <ul>
                        <li>‚úÖ Object state management</li>
                        <li>‚úÖ Multiple validation strategies</li>
                        <li>‚úÖ Clear error messages</li>
                        <li>‚úÖ Dynamic field arrays (work experience)</li>
                        <li>‚úÖ Conditional fields</li>
                        <li>‚úÖ File handling</li>
                        <li>‚úÖ TypeScript typing</li>
                        <li>‚úÖ Accessible form controls</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">interface WorkExperience {
  id: string;
  company: string;
  position: string;
  startDate: string;
  endDate: string;
  current: boolean;
}

interface JobApplicationData {
  // Personal
  firstName: string;
  lastName: string;
  email: string;
  phone: string;
  
  // Professional
  yearsExperience: string;
  workExperiences: WorkExperience[];
  
  // Documents
  resume: File | null;
  coverLetter: string;
  
  // Optional
  linkedIn: string;
  portfolio: string;
  referral: boolean;
  referralSource: string;
}

function JobApplicationForm() {
  const [formData, setFormData] = useState&lt;JobApplicationData&gt;({
    firstName: '',
    lastName: '',
    email: '',
    phone: '',
    yearsExperience: '',
    workExperiences: [{
      id: crypto.randomUUID(),
      company: '',
      position: '',
      startDate: '',
      endDate: '',
      current: false
    }],
    resume: null,
    coverLetter: '',
    linkedIn: '',
    portfolio: '',
    referral: false,
    referralSource: ''
  });

  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});
  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Validation functions
  const validateEmail = (email: string): string | undefined => {
    if (!email) return 'Email is required';
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
      return 'Please enter a valid email address';
    }
  };

  const validatePhone = (phone: string): string | undefined => {
    if (!phone) return 'Phone number is required';
    if (!/^\d{10}$/.test(phone.replace(/\D/g, ''))) {
      return 'Please enter a valid 10-digit phone number';
    }
  };

  const validateRequired = (value: string, fieldName: string): string | undefined => {
    if (!value.trim()) return `${fieldName} is required`;
  };

  // Handle field updates
  const updateField = (field: keyof JobApplicationData, value: any) => {
    setFormData(prev => ({ ...prev, [field]: value }));
    
    // Clear error when user types
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };

  // Handle blur
  const handleBlur = (field: string) => {
    setTouched(prev => ({ ...prev, [field]: true }));
    
    // Run validation for this field
    let error: string | undefined;
    switch (field) {
      case 'firstName':
        error = validateRequired(formData.firstName, 'First name');
        break;
      case 'lastName':
        error = validateRequired(formData.lastName, 'Last name');
        break;
      case 'email':
        error = validateEmail(formData.email);
        break;
      case 'phone':
        error = validatePhone(formData.phone);
        break;
      case 'yearsExperience':
        error = validateRequired(formData.yearsExperience, 'Years of experience');
        break;
    }
    
    if (error) {
      setErrors(prev => ({ ...prev, [field]: error }));
    }
  };

  // Work experience handlers
  const addExperience = () => {
    setFormData(prev => ({
      ...prev,
      workExperiences: [
        ...prev.workExperiences,
        {
          id: crypto.randomUUID(),
          company: '',
          position: '',
          startDate: '',
          endDate: '',
          current: false
        }
      ]
    }));
  };

  const removeExperience = (id: string) => {
    setFormData(prev => ({
      ...prev,
      workExperiences: prev.workExperiences.filter(exp => exp.id !== id)
    }));
  };

  const updateExperience = (id: string, field: keyof WorkExperience, value: any) => {
    setFormData(prev => ({
      ...prev,
      workExperiences: prev.workExperiences.map(exp =>
        exp.id === id ? { ...exp, [field]: value } : exp
      )
    }));
  };

  // File handling
  const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const file = e.target.files?.[0] || null;
    
    if (file) {
      // Validate file
      if (file.size > 5 * 1024 * 1024) { // 5MB
        setErrors(prev => ({ ...prev, resume: 'File size must be less than 5MB' }));
        return;
      }
      
      if (!['application/pdf', 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'].includes(file.type)) {
        setErrors(prev => ({ ...prev, resume: 'Only PDF and Word documents are allowed' }));
        return;
      }
    }
    
    updateField('resume', file);
  };

  // Validate entire form
  const validateForm = (): boolean => {
    const newErrors: Record&lt;string, string&gt; = {};

    // Basic fields
    const firstNameError = validateRequired(formData.firstName, 'First name');
    if (firstNameError) newErrors.firstName = firstNameError;

    const lastNameError = validateRequired(formData.lastName, 'Last name');
    if (lastNameError) newErrors.lastName = lastNameError;

    const emailError = validateEmail(formData.email);
    if (emailError) newErrors.email = emailError;

    const phoneError = validatePhone(formData.phone);
    if (phoneError) newErrors.phone = phoneError;

    const expError = validateRequired(formData.yearsExperience, 'Years of experience');
    if (expError) newErrors.yearsExperience = expError;

    // Resume
    if (!formData.resume) {
      newErrors.resume = 'Resume is required';
    }

    // Work experiences
    formData.workExperiences.forEach((exp, index) => {
      if (!exp.company) newErrors[`exp-${index}-company`] = 'Company is required';
      if (!exp.position) newErrors[`exp-${index}-position`] = 'Position is required';
    });

    // Conditional validation
    if (formData.referral && !formData.referralSource) {
      newErrors.referralSource = 'Please tell us who referred you';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // Submit
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    // Mark all as touched
    setTouched({
      firstName: true,
      lastName: true,
      email: true,
      phone: true,
      yearsExperience: true
    });

    if (!validateForm()) {
      alert('Please fix the errors before submitting');
      return;
    }

    setIsSubmitting(true);

    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      console.log('Application submitted:', formData);
      alert('Application submitted successfully!');
      
      // Reset form
      setFormData({
        firstName: '',
        lastName: '',
        email: '',
        phone: '',
        yearsExperience: '',
        workExperiences: [{
          id: crypto.randomUUID(),
          company: '',
          position: '',
          startDate: '',
          endDate: '',
          current: false
        }],
        resume: null,
        coverLetter: '',
        linkedIn: '',
        portfolio: '',
        referral: false,
        referralSource: ''
      });
      setErrors({});
      setTouched({});
      
    } catch (error) {
      setErrors({ submit: 'Failed to submit application. Please try again.' });
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    &lt;form onSubmit={handleSubmit} style={{ maxWidth: '800px', margin: '0 auto' }}&gt;
      &lt;h2&gt;Job Application&lt;/h2&gt;

      {/* Personal Information Section */}
      &lt;section style={{ marginBottom: '2rem' }}&gt;
        &lt;h3&gt;Personal Information&lt;/h3&gt;
        &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}&gt;
          &lt;div&gt;
            &lt;label htmlFor="firstName"&gt;First Name *&lt;/label&gt;
            &lt;input
              id="firstName"
              type="text"
              value={formData.firstName}
              onChange={(e) => updateField('firstName', e.target.value)}
              onBlur={() => handleBlur('firstName')}
              style={{
                width: '100%',
                padding: '0.5rem',
                border: `1px solid ${errors.firstName && touched.firstName ? '#f56565' : '#ddd'}`
              }}
            /&gt;
            {errors.firstName && touched.firstName && (
              &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                {errors.firstName}
              &lt;/span&gt;
            )}
          &lt;/div&gt;

          &lt;div&gt;
            &lt;label htmlFor="lastName"&gt;Last Name *&lt;/label&gt;
            &lt;input
              id="lastName"
              type="text"
              value={formData.lastName}
              onChange={(e) => updateField('lastName', e.target.value)}
              onBlur={() => handleBlur('lastName')}
              style={{
                width: '100%',
                padding: '0.5rem',
                border: `1px solid ${errors.lastName && touched.lastName ? '#f56565' : '#ddd'}`
              }}
            /&gt;
            {errors.lastName && touched.lastName && (
              &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                {errors.lastName}
              &lt;/span&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;

        &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem', marginTop: '1rem' }}&gt;
          &lt;div&gt;
            &lt;label htmlFor="email"&gt;Email *&lt;/label&gt;
            &lt;input
              id="email"
              type="email"
              value={formData.email}
              onChange={(e) => updateField('email', e.target.value)}
              onBlur={() => handleBlur('email')}
              style={{
                width: '100%',
                padding: '0.5rem',
                border: `1px solid ${errors.email && touched.email ? '#f56565' : '#ddd'}`
              }}
            /&gt;
            {errors.email && touched.email && (
              &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                {errors.email}
              &lt;/span&gt;
            )}
          &lt;/div&gt;

          &lt;div&gt;
            &lt;label htmlFor="phone"&gt;Phone *&lt;/label&gt;
            &lt;input
              id="phone"
              type="tel"
              value={formData.phone}
              onChange={(e) => updateField('phone', e.target.value)}
              onBlur={() => handleBlur('phone')}
              placeholder="(555) 123-4567"
              style={{
                width: '100%',
                padding: '0.5rem',
                border: `1px solid ${errors.phone && touched.phone ? '#f56565' : '#ddd'}`
              }}
            /&gt;
            {errors.phone && touched.phone && (
              &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                {errors.phone}
              &lt;/span&gt;
            )}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      {/* Professional Experience */}
      &lt;section style={{ marginBottom: '2rem' }}&gt;
        &lt;h3&gt;Professional Experience&lt;/h3&gt;
        
        &lt;div style={{ marginBottom: '1rem' }}&gt;
          &lt;label htmlFor="yearsExperience"&gt;Years of Experience *&lt;/label&gt;
          &lt;select
            id="yearsExperience"
            value={formData.yearsExperience}
            onChange={(e) => updateField('yearsExperience', e.target.value)}
            onBlur={() => handleBlur('yearsExperience')}
            style={{
              width: '100%',
              padding: '0.5rem',
              border: `1px solid ${errors.yearsExperience && touched.yearsExperience ? '#f56565' : '#ddd'}`
            }}
          &gt;
            &lt;option value=""&gt;Select...&lt;/option&gt;
            &lt;option value="0-1"&gt;0-1 years&lt;/option&gt;
            &lt;option value="1-3"&gt;1-3 years&lt;/option&gt;
            &lt;option value="3-5"&gt;3-5 years&lt;/option&gt;
            &lt;option value="5-10"&gt;5-10 years&lt;/option&gt;
            &lt;option value="10+"&gt;10+ years&lt;/option&gt;
          &lt;/select&gt;
          {errors.yearsExperience && touched.yearsExperience && (
            &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
              {errors.yearsExperience}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        {/* Work Experiences Array */}
        &lt;h4&gt;Work History&lt;/h4&gt;
        {formData.workExperiences.map((exp, index) => (
          &lt;div
            key={exp.id}
            style={{
              border: '1px solid #ddd',
              padding: '1rem',
              marginBottom: '1rem',
              borderRadius: '4px'
            }}
          &gt;
            &lt;div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '0.5rem' }}&gt;
              &lt;strong&gt;Experience {index + 1}&lt;/strong&gt;
              {formData.workExperiences.length > 1 && (
                &lt;button
                  type="button"
                  onClick={() => removeExperience(exp.id)}
                  style={{
                    background: '#f56565',
                    color: 'white',
                    border: 'none',
                    padding: '0.25rem 0.5rem',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  }}
                &gt;
                  Remove
                &lt;/button&gt;
              )}
            &lt;/div&gt;

            &lt;div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '0.5rem' }}&gt;
              &lt;input
                type="text"
                value={exp.company}
                onChange={(e) => updateExperience(exp.id, 'company', e.target.value)}
                placeholder="Company"
                style={{ padding: '0.5rem' }}
              /&gt;
              &lt;input
                type="text"
                value={exp.position}
                onChange={(e) => updateExperience(exp.id, 'position', e.target.value)}
                placeholder="Position"
                style={{ padding: '0.5rem' }}
              /&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        ))}

        &lt;button
          type="button"
          onClick={addExperience}
          style={{
            background: '#48bb78',
            color: 'white',
            border: 'none',
            padding: '0.5rem 1rem',
            borderRadius: '4px',
            cursor: 'pointer'
          }}
        &gt;
          + Add Work Experience
        &lt;/button&gt;
      &lt;/section&gt;

      {/* Documents */}
      &lt;section style={{ marginBottom: '2rem' }}&gt;
        &lt;h3&gt;Documents&lt;/h3&gt;
        
        &lt;div style={{ marginBottom: '1rem' }}&gt;
          &lt;label htmlFor="resume"&gt;Resume *&lt;/label&gt;
          &lt;input
            id="resume"
            type="file"
            onChange={handleFileChange}
            accept=".pdf,.doc,.docx"
            style={{ display: 'block', marginTop: '0.5rem' }}
          /&gt;
          {formData.resume && (
            &lt;p style={{ fontSize: '0.875rem', color: '#48bb78' }}&gt;
              ‚úì {formData.resume.name}
            &lt;/p&gt;
          )}
          {errors.resume && (
            &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
              {errors.resume}
            &lt;/span&gt;
          )}
        &lt;/div&gt;

        &lt;div&gt;
          &lt;label htmlFor="coverLetter"&gt;Cover Letter (Optional)&lt;/label&gt;
          &lt;textarea
            id="coverLetter"
            value={formData.coverLetter}
            onChange={(e) => updateField('coverLetter', e.target.value)}
            placeholder="Tell us why you're interested in this position..."
            rows={5}
            style={{
              width: '100%',
              padding: '0.5rem',
              marginTop: '0.5rem',
              fontFamily: 'inherit'
            }}
          /&gt;
        &lt;/div&gt;
      &lt;/section&gt;

      {/* Referral - Conditional Field */}
      &lt;section style={{ marginBottom: '2rem' }}&gt;
        &lt;label style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}&gt;
          &lt;input
            type="checkbox"
            checked={formData.referral}
            onChange={(e) => updateField('referral', e.target.checked)}
          /&gt;
          I was referred by someone
        &lt;/label&gt;

        {formData.referral && (
          &lt;div style={{ marginTop: '1rem' }}&gt;
            &lt;label htmlFor="referralSource"&gt;Who referred you? *&lt;/label&gt;
            &lt;input
              id="referralSource"
              type="text"
              value={formData.referralSource}
              onChange={(e) => updateField('referralSource', e.target.value)}
              placeholder="Name of person who referred you"
              style={{
                width: '100%',
                padding: '0.5rem',
                marginTop: '0.5rem',
                border: `1px solid ${errors.referralSource ? '#f56565' : '#ddd'}`
              }}
            /&gt;
            {errors.referralSource && (
              &lt;span style={{ color: '#f56565', fontSize: '0.875rem' }}&gt;
                {errors.referralSource}
              &lt;/span&gt;
            )}
          &lt;/div&gt;
        )}
      &lt;/section&gt;

      {/* Submit Error */}
      {errors.submit && (
        &lt;div
          style={{
            background: '#ffebee',
            border: '1px solid #f56565',
            padding: '1rem',
            marginBottom: '1rem',
            borderRadius: '4px',
            color: '#f56565'
          }}
        &gt;
          {errors.submit}
        &lt;/div&gt;
      )}

      {/* Submit Button */}
      &lt;button
        type="submit"
        disabled={isSubmitting}
        style={{
          width: '100%',
          padding: '1rem',
          background: isSubmitting ? '#ddd' : '#667eea',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          fontSize: '1.1rem',
          fontWeight: 'bold',
          cursor: isSubmitting ? 'not-allowed' : 'pointer'
        }}
      &gt;
        {isSubmitting ? 'Submitting...' : 'Submit Application'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What This Example Demonstrates</h4>
                    <ul>
                        <li>Structured state management with proper TypeScript typing</li>
                        <li>Comprehensive validation with clear error messages</li>
                        <li>Dynamic field arrays (work experiences)</li>
                        <li>File upload with validation</li>
                        <li>Conditional fields (referral source)</li>
                        <li>Loading states during submission</li>
                        <li>Proper form reset after submission</li>
                        <li>Accessible form controls with labels and IDs</li>
                        <li>Clean, maintainable code structure</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Best Practices -->
            <section id="section9" aria-labelledby="section9-title">
                <h2 id="section9-title">‚≠ê Best Practices</h2>
                <p>Let's wrap up with a comprehensive list of best practices for complex form handling:</p>

                <h3>State Management</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Use object state for forms with 5+ fields</li>
                        <li>‚úÖ Consider useReducer for very complex forms (20+ fields)</li>
                        <li>‚úÖ Keep related data together (don't split unnecessarily)</li>
                        <li>‚úÖ Use proper TypeScript interfaces for form data</li>
                        <li>‚úÖ Separate form data from UI state (errors, touched, isSubmitting)</li>
                    </ul>
                </div>

                <h3>Validation</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Use on-blur validation for most fields</li>
                        <li>‚úÖ Use real-time validation for password strength and formatting</li>
                        <li>‚úÖ Debounce expensive validations (async checks)</li>
                        <li>‚úÖ Validate everything on submit as final check</li>
                        <li>‚úÖ Clear errors when user starts fixing them</li>
                        <li>‚úÖ Track touched state to avoid showing errors prematurely</li>
                    </ul>
                </div>

                <h3>Error Messages</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Be specific and helpful ("Email must include @" not "Invalid")</li>
                        <li>‚úÖ Position errors near the relevant field</li>
                        <li>‚úÖ Use color AND text (don't rely on color alone)</li>
                        <li>‚úÖ Make errors accessible with ARIA attributes</li>
                        <li>‚úÖ Show one error per field to avoid overwhelming users</li>
                        <li>‚úÖ Use friendly, conversational language</li>
                    </ul>
                </div>

                <h3>Performance</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Split large forms into smaller components</li>
                        <li>‚úÖ Use React.memo for field components</li>
                        <li>‚úÖ Use useCallback for event handlers</li>
                        <li>‚úÖ Debounce expensive operations</li>
                        <li>‚úÖ Consider uncontrolled inputs for simple forms</li>
                        <li>‚úÖ Use proper keys for field arrays (ID, not index)</li>
                    </ul>
                </div>

                <h3>Accessibility</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Associate labels with inputs using htmlFor/id</li>
                        <li>‚úÖ Use aria-invalid on fields with errors</li>
                        <li>‚úÖ Use aria-describedby to link errors to inputs</li>
                        <li>‚úÖ Use role="alert" on error messages</li>
                        <li>‚úÖ Mark required fields with aria-required</li>
                        <li>‚úÖ Ensure sufficient color contrast (4.5:1)</li>
                        <li>‚úÖ Make forms keyboard navigable</li>
                    </ul>
                </div>

                <h3>User Experience</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Show clear progress for multi-step forms</li>
                        <li>‚úÖ Allow users to save and resume long forms</li>
                        <li>‚úÖ Provide helpful placeholder text and examples</li>
                        <li>‚úÖ Disable submit button during submission</li>
                        <li>‚úÖ Show loading indicators for async operations</li>
                        <li>‚úÖ Confirm successful submissions clearly</li>
                        <li>‚úÖ Allow users to go back in multi-step forms</li>
                    </ul>
                </div>

                <h3>Security & Privacy</h3>
                <div class="card">
                    <ul>
                        <li>‚úÖ Validate on both client and server</li>
                        <li>‚úÖ Don't store sensitive data in localStorage</li>
                        <li>‚úÖ Use proper input types (email, tel, password)</li>
                        <li>‚úÖ Implement rate limiting for async validations</li>
                        <li>‚úÖ Clear form data after successful submission</li>
                        <li>‚úÖ Use HTTPS for all form submissions</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Summary -->
            <section id="section10" aria-labelledby="section10-title">
                <h2 id="section10-title">üìö Summary</h2>
                <p>Congratulations! You've mastered complex form handling in React with TypeScript. Let's recap what you've learned:</p>

                <div class="card">
                    <h3>Key Takeaways</h3>
                    <ul>
                        <li>‚úÖ <strong>State Management</strong> - Use object state for scalability, useReducer for very complex forms</li>
                        <li>‚úÖ <strong>Validation</strong> - Combine multiple strategies: real-time, on-blur, on-submit, and debounced async</li>
                        <li>‚úÖ <strong>Error Messages</strong> - Be specific, helpful, visible, and accessible</li>
                        <li>‚úÖ <strong>Dynamic Fields</strong> - Use arrays with unique IDs, never array indices as keys</li>
                        <li>‚úÖ <strong>Performance</strong> - Split into components, use memo and useCallback, debounce expensive ops</li>
                        <li>‚úÖ <strong>Advanced Patterns</strong> - Multi-step forms, conditional fields, dependent validation, persistence</li>
                        <li>‚úÖ <strong>TypeScript</strong> - Properly type all form data, errors, and handlers</li>
                        <li>‚úÖ <strong>Accessibility</strong> - Use proper ARIA attributes, labels, and keyboard navigation</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ What's Next?</h3>
                    <p style="color: white;">In the upcoming lessons, you'll learn:</p>
                    <ul style="color: white;">
                        <li><strong>Lesson 7.2: React Hook Form</strong> - A powerful library that makes forms much easier</li>
                        <li><strong>Lesson 7.3: Form Validation with Zod</strong> - Schema-based validation for type-safe forms</li>
                        <li><strong>Lesson 7.4: File Uploads</strong> - Handling images, documents, and multiple files</li>
                        <li><strong>Lesson 7.5: Advanced Form Patterns</strong> - Form wizards, dynamic schemas, and more</li>
                    </ul>
                    <p style="color: white;">These lessons will build on the foundation you've established here!</p>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üí™ You've Learned</h3>
                    <ul>
                        <li>How to manage complex form state effectively</li>
                        <li>Multiple validation strategies and when to use each</li>
                        <li>How to display clear, helpful error messages</li>
                        <li>Dynamic field arrays with add/remove/update functionality</li>
                        <li>Form performance optimization techniques</li>
                        <li>Advanced patterns like multi-step forms and conditional fields</li>
                        <li>How to build production-ready, accessible forms</li>
                    </ul>
                    <p><strong>You're now equipped to build professional-grade forms in React!</strong></p>
                </div>
            </section>
        </div>
    </main>

    <!-- Lesson Navigation -->
    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_6_5_layout_routes.html" class="nav-button prev-lesson">
            <span class="nav-label">‚Üê Previous Lesson</span>
            <span class="nav-title">Lesson 6.5: Layout Routes</span>
        </a>
        <a href="index.html" class="nav-button home">
            <span class="nav-label">üìö</span>
            <span class="nav-title">All Lessons</span>
        </a>
        <a href="lesson_7_2_react_hook_form.html" class="nav-button next-lesson">
            <span class="nav-label">Next Lesson ‚Üí</span>
            <span class="nav-title">Lesson 7.2: React Hook Form</span>
        </a>
    </nav>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="https://react.dev" target="_blank">React Docs</a> |
                <a href="https://www.typescriptlang.org/docs/" target="_blank">TypeScript Docs</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
