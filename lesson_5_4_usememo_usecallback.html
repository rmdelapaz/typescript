<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React performance optimization with useMemo and useCallback hooks - Learn memoization, prevent unnecessary re-renders, and optimize expensive computations with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>useMemo and useCallback - React TypeScript Course</title>
    <link rel="stylesheet" href="../styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="../index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="../index.html">Home</a>
                <a href="../index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="../index.html">Home</a></li>
            <li><a href="../index.html#module5">Module 5: Advanced Hooks and Patterns</a></li>
            <li aria-current="page">Lesson 5.4: useMemo and useCallback</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>‚ö° useMemo and useCallback</h1>
                <p class="lead">Welcome to one of React's most powerful performance optimization tools! You've learned about useState for managing state, useEffect for side effects, and useRef for persisting values - but what happens when your components start doing expensive calculations on every render, or when child components re-render unnecessarily? That's where useMemo and useCallback come in! Think of useMemo as a "smart cache" that remembers the result of expensive calculations, and useCallback as a "function memory" that keeps your functions stable across renders. These hooks are like performance boosters for your React app - but with great power comes great responsibility! Let's learn when to use them (and when NOT to). ‚ö°</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand what memoization is and how it works</li>
                        <li>Use useMemo to optimize expensive computations</li>
                        <li>Use useCallback to memoize function references</li>
                        <li>Identify when to use (and when NOT to use) these hooks</li>
                        <li>Type memoized values and callbacks with TypeScript</li>
                        <li>Understand React's rendering behavior and optimization</li>
                        <li>Combine useMemo/useCallback with other hooks effectively</li>
                        <li>Profile and measure performance improvements</li>
                        <li>Avoid common memoization pitfalls and anti-patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build optimized data tables, search filters, and complex calculations</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding Performance in React</a></li>
                        <li><a href="#section2" class="toc-link">What is Memoization?</a></li>
                        <li><a href="#section3" class="toc-link">The useMemo Hook</a></li>
                        <li><a href="#section4" class="toc-link">The useCallback Hook</a></li>
                        <li><a href="#section5" class="toc-link">useMemo vs useCallback</a></li>
                        <li><a href="#section6" class="toc-link">When to Use (and When NOT to Use)</a></li>
                        <li><a href="#section7" class="toc-link">Typing with TypeScript</a></li>
                        <li><a href="#section8" class="toc-link">Real-World Examples</a></li>
                        <li><a href="#section9" class="toc-link">Performance Profiling</a></li>
                        <li><a href="#section10" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section11" class="toc-link">Best Practices</a></li>
                        <li><a href="#section12" class="toc-link">Common Mistakes</a></li>
                        <li><a href="#section13" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Performance in React -->
            <section id="section1" class="lesson-section">
                <h2>üéØ Understanding Performance in React</h2>
                <p>Before we dive into useMemo and useCallback, let's understand how React renders components and why performance optimization matters.</p>

                <h3>How React Renders Components</h3>
                <p>Every time a component's state or props change, React re-renders that component and all its children. This is usually fine - React is fast! But sometimes, it can cause performance issues.</p>

                <div class="mermaid">
                graph TD
                    A[State/Props Change] --> B[Component Re-renders]
                    B --> C[All Children Re-render]
                    C --> D[Run All Function Code Again]
                    D --> E[Recalculate All Values]
                    
                    style A fill:#f093fb,stroke:#333,stroke-width:2px
                    style E fill:#ffc107,stroke:#333,stroke-width:2px
                </div>

                <h3>When Does Performance Matter?</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Performance Matters When:</h4>
                    <ul>
                        <li><strong>Expensive calculations:</strong> Filtering/sorting large lists, complex computations</li>
                        <li><strong>Frequent re-renders:</strong> Components that update many times per second</li>
                        <li><strong>Large component trees:</strong> Parent re-renders causing cascade of child re-renders</li>
                        <li><strong>User experience:</strong> UI feels sluggish, animations stutter, inputs lag</li>
                        <li><strong>Data-heavy operations:</strong> Processing thousands of items, complex transformations</li>
                    </ul>
                </div>

                <h3>The Performance Trap</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ö†Ô∏è This runs EVERY render, even if data hasn't changed!
function ProductList({ products }: { products: Product[] }) {
    console.log('Rendering ProductList');
    
    // This expensive calculation runs on EVERY render
    const sortedProducts = products
        .slice()
        .sort((a, b) => b.rating - a.rating);
    
    const averagePrice = products.reduce((sum, p) => sum + p.price, 0) / products.length;
    
    return (
        &lt;div&gt;
            &lt;p&gt;Average Price: ${averagePrice.toFixed(2)}&lt;/p&gt;
            {sortedProducts.map(product => (
                &lt;ProductCard key={product.id} product={product} /&gt;
            ))}
        &lt;/div&gt;
    );
}

// If parent re-renders for ANY reason, these calculations run again!
// Even if products array hasn't changed!</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è The Problem</h4>
                    <p>Every time the parent component re-renders (maybe because of unrelated state), this component recalculates everything:</p>
                    <ul>
                        <li>Sorts the entire products array</li>
                        <li>Calculates average price</li>
                        <li>Creates new function references</li>
                        <li>Even if the products data is identical!</li>
                    </ul>
                </div>

                <h3>React's Default Behavior</h3>
                <table>
                    <thead>
                        <tr>
                            <th>What Happens</th>
                            <th>Consequence</th>
                            <th>When It's a Problem</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Parent re-renders</td>
                            <td>All children re-render</td>
                            <td>Deep component trees</td>
                        </tr>
                        <tr>
                            <td>Component re-renders</td>
                            <td>All code runs again</td>
                            <td>Expensive calculations</td>
                        </tr>
                        <tr>
                            <td>Functions recreated</td>
                            <td>New references each render</td>
                            <td>Props to memoized children</td>
                        </tr>
                        <tr>
                            <td>Objects/arrays recreated</td>
                            <td>Reference equality fails</td>
                            <td>Dependency arrays, memo</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Good News</h4>
                    <p>React provides two hooks to solve these problems:</p>
                    <ul>
                        <li><strong>useMemo:</strong> Memoizes (caches) the result of expensive calculations</li>
                        <li><strong>useCallback:</strong> Memoizes (caches) function references</li>
                    </ul>
                    <p>These hooks tell React: "Only recalculate/recreate when dependencies actually change!"</p>
                </div>
            </section>

            <!-- Section 2: What is Memoization? -->
            <section id="section2" class="lesson-section">
                <h2>üß† What is Memoization?</h2>
                <p>Memoization is a programming technique where you cache (remember) the result of expensive operations and return the cached result when the same inputs occur again.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Memoization:</strong> An optimization technique that stores the results of expensive function calls and returns the cached result when the same inputs occur again, avoiding redundant calculations.</p>
                </div>

                <h3>Real-World Analogy</h3>
                <div class="card">
                    <h4>üçï The Pizza Restaurant Analogy</h4>
                    <p>Imagine a pizza restaurant where making a pizza takes 20 minutes:</p>
                    
                    <p><strong>Without Memoization:</strong></p>
                    <ul>
                        <li>Customer orders a Margherita pizza ‚Üí Cook makes it (20 min)</li>
                        <li>5 minutes later, another customer orders a Margherita ‚Üí Cook makes it again (20 min)</li>
                        <li>Another customer orders the same ‚Üí Cook makes it again (20 min)</li>
                        <li>Total time wasted: 60 minutes for the same recipe!</li>
                    </ul>
                    
                    <p><strong>With Memoization:</strong></p>
                    <ul>
                        <li>First Margherita order ‚Üí Cook makes it and saves the recipe result (20 min)</li>
                        <li>Second Margherita order ‚Üí Cook checks cache, serves immediately! (instant)</li>
                        <li>Third Margherita order ‚Üí Serve from cache again! (instant)</li>
                        <li>Different pizza (Pepperoni) ‚Üí Cache miss, make fresh and cache it</li>
                    </ul>
                </div>

                <h3>How Memoization Works</h3>
                <div class="mermaid">
                graph LR
                    A[Function Called] --> B{Check Cache}
                    B -->|Hit: Found| C[Return Cached Result]
                    B -->|Miss: Not Found| D[Calculate Result]
                    D --> E[Store in Cache]
                    E --> F[Return Result]
                    
                    style C fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style D fill:#ffc107,stroke:#333,stroke-width:2px
</div>

                <h3>Simple Memoization Example</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Manual memoization (conceptual)
const cache = new Map();

function expensiveCalculation(n: number): number {
    // Check if we've calculated this before
    if (cache.has(n)) {
        console.log('Returning cached result');
        return cache.get(n)!;
    }
    
    // Not in cache, calculate it
    console.log('Calculating...');
    let result = 0;
    for (let i = 0; i < 1000000000; i++) {
        result += n;
    }
    
    // Store in cache for next time
    cache.set(n, result);
    return result;
}

// First call - calculates (slow)
expensiveCalculation(5); // Logs: "Calculating..."

// Second call with same input - returns cached result (fast!)
expensiveCalculation(5); // Logs: "Returning cached result"

// Different input - calculates again
expensiveCalculation(10); // Logs: "Calculating..."</code></pre>
                </div>

                <h3>Memoization in React</h3>
                <p>React's useMemo and useCallback do this automatically for you! They check if dependencies changed, and only recalculate when needed.</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useMemo } from 'react';

function MyComponent({ data }: { data: number[] }) {
    // React will cache the result and only recalculate when 'data' changes
    const sortedData = useMemo(() => {
        console.log('Sorting data...');
        return [...data].sort((a, b) => a - b);
    }, [data]); // Dependency array - recalculate only when data changes
    
    return &lt;div&gt;{sortedData.join(', ')}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>Memoization trades <strong>memory</strong> (storing cached results) for <strong>speed</strong> (avoiding recalculation). This is only beneficial when:</p>
                    <ul>
                        <li>The calculation is expensive (takes noticeable time)</li>
                        <li>The same inputs appear multiple times</li>
                        <li>The memory cost is acceptable</li>
                    </ul>
                </div>
            </section>

            <!-- Section 3: The useMemo Hook -->
            <section id="section3" class="lesson-section">
                <h2>üéØ The useMemo Hook</h2>
                <p>useMemo lets you cache the result of a calculation between re-renders. It only recalculates when dependencies change.</p>

                <h3>Basic Syntax</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useMemo } from 'react';

function MyComponent() {
    const memoizedValue = useMemo(() => {
        // Expensive calculation here
        return calculateExpensiveValue();
    }, [dependency1, dependency2]); // Dependencies array
    
    return &lt;div&gt;{memoizedValue}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ useMemo Signature</h4>
                    <pre style="color: white; background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 4px;"><code>const memoizedValue = useMemo(
    () => computeExpensiveValue(a, b),
    [a, b]
);

// Returns the memoized value
// Recalculates only when dependencies [a, b] change</code></pre>
                </div>

                <h3>How useMemo Works</h3>
                <ol>
                    <li><strong>First render:</strong> React runs your calculation function and stores the result</li>
                    <li><strong>Subsequent renders:</strong> React checks if dependencies changed
                        <ul>
                            <li>If unchanged ‚Üí Returns cached result (fast!)</li>
                            <li>If changed ‚Üí Re-runs calculation and caches new result</li>
                        </ul>
                    </li>
                </ol>

                <h3>Example 1: Filtering a Large List</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    age: number;
    active: boolean;
}

interface UserListProps {
    users: User[];
    searchTerm: string;
}

function UserList({ users, searchTerm }: UserListProps) {
    // Without useMemo - filters on EVERY render
    // const filteredUsers = users.filter(user =>
    //     user.name.toLowerCase().includes(searchTerm.toLowerCase())
    // );
    
    // ‚úÖ With useMemo - only filters when users or searchTerm change
    const filteredUsers = useMemo(() => {
        console.log('Filtering users...');
        return users.filter(user =>
            user.name.toLowerCase().includes(searchTerm.toLowerCase())
        );
    }, [users, searchTerm]);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Found {filteredUsers.length} users&lt;/p&gt;
            {filteredUsers.map(user => (
                &lt;div key={user.id}&gt;{user.name}&lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}

// Parent component re-renders due to other state?
// filteredUsers calculation is skipped! (unless users/searchTerm changed)</code></pre>
                </div>

                <h3>Example 2: Expensive Calculation</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface DataAnalyticsProps {
    data: number[];
}

function DataAnalytics({ data }: DataAnalyticsProps) {
    // Expensive statistical calculations
    const statistics = useMemo(() => {
        console.log('Calculating statistics...');
        
        const sorted = [...data].sort((a, b) => a - b);
        const sum = data.reduce((acc, val) => acc + val, 0);
        const mean = sum / data.length;
        const median = sorted[Math.floor(sorted.length / 2)];
        const variance = data.reduce((acc, val) => 
            acc + Math.pow(val - mean, 2), 0) / data.length;
        const stdDev = Math.sqrt(variance);
        
        return { mean, median, stdDev, min: sorted[0], max: sorted[sorted.length - 1] };
    }, [data]); // Only recalculate when data array changes
    
    return (
        &lt;div&gt;
            &lt;h3&gt;Statistics&lt;/h3&gt;
            &lt;p&gt;Mean: {statistics.mean.toFixed(2)}&lt;/p&gt;
            &lt;p&gt;Median: {statistics.median}&lt;/p&gt;
            &lt;p&gt;Std Dev: {statistics.stdDev.toFixed(2)}&lt;/p&gt;
            &lt;p&gt;Range: {statistics.min} - {statistics.max}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Example 3: Derived State</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
    inStock: boolean;
}

interface ProductDashboardProps {
    products: Product[];
}

function ProductDashboard({ products }: ProductDashboardProps) {
    // Multiple derived values, all memoized
    const inStockProducts = useMemo(() => 
        products.filter(p => p.inStock),
        [products]
    );
    
    const totalValue = useMemo(() =>
        products.reduce((sum, p) => sum + p.price, 0),
        [products]
    );
    
    const categoryCounts = useMemo(() => {
        const counts: Record&lt;string, number&gt; = {};
        products.forEach(p => {
            counts[p.category] = (counts[p.category] || 0) + 1;
        });
        return counts;
    }, [products]);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Dashboard&lt;/h2&gt;
            &lt;p&gt;Total Products: {products.length}&lt;/p&gt;
            &lt;p&gt;In Stock: {inStockProducts.length}&lt;/p&gt;
            &lt;p&gt;Total Value: ${totalValue.toFixed(2)}&lt;/p&gt;
            &lt;h3&gt;By Category&lt;/h3&gt;
            &lt;ul&gt;
                {Object.entries(categoryCounts).map(([cat, count]) => (
                    &lt;li key={cat}&gt;{cat}: {count}&lt;/li&gt;
                ))}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use useMemo</h4>
                    <ul>
                        <li>Filtering or sorting large arrays (1000+ items)</li>
                        <li>Complex mathematical calculations</li>
                        <li>Processing large datasets</li>
                        <li>Generating derived data structures</li>
                        <li>Expensive object transformations</li>
                        <li>When you can measure a performance improvement</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use useMemo</h4>
                    <ul>
                        <li>Simple calculations (adding two numbers)</li>
                        <li>Creating basic objects or arrays</li>
                        <li>Premature optimization (measure first!)</li>
                        <li>Every single value in your component</li>
                        <li>When the calculation is cheaper than memoization overhead</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: The useCallback Hook -->
            <section id="section4" class="lesson-section">
                <h2>üîÑ The useCallback Hook</h2>
                <p>useCallback is similar to useMemo, but instead of memoizing a value, it memoizes a function itself. This prevents recreating function references on every render.</p>

                <h3>Basic Syntax</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useCallback } from 'react';

function MyComponent() {
    const memoizedCallback = useCallback(() => {
        // Function logic here
        doSomething(dependency1, dependency2);
    }, [dependency1, dependency2]); // Dependencies array
    
    return &lt;button onClick={memoizedCallback}&gt;Click me&lt;/button&gt;;
}</code></pre>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ useCallback Signature</h4>
                    <pre style="color: white; background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 4px;"><code>const memoizedFunction = useCallback(
    (args) => {
        // Function body
    },
    [dependencies]
);

// Returns the memoized function reference
// Recreates only when dependencies change</code></pre>
                </div>

                <h3>Why Function References Matter</h3>
                <p>In JavaScript, every function is a unique object. Creating a function twice creates two different references, even if the code is identical:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// These are NOT equal!
const func1 = () => console.log('hello');
const func2 = () => console.log('hello');
console.log(func1 === func2); // false - different references!

// This causes problems in React
function Parent() {
    // This creates a NEW function on EVERY render
    const handleClick = () => {
        console.log('clicked');
    };
    
    // Child receives a "new" function every render
    // Even though the function does the exact same thing!
    return &lt;Child onClick={handleClick} /&gt;;
}</code></pre>
                </div>

                <h3>The Problem: Functions Recreated Every Render</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Problem: Child re-renders unnecessarily
const Child = React.memo(({ onClick }: { onClick: () => void }) => {
    console.log('Child rendered');
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});

function Parent() {
    const [count, setCount] = useState(0);
    
    // New function reference on every render!
    const handleClick = () => {
        console.log('Button clicked');
    };
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
            {/* Child re-renders even though handleClick logic didn't change */}
            &lt;Child onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}

// Every time count changes, Child re-renders
// Because handleClick is a new reference each time!</code></pre>
                </div>

                <h3>The Solution: useCallback</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Solution: Stable function reference
const Child = React.memo(({ onClick }: { onClick: () => void }) => {
    console.log('Child rendered');
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});

function Parent() {
    const [count, setCount] = useState(0);
    
    // Same function reference across renders!
    const handleClick = useCallback(() => {
        console.log('Button clicked');
    }, []); // No dependencies = never recreated
    
    return (
        &lt;div&gt;
            &lt;p&gt;Count: {count}&lt;/p&gt;
            &lt;button onClick={() => setCount(count + 1)}&gt;Increment&lt;/button&gt;
            {/* Child doesn't re-render when count changes! */}
            &lt;Child onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}

// Now Child only renders when it actually needs to!</code></pre>
                </div>

                <h3>Example 1: Passing Callbacks to Memoized Children</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Todo {
    id: number;
    text: string;
    completed: boolean;
}

interface TodoItemProps {
    todo: Todo;
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}

// Memoized child component
const TodoItem = React.memo(({ todo, onToggle, onDelete }: TodoItemProps) => {
    console.log(`Rendering todo: ${todo.text}`);
    
    return (
        &lt;div&gt;
            &lt;input
                type="checkbox"
                checked={todo.completed}
                onChange={() => onToggle(todo.id)}
            /&gt;
            &lt;span&gt;{todo.text}&lt;/span&gt;
            &lt;button onClick={() => onDelete(todo.id)}&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
    );
});

function TodoList() {
    const [todos, setTodos] = useState&lt;Todo[]&gt;([
        { id: 1, text: 'Learn React', completed: false },
        { id: 2, text: 'Learn TypeScript', completed: true }
    ]);
    
    // ‚úÖ Memoized callbacks - stable references
    const handleToggle = useCallback((id: number) => {
        setTodos(prev => prev.map(todo =>
            todo.id === id ? { ...todo, completed: !todo.completed } : todo
        ));
    }, []); // No dependencies needed - uses functional update
    
    const handleDelete = useCallback((id: number) => {
        setTodos(prev => prev.filter(todo => todo.id !== id));
    }, []);
    
    return (
        &lt;div&gt;
            {todos.map(todo => (
                &lt;TodoItem
                    key={todo.id}
                    todo={todo}
                    onToggle={handleToggle}
                    onDelete={handleDelete}
                /&gt;
            ))}
        &lt;/div&gt;
    );
}

// Only the affected TodoItem re-renders, not all of them!</code></pre>
                </div>

                <h3>Example 2: useCallback with Dependencies</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface SearchProps {
    onSearch: (query: string) => void;
}

function SearchComponent() {
    const [query, setQuery] = useState('');
    const [filter, setFilter] = useState('all');
    
    // Callback depends on filter
    const handleSearch = useCallback((searchTerm: string) => {
        console.log(`Searching for "${searchTerm}" with filter: ${filter}`);
        // API call with query and filter
        fetchResults(searchTerm, filter);
    }, [filter]); // Recreate when filter changes
    
    return (
        &lt;div&gt;
            &lt;select value={filter} onChange={e => setFilter(e.target.value)}&gt;
                &lt;option value="all"&gt;All&lt;/option&gt;
                &lt;option value="active"&gt;Active&lt;/option&gt;
                &lt;option value="completed"&gt;Completed&lt;/option&gt;
            &lt;/select&gt;
            &lt;SearchInput onSearch={handleSearch} /&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Example 3: Event Handlers with State</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface FormProps {
    onSubmit: (data: FormData) => void;
}

function ComplexForm() {
    const [formData, setFormData] = useState({
        name: '',
        email: '',
        message: ''
    });
    const [status, setStatus] = useState('idle');
    
    // Callback uses current formData
    const handleSubmit = useCallback((e: React.FormEvent) => {
        e.preventDefault();
        setStatus('submitting');
        
        // Use current formData values
        submitForm(formData)
            .then(() => setStatus('success'))
            .catch(() => setStatus('error'));
    }, [formData]); // Recreate when formData changes
    
    // Individual field handlers
    const handleNameChange = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        setFormData(prev => ({ ...prev, name: e.target.value }));
    }, []);
    
    const handleEmailChange = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        setFormData(prev => ({ ...prev, email: e.target.value }));
    }, []);
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;input value={formData.name} onChange={handleNameChange} /&gt;
            &lt;input value={formData.email} onChange={handleEmailChange} /&gt;
            &lt;button type="submit" disabled={status === 'submitting'}&gt;
                Submit
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use useCallback</h4>
                    <ul>
                        <li>Passing callbacks to memoized child components (React.memo)</li>
                        <li>Functions used as dependencies in useEffect or other hooks</li>
                        <li>Event handlers passed to expensive-to-render children</li>
                        <li>Callbacks passed to custom hooks</li>
                        <li>Functions that create subscriptions or WebSocket connections</li>
                        <li>When profiling shows unnecessary child re-renders</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use useCallback</h4>
                    <ul>
                        <li>Every function in your component (overkill!)</li>
                        <li>Functions not passed as props or dependencies</li>
                        <li>Simple event handlers on native DOM elements</li>
                        <li>Functions in components that rarely re-render</li>
                        <li>When the child component isn't memoized anyway</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: useMemo vs useCallback -->
            <section id="section5" class="lesson-section">
                <h2>‚öñÔ∏è useMemo vs useCallback</h2>
                <p>These two hooks are closely related but serve different purposes. Let's understand the key differences and when to use each.</p>

                <h3>The Fundamental Difference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>useMemo</th>
                            <th>useCallback</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>What it memoizes</strong></td>
                            <td>The <strong>result</strong> of a function</td>
                            <td>The <strong>function</strong> itself</td>
                        </tr>
                        <tr>
                            <td><strong>Returns</strong></td>
                            <td>Any value (number, object, array, etc.)</td>
                            <td>A function reference</td>
                        </tr>
                        <tr>
                            <td><strong>Use case</strong></td>
                            <td>Expensive calculations</td>
                            <td>Stable function references</td>
                        </tr>
                        <tr>
                            <td><strong>Example</strong></td>
                            <td>Sorting/filtering large arrays</td>
                            <td>Event handlers for memoized children</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Side-by-Side Comparison</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function ComparisonExample({ data }: { data: number[] }) {
    // useMemo - memoizes the RESULT (sorted array)
    const sortedData = useMemo(() => {
        return [...data].sort((a, b) => a - b); // Returns sorted array
    }, [data]);
    // sortedData is the array: [1, 2, 3, 4, 5]
    
    // useCallback - memoizes the FUNCTION
    const handleSort = useCallback(() => {
        console.log('Sorting data');
        return [...data].sort((a, b) => a - b); // Returns function
    }, [data]);
    // handleSort is the function: () => {...}
    
    return (
        &lt;div&gt;
            {/* useMemo: Use the value directly */}
            &lt;p&gt;Sorted: {sortedData.join(', ')}&lt;/p&gt;
            
            {/* useCallback: Call the function when needed */}
            &lt;button onClick={handleSort}&gt;Sort&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Interchangeability</h3>
                <p>Technically, useCallback is just syntactic sugar for useMemo that returns a function:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// These are equivalent:

// Using useCallback
const handleClick = useCallback(() => {
    console.log('clicked');
}, []);

// Using useMemo to return a function
const handleClick = useMemo(() => {
    return () => {
        console.log('clicked');
    };
}, []);

// But useCallback is clearer and more readable!</code></pre>
                </div>

                <h3>Real-World Example: Both Together</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
}

interface ProductListProps {
    products: Product[];
}

function ProductList({ products }: ProductListProps) {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortBy, setSortBy] = useState&lt;'name' | 'price'&gt;('name');
    
    // useMemo: Memoize the filtered and sorted products (result)
    const processedProducts = useMemo(() => {
        console.log('Processing products...');
        
        // Filter
        let filtered = products.filter(p =>
            p.name.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        // Sort
        filtered.sort((a, b) => {
            if (sortBy === 'name') {
                return a.name.localeCompare(b.name);
            }
            return a.price - b.price;
        });
        
        return filtered;
    }, [products, searchTerm, sortBy]);
    // processedProducts is the array of processed products
    
    // useCallback: Memoize the search handler (function)
    const handleSearch = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        setSearchTerm(e.target.value);
    }, []);
    // handleSearch is the function itself
    
    // useCallback: Memoize the sort handler (function)
    const handleSortChange = useCallback((e: React.ChangeEvent&lt;HTMLSelectElement&gt;) => {
        setSortBy(e.target.value as 'name' | 'price');
    }, []);
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={searchTerm}
                onChange={handleSearch}
                placeholder="Search products..."
            /&gt;
            
            &lt;select value={sortBy} onChange={handleSortChange}&gt;
                &lt;option value="name"&gt;Sort by Name&lt;/option&gt;
                &lt;option value="price"&gt;Sort by Price&lt;/option&gt;
            &lt;/select&gt;
            
            &lt;p&gt;Showing {processedProducts.length} products&lt;/p&gt;
            
            {processedProducts.map(product => (
                &lt;ProductCard key={product.id} product={product} /&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Decision Tree</h3>
                <div class="mermaid">
                graph TD
                    A[Need to optimize?] --> B{What are you optimizing?}
                    B -->|A calculated value| C[Use useMemo]
                    B -->|A function reference| D[Use useCallback]
                    
                    C --> E{Expensive calculation?}
                    E -->|Yes| F[‚úÖ useMemo is helpful]
                    E -->|No| G[‚ùå Probably not worth it]
                    
                    D --> H{Passed to memoized child?}
                    H -->|Yes| I[‚úÖ useCallback is helpful]
                    H -->|No| J[‚ùå Probably not worth it]
                    
                    style F fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style I fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style G fill:#f093fb,stroke:#333,stroke-width:2px
                    style J fill:#f093fb,stroke:#333,stroke-width:2px
                </graph>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Quick Reference</h4>
                    <ul>
                        <li><strong>useMemo:</strong> "Remember this <em>result</em>" ‚Üí Returns the calculated value</li>
                        <li><strong>useCallback:</strong> "Remember this <em>function</em>" ‚Üí Returns the function itself</li>
                        <li>Both prevent recreation when dependencies don't change</li>
                        <li>Both have the same dependency array mechanics</li>
                        <li>Both can hurt performance if overused</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: When to Use (and When NOT to Use) -->
            <section id="section6" class="lesson-section">
                <h2>üéØ When to Use (and When NOT to Use)</h2>
                <p>The most important skill with useMemo and useCallback is knowing when they help and when they hurt. Let's build that intuition.</p>

                <h3>The Golden Rule</h3>
                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ Golden Rule of Memoization</h4>
                    <p style="color: white; font-size: 1.1rem;"><strong>"Only optimize when you can measure a problem."</strong></p>
                    <p style="color: white;">Don't memoize everything "just in case". Memoization has costs too!</p>
                </div>

                <h3>The Cost of Memoization</h3>
                <p>useMemo and useCallback aren't free! They have costs:</p>
                <ul>
                    <li><strong>Memory:</strong> Storing cached values takes memory</li>
                    <li><strong>Comparison:</strong> React must compare dependencies on every render</li>
                    <li><strong>Complexity:</strong> More code to read and maintain</li>
                    <li><strong>Bugs:</strong> Wrong dependencies can cause subtle bugs</li>
                </ul>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Over-optimization - the cost outweighs the benefit!
function SimpleCounter() {
    const [count, setCount] = useState(0);
    
    // Bad: Memoizing a simple addition
    const doubleCount = useMemo(() => count * 2, [count]);
    
    // Bad: Memoizing a simple string
    const message = useMemo(() => `Count is ${count}`, [count]);
    
    // Bad: Memoizing a simple function
    const increment = useCallback(() => setCount(c => c + 1), []);
    
    return (
        &lt;div&gt;
            &lt;p&gt;{message}&lt;/p&gt;
            &lt;p&gt;Double: {doubleCount}&lt;/p&gt;
            &lt;button onClick={increment}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ Better: Keep it simple
function SimpleCounter() {
    const [count, setCount] = useState(0);
    
    // These are so cheap, memoization adds overhead instead of removing it
    const doubleCount = count * 2;
    const message = `Count is ${count}`;
    
    return (
        &lt;div&gt;
            &lt;p&gt;{message}&lt;/p&gt;
            &lt;p&gt;Double: {doubleCount}&lt;/p&gt;
            &lt;button onClick={() => setCount(c => c + 1)}&gt;+&lt;/button&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Good Use Cases ‚úÖ</h3>

                <h4>1. Filtering/Sorting Large Lists</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Good: Expensive operation on large dataset
function UserTable({ users }: { users: User[] }) { // 10,000+ users
    const [sortKey, setSortKey] = useState('name');
    
    const sortedUsers = useMemo(() => {
        return [...users].sort((a, b) => 
            a[sortKey].localeCompare(b[sortKey])
        );
    }, [users, sortKey]);
    
    // Without useMemo, sorting 10,000 items on every render is expensive!
}</code></pre>
                </div>

                <h4>2. Complex Calculations</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Good: Computationally expensive
function DataVisualization({ data }: { data: number[] }) {
    const statistics = useMemo(() => {
        // Multiple passes through large dataset
        const sorted = [...data].sort((a, b) => a - b);
        const mean = data.reduce((a, b) => a + b) / data.length;
        const median = sorted[Math.floor(data.length / 2)];
        const mode = calculateMode(data); // Custom expensive function
        const stdDev = calculateStandardDeviation(data, mean);
        
        return { mean, median, mode, stdDev };
    }, [data]);
    
    // These calculations are worth caching
}</code></pre>
                </div>

                <h4>3. Preventing Child Re-renders</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚úÖ Good: Child is memoized and expensive to render
const ExpensiveList = React.memo(({ items, onItemClick }: Props) => {
    console.log('Rendering 1000+ items...');
    return (
        &lt;div&gt;
            {items.map(item => (
                &lt;ExpensiveItem key={item.id} item={item} onClick={onItemClick} /&gt;
            ))}
        &lt;/div&gt;
    );
});

function Parent() {
    const [unrelatedState, setUnrelatedState] = useState(0);
    const items = [...]; // Large array
    
    // Without useCallback, ExpensiveList re-renders when unrelatedState changes
    const handleItemClick = useCallback((id: number) => {
        console.log('Clicked:', id);
    }, []);
    
    return &lt;ExpensiveList items={items} onItemClick={handleItemClick} /&gt;;
}</code></pre>
                </div>

                <h3>Bad Use Cases ‚ùå</h3>

                <h4>1. Simple Calculations</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad: Over-optimization
function Profile({ user }: { user: User }) {
    // These are instant - don't memoize!
    const fullName = useMemo(() => 
        `${user.firstName} ${user.lastName}`, [user]); // Overkill!
    
    const age = useMemo(() => 
        new Date().getFullYear() - user.birthYear, [user]); // Overkill!
    
    // Just do them directly:
    // const fullName = `${user.firstName} ${user.lastName}`;
    // const age = new Date().getFullYear() - user.birthYear;
}</code></pre>
                </div>

                <h4>2. Callbacks Not Passed to Memoized Children</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad: Unnecessary complexity
function Form() {
    const [name, setName] = useState('');
    
    // Pointless - just attached to a regular input
    const handleChange = useCallback((e) => {
        setName(e.target.value);
    }, []);
    
    // Regular input doesn't benefit from stable function reference
    return &lt;input onChange={handleChange} /&gt;;
    
    // Better: &lt;input onChange={e => setName(e.target.value)} /&gt;
}</code></pre>
                </div>

                <h4>3. Dependencies That Always Change</h4>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad: Defeats the purpose
function Component({ config }: { config: Config }) {
    // config is a new object every render, so this never caches!
    const processed = useMemo(() => {
        return processConfig(config);
    }, [config]); // config is always "new"
    
    // useMemo does nothing here - it recalculates every time anyway!
}</code></pre>
                </div>

                <h3>The Checklist</h3>
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use useMemo when:</h4>
                    <ul>
                        <li>‚òê The calculation is measurably expensive (100ms+)</li>
                        <li>‚òê It involves large datasets (1000+ items)</li>
                        <li>‚òê Profiling shows it as a bottleneck</li>
                        <li>‚òê Dependencies change rarely</li>
                        <li>‚òê The value is passed to memoized children</li>
                    </ul>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Use useCallback when:</h4>
                    <ul>
                        <li>‚òê Function is passed to React.memo'd children</li>
                        <li>‚òê Function is a dependency in useEffect</li>
                        <li>‚òê Child component re-renders are expensive</li>
                        <li>‚òê Function is passed to custom hooks</li>
                        <li>‚òê Profiling shows unnecessary child re-renders</li>
                    </ul>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Don't Use When:</h4>
                    <ul>
                        <li>‚òê The operation is instant (< 1ms)</li>
                        <li>‚òê You're just guessing it might help</li>
                        <li>‚òê The component rarely re-renders anyway</li>
                        <li>‚òê Dependencies change on every render</li>
                        <li>‚òê Children aren't memoized (for useCallback)</li>
                        <li>‚òê You haven't measured the problem</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Typing with TypeScript -->
            <section id="section7" class="lesson-section">
                <h2>üìò Typing with TypeScript</h2>
                <p>TypeScript makes useMemo and useCallback even more powerful by catching type errors at compile time. Let's explore how to type these hooks properly.</p>

                <h3>Basic TypeScript with useMemo</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useMemo } from 'react';

function Component() {
    // TypeScript infers the type automatically
    const count = useMemo(() => {
        return 42; // TypeScript knows this is number
    }, []);
    // count: number
    
    // You can also explicitly type it
    const message = useMemo&lt;string&gt;(() => {
        return 'Hello World';
    }, []);
    // message: string
    
    // Arrays and objects are inferred too
    const users = useMemo(() => {
        return [
            { id: 1, name: 'Alice' },
            { id: 2, name: 'Bob' }
        ];
    }, []);
    // users: { id: number; name: string; }[]
}</code></pre>
                </div>

                <h3>Typing Complex Return Values</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface User {
    id: number;
    name: string;
    email: string;
    role: 'admin' | 'user';
}

interface UserStats {
    total: number;
    admins: number;
    activeUsers: User[];
}

function UserDashboard({ users }: { users: User[] }) {
    // Explicitly type the return value for clarity
    const stats = useMemo&lt;UserStats&gt;(() => {
        return {
            total: users.length,
            admins: users.filter(u => u.role === 'admin').length,
            activeUsers: users.filter(u => u.role === 'user')
        };
    }, [users]);
    
    // TypeScript knows stats has these properties
    return (
        &lt;div&gt;
            &lt;p&gt;Total: {stats.total}&lt;/p&gt;
            &lt;p&gt;Admins: {stats.admins}&lt;/p&gt;
            &lt;p&gt;Active: {stats.activeUsers.length}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Basic TypeScript with useCallback</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { useCallback } from 'react';

function Component() {
    // TypeScript infers parameter and return types
    const handleClick = useCallback((id: number) => {
        console.log('Clicked:', id);
    }, []);
    // handleClick: (id: number) => void
    
    // Explicitly typing event handlers
    const handleChange = useCallback((e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
        console.log(e.target.value);
    }, []);
    // handleChange: (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => void
    
    // Functions that return values
    const calculateTotal = useCallback((items: number[]): number => {
        return items.reduce((sum, item) => sum + item, 0);
    }, []);
    // calculateTotal: (items: number[]) => number
}</code></pre>
                </div>

                <h3>Typing Generic Callbacks</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Item {
    id: number;
    name: string;
}

interface ListProps&lt;T&gt; {
    items: T[];
    onItemClick: (item: T) => void;
    onItemDelete: (id: number) => void;
}

function GenericList&lt;T extends { id: number }&gt;({ 
    items, 
    onItemClick,
    onItemDelete 
}: ListProps&lt;T&gt;) {
    // Callback that works with generic type
    const handleClick = useCallback((item: T) => {
        onItemClick(item);
    }, [onItemClick]);
    
    // Type-safe delete handler
    const handleDelete = useCallback((id: number) => {
        onItemDelete(id);
    }, [onItemDelete]);
    
    return (
        &lt;div&gt;
            {items.map(item => (
                &lt;div key={item.id}&gt;
                    &lt;button onClick={() => handleClick(item)}&gt;View&lt;/button&gt;
                    &lt;button onClick={() => handleDelete(item.id)}&gt;Delete&lt;/button&gt;
                &lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Typing Async Callbacks</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface FetchResult&lt;T&gt; {
    data: T | null;
    error: Error | null;
    loading: boolean;
}

function DataFetcher() {
    const [result, setResult] = useState&lt;FetchResult&lt;User&gt;&gt;({
        data: null,
        error: null,
        loading: false
    });
    
    // Async callback with proper typing
    const fetchUser = useCallback(async (id: number): Promise&lt;void&gt; => {
        setResult({ data: null, error: null, loading: true });
        
        try {
            const response = await fetch(`/api/users/${id}`);
            const data: User = await response.json();
            setResult({ data, error: null, loading: false });
        } catch (error) {
            setResult({ 
                data: null, 
                error: error as Error, 
                loading: false 
            });
        }
    }, []);
    // fetchUser: (id: number) => Promise&lt;void&gt;
    
    return (
        &lt;button onClick={() => fetchUser(1)}&gt;
            Load User
        &lt;/button&gt;
    );
}</code></pre>
                </div>

                <h3>Typing with Utility Types</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    stock: number;
}

function ProductManager() {
    const [products, setProducts] = useState&lt;Product[]&gt;([]);
    
    // Using Partial for updates
    const updateProduct = useCallback((
        id: number, 
        updates: Partial&lt;Product&gt;
    ): void => {
        setProducts(prev => prev.map(p => 
            p.id === id ? { ...p, ...updates } : p
        ));
    }, []);
    
    // Using Pick to select specific fields
    const updatePrice = useCallback((
        id: number,
        priceUpdate: Pick&lt;Product, 'price'&gt;
    ): void => {
        setProducts(prev => prev.map(p =>
            p.id === id ? { ...p, price: priceUpdate.price } : p
        ));
    }, []);
    
    // Using Omit to exclude fields
    const createProduct = useCallback((
        product: Omit&lt;Product, 'id'&gt;
    ): void => {
        const newProduct: Product = {
            ...product,
            id: Date.now()
        };
        setProducts(prev => [...prev, newProduct]);
    }, []);
    
    return &lt;div&gt;{/* UI */}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Typing Hook Dependencies</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface SearchOptions {
    query: string;
    filters: string[];
    sortBy: string;
}

function SearchComponent({ options }: { options: SearchOptions }) {
    // Dependencies are type-checked
    const results = useMemo(() => {
        return performSearch(options);
    }, [options]); // TypeScript ensures 'options' matches the type
    
    // Wrong dependencies cause type errors
    const handleSearch = useCallback(() => {
        console.log(options.query);
    }, []); // ‚ö†Ô∏è TypeScript warns: options should be in dependencies!
    
    // Correct dependencies
    const handleSearchCorrect = useCallback(() => {
        console.log(options.query);
    }, [options]); // ‚úÖ TypeScript is happy
}</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ TypeScript Best Practices</h4>
                    <ul>
                        <li>Let TypeScript infer types when possible - it's usually right</li>
                        <li>Use explicit types for complex return values or when clarity helps</li>
                        <li>Leverage utility types (Partial, Pick, Omit) for flexibility</li>
                        <li>Type event handlers properly (React.ChangeEvent, React.MouseEvent, etc.)</li>
                        <li>Use generics for reusable components and hooks</li>
                        <li>Let TypeScript catch missing or wrong dependencies</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Real-World Examples -->
            <section id="section8" class="lesson-section">
                <h2>üåç Real-World Examples</h2>
                <p>Let's see how useMemo and useCallback work in real production scenarios.</p>

                <h3>Example 1: Data Table with Sorting and Filtering</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface Employee {
    id: number;
    name: string;
    department: string;
    salary: number;
    hireDate: Date;
}

interface DataTableProps {
    employees: Employee[];
}

function EmployeeTable({ employees }: DataTableProps) {
    const [searchTerm, setSearchTerm] = useState('');
    const [sortField, setSortField] = useState&lt;keyof Employee&gt;('name');
    const [sortDirection, setSortDirection] = useState&lt;'asc' | 'desc'&gt;('asc');
    const [departmentFilter, setDepartmentFilter] = useState('all');
    
    // Memoize filtered and sorted data
    const processedEmployees = useMemo(() => {
        console.log('Processing employees...');
        
        // Filter by search term
        let filtered = employees.filter(emp =>
            emp.name.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        // Filter by department
        if (departmentFilter !== 'all') {
            filtered = filtered.filter(emp => emp.department === departmentFilter);
        }
        
        // Sort
        filtered.sort((a, b) => {
            const aVal = a[sortField];
            const bVal = b[sortField];
            
            if (typeof aVal === 'string' && typeof bVal === 'string') {
                return sortDirection === 'asc' 
                    ? aVal.localeCompare(bVal)
                    : bVal.localeCompare(aVal);
            }
            
            if (typeof aVal === 'number' && typeof bVal === 'number') {
                return sortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            }
            
            return 0;
        });
        
        return filtered;
    }, [employees, searchTerm, sortField, sortDirection, departmentFilter]);
    
    // Memoize sort handler
    const handleSort = useCallback((field: keyof Employee) => {
        if (field === sortField) {
            setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
        } else {
            setSortField(field);
            setSortDirection('asc');
        }
    }, [sortField]);
    
    // Get unique departments for filter
    const departments = useMemo(() => {
        const depts = new Set(employees.map(e => e.department));
        return Array.from(depts);
    }, [employees]);
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                placeholder="Search employees..."
            /&gt;
            
            &lt;select 
                value={departmentFilter}
                onChange={(e) => setDepartmentFilter(e.target.value)}
            &gt;
                &lt;option value="all"&gt;All Departments&lt;/option&gt;
                {departments.map(dept => (
                    &lt;option key={dept} value={dept}&gt;{dept}&lt;/option&gt;
                ))}
            &lt;/select&gt;
            
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th onClick={() => handleSort('name')}&gt;Name&lt;/th&gt;
                        &lt;th onClick={() => handleSort('department')}&gt;Department&lt;/th&gt;
                        &lt;th onClick={() => handleSort('salary')}&gt;Salary&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {processedEmployees.map(emp => (
                        &lt;tr key={emp.id}&gt;
                            &lt;td&gt;{emp.name}&lt;/td&gt;
                            &lt;td&gt;{emp.department}&lt;/td&gt;
                            &lt;td&gt;${emp.salary.toLocaleString()}&lt;/td&gt;
                        &lt;/tr&gt;
                    ))}
                &lt;/tbody&gt;
            &lt;/table&gt;
            
            &lt;p&gt;Showing {processedEmployees.length} of {employees.length} employees&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Example 2: Shopping Cart with Calculations</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface CartItem {
    id: number;
    name: string;
    price: number;
    quantity: number;
    taxRate: number;
}

interface CartSummary {
    subtotal: number;
    tax: number;
    total: number;
    itemCount: number;
}

function ShoppingCart() {
    const [items, setItems] = useState&lt;CartItem[]&gt;([]);
    const [discountCode, setDiscountCode] = useState('');
    
    // Calculate cart summary
    const summary = useMemo&lt;CartSummary&gt;(() => {
        const subtotal = items.reduce(
            (sum, item) => sum + (item.price * item.quantity), 
            0
        );
        
        const tax = items.reduce(
            (sum, item) => sum + (item.price * item.quantity * item.taxRate),
            0
        );
        
        const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
        
        let total = subtotal + tax;
        
        // Apply discount
        if (discountCode === 'SAVE10') {
            total *= 0.9;
        }
        
        return { subtotal, tax, total, itemCount };
    }, [items, discountCode]);
    
    // Memoized update handlers
    const updateQuantity = useCallback((id: number, quantity: number) => {
        setItems(prev => prev.map(item =>
            item.id === id ? { ...item, quantity: Math.max(0, quantity) } : item
        ));
    }, []);
    
    const removeItem = useCallback((id: number) => {
        setItems(prev => prev.filter(item => item.id !== id));
    }, []);
    
    const clearCart = useCallback(() => {
        setItems([]);
        setDiscountCode('');
    }, []);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Shopping Cart ({summary.itemCount} items)&lt;/h2&gt;
            
            {items.map(item => (
                &lt;CartItemRow
                    key={item.id}
                    item={item}
                    onUpdateQuantity={updateQuantity}
                    onRemove={removeItem}
                /&gt;
            ))}
            
            &lt;div className="cart-summary"&gt;
                &lt;p&gt;Subtotal: ${summary.subtotal.toFixed(2)}&lt;/p&gt;
                &lt;p&gt;Tax: ${summary.tax.toFixed(2)}&lt;/p&gt;
                &lt;p&gt;Total: ${summary.total.toFixed(2)}&lt;/p&gt;
            &lt;/div&gt;
            
            &lt;input
                type="text"
                value={discountCode}
                onChange={(e) => setDiscountCode(e.target.value.toUpperCase())}
                placeholder="Discount code"
            /&gt;
            
            &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;
        &lt;/div&gt;
    );
}

// Memoized child component
const CartItemRow = React.memo(({ 
    item, 
    onUpdateQuantity, 
    onRemove 
}: {
    item: CartItem;
    onUpdateQuantity: (id: number, quantity: number) => void;
    onRemove: (id: number) => void;
}) => {
    console.log(`Rendering cart item: ${item.name}`);
    
    return (
        &lt;div className="cart-item"&gt;
            &lt;span&gt;{item.name}&lt;/span&gt;
            &lt;span&gt;${item.price.toFixed(2)}&lt;/span&gt;
            &lt;input
                type="number"
                value={item.quantity}
                onChange={(e) => onUpdateQuantity(item.id, Number(e.target.value))}
                min="0"
            /&gt;
            &lt;span&gt;${(item.price * item.quantity).toFixed(2)}&lt;/span&gt;
            &lt;button onClick={() => onRemove(item.id)}&gt;Remove&lt;/button&gt;
        &lt;/div&gt;
    );
});</code></pre>
                </div>

                <h3>Example 3: Search with Debouncing</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface SearchResult {
    id: number;
    title: string;
    description: string;
}

function SearchWithDebounce() {
    const [query, setQuery] = useState('');
    const [debouncedQuery, setDebouncedQuery] = useState('');
    const [results, setResults] = useState&lt;SearchResult[]&gt;([]);
    const [isSearching, setIsSearching] = useState(false);
    
    // Debounce the search query
    useEffect(() => {
        const timer = setTimeout(() => {
            setDebouncedQuery(query);
        }, 500);
        
        return () => clearTimeout(timer);
    }, [query]);
    
    // Memoized search function
    const performSearch = useCallback(async (searchQuery: string) => {
        if (!searchQuery.trim()) {
            setResults([]);
            return;
        }
        
        setIsSearching(true);
        try {
            const response = await fetch(`/api/search?q=${searchQuery}`);
            const data: SearchResult[] = await response.json();
            setResults(data);
        } catch (error) {
            console.error('Search failed:', error);
            setResults([]);
        } finally {
            setIsSearching(false);
        }
    }, []);
    
    // Execute search when debounced query changes
    useEffect(() => {
        performSearch(debouncedQuery);
    }, [debouncedQuery, performSearch]);
    
    // Memoized highlight function
    const highlightMatch = useCallback((text: string, query: string): string => {
        if (!query) return text;
        
        const regex = new RegExp(`(${query})`, 'gi');
        return text.replace(regex, '&lt;mark&gt;$1&lt;/mark&gt;');
    }, []);
    
    // Memoized filtered results (client-side refinement)
    const displayResults = useMemo(() => {
        return results.slice(0, 10); // Show top 10
    }, [results]);
    
    return (
        &lt;div&gt;
            &lt;input
                type="search"
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                placeholder="Search..."
            /&gt;
            
            {isSearching && &lt;p&gt;Searching...&lt;/p&gt;}
            
            &lt;div className="results"&gt;
                {displayResults.map(result => (
                    &lt;div key={result.id} className="result"&gt;
                        &lt;h3 dangerouslySetInnerHTML={{
                            __html: highlightMatch(result.title, query)
                        }} /&gt;
                        &lt;p&gt;{result.description}&lt;/p&gt;
                    &lt;/div&gt;
                ))}
            &lt;/div&gt;
            
            {!isSearching && query && displayResults.length === 0 && (
                &lt;p&gt;No results found for "{query}"&lt;/p&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Example 4: Form Validation with Complex Rules</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">interface FormData {
    email: string;
    password: string;
    confirmPassword: string;
    age: number;
    terms: boolean;
}

interface ValidationErrors {
    [key: string]: string;
}

function RegistrationForm() {
    const [formData, setFormData] = useState&lt;FormData&gt;({
        email: '',
        password: '',
        confirmPassword: '',
        age: 0,
        terms: false
    });
    
    // Memoized validation
    const errors = useMemo&lt;ValidationErrors&gt;(() => {
        const newErrors: ValidationErrors = {};
        
        // Email validation
        if (formData.email && !formData.email.includes('@')) {
            newErrors.email = 'Invalid email address';
        }
        
        // Password strength
        if (formData.password && formData.password.length < 8) {
            newErrors.password = 'Password must be at least 8 characters';
        }
        
        if (formData.password && !/[A-Z]/.test(formData.password)) {
            newErrors.password = 'Password must contain uppercase letter';
        }
        
        // Password match
        if (formData.confirmPassword && 
            formData.password !== formData.confirmPassword) {
            newErrors.confirmPassword = 'Passwords do not match';
        }
        
        // Age validation
        if (formData.age && formData.age < 18) {
            newErrors.age = 'Must be 18 or older';
        }
        
        // Terms
        if (!formData.terms) {
            newErrors.terms = 'You must accept the terms';
        }
        
        return newErrors;
    }, [formData]);
    
    // Check if form is valid
    const isValid = useMemo(() => {
        return Object.keys(errors).length === 0 &&
               formData.email &&
               formData.password &&
               formData.confirmPassword &&
               formData.age > 0;
    }, [errors, formData]);
    
    // Memoized field update handler
    const updateField = useCallback((field: keyof FormData, value: any) => {
        setFormData(prev => ({ ...prev, [field]: value }));
    }, []);
    
    // Memoized submit handler
    const handleSubmit = useCallback((e: React.FormEvent) => {
        e.preventDefault();
        
        if (!isValid) {
            alert('Please fix errors before submitting');
            return;
        }
        
        console.log('Submitting:', formData);
        // API call here
    }, [isValid, formData]);
    
    return (
        &lt;form onSubmit={handleSubmit}&gt;
            &lt;div&gt;
                &lt;input
                    type="email"
                    value={formData.email}
                    onChange={(e) => updateField('email', e.target.value)}
                    placeholder="Email"
                /&gt;
                {errors.email && &lt;span className="error"&gt;{errors.email}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="password"
                    value={formData.password}
                    onChange={(e) => updateField('password', e.target.value)}
                    placeholder="Password"
                /&gt;
                {errors.password && &lt;span className="error"&gt;{errors.password}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="password"
                    value={formData.confirmPassword}
                    onChange={(e) => updateField('confirmPassword', e.target.value)}
                    placeholder="Confirm Password"
                /&gt;
                {errors.confirmPassword && 
                    &lt;span className="error"&gt;{errors.confirmPassword}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;input
                    type="number"
                    value={formData.age || ''}
                    onChange={(e) => updateField('age', Number(e.target.value))}
                    placeholder="Age"
                /&gt;
                {errors.age && &lt;span className="error"&gt;{errors.age}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;div&gt;
                &lt;label&gt;
                    &lt;input
                        type="checkbox"
                        checked={formData.terms}
                        onChange={(e) => updateField('terms', e.target.checked)}
                    /&gt;
                    I accept the terms and conditions
                &lt;/label&gt;
                {errors.terms && &lt;span className="error"&gt;{errors.terms}&lt;/span&gt;}
            &lt;/div&gt;
            
            &lt;button type="submit" disabled={!isValid}&gt;
                Register
            &lt;/button&gt;
        &lt;/form&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Real-World Patterns</h4>
                    <ul>
                        <li><strong>Data tables:</strong> useMemo for filtering/sorting large datasets</li>
                        <li><strong>Shopping carts:</strong> useMemo for totals, useCallback for item operations</li>
                        <li><strong>Search:</strong> useCallback for debounced searches, useMemo for results processing</li>
                        <li><strong>Forms:</strong> useMemo for validation, useCallback for field updates</li>
                        <li><strong>Dashboards:</strong> useMemo for aggregated statistics from large datasets</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Performance Profiling -->
            <section id="section9" class="lesson-section">
                <h2>üìä Performance Profiling</h2>
                <p>Before you optimize, you need to measure! Let's learn how to profile your React app and identify real performance bottlenecks.</p>

                <h3>React DevTools Profiler</h3>
                <p>React DevTools includes a Profiler that shows you exactly what's rendering and how long it takes.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Setting Up React DevTools Profiler</h4>
                    <ol>
                        <li>Install React DevTools browser extension</li>
                        <li>Open your React app in development mode</li>
                        <li>Open browser DevTools ‚Üí React Profiler tab</li>
                        <li>Click the record button (‚è∫Ô∏è)</li>
                        <li>Interact with your app</li>
                        <li>Click stop (‚èπÔ∏è) to see results</li>
                    </ol>
                </div>

                <h3>Reading Profiler Results</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Add console.log to see re-renders
function MyComponent({ data }: { data: number[] }) {
    console.log('MyComponent rendered');
    
    const sortedData = useMemo(() => {
        console.log('Sorting data...');
        return [...data].sort((a, b) => a - b);
    }, [data]);
    
    return &lt;div&gt;{sortedData.join(', ')}&lt;/div&gt;;
}

// Without useMemo:
// Parent re-renders ‚Üí "MyComponent rendered" + "Sorting data..."
// With useMemo:
// Parent re-renders ‚Üí "MyComponent rendered" only (sorting skipped!)</code></pre>
                </div>

                <h3>Using the Profiler API</h3>
                <p>React provides a Profiler component to programmatically measure performance:</p>

                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">import { Profiler, ProfilerOnRenderCallback } from 'react';

function App() {
    const onRenderCallback: ProfilerOnRenderCallback = (
        id, // Component name
        phase, // "mount" or "update"
        actualDuration, // Time spent rendering
        baseDuration, // Estimated time without memoization
        startTime, // When render started
        commitTime // When render committed
    ) => {
        console.log(`${id} (${phase}): ${actualDuration}ms`);
        
        if (actualDuration > 100) {
            console.warn(`Slow render detected in ${id}!`);
        }
    };
    
    return (
        &lt;Profiler id="App" onRender={onRenderCallback}&gt;
            &lt;MyComponent /&gt;
        &lt;/Profiler&gt;
    );
}</code></pre>
                </div>

                <h3>Performance Testing Pattern</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">function PerformanceTest() {
    const [data] = useState(() => 
        Array.from({ length: 10000 }, (_, i) => i)
    );
    const [trigger, setTrigger] = useState(0);
    
    // Test WITHOUT useMemo
    console.time('Without useMemo');
    const sortedWithout = [...data].sort((a, b) => b - a);
    console.timeEnd('Without useMemo');
    
    // Test WITH useMemo
    console.time('With useMemo');
    const sortedWith = useMemo(() => {
        return [...data].sort((a, b) => b - a);
    }, [data]);
    console.timeEnd('With useMemo');
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => setTrigger(t => t + 1)}&gt;
                Force Re-render ({trigger})
            &lt;/button&gt;
            &lt;p&gt;Check console for timing results&lt;/p&gt;
        &lt;/div&gt;
    );
    
    // First render: Both take similar time
    // Re-renders: useMemo is instant, without is slow!
}</code></pre>
                </div>

                <h3>Measuring Child Re-renders</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Create a render counter
let renderCount = 0;

const ExpensiveChild = React.memo(({ 
    data, 
    onClick 
}: { 
    data: number[]; 
    onClick: () => void 
}) => {
    renderCount++;
    console.log(`ExpensiveChild render #${renderCount}`);
    
    return (
        &lt;div&gt;
            &lt;p&gt;Rendered {renderCount} times&lt;/p&gt;
            &lt;button onClick={onClick}&gt;Click&lt;/button&gt;
        &lt;/div&gt;
    );
});

function Parent() {
    const [count, setCount] = useState(0);
    const data = [1, 2, 3];
    
    // Without useCallback
    // const handleClick = () => console.log('clicked');
    
    // With useCallback
    const handleClick = useCallback(() => {
        console.log('clicked');
    }, []);
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => setCount(c => c + 1)}&gt;
                Parent count: {count}
            &lt;/button&gt;
            &lt;ExpensiveChild data={data} onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}

// Without useCallback: Child re-renders every time parent count changes
// With useCallback: Child only renders once!</code></pre>
                </div>

                <h3>Browser Performance Tab</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Using Browser Performance Tools</h4>
                    <ol>
                        <li>Open Chrome DevTools ‚Üí Performance tab</li>
                        <li>Click record, interact with your app, then stop</li>
                        <li>Look for:
                            <ul>
                                <li><strong>Long tasks:</strong> JavaScript execution over 50ms</li>
                                <li><strong>Excessive re-renders:</strong> Many React commits</li>
                                <li><strong>Layout thrashing:</strong> Repeated layout calculations</li>
                            </ul>
                        </li>
                        <li>Identify expensive functions in the flame graph</li>
                        <li>Optimize those specific areas</li>
                    </ol>
                </div>

                <h3>Before and After Comparison</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// Create a performance comparison
function PerformanceComparison() {
    const [withMemo, setWithMemo] = useState(true);
    const [data] = useState(() => 
        Array.from({ length: 50000 }, (_, i) => ({
            id: i,
            value: Math.random()
        }))
    );
    
    const startTime = performance.now();
    
    // Version WITH useMemo
    const processedWithMemo = useMemo(() => {
        return data
            .filter(item => item.value > 0.5)
            .sort((a, b) => b.value - a.value)
            .slice(0, 100);
    }, [data]);
    
    // Version WITHOUT useMemo
    const processedWithout = data
        .filter(item => item.value > 0.5)
        .sort((a, b) => b.value - a.value)
        .slice(0, 100);
    
    const endTime = performance.now();
    const duration = endTime - startTime;
    
    const result = withMemo ? processedWithMemo : processedWithout;
    
    return (
        &lt;div&gt;
            &lt;button onClick={() => setWithMemo(!withMemo)}&gt;
                Toggle: {withMemo ? 'WITH' : 'WITHOUT'} useMemo
            &lt;/button&gt;
            &lt;p&gt;Render time: {duration.toFixed(2)}ms&lt;/p&gt;
            &lt;p&gt;Items: {result.length}&lt;/p&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Profiling Best Practices</h4>
                    <ul>
                        <li>Always profile in production mode for accurate results</li>
                        <li>Profile with realistic data volumes (not just 10 items!)</li>
                        <li>Test on lower-end devices, not just your powerful dev machine</li>
                        <li>Compare before and after optimization to confirm improvement</li>
                        <li>Focus on the 80/20 rule - optimize the biggest bottlenecks first</li>
                        <li>Don't optimize based on assumptions - measure first!</li>
                    </ul>
                </div>
            </section>

            <!-- Section 10: Hands-on Practice -->
            <section id="section10" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Practice</h2>
                <p>Time to apply what you've learned! Complete these exercises to master useMemo and useCallback.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Optimize a Product Filter</h3>
                    <p><strong>Goal:</strong> Use useMemo to optimize filtering and sorting a product list.</p>
                    
                    <p><strong>Starting Code:</strong></p>
                    <details>
                        <summary>View Starting Code</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">interface Product {
    id: number;
    name: string;
    price: number;
    category: string;
    rating: number;
}

function ProductList({ products }: { products: Product[] }) {
    const [searchTerm, setSearchTerm] = useState('');
    const [minPrice, setMinPrice] = useState(0);
    const [sortBy, setSortBy] = useState&lt;'price' | 'rating'&gt;('price');
    
    // üî¥ OPTIMIZE THIS - it runs every render!
    const filteredProducts = products
        .filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()))
        .filter(p => p.price >= minPrice)
        .sort((a, b) => b[sortBy] - a[sortBy]);
    
    return (
        &lt;div&gt;
            &lt;input 
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                placeholder="Search..."
            /&gt;
            &lt;input
                type="number"
                value={minPrice}
                onChange={e => setMinPrice(Number(e.target.value))}
                placeholder="Min price"
            /&gt;
            &lt;select value={sortBy} onChange={e => setSortBy(e.target.value as any)}&gt;
                &lt;option value="price"&gt;Price&lt;/option&gt;
                &lt;option value="rating"&gt;Rating&lt;/option&gt;
            &lt;/select&gt;
            {filteredProducts.map(p => (
                &lt;div key={p.id}&gt;{p.name} - ${p.price}&lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Wrap the filtering and sorting logic in useMemo with proper dependencies: [products, searchTerm, minPrice, sortBy]</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">function ProductList({ products }: { products: Product[] }) {
    const [searchTerm, setSearchTerm] = useState('');
    const [minPrice, setMinPrice] = useState(0);
    const [sortBy, setSortBy] = useState&lt;'price' | 'rating'&gt;('price');
    
    // ‚úÖ Optimized with useMemo
    const filteredProducts = useMemo(() => {
        console.log('Filtering and sorting products...');
        return products
            .filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()))
            .filter(p => p.price >= minPrice)
            .sort((a, b) => b[sortBy] - a[sortBy]);
    }, [products, searchTerm, minPrice, sortBy]);
    
    return (
        &lt;div&gt;
            &lt;input 
                value={searchTerm}
                onChange={e => setSearchTerm(e.target.value)}
                placeholder="Search..."
            /&gt;
            &lt;input
                type="number"
                value={minPrice}
                onChange={e => setMinPrice(Number(e.target.value))}
                placeholder="Min price"
            /&gt;
            &lt;select value={sortBy} onChange={e => setSortBy(e.target.value as any)}&gt;
                &lt;option value="price"&gt;Price&lt;/option&gt;
                &lt;option value="rating"&gt;Rating&lt;/option&gt;
            &lt;/select&gt;
            {filteredProducts.map(p => (
                &lt;div key={p.id}&gt;{p.name} - ${p.price}&lt;/div&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Fix Unnecessary Child Re-renders</h3>
                    <p><strong>Goal:</strong> Use useCallback to prevent unnecessary re-renders of memoized children.</p>
                    
                    <p><strong>Starting Code:</strong></p>
                    <details>
                        <summary>View Starting Code</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">const TaskItem = React.memo(({ 
    task, 
    onToggle, 
    onDelete 
}: {
    task: { id: number; text: string; done: boolean };
    onToggle: (id: number) => void;
    onDelete: (id: number) => void;
}) => {
    console.log(`Rendering task: ${task.text}`);
    return (
        &lt;div&gt;
            &lt;input
                type="checkbox"
                checked={task.done}
                onChange={() => onToggle(task.id)}
            /&gt;
            &lt;span&gt;{task.text}&lt;/span&gt;
            &lt;button onClick={() => onDelete(task.id)}&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
    );
});

function TaskList() {
    const [tasks, setTasks] = useState([
        { id: 1, text: 'Learn React', done: false },
        { id: 2, text: 'Learn TypeScript', done: true }
    ]);
    const [newTask, setNewTask] = useState('');
    
    // üî¥ PROBLEM: These recreate on every render
    const handleToggle = (id: number) => {
        setTasks(prev => prev.map(t => 
            t.id === id ? { ...t, done: !t.done } : t
        ));
    };
    
    const handleDelete = (id: number) => {
        setTasks(prev => prev.filter(t => t.id !== id));
    };
    
    return (
        &lt;div&gt;
            &lt;input 
                value={newTask}
                onChange={e => setNewTask(e.target.value)}
            /&gt;
            {tasks.map(task => (
                &lt;TaskItem
                    key={task.id}
                    task={task}
                    onToggle={handleToggle}
                    onDelete={handleDelete}
                /&gt;
            ))}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>

                    <details>
                        <summary>üí° Hint</summary>
                        <p>Wrap handleToggle and handleDelete with useCallback. Since they use functional updates (prev =&gt;), they don't need any dependencies!</p>
                    </details>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">function TaskList() {
    const [tasks, setTasks] = useState([
        { id: 1, text: 'Learn React', done: false },
        { id: 2, text: 'Learn TypeScript', done: true }
    ]);
    const [newTask, setNewTask] = useState('');
    
    // ‚úÖ Optimized with useCallback
    const handleToggle = useCallback((id: number) => {
        setTasks(prev => prev.map(t => 
            t.id === id ? { ...t, done: !t.done } : t
        ));
    }, []); // No dependencies needed with functional update!
    
    const handleDelete = useCallback((id: number) => {
        setTasks(prev => prev.filter(t => t.id !== id));
    }, []);
    
    return (
        &lt;div&gt;
            &lt;input 
                value={newTask}
                onChange={e => setNewTask(e.target.value)}
            /&gt;
            {tasks.map(task => (
                &lt;TaskItem
                    key={task.id}
                    task={task}
                    onToggle={handleToggle}
                    onDelete={handleDelete}
                /&gt;
            ))}
        &lt;/div&gt;
    );
}

// Now typing in the input doesn't re-render all TaskItems!</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Build a Data Dashboard</h3>
                    <p><strong>Goal:</strong> Create a dashboard that efficiently calculates statistics from a large dataset.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Display total count, average, min, max, and sum</li>
                        <li>Allow filtering by value range</li>
                        <li>Use useMemo for all calculations</li>
                        <li>Handle datasets with 10,000+ numbers</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">function DataDashboard() {
    const [data] = useState(() => 
        Array.from({ length: 10000 }, () => Math.random() * 1000)
    );
    const [minFilter, setMinFilter] = useState(0);
    const [maxFilter, setMaxFilter] = useState(1000);
    
    // Filter data
    const filteredData = useMemo(() => {
        console.log('Filtering data...');
        return data.filter(n => n >= minFilter && n <= maxFilter);
    }, [data, minFilter, maxFilter]);
    
    // Calculate statistics
    const stats = useMemo(() => {
        console.log('Calculating statistics...');
        
        if (filteredData.length === 0) {
            return { count: 0, avg: 0, min: 0, max: 0, sum: 0 };
        }
        
        const sum = filteredData.reduce((acc, val) => acc + val, 0);
        const avg = sum / filteredData.length;
        const min = Math.min(...filteredData);
        const max = Math.max(...filteredData);
        
        return { count: filteredData.length, avg, min, max, sum };
    }, [filteredData]);
    
    return (
        &lt;div&gt;
            &lt;h2&gt;Data Dashboard&lt;/h2&gt;
            
            &lt;div&gt;
                &lt;label&gt;Min: &lt;input
                    type="number"
                    value={minFilter}
                    onChange={e => setMinFilter(Number(e.target.value))}
                /&gt;&lt;/label&gt;
                
                &lt;label&gt;Max: &lt;input
                    type="number"
                    value={maxFilter}
                    onChange={e => setMaxFilter(Number(e.target.value))}
                /&gt;&lt;/label&gt;
            &lt;/div&gt;
            
            &lt;div className="stats"&gt;
                &lt;p&gt;Count: {stats.count}&lt;/p&gt;
                &lt;p&gt;Average: {stats.avg.toFixed(2)}&lt;/p&gt;
                &lt;p&gt;Min: {stats.min.toFixed(2)}&lt;/p&gt;
                &lt;p&gt;Max: {stats.max.toFixed(2)}&lt;/p&gt;
                &lt;p&gt;Sum: {stats.sum.toFixed(2)}&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Challenge: Build an Optimized Autocomplete</h3>
                    <p><strong>Goal:</strong> Create a performant autocomplete component that searches through 1000+ items.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Search through array of 1000+ strings</li>
                        <li>Show top 10 matches</li>
                        <li>Highlight matching text</li>
                        <li>Optimize with useMemo and useCallback</li>
                        <li>Handle keyboard navigation (up/down arrows)</li>
                    </ul>

                    <details>
                        <summary>‚úÖ Solution</summary>
                        <div class="code-block">
                            <button class="copy-button">Copy</button>
                            <pre><code class="language-typescript">function Autocomplete({ items }: { items: string[] }) {
    const [query, setQuery] = useState('');
    const [selectedIndex, setSelectedIndex] = useState(0);
    const [isOpen, setIsOpen] = useState(false);
    
    // Search and filter
    const matches = useMemo(() => {
        if (!query) return [];
        
        console.log('Searching...');
        return items
            .filter(item => 
                item.toLowerCase().includes(query.toLowerCase())
            )
            .slice(0, 10); // Top 10 results
    }, [items, query]);
    
    // Highlight helper
    const highlightMatch = useCallback((text: string, query: string) => {
        if (!query) return text;
        
        const parts = text.split(new RegExp(`(${query})`, 'gi'));
        return parts.map((part, i) => 
            part.toLowerCase() === query.toLowerCase()
                ? `&lt;mark&gt;${part}&lt;/mark&gt;`
                : part
        ).join('');
    }, []);
    
    // Keyboard navigation
    const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
        if (!isOpen) return;
        
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            setSelectedIndex(i => Math.min(i + 1, matches.length - 1));
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setSelectedIndex(i => Math.max(i - 1, 0));
        } else if (e.key === 'Enter' && matches[selectedIndex]) {
            setQuery(matches[selectedIndex]);
            setIsOpen(false);
        }
    }, [isOpen, matches, selectedIndex]);
    
    return (
        &lt;div&gt;
            &lt;input
                value={query}
                onChange={e => {
                    setQuery(e.target.value);
                    setIsOpen(true);
                    setSelectedIndex(0);
                }}
                onKeyDown={handleKeyDown}
                placeholder="Search..."
            /&gt;
            
            {isOpen && matches.length > 0 && (
                &lt;ul&gt;
                    {matches.map((match, i) => (
                        &lt;li
                            key={i}
                            className={i === selectedIndex ? 'selected' : ''}
                            onClick={() => {
                                setQuery(match);
                                setIsOpen(false);
                            }}
                            dangerouslySetInnerHTML={{
                                __html: highlightMatch(match, query)
                            }}
                        /&gt;
                    ))}
                &lt;/ul&gt;
            )}
        &lt;/div&gt;
    );
}</code></pre>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Section 11: Best Practices -->
            <section id="section11" class="lesson-section">
                <h2>‚úÖ Best Practices</h2>
                <p>Follow these guidelines to use useMemo and useCallback effectively.</p>

                <h3>‚úÖ Do's</h3>
                <ul>
                    <li><strong>Measure first:</strong> Profile your app before optimizing - don't guess</li>
                    <li><strong>Use for expensive operations:</strong> Large list operations, complex calculations</li>
                    <li><strong>Optimize child re-renders:</strong> Use useCallback with React.memo'd children</li>
                    <li><strong>List all dependencies:</strong> React DevTools will warn you about missing ones</li>
                    <li><strong>Use functional updates:</strong> Avoid dependencies when possible with setState(prev => ...)</li>
                    <li><strong>Document why you're memoizing:</strong> Add comments explaining the optimization</li>
                    <li><strong>Memoize expensive custom hooks:</strong> If a hook does heavy calculations</li>
                    <li><strong>Use with Context providers:</strong> Memoize context values to prevent cascade re-renders</li>
                    <li><strong>Combine with React.memo:</strong> Maximum benefit when child is memoized too</li>
                    <li><strong>Test the optimization:</strong> Verify it actually improves performance</li>
                </ul>

                <h3>‚ùå Don'ts</h3>
                <ul>
                    <li><strong>Don't memoize everything:</strong> It adds overhead and complexity</li>
                    <li><strong>Don't use for simple calculations:</strong> Adding two numbers doesn't need useMemo</li>
                    <li><strong>Don't memoize primitives:</strong> Numbers, strings, booleans are cheap</li>
                    <li><strong>Don't use with changing dependencies:</strong> If deps change every render, memoization does nothing</li>
                    <li><strong>Don't forget dependencies:</strong> Missing deps cause stale closures</li>
                    <li><strong>Don't optimize prematurely:</strong> Build first, measure, then optimize</li>
                    <li><strong>Don't use for every callback:</strong> Only callbacks passed to memoized children</li>
                    <li><strong>Don't memoize state setters:</strong> They're already stable (setState from useState)</li>
                    <li><strong>Don't use without React.memo:</strong> useCallback alone doesn't prevent re-renders</li>
                    <li><strong>Don't sacrifice readability:</strong> If code becomes hard to understand, optimization isn't worth it</li>
                </ul>

                <h3>üí° Pro Tips</h3>
                <ul>
                    <li><strong>Start with useMemo, add useCallback as needed:</strong> Value optimization often matters more</li>
                    <li><strong>Use ESLint plugin:</strong> Install eslint-plugin-react-hooks for dependency warnings</li>
                    <li><strong>Profile in production mode:</strong> Development mode has extra overhead</li>
                    <li><strong>Consider code splitting first:</strong> Sometimes lazy loading helps more than memoization</li>
                    <li><strong>Virtualize long lists:</strong> Use libraries like react-window for huge lists</li>
                    <li><strong>Debounce user input:</strong> Combine with useMemo for search/filter scenarios</li>
                    <li><strong>Memoize context values:</strong> Prevents all consumers from re-rendering</li>
                    <li><strong>Use Web Workers for heavy calculations:</strong> Move expensive work off main thread</li>
                    <li><strong>Cache API responses:</strong> Combine with React Query or SWR for better performance</li>
                    <li><strong>Remember the cost:</strong> Each useMemo/useCallback has a small overhead</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéØ Optimization Priority</h4>
                    <ol>
                        <li><strong>First:</strong> Fix algorithm inefficiencies (O(n¬≤) ‚Üí O(n))</li>
                        <li><strong>Second:</strong> Code splitting and lazy loading</li>
                        <li><strong>Third:</strong> Virtualization for long lists</li>
                        <li><strong>Fourth:</strong> Memoization with useMemo/useCallback</li>
                        <li><strong>Fifth:</strong> Web Workers for CPU-intensive tasks</li>
                    </ol>
                    <p>Memoization is powerful, but it's not always the first solution!</p>
                </div>
            </section>

            <!-- Section 12: Common Mistakes -->
            <section id="section12" class="lesson-section">
                <h2>‚ö†Ô∏è Common Mistakes to Avoid</h2>
                <p>Learn from these common pitfalls so you don't have to make them yourself!</p>

                <h3>Mistake 1: Missing Dependencies</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - missing dependency
function Component({ userId }: { userId: number }) {
    const [data, setData] = useState(null);
    
    const fetchData = useCallback(async () => {
        const response = await fetch(`/api/user/${userId}`);
        setData(await response.json());
    }, []); // Missing userId!
    
    // fetchData always uses the INITIAL userId value!
}

// ‚úÖ Good - include all dependencies
function Component({ userId }: { userId: number }) {
    const [data, setData] = useState(null);
    
    const fetchData = useCallback(async () => {
        const response = await fetch(`/api/user/${userId}`);
        setData(await response.json());
    }, [userId]); // Correct!
}</code></pre>
                </div>

                <h3>Mistake 2: Memoizing Everything</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - over-optimization
function Component({ name, age }: { name: string; age: number }) {
    const greeting = useMemo(() => `Hello ${name}`, [name]); // Overkill!
    const isAdult = useMemo(() => age >= 18, [age]); // Overkill!
    const doubleAge = useMemo(() => age * 2, [age]); // Overkill!
    
    return &lt;div&gt;{greeting} - Adult: {isAdult ? 'Yes' : 'No'}&lt;/div&gt;;
}

// ‚úÖ Good - keep it simple
function Component({ name, age }: { name: string; age: number }) {
    const greeting = `Hello ${name}`; // Instant!
    const isAdult = age >= 18; // Instant!
    const doubleAge = age * 2; // Instant!
    
    return &lt;div&gt;{greeting} - Adult: {isAdult ? 'Yes' : 'No'}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Mistake 3: Wrong Dependencies</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - dependency that always changes
function Component({ config }: { config: { theme: string } }) {
    // config is a new object every render!
    const theme = useMemo(() => {
        return config.theme.toUpperCase();
    }, [config]); // This recalculates every time anyway!
    
    return &lt;div&gt;{theme}&lt;/div&gt;;
}

// ‚úÖ Good - depend on primitive value
function Component({ config }: { config: { theme: string } }) {
    const theme = useMemo(() => {
        return config.theme.toUpperCase();
    }, [config.theme]); // Only recalculate when theme string changes
    
    return &lt;div&gt;{theme}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Mistake 4: useCallback Without React.memo</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - useCallback is pointless here
const RegularChild = ({ onClick }: { onClick: () => void }) => {
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
};

function Parent() {
    const [count, setCount] = useState(0);
    
    // Pointless - RegularChild re-renders anyway!
    const handleClick = useCallback(() => {
        console.log('clicked');
    }, []);
    
    return (
        &lt;div&gt;
            &lt;p&gt;{count}&lt;/p&gt;
            &lt;button onClick={() => setCount(c => c + 1)}&gt;+&lt;/button&gt;
            &lt;RegularChild onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}

// ‚úÖ Good - useCallback with React.memo
const MemoizedChild = React.memo(({ onClick }: { onClick: () => void }) => {
    console.log('Child rendered');
    return &lt;button onClick={onClick}&gt;Click&lt;/button&gt;;
});

function Parent() {
    const [count, setCount] = useState(0);
    
    // Now it prevents MemoizedChild from re-rendering!
    const handleClick = useCallback(() => {
        console.log('clicked');
    }, []);
    
    return (
        &lt;div&gt;
            &lt;p&gt;{count}&lt;/p&gt;
            &lt;button onClick={() => setCount(c => c + 1)}&gt;+&lt;/button&gt;
            &lt;MemoizedChild onClick={handleClick} /&gt;
        &lt;/div&gt;
    );
}</code></pre>
                </div>

                <h3>Mistake 5: Comparing Objects/Arrays</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - creating new array/object in dependencies
function Component({ items }: { items: number[] }) {
    const processed = useMemo(() => {
        return items.map(i => i * 2);
    }, [items.filter(i => i > 0)]); // New array every time!
    
    // This never uses the cached value!
}

// ‚úÖ Good - stable dependencies
function Component({ items }: { items: number[] }) {
    // Filter first, then memoize
    const positiveItems = useMemo(() => 
        items.filter(i => i > 0), [items]);
    
    const processed = useMemo(() => 
        positiveItems.map(i => i * 2), [positiveItems]);
    
    return &lt;div&gt;{processed.join(', ')}&lt;/div&gt;;
}</code></pre>
                </div>

                <h3>Mistake 6: Premature Optimization</h3>
                <div class="code-block">
                    <button class="copy-button">Copy</button>
                    <pre><code class="language-typescript">// ‚ùå Bad - optimizing before measuring
function SmallComponent() {
    const [items] = useState([1, 2, 3, 4, 5]); // Only 5 items!
    
    // Pointless optimization for tiny array
    const doubled = useMemo(() => 
        items.map(i => i * 2), [items]);
    
    return &lt;div&gt;{doubled.join(', ')}&lt;/div&gt;;
}

// ‚úÖ Good - no optimization needed
function SmallComponent() {
    const [items] = useState([1, 2, 3, 4, 5]);
    
    // So cheap, just do it!
    const doubled = items.map(i => i * 2);
    
    return &lt;div&gt;{doubled.join(', ')}&lt;/div&gt;;
}</code></pre>
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Remember</h4>
                    <ul>
                        <li>Include ALL dependencies - ESLint will help you</li>
                        <li>Don't optimize every function and value</li>
                        <li>Depend on primitives when possible, not objects/arrays</li>
                        <li>useCallback only helps with React.memo'd children</li>
                        <li>Don't create new objects/arrays in dependency arrays</li>
                        <li>Measure before you optimize - "premature optimization is the root of all evil"</li>
                    </ul>
                </div>
            </section>

            <!-- Section 13: Summary -->
            <section id="section13" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>useMemo memoizes values</strong> - caches the result of expensive calculations</li>
                        <li><strong>useCallback memoizes functions</strong> - caches function references to prevent recreation</li>
                        <li><strong>Both prevent unnecessary recalculations</strong> - only recompute when dependencies change</li>
                        <li><strong>Memoization isn't free</strong> - it has memory and comparison costs</li>
                        <li><strong>Measure before optimizing</strong> - profile your app to find real bottlenecks</li>
                        <li><strong>Use for expensive operations</strong> - large lists, complex calculations, heavy processing</li>
                        <li><strong>useCallback needs React.memo</strong> - combine with memoized children for best results</li>
                        <li><strong>Dependencies matter</strong> - missing or wrong deps cause bugs</li>
                        <li><strong>Don't optimize everything</strong> - simple operations don't benefit from memoization</li>
                        <li><strong>TypeScript ensures type safety</strong> - catches dependency and type errors at compile time</li>
                    </ul>
                </div>

                <h3>üìä Quick Comparison</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>useMemo</th>
                            <th>useCallback</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Memoizes</strong></td>
                            <td>Return value</td>
                            <td>Function reference</td>
                        </tr>
                        <tr>
                            <td><strong>Returns</strong></td>
                            <td>Computed value</td>
                            <td>Function itself</td>
                        </tr>
                        <tr>
                            <td><strong>Use case</strong></td>
                            <td>Expensive calculations</td>
                            <td>Stable callbacks</td>
                        </tr>
                        <tr>
                            <td><strong>Best with</strong></td>
                            <td>Heavy data processing</td>
                            <td>React.memo children</td>
                        </tr>
                        <tr>
                            <td><strong>Example</strong></td>
                            <td>Filter/sort 10,000 items</td>
                            <td>onClick handler for memoized child</td>
                        </tr>
                        <tr>
                            <td><strong>Syntax</strong></td>
                            <td>useMemo(() => value, [deps])</td>
                            <td>useCallback(() => {}, [deps])</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üéØ When to Use Decision Tree</h3>
                <div class="mermaid">
                graph TD
                    A[Performance Issue?] --> B{Measured the problem?}
                    B -->|No| C[Profile first!]
                    B -->|Yes| D{What's the issue?}
                    
                    D --> E[Expensive calculation]
                    D --> F[Child re-renders]
                    D --> G[Frequent re-renders]
                    
                    E --> H{How expensive?}
                    H -->|100ms+| I[‚úÖ useMemo]
                    H -->|&lt;1ms| J[‚ùå No optimization needed]
                    
                    F --> K{Child memoized?}
                    K -->|Yes| L[‚úÖ useCallback]
                    K -->|No| M[Memoize child first]
                    
                    G --> N{What's re-rendering?}
                    N --> O[Parent] --> P[‚úÖ React.memo parent]
                    N --> Q[Large list] --> R[‚úÖ Virtualization]
                    
                    style I fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style L fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style P fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style R fill:#48bb78,stroke:#333,stroke-width:2px,color:#fff
                    style J fill:#f093fb,stroke:#333,stroke-width:2px
                    style M fill:#ffc107,stroke:#333,stroke-width:2px
                </graph>
                </div>

                <h3>üîë Key Patterns</h3>
                <div class="card">
                    <h4>Pattern 1: Filtering and Sorting</h4>
                    <pre><code class="language-typescript">const filtered = useMemo(() => 
    data.filter(predicate).sort(compareFn),
    [data, predicate, compareFn]
);</code></pre>
                </div>

                <div class="card">
                    <h4>Pattern 2: Complex Calculations</h4>
                    <pre><code class="language-typescript">const stats = useMemo(() => ({
    sum: data.reduce((a, b) => a + b, 0),
    avg: data.reduce((a, b) => a + b) / data.length,
    max: Math.max(...data)
}), [data]);</code></pre>
                </div>

                <div class="card">
                    <h4>Pattern 3: Stable Callbacks for Memoized Children</h4>
                    <pre><code class="language-typescript">const handleClick = useCallback((id: number) => {
    setItems(prev => prev.filter(item => item.id !== id));
}, []);

return &lt;MemoizedChild onDelete={handleClick} /&gt;;</code></pre>
                </div>

                <div class="card">
                    <h4>Pattern 4: Derived State</h4>
                    <pre><code class="language-typescript">const activeItems = useMemo(() => 
    items.filter(item => item.active),
    [items]
);

const itemCount = useMemo(() => 
    activeItems.length,
    [activeItems]
);</code></pre>
                </div>

                <h3>üö´ Anti-Patterns to Avoid</h3>
                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <ul>
                        <li>‚ùå Memoizing simple primitives: <code>useMemo(() => 2 + 2, [])</code></li>
                        <li>‚ùå Missing dependencies: <code>useMemo(() => data.filter(x => x > threshold), [data])</code></li>
                        <li>‚ùå useCallback without React.memo child</li>
                        <li>‚ùå Creating objects in dependency array: <code>[{ config }]</code></li>
                        <li>‚ùå Optimizing before measuring</li>
                        <li>‚ùå Memoizing every single function and value</li>
                    </ul>
                </div>

                <h3>üéì What You've Learned</h3>
                <p>Congratulations! You now understand:</p>
                <ul>
                    <li>‚úÖ How React's rendering works and when performance matters</li>
                    <li>‚úÖ What memoization is and how it trades memory for speed</li>
                    <li>‚úÖ How to use useMemo to cache expensive calculations</li>
                    <li>‚úÖ How to use useCallback to memoize function references</li>
                    <li>‚úÖ The differences between useMemo and useCallback</li>
                    <li>‚úÖ When to use (and when NOT to use) these hooks</li>
                    <li>‚úÖ How to properly type memoized values with TypeScript</li>
                    <li>‚úÖ Real-world patterns for data tables, carts, search, and forms</li>
                    <li>‚úÖ How to profile and measure performance improvements</li>
                    <li>‚úÖ Best practices and common mistakes to avoid</li>
                </ul>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://react.dev/reference/react/useMemo" target="_blank" rel="noopener">React useMemo Documentation</a></li>
                    <li><a href="https://react.dev/reference/react/useCallback" target="_blank" rel="noopener">React useCallback Documentation</a></li>
                    <li><a href="https://react.dev/reference/react/memo" target="_blank" rel="noopener">React.memo Documentation</a></li>
                    <li><a href="https://kentcdodds.com/blog/usememo-and-usecallback" target="_blank" rel="noopener">Kent C. Dodds - When to useMemo and useCallback</a></li>
                    <li><a href="https://www.developerway.com/posts/how-to-use-memo-use-callback" target="_blank" rel="noopener">Advanced Guide to React Performance</a></li>
                    <li><a href="https://web.dev/react/" target="_blank" rel="noopener">Web.dev - Optimize React Performance</a></li>
                    <li><a href="https://reactjs.org/docs/optimizing-performance.html" target="_blank" rel="noopener">Optimizing Performance - React Docs</a></li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>Compound Components Pattern</strong> - an advanced pattern for building flexible, reusable component APIs. You'll learn how to create component systems that work together seamlessly, sharing state implicitly while maintaining clean, intuitive interfaces. Perfect for building libraries like tabs, accordions, and dropdowns!</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Practice Challenge</h3>
                    <p style="color: white;">Before moving on, try building one of these projects to solidify your understanding:</p>
                    <ul style="color: white;">
                        <li><strong>Optimized Data Grid:</strong> Build a sortable, filterable table with 10,000+ rows that stays smooth</li>
                        <li><strong>Real-Time Dashboard:</strong> Create a dashboard that processes streaming data without lag</li>
                        <li><strong>Advanced Search:</strong> Build a search with filters, facets, and instant results on 1000+ items</li>
                        <li><strong>Shopping Cart:</strong> Create a cart with complex calculations (tax, shipping, discounts) that updates instantly</li>
                        <li><strong>Performance Optimizer:</strong> Take an existing slow component and optimize it with useMemo/useCallback</li>
                    </ul>
                </div>

                <h3>üí° Final Thoughts</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <p><strong>Remember the golden rule:</strong> React is already fast! Most apps don't need heavy optimization. But when you do hit performance bottlenecks, useMemo and useCallback are powerful tools in your arsenal.</p>
                    <p>The key is knowing when to use them:</p>
                    <ul>
                        <li>‚úÖ <strong>Do</strong> optimize when you measure a real problem</li>
                        <li>‚úÖ <strong>Do</strong> use for expensive operations on large datasets</li>
                        <li>‚úÖ <strong>Do</strong> combine with React.memo for maximum benefit</li>
                        <li>‚ùå <strong>Don't</strong> optimize everything "just in case"</li>
                        <li>‚ùå <strong>Don't</strong> use for simple, cheap operations</li>
                        <li>‚ùå <strong>Don't</strong> sacrifice code clarity for micro-optimizations</li>
                    </ul>
                    <p>Build first, measure second, optimize third. Happy coding! üöÄ</p>
                </div>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've mastered React's performance optimization hooks! You now understand how to identify performance bottlenecks, measure their impact, and optimize strategically with useMemo and useCallback. This knowledge will help you build fast, responsive React applications that scale. Remember: premature optimization is the root of all evil, but smart optimization at the right time is pure gold. You've got the skills - now go build something amazing! üí™</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_5_3_useref_hook.html" class="prev-lesson">‚Üê Previous: Lesson 5.3 - useRef Hook</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_5_5_compound_components.html" class="next-lesson">Next: Lesson 5.5 - Compound Components Pattern ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to build amazing React applications with TypeScript.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
