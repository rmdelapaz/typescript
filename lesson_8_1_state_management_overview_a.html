<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Understand state management in React applications. Learn when to use local vs global state, explore state management libraries, architectural patterns, and how to select the right tool for your application.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.1: State Management Overview - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.1: State Management Overview</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üèóÔ∏è Lesson 8.1: State Management Overview</h1>
                <p class="lead">Welcome to Module 8! As your React applications grow, managing state becomes increasingly challenging. What starts as simple useState calls can evolve into prop drilling nightmares, performance bottlenecks, and maintenance headaches. In this lesson, you'll learn to recognize different types of state, understand when to use various state management solutions, and make informed architectural decisions that scale with your application.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Distinguish between local state, shared state, server state, and URL state</li>
                        <li>Identify when to keep state local vs. when to lift it up</li>
                        <li>Understand the trade-offs between different state management solutions</li>
                        <li>Recognize the signs that your application needs a state management library</li>
                        <li>Compare popular state management libraries and their use cases</li>
                        <li>Apply architectural patterns for organizing application state</li>
                        <li>Select the right state management tool for your specific needs</li>
                        <li>Plan a scalable state management strategy from the beginning</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Prerequisites:</strong> Modules 1-7, especially Module 5 (Advanced Hooks and Patterns)</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">What is State Management?</a></li>
                        <li><a href="#section2" class="toc-link">Types of State in React Applications</a></li>
                        <li><a href="#section3" class="toc-link">Local vs Global State</a></li>
                        <li><a href="#section4" class="toc-link">Common State Management Problems</a></li>
                        <li><a href="#section5" class="toc-link">State Management Solutions Landscape</a></li>
                        <li><a href="#section6" class="toc-link">Comparing State Management Libraries</a></li>
                        <li><a href="#section7" class="toc-link">Architectural Patterns</a></li>
                        <li><a href="#section8" class="toc-link">Decision Framework</a></li>
                        <li><a href="#section9" class="toc-link">Best Practices</a></li>
                        <li><a href="#section10" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: What is State Management? -->
            <section id="section1" class="lesson-section">
                <h2>ü§î What is State Management?</h2>
                
                <p>Before diving into different solutions, let's establish what we mean by "state" and why managing it effectively is crucial to building maintainable React applications.</p>

                <h3>Defining State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>State</strong> is any data that changes over time in your application. It represents the current "snapshot" of your application at any given moment‚Äîwhat the user sees, what data has been loaded, what the user has selected, and so on.</p>
                </div>

                <p>Think of state as your application's memory. Just as you remember what you had for breakfast or what tabs you have open in your browser, your application needs to "remember" things like:</p>

                <ul>
                    <li>Is the user logged in?</li>
                    <li>What items are in the shopping cart?</li>
                    <li>Which theme is active (light or dark)?</li>
                    <li>Is a modal currently open?</li>
                    <li>What data did we fetch from the API?</li>
                    <li>What text is the user typing in the search box?</li>
                </ul>

                <h3>Why State Management Matters</h3>

                <p>As applications grow, managing state becomes one of the most challenging aspects of frontend development. Here's why:</p>

                <div class="mermaid">
                    graph TB
                    A[State Management Challenges] --> B[Synchronization]
                    A --> C[Performance]
                    A --> D[Debugging]
                    A --> E[Maintainability]
                    
                    B --> B1[Multiple components need same data]
                    B --> B2[Keeping UI in sync with state]
                    B --> B3[Avoiding stale data]
                    
                    C --> C1[Unnecessary re-renders]
                    C --> C2[Large component trees]
                    C --> C3[Frequent updates]
                    
                    D --> D1[Where did this value come from?]
                    D --> D2[Why did this component re-render?]
                    D --> D3[What changed this state?]
                    
                    E --> E1[Prop drilling]
                    E --> E2[Scattered state logic]
                    E --> E3[Hard to understand data flow]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>The Evolution of an Application's State</h3>

                <p>Let's look at how state management evolves as an application grows:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Application Size</th>
                            <th>State Complexity</th>
                            <th>Typical Solution</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Small</strong><br/>(1-5 components)</td>
                            <td>Simple, contained</td>
                            <td>Local useState</td>
                            <td>Counter, toggle button</td>
                        </tr>
                        <tr>
                            <td><strong>Medium</strong><br/>(5-20 components)</td>
                            <td>Shared between siblings</td>
                            <td>Lifting state up, props</td>
                            <td>Todo list, simple form</td>
                        </tr>
                        <tr>
                            <td><strong>Large</strong><br/>(20-50 components)</td>
                            <td>Many distant components need access</td>
                            <td>Context API, custom hooks</td>
                            <td>E-commerce cart, user auth</td>
                        </tr>
                        <tr>
                            <td><strong>Very Large</strong><br/>(50+ components)</td>
                            <td>Complex interdependencies</td>
                            <td>State management library (Zustand, Redux)</td>
                            <td>Admin dashboard, social media app</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Insight</h4>
                    <p>State management isn't about choosing a fancy library‚Äîit's about making data flow in your application predictable, debuggable, and maintainable. The best state management solution is often the simplest one that solves your specific problems.</p>
                </div>

                <h3>State Management Goals</h3>

                <p>Good state management should achieve these goals:</p>

                <ol>
                    <li><strong>Predictability:</strong> Given the same state and actions, the application behaves the same way</li>
                    <li><strong>Maintainability:</strong> Easy to understand, modify, and extend</li>
                    <li><strong>Debuggability:</strong> Easy to trace state changes and identify bugs</li>
                    <li><strong>Performance:</strong> Efficient updates without unnecessary re-renders</li>
                    <li><strong>Developer Experience:</strong> Pleasant to work with, good TypeScript support</li>
                    <li><strong>Testability:</strong> Easy to test state logic in isolation</li>
                </ol>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ The Golden Rule</h4>
                    <p><strong>Start simple, scale when needed.</strong> Don't reach for Redux on day one if useState and props work fine. But also don't hesitate to refactor when you feel pain points. The best architecture evolves with your application's needs.</p>
                </div>
            </section>

            <!-- Section 2: Types of State in React Applications -->
            <section id="section2" class="lesson-section">
                <h2>üéØ Types of State in React Applications</h2>
                
                <p>Not all state is created equal. Understanding the different categories of state helps you choose the right management approach for each type.</p>

                <h3>The Four Categories of State</h3>

                <div class="mermaid">
                    graph LR
                    A[Application State] --> B[Local State]
                    A --> C[Shared State]
                    A --> D[Server State]
                    A --> E[URL State]
                    
                    B --> B1[Component-specific]
                    C --> C1[Multiple components]
                    D --> D1[From backend APIs]
                    E --> E1[From URL params]
                    
                    style A fill:#667eea,color:#fff
                </div>

                <h3>1. Local State (UI State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Local state</strong> is data that only a single component (and possibly its children) needs to know about. It's ephemeral, lives only as long as the component is mounted, and doesn't need to be shared globally.</p>
                </div>

                <p><strong>Examples of local state:</strong></p>
                <ul>
                    <li>Form input values (before submission)</li>
                    <li>Is a dropdown menu open?</li>
                    <li>Current tab in a tabbed interface</li>
                    <li>Is a tooltip visible?</li>
                    <li>Hover state of a button</li>
                </ul>

                <p><strong>Best managed with:</strong> <code>useState</code>, <code>useReducer</code></p>

                <pre><code class="language-typescript">// Example: Local state for a dropdown
function Dropdown({ options }: DropdownProps) {
  const [isOpen, setIsOpen] = useState(false);
  const [selected, setSelected] = useState&lt;string | null&gt;(null);

  return (
    &lt;div&gt;
      &lt;button onClick={() => setIsOpen(!isOpen)}&gt;
        {selected || 'Select an option'}
      &lt;/button&gt;
      {isOpen && (
        &lt;ul&gt;
          {options.map(option => (
            &lt;li 
              key={option.value}
              onClick={() => {
                setSelected(option.label);
                setIsOpen(false);
              }}
            &gt;
              {option.label}
            &lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Local State</h4>
                    <p><strong>Use local state when:</strong> Only one component needs it, it doesn't persist when unmounted, and it doesn't need to be synchronized with other parts of the app.</p>
                </div>

                <h3>2. Shared State (Application State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Shared state</strong> is data that multiple components across your application need access to. It typically persists longer than a single component's lifecycle and needs to stay synchronized.</p>
                </div>

                <p><strong>Examples of shared state:</strong></p>
                <ul>
                    <li>User authentication status</li>
                    <li>Current theme (light/dark mode)</li>
                    <li>Shopping cart items</li>
                    <li>Notification system</li>
                    <li>Active language/locale</li>
                    <li>Sidebar collapsed/expanded state</li>
                </ul>

                <p><strong>Best managed with:</strong> Context API, Zustand, Redux, Jotai</p>

                <pre><code class="language-typescript">// Example: Shared state with Context
interface ThemeContextType {
  theme: 'light' | 'dark';
  toggleTheme: () => void;
}

const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState&lt;'light' | 'dark'&gt;('light');

  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };

  return (
    &lt;ThemeContext.Provider value={{ theme, toggleTheme }}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// Used anywhere in the app
function Header() {
  const { theme, toggleTheme } = useContext(ThemeContext)!;
  
  return (
    &lt;header className={theme}&gt;
      &lt;button onClick={toggleTheme}&gt;
        {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      &lt;/button&gt;
    &lt;/header&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Shared State</h4>
                    <p><strong>Use shared state when:</strong> Multiple components in different parts of the tree need the same data, the data needs to persist across route changes, or you're experiencing "prop drilling" pain.</p>
                </div>

                <h3>3. Server State (Remote State)</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Server state</strong> is data that originates from a remote server and is cached on the client. It's unique because you don't fully control it‚Äîthe server is the source of truth, and your local copy might be stale.</p>
                </div>

                <p><strong>Examples of server state:</strong></p>
                <ul>
                    <li>User profile data fetched from API</li>
                    <li>List of products in an e-commerce store</li>
                    <li>Blog posts and articles</li>
                    <li>Real-time data (stock prices, chat messages)</li>
                    <li>Search results</li>
                </ul>

                <p><strong>Unique characteristics of server state:</strong></p>
                <ul>
                    <li>Asynchronous by nature</li>
                    <li>Can become stale and need refreshing</li>
                    <li>Multiple components may request the same data</li>
                    <li>Needs error handling and loading states</li>
                    <li>May need caching and invalidation strategies</li>
                    <li>Can have race conditions</li>
                </ul>

                <p><strong>Best managed with:</strong> React Query (TanStack Query), SWR, RTK Query, Apollo Client (for GraphQL)</p>

                <pre><code class="language-typescript">// Example: Server state with React Query
import { useQuery } from '@tanstack/react-query';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile({ userId }: { userId: number }) {
  const { data, isLoading, error } = useQuery&lt;User&gt;({
    queryKey: ['user', userId],
    queryFn: async () => {
      const response = await fetch(`/api/users/${userId}`);
      if (!response.ok) throw new Error('Failed to fetch user');
      return response.json();
    },
    staleTime: 5 * 60 * 1000, // Data is fresh for 5 minutes
  });

  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (error) return &lt;div&gt;Error: {error.message}&lt;/div&gt;;

  return (
    &lt;div&gt;
      &lt;h1&gt;{data.name}&lt;/h1&gt;
      &lt;p&gt;{data.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Mistake</h4>
                    <p>Don't treat server state the same as client state! Putting API data in Redux/Zustand forces you to manually handle loading states, caching, refetching, and cache invalidation‚Äîall things that specialized libraries do automatically.</p>
                </div>

                <h3>4. URL State</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>URL state</strong> is information stored in the URL itself‚Äîincluding the pathname, query parameters, and hash. It's special because it's shareable, bookmarkable, and survives page refreshes.</p>
                </div>

                <p><strong>Examples of URL state:</strong></p>
                <ul>
                    <li>Current page/route</li>
                    <li>Search query</li>
                    <li>Filter and sort parameters</li>
                    <li>Selected tab</li>
                    <li>Pagination state</li>
                    <li>Modal or dialog state (for deep linking)</li>
                </ul>

                <p><strong>Best managed with:</strong> React Router, Next.js router, browser URLSearchParams API</p>

                <pre><code class="language-typescript">// Example: URL state with React Router
import { useSearchParams } from 'react-router-dom';

function ProductList() {
  const [searchParams, setSearchParams] = useSearchParams();
  
  const category = searchParams.get('category') || 'all';
  const sortBy = searchParams.get('sort') || 'name';
  const page = Number(searchParams.get('page')) || 1;

  const updateFilters = (newCategory: string) => {
    setSearchParams({
      category: newCategory,
      sort: sortBy,
      page: '1' // Reset to first page on filter change
    });
  };

  return (
    &lt;div&gt;
      &lt;h2&gt;Products - {category}&lt;/h2&gt;
      &lt;select value={category} onChange={e => updateFilters(e.target.value)}&gt;
        &lt;option value="all"&gt;All Products&lt;/option&gt;
        &lt;option value="electronics"&gt;Electronics&lt;/option&gt;
        &lt;option value="clothing"&gt;Clothing&lt;/option&gt;
      &lt;/select&gt;
      {/* Product list here */}
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use URL State</h4>
                    <p><strong>Use URL state when:</strong> Users should be able to share or bookmark the current view, state should persist through refreshes, or you want browser back/forward buttons to work naturally.</p>
                </div>

                <h3>State Type Comparison</h3>

                <table>
                    <thead>
                        <tr>
                            <th>State Type</th>
                            <th>Lifespan</th>
                            <th>Scope</th>
                            <th>Persistence</th>
                            <th>Best Tool</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Local</strong></td>
                            <td>Component mount</td>
                            <td>Single component</td>
                            <td>Lost on unmount</td>
                            <td>useState</td>
                        </tr>
                        <tr>
                            <td><strong>Shared</strong></td>
                            <td>App lifecycle</td>
                            <td>Multiple components</td>
                            <td>While app is running</td>
                            <td>Context/Zustand/Redux</td>
                        </tr>
                        <tr>
                            <td><strong>Server</strong></td>
                            <td>Configurable cache</td>
                            <td>Global (cached)</td>
                            <td>Managed by library</td>
                            <td>React Query/SWR</td>
                        </tr>
                        <tr>
                            <td><strong>URL</strong></td>
                            <td>Until navigation</td>
                            <td>Global (in URL)</td>
                            <td>Survives refresh</td>
                            <td>React Router</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip</h4>
                    <p>Many state management problems can be solved by simply using the right type of state. For example, if you're putting search filters in Redux, consider using URL params instead‚Äîthey're more user-friendly and require zero extra code for persistence!</p>
                </div>
            </section>

            <!-- Section 3: Local vs Global State -->
            <section id="section3" class="lesson-section">
                <h2>‚öñÔ∏è Local vs Global State</h2>
                
                <p>One of the most important architectural decisions in React is determining where state should live. Let's explore the principles and patterns for making this decision.</p>

                <h3>The Principle of Colocation</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Colocation Principle</h4>
                    <p style="color: white;"><strong>"State should live as close as possible to where it's used."</strong></p>
                    <p style="color: white;">This means keeping state local by default and only "lifting it up" when multiple components genuinely need to share it.</p>
                </div>

                <h3>Why Colocation Matters</h3>

                <p>Keeping state local has several benefits:</p>

                <ol>
                    <li><strong>Easier to understand:</strong> The state and the components that use it are in the same file</li>
                    <li><strong>Better performance:</strong> State changes only re-render the components that need to update</li>
                    <li><strong>Simpler testing:</strong> Components with local state are self-contained and easier to test</li>
                    <li><strong>Easier refactoring:</strong> Moving or removing components doesn't affect distant parts of the app</li>
                    <li><strong>Less cognitive load:</strong> You don't need to understand the entire app to work on one component</li>
                </ol>

                <h3>When to Keep State Local</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Keep State Local When</h4>
                    <ul>
                        <li>Only one component (and maybe its children) needs the state</li>
                        <li>The state is UI-specific (hover, focus, open/closed)</li>
                        <li>The state doesn't need to persist when the component unmounts</li>
                        <li>The state isn't needed by sibling components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Good: Local state for accordion
function Accordion({ items }: { items: Item[] }) {
  const [openIndex, setOpenIndex] = useState&lt;number | null&gt;(null);

  return (
    &lt;div&gt;
      {items.map((item, index) => (
        &lt;div key={item.id}&gt;
          &lt;button onClick={() => setOpenIndex(index === openIndex ? null : index)}&gt;
            {item.title}
          &lt;/button&gt;
          {openIndex === index && &lt;div&gt;{item.content}&lt;/div&gt;}
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>When to Lift State Up</h3>

                <p>Sometimes state needs to be "lifted up" to a common ancestor so multiple components can access it:</p>

                <div class="mermaid">
                    graph TB
                    A[Parent Component<br/>State Lives Here] --> B[Child A<br/>Reads State]
                    A --> C[Child B<br/>Updates State]
                    A --> D[Child C<br/>Reads State]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#4CAF50,color:#fff
                    style C fill:#FFA726,color:#fff
                    style D fill:#4CAF50,color:#fff
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Lift State Up When</h4>
                    <ul>
                        <li>Multiple sibling components need the same state</li>
                        <li>One component needs to update state that another component displays</li>
                        <li>Parent needs to coordinate behavior between children</li>
                        <li>State needs to be synchronized across components</li>
                    </ul>
                </div>

                <pre><code class="language-typescript">// Example: Lifting state up
function SearchPage() {
  // State lifted to parent so both children can access it
  const [searchQuery, setSearchQuery] = useState('');
  const [results, setResults] = useState&lt;Result[]&gt;([]);

  return (
    &lt;div&gt;
      {/* Child A updates the state */}
      &lt;SearchBar 
        value={searchQuery} 
        onChange={setSearchQuery}
        onSearch={() => fetchResults(searchQuery).then(setResults)}
      /&gt;
      
      {/* Child B reads the state */}
      &lt;SearchResults 
        query={searchQuery} 
        results={results} 
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>The Prop Drilling Problem</h3>

                <p>When you lift state too high or need to pass it through many layers of components, you encounter "prop drilling":</p>

                <pre><code class="language-typescript">// ‚ùå Prop drilling problem
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return &lt;Layout user={user} setUser={setUser} /&gt;;
}

function Layout({ user, setUser }: LayoutProps) {
  return (
    &lt;div&gt;
      &lt;Sidebar user={user} setUser={setUser} /&gt;
      &lt;Content user={user} /&gt;
    &lt;/div&gt;
  );
}

function Sidebar({ user, setUser }: SidebarProps) {
  return (
    &lt;nav&gt;
      &lt;UserMenu user={user} setUser={setUser} /&gt;
    &lt;/nav&gt;
  );
}

function UserMenu({ user, setUser }: UserMenuProps) {
  // Finally using it here!
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>

                <p><strong>Problems with prop drilling:</strong></p>
                <ul>
                    <li>Intermediate components need props they don't use (Layout, Sidebar)</li>
                    <li>Hard to refactor‚Äîchanging prop names affects many files</li>
                    <li>Makes component trees rigid and brittle</li>
                    <li>TypeScript types become verbose and repetitive</li>
                </ul>

                <h3>Solutions to Prop Drilling</h3>

                <p>When prop drilling becomes painful, consider these solutions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Solution</th>
                            <th>When to Use</th>
                            <th>Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Component Composition</strong></td>
                            <td>Layout components, wrapper components</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>Context API</strong></td>
                            <td>Theme, auth, 2-5 globally shared values</td>
                            <td>Low-Medium</td>
                        </tr>
                        <tr>
                            <td><strong>Custom Hooks</strong></td>
                            <td>Shared logic with local state</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td><strong>State Library</strong></td>
                            <td>Many global values, complex updates</td>
                            <td>Medium-High</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Component Composition Pattern</h3>

                <p>Often overlooked, component composition can eliminate prop drilling without any state management library:</p>

                <pre><code class="language-typescript">// ‚úÖ Better: Component composition
function App() {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  
  return (
    &lt;Layout
      sidebar={&lt;Sidebar userMenu={&lt;UserMenu user={user} setUser={setUser} /&gt;} /&gt;}
      content={&lt;Content user={user} /&gt;}
    /&gt;
  );
}

function Layout({ sidebar, content }: LayoutProps) {
  // No user props needed!
  return (
    &lt;div&gt;
      {sidebar}
      {content}
    &lt;/div&gt;
  );
}

function Sidebar({ userMenu }: SidebarProps) {
  // No user props needed!
  return &lt;nav&gt;{userMenu}&lt;/nav&gt;;
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Decision Tree</h4>
                    <ol>
                        <li><strong>Start:</strong> Keep state in the component that needs it</li>
                        <li><strong>If siblings need it:</strong> Lift to common parent</li>
                        <li><strong>If prop drilling 3+ levels:</strong> Try component composition</li>
                        <li><strong>If composition doesn't help:</strong> Use Context or state library</li>
                    </ol>
                </div>
            </section>

            <!-- Section 4: Common State Management Problems -->
            <section id="section4" class="lesson-section">
                <h2>üö® Common State Management Problems</h2>
                
                <p>As applications grow, certain state management patterns emerge. Recognizing these problems helps you know when it's time to refactor or adopt a different approach.</p>

                <h3>Problem 1: Prop Drilling Hell</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>You're passing props through 4+ levels of components that don't use them, just to get data to deeply nested children.</p>
                </div>

                <p><strong>Signs you have this problem:</strong></p>
                <ul>
                    <li>Components have props they don't use, only pass through</li>
                    <li>Changing a prop name requires editing many files</li>
                    <li>Adding a new prop requires touching many components</li>
                    <li>Component function signatures are getting long and unwieldy</li>
                </ul>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use Context API for truly global data (theme, auth)</li>
                    <li>Apply component composition to avoid prop threading</li>
                    <li>Consider a state management library if you have many such cases</li>
                </ul>

                <h3>Problem 2: Scattered State Updates</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>The same piece of state is being updated in many different places, making it hard to track down bugs.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Cart state updated in many places
function ProductCard({ product }: ProductCardProps) {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = () => {
    setCart([...cart, { ...product, quantity: 1 }]);
  };
  
  return &lt;button onClick={addToCart}&gt;Add to Cart&lt;/button&gt;;
}

function CartButton() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const clearCart = () => {
    setCart([]);
  };
  
  return &lt;button onClick={clearCart}&gt;Clear Cart&lt;/button&gt;;
}

// Updates also in CartItem, CheckoutForm, etc...</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Create custom hooks that encapsulate update logic</li>
                    <li>Use useReducer to centralize state updates</li>
                    <li>Use a state library with action creators</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Centralized updates via custom hook
function useCart() {
  const [cart, setCart] = useContext(CartContext)!;
  
  const addToCart = (product: Product) => {
    setCart(prev => [...prev, { ...product, quantity: 1 }]);
  };
  
  const removeFromCart = (productId: string) => {
    setCart(prev => prev.filter(item => item.id !== productId));
  };
  
  const clearCart = () => {
    setCart([]);
  };
  
  return { cart, addToCart, removeFromCart, clearCart };
}

// Now components only call the hook methods
function ProductCard({ product }: ProductCardProps) {
  const { addToCart } = useCart();
  return &lt;button onClick={() => addToCart(product)}&gt;Add&lt;/button&gt;;
}</code></pre>

                <h3>Problem 3: Stale Closures</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Event handlers or effects are using old values of state, causing unexpected behavior.</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Stale closure
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      console.log('Count:', count); // Always logs 0!
      setCount(count + 1); // Always sets to 1!
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Empty deps = stale closure
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use functional updates: <code>setCount(prev => prev + 1)</code></li>
                    <li>Include dependencies in useEffect array</li>
                    <li>Use useRef for values you want to reference but not trigger re-renders</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Functional update
function Counter() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setCount(prev => {
        console.log('Count:', prev);
        return prev + 1;
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, []); // Now safe with empty deps
  
  return &lt;div&gt;{count}&lt;/div&gt;;
}</code></pre>

                <h3>Problem 4: Race Conditions</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Async operations complete out of order, causing the wrong data to be displayed (e.g., search results for an old query showing up after newer results).</p>
                </div>

                <pre><code class="language-typescript">// ‚ùå Problem: Race condition
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    fetchResults(query).then(data => {
      setResults(data); // Might be stale!
    });
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>Use cleanup function to ignore stale responses</li>
                    <li>Use AbortController to cancel old requests</li>
                    <li>Use libraries like React Query that handle this automatically</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Fixed: Cleanup ignores stale results
function SearchResults({ query }: { query: string }) {
  const [results, setResults] = useState&lt;Result[]&gt;([]);
  
  useEffect(() => {
    let ignore = false;
    
    fetchResults(query).then(data => {
      if (!ignore) {
        setResults(data);
      }
    });
    
    return () => {
      ignore = true; // Cleanup: ignore stale response
    };
  }, [query]);
  
  return &lt;ul&gt;{results.map(r => &lt;li key={r.id}&gt;{r.name}&lt;/li&gt;)}&lt;/ul&gt;;
}</code></pre>

                <h3>Problem 5: Unnecessary Re-renders</h3>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Symptom</h4>
                    <p>Components re-render even though the data they display hasn't changed, causing performance problems.</p>
                </div>

                <p><strong>Common causes:</strong></p>
                <ul>
                    <li>Creating new objects/arrays on every render</li>
                    <li>Passing inline functions as props</li>
                    <li>Context value changes on every render</li>
                    <li>Not memoizing expensive computations</li>
                </ul>

                <pre><code class="language-typescript">// ‚ùå Problem: Context re-renders everything
function AppProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const [theme, setTheme] = useState('light');
  
  // New object on every render!
  const value = { user, setUser, theme, setTheme };
  
  return (
    &lt;AppContext.Provider value={value}&gt;
      {children}
    &lt;/AppContext.Provider&gt;
  );
}

// Every component using this context re-renders when ANY value changes!</code></pre>

                <p><strong>Solutions:</strong></p>
                <ul>
                    <li>useMemo to memoize context values</li>
                    <li>Split contexts by concern (UserContext, ThemeContext)</li>
                    <li>Use React.memo for expensive components</li>
                    <li>State management libraries with fine-grained reactivity</li>
                </ul>

                <pre><code class="language-typescript">// ‚úÖ Better: Separate contexts
function UserProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState&lt;User | null&gt;(null);
  const value = useMemo(() => ({ user, setUser }), [user]);
  
  return &lt;UserContext.Provider value={value}&gt;{children}&lt;/UserContext.Provider&gt;;
}

function ThemeProvider({ children }: { children: ReactNode }) {
  const [theme, setTheme] = useState('light');
  const value = useMemo(() => ({ theme, setTheme }), [theme]);
  
  return &lt;ThemeContext.Provider value={value}&gt;{children}&lt;/ThemeContext.Provider&gt;;
}

// Now changing theme doesn't re-render components that only use user!</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When Problems Indicate You Need a Library</h4>
                    <p>If you're experiencing <strong>multiple</strong> of these problems simultaneously, and simple refactoring isn't helping, it's probably time to consider a dedicated state management library.</p>
                </div>
            </section>
