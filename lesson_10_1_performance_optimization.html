<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn performance optimization techniques in React with TypeScript, including React DevTools Profiler, identifying bottlenecks, and optimization strategies.">
    <meta name="author" content="Ray">
    <title>Lesson 10.1: Performance Optimization - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <a href="#main-content" class="skip-link">Skip to main content</a>

    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 10: Advanced Topics and Deployment</a></li>
            <li aria-current="page">Lesson 10.1: Performance Optimization</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üöÄ Lesson 10.1: Performance Optimization</h1>
                <p class="lead">Master the art of building fast, efficient React applications. Learn how to measure performance, identify bottlenecks, and apply optimization techniques that make a real difference.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Use React DevTools Profiler to identify performance issues</li>
                        <li>Understand and measure render performance with Core Web Vitals</li>
                        <li>Implement code splitting for faster initial loads</li>
                        <li>Optimize bundle size and reduce JavaScript payload</li>
                        <li>Apply image optimization techniques and best practices</li>
                        <li>Improve Largest Contentful Paint, First Input Delay, and Cumulative Layout Shift</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Profile and optimize a real React application</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Introduction to Performance Optimization</a></li>
                        <li><a href="#why-performance-matters" class="toc-link">Why Performance Matters</a></li>
                        <li><a href="#measuring-performance" class="toc-link">Measuring Performance</a></li>
                        <li><a href="#react-devtools-profiler" class="toc-link">React DevTools Profiler</a></li>
                        <li><a href="#identifying-bottlenecks" class="toc-link">Identifying Performance Bottlenecks</a></li>
                        <li><a href="#render-optimization" class="toc-link">Render Optimization Strategies</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Introduction to Performance Optimization</h2>
            
            <p>Welcome to Module 10! You've learned a tremendous amount about building React applications with TypeScript. Now it's time to make them <strong>fast</strong>. Performance optimization is what separates good applications from great ones.</p>

            <p>Performance isn't just about making things faster‚Äîit's about creating better user experiences, improving accessibility, and even helping your application rank better in search engines. A slow app loses users, reduces engagement, and can cost your business real money.</p>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ The Performance Mindset</h4>
                <p>Think of performance optimization like tuning a car. You wouldn't start by replacing the engine‚Äîyou'd first identify what's actually slow, measure it, and make targeted improvements. The same principle applies to React applications.</p>
            </div>

            <h3>üìä What We'll Cover in This Lesson</h3>
            
            <p>This lesson focuses on <em>practical, real-world performance optimization</em>. We'll learn to:</p>

            <ol>
                <li><strong>Measure</strong> - Use React DevTools and browser tools to identify slow parts</li>
                <li><strong>Analyze</strong> - Understand what's causing performance problems</li>
                <li><strong>Optimize</strong> - Apply targeted fixes that actually make a difference</li>
                <li><strong>Verify</strong> - Confirm improvements with measurable metrics</li>
            </ol>

            <div class="mermaid">
                graph LR
                    A[Slow App] --> B[Measure Performance]
                    B --> C[Identify Bottlenecks]
                    C --> D[Apply Optimizations]
                    D --> E[Verify Improvements]
                    E --> F[Fast App! üéâ]
                    style A fill:#ffcdd2
                    style F fill:#c8e6c9
                    style B fill:#fff9c4
                    style C fill:#fff9c4
                    style D fill:#b3e5fc
                    style E fill:#b3e5fc
            </div>
        </section>

        <section id="why-performance-matters" aria-labelledby="why-performance-matters-heading">
            <h2 id="why-performance-matters-heading">üí° Why Performance Matters</h2>
            
            <p>Before diving into optimization techniques, let's understand <em>why</em> performance is so critical. It's not just about bragging rights or perfectionism‚Äîit has real, measurable impacts on your application's success.</p>

            <h3>üåç Real-World Impact of Performance</h3>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üìà The Business Case for Performance</h4>
                <p>Research consistently shows that faster websites perform better:</p>
                <ul>
                    <li><strong>Pinterest</strong> reduced load times by 40% and saw a 15% increase in sign-ups</li>
                    <li><strong>BBC</strong> found they lost 10% of users for every additional second of load time</li>
                    <li><strong>Amazon</strong> calculated that every 100ms delay costs them 1% in sales</li>
                    <li><strong>Google</strong> uses page speed as a ranking factor for search results</li>
                </ul>
            </div>

            <h3>üë• User Experience Impact</h3>

            <p>Performance directly affects how users perceive and interact with your application:</p>

            <table>
                <thead>
                    <tr>
                        <th>Load Time</th>
                        <th>User Perception</th>
                        <th>Likely User Action</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>0-1 second</td>
                        <td>Instant, fluid</td>
                        <td>Continues using app confidently</td>
                    </tr>
                    <tr>
                        <td>1-3 seconds</td>
                        <td>Noticeable delay</td>
                        <td>Stays engaged but notices lag</td>
                    </tr>
                    <tr>
                        <td>3-5 seconds</td>
                        <td>Frustrating wait</td>
                        <td>Starts getting impatient</td>
                    </tr>
                    <tr>
                        <td>5-10 seconds</td>
                        <td>Unacceptable</td>
                        <td>Likely to abandon or refresh</td>
                    </tr>
                    <tr>
                        <td>10+ seconds</td>
                        <td>Broken</td>
                        <td>Leaves and may not return</td>
                    </tr>
                </tbody>
            </table>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è The Mobile Reality</h4>
                <p>Most web traffic now comes from mobile devices, often on slower networks. What feels fast on your development laptop with high-speed internet might be painfully slow for real users. Always test on real devices with network throttling!</p>
            </div>

            <h3>‚ôø Accessibility Considerations</h3>

            <p>Performance is an accessibility issue. Users with slower devices, older browsers, or limited data plans are disproportionately affected by poor performance. Optimizing your app makes it more accessible to everyone.</p>

            <pre><code class="language-typescript">// Poor performance example - re-renders on every keystroke
function SlowSearch() {
  const [query, setQuery] = useState('');
  const results = expensiveSearch(query); // üò± Runs on every render!
  
  return (
    &lt;div&gt;
      &lt;input 
        value={query} 
        onChange={(e) =&gt; setQuery(e.target.value)}
      /&gt;
      &lt;SearchResults data={results} /&gt;
    &lt;/div&gt;
  );
}

// Better approach - we'll learn multiple ways to optimize this!
function FastSearch() {
  const [query, setQuery] = useState('');
  const debouncedQuery = useDebounce(query, 300);
  const results = useMemo(
    () =&gt; expensiveSearch(debouncedQuery),
    [debouncedQuery]
  );
  
  return (
    &lt;div&gt;
      &lt;input 
        value={query} 
        onChange={(e) =&gt; setQuery(e.target.value)}
      /&gt;
      &lt;SearchResults data={results} /&gt;
    &lt;/div&gt;
  );
}</code></pre>
        </section>

        <section id="measuring-performance" aria-labelledby="measuring-performance-heading">
            <h2 id="measuring-performance-heading">üìè Measuring Performance</h2>
            
            <p>You can't optimize what you can't measure. The first rule of performance optimization is: <strong>always measure before and after</strong>. Let's explore the tools and metrics we'll use throughout this lesson.</p>

            <h3>üõ†Ô∏è Performance Measurement Tools</h3>

            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h4 style="color: white;">üìñ Essential Performance Tools</h4>
                <ol style="color: white;">
                    <li><strong>React DevTools Profiler</strong> - Measures React component render performance</li>
                    <li><strong>Chrome DevTools Performance Tab</strong> - Low-level browser performance profiling</li>
                    <li><strong>Lighthouse</strong> - Automated performance audits and recommendations</li>
                    <li><strong>Web Vitals</strong> - Real user experience metrics</li>
                    <li><strong>Bundle Analyzers</strong> - Visualize what's in your JavaScript bundles</li>
                </ol>
            </div>

            <h3>üìä Key Performance Metrics</h3>

            <p>Modern web performance centers around Google's <strong>Core Web Vitals</strong>, three metrics that measure real user experience:</p>

            <div class="mermaid">
                graph TD
                    A[Core Web Vitals] --> B[LCP<br/>Largest Contentful Paint]
                    A --> C[FID<br/>First Input Delay]
                    A --> D[CLS<br/>Cumulative Layout Shift]
                    
                    B --> B1[Loading Performance<br/>How fast main content appears<br/>Goal: &lt; 2.5 seconds]
                    C --> C1[Interactivity<br/>How quickly page responds<br/>Goal: &lt; 100 milliseconds]
                    D --> D1[Visual Stability<br/>How much page shifts<br/>Goal: &lt; 0.1]
                    
                    style A fill:#667eea,color:#fff
                    style B fill:#c8e6c9
                    style C fill:#c8e6c9
                    style D fill:#c8e6c9
                    style B1 fill:#e8f5e9
                    style C1 fill:#e8f5e9
                    style D1 fill:#e8f5e9
            </div>

            <h4>üéØ Understanding Each Metric</h4>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Largest Contentful Paint (LCP)</h4>
                <p><strong>What it measures:</strong> How long it takes for the largest visible element (hero image, heading, text block) to appear on screen.</p>
                <p><strong>Why it matters:</strong> Users perceive the page as loaded when they see the main content.</p>
                <p><strong>Good score:</strong> Less than 2.5 seconds</p>
                <p><strong>Common issues:</strong> Large images, render-blocking JavaScript, slow server response times</p>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° First Input Delay (FID)</h4>
                <p><strong>What it measures:</strong> Time from when a user first interacts (click, tap, key press) to when the browser can actually respond.</p>
                <p><strong>Why it matters:</strong> Users get frustrated when buttons don't respond immediately.</p>
                <p><strong>Good score:</strong> Less than 100 milliseconds</p>
                <p><strong>Common issues:</strong> Long JavaScript tasks blocking the main thread</p>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Cumulative Layout Shift (CLS)</h4>
                <p><strong>What it measures:</strong> How much visible content shifts around as the page loads.</p>
                <p><strong>Why it matters:</strong> Unexpected layout shifts cause users to click the wrong things and create a janky experience.</p>
                <p><strong>Good score:</strong> Less than 0.1</p>
                <p><strong>Common issues:</strong> Images without dimensions, web fonts causing text to shift, dynamic content insertion</p>
            </div>

            <h3>üîç Using Lighthouse for Quick Audits</h3>

            <p>Lighthouse is built into Chrome DevTools and provides instant performance insights. Let's learn how to use it:</p>

            <pre><code class="language-typescript">// To run a Lighthouse audit:
// 1. Open Chrome DevTools (F12 or Cmd+Option+I)
// 2. Click the "Lighthouse" tab
// 3. Select "Performance" category
// 4. Click "Analyze page load"

// Lighthouse gives you a score (0-100) and specific recommendations
// like:
// - "Serve images in next-gen formats (WebP)"
// - "Reduce unused JavaScript"
// - "Properly size images"
// - "Eliminate render-blocking resources"</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Pro Tip: Run Multiple Tests</h4>
                <p>Performance can vary based on network conditions, CPU load, and other factors. Always run Lighthouse at least 3 times and look at the average scores. Test on both desktop and mobile, and use "Incognito mode" to avoid browser extensions affecting results.</p>
            </div>

            <h3>üìà Establishing a Performance Baseline</h3>

            <p>Before optimizing anything, establish baseline metrics for your application:</p>

            <pre><code class="language-typescript">// Create a simple performance logging utility
interface PerformanceMetrics {
  lcp: number;
  fid: number;
  cls: number;
  ttfb: number; // Time to First Byte
  fcp: number;  // First Contentful Paint
}

function measureWebVitals(): PerformanceMetrics {
  const metrics: Partial&lt;PerformanceMetrics&gt; = {};
  
  // Measure LCP
  new PerformanceObserver((list) =&gt; {
    const entries = list.getEntries();
    const lastEntry = entries[entries.length - 1];
    metrics.lcp = lastEntry.renderTime || lastEntry.loadTime;
    console.log('LCP:', metrics.lcp);
  }).observe({ entryTypes: ['largest-contentful-paint'] });
  
  // Measure FID
  new PerformanceObserver((list) =&gt; {
    const entries = list.getEntries();
    entries.forEach((entry: any) =&gt; {
      metrics.fid = entry.processingStart - entry.startTime;
      console.log('FID:', metrics.fid);
    });
  }).observe({ entryTypes: ['first-input'] });
  
  // Measure CLS
  let clsValue = 0;
  new PerformanceObserver((list) =&gt; {
    for (const entry of list.getEntries() as any[]) {
      if (!entry.hadRecentInput) {
        clsValue += entry.value;
      }
    }
    metrics.cls = clsValue;
    console.log('CLS:', metrics.cls);
  }).observe({ entryTypes: ['layout-shift'] });
  
  return metrics as PerformanceMetrics;
}

// Use in your app
function App() {
  useEffect(() =&gt; {
    const metrics = measureWebVitals();
    
    // Send to analytics service
    // analytics.track('web-vitals', metrics);
  }, []);
  
  return &lt;YourApp /&gt;;
}</code></pre>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è Development vs Production</h4>
                <p>React's development build is significantly slower than production due to warnings, stack traces, and other debugging features. Always test performance with a production build!</p>
                <pre><code>npm run build
npm run preview  # or serve the build folder</code></pre>
            </div>
        </section>

        <section id="react-devtools-profiler" aria-labelledby="react-devtools-profiler-heading">
            <h2 id="react-devtools-profiler-heading">üî¨ React DevTools Profiler</h2>
            
            <p>The React DevTools Profiler is your best friend for identifying React-specific performance issues. It shows exactly which components are rendering, how long they take, and why they re-rendered.</p>

            <h3>üöÄ Installing React DevTools</h3>

            <p>React DevTools is available as a browser extension:</p>

            <ul>
                <li><strong>Chrome:</strong> <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">Chrome Web Store</a></li>
                <li><strong>Firefox:</strong> <a href="https://addons.mozilla.org/en-US/firefox/addon/react-devtools/" target="_blank" rel="noopener">Firefox Add-ons</a></li>
                <li><strong>Edge:</strong> Use the Chrome extension</li>
            </ul>

            <p>Once installed, you'll see two new tabs in your DevTools: "Components" and "Profiler".</p>

            <h3>üìä Using the Profiler</h3>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Step-by-Step: Profiling Your App</h4>
                <ol>
                    <li>Open React DevTools and click the "Profiler" tab</li>
                    <li>Click the blue record button (‚è∫Ô∏è)</li>
                    <li>Interact with your app (the actions you want to measure)</li>
                    <li>Click the record button again to stop</li>
                    <li>Analyze the flame graph and commit data</li>
                </ol>
            </div>

            <h3>üî• Understanding the Flame Graph</h3>

            <p>The Profiler displays a <strong>flame graph</strong> showing your component tree and render times:</p>

            <div class="mermaid">
                graph TD
                    A[App - 45ms] --> B[Header - 5ms]
                    A --> C[MainContent - 38ms]
                    A --> D[Footer - 2ms]
                    
                    C --> E[Sidebar - 3ms]
                    C --> F[ArticleList - 35ms]
                    
                    F --> G[Article - 8ms]
                    F --> H[Article - 9ms]
                    F --> I[Article - 10ms]
                    F --> J[Article - 8ms]
                    
                    style A fill:#ffcdd2
                    style C fill:#ffcdd2
                    style F fill:#ffcdd2
                    style G fill:#fff9c4
                    style H fill:#fff9c4
                    style I fill:#ffab91
                    style J fill:#fff9c4
                    style B fill:#c8e6c9
                    style D fill:#c8e6c9
                    style E fill:#c8e6c9
            </div>

            <p>In this visualization:</p>
            <ul>
                <li><strong style="color: #c8e6c9; background: #1b5e20; padding: 2px 6px; border-radius: 3px;">Green</strong> = Fast (good!)</li>
                <li><strong style="color: #fff; background: #f57c00; padding: 2px 6px; border-radius: 3px;">Yellow/Orange</strong> = Slow (investigate)</li>
                <li><strong style="color: #fff; background: #c62828; padding: 2px 6px; border-radius: 3px;">Red</strong> = Very slow (optimize now!)</li>
            </ul>

            <h3>üéØ What the Profiler Shows</h3>

            <p>For each component render, you can see:</p>

            <table>
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>What It Means</th>
                        <th>What to Look For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Render duration</strong></td>
                        <td>How long the component took to render</td>
                        <td>Components taking &gt;16ms (one frame at 60fps)</td>
                    </tr>
                    <tr>
                        <td><strong>Why did this render?</strong></td>
                        <td>What caused the component to re-render</td>
                        <td>Unnecessary renders (props didn't actually change)</td>
                    </tr>
                    <tr>
                        <td><strong>Render count</strong></td>
                        <td>How many times it rendered during recording</td>
                        <td>Components rendering too frequently</td>
                    </tr>
                    <tr>
                        <td><strong>Committed at</strong></td>
                        <td>When the render was committed to DOM</td>
                        <td>Patterns in timing (e.g., all renders at once)</td>
                    </tr>
                </tbody>
            </table>

            <h3>üí° Practical Example: Finding Slow Components</h3>

            <p>Let's profile a real application and identify issues:</p>

            <pre><code class="language-typescript">// Example: A product list that's rendering slowly
interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  rating: number;
}

// üò± Slow component - re-renders unnecessarily
function ProductCard({ product }: { product: Product }) {
  console.log('ProductCard rendering:', product.name);
  
  // Expensive calculation on every render
  const formattedPrice = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(product.price);
  
  // Complex rendering logic
  const stars = Array.from({ length: 5 }, (_, i) =&gt; {
    return i &lt; Math.floor(product.rating) ? '‚òÖ' : '‚òÜ';
  }).join('');
  
  return (
    &lt;div className="product-card"&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;{formattedPrice}&lt;/p&gt;
      &lt;p&gt;{stars} ({product.rating})&lt;/p&gt;
      &lt;p&gt;{product.description}&lt;/p&gt;
    &lt;/div&gt;
  );
}

function ProductList({ products }: { products: Product[] }) {
  const [sortBy, setSortBy] = useState&lt;'name' | 'price'&gt;('name');
  
  // Sorting happens on every render!
  const sortedProducts = [...products].sort((a, b) =&gt; {
    if (sortBy === 'name') {
      return a.name.localeCompare(b.name);
    }
    return a.price - b.price;
  });
  
  return (
    &lt;div&gt;
      &lt;select value={sortBy} onChange={(e) =&gt; setSortBy(e.target.value as any)}&gt;
        &lt;option value="name"&gt;Sort by Name&lt;/option&gt;
        &lt;option value="price"&gt;Sort by Price&lt;/option&gt;
      &lt;/select&gt;
      
      {sortedProducts.map(product =&gt; (
        &lt;ProductCard key={product.id} product={product} /&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è What the Profiler Would Show</h4>
                <p>When you profile this component:</p>
                <ul>
                    <li><strong>ProductList</strong> renders on every sort change ‚úÖ (expected)</li>
                    <li><strong>Every ProductCard</strong> re-renders even though product data didn't change üò± (wasteful!)</li>
                    <li>The sorting calculation runs on every render üò± (unnecessary!)</li>
                    <li>Number formatting happens repeatedly for the same prices üò± (expensive!)</li>
                </ul>
            </div>

            <p>We'll learn how to fix these issues in the next section!</p>

            <h3>üîç Analyzing "Why Did This Render?"</h3>

            <p>One of the Profiler's most useful features is showing <em>why</em> a component rendered:</p>

            <pre><code class="language-typescript">// Click on any component in the Profiler to see:

// ‚úÖ Good reasons to render:
// - "State changed" - Component's own state updated
// - "Props changed" - Parent passed different props
// - "Parent rendered" - But props actually changed

// üò± Bad reasons (opportunities to optimize):
// - "Parent rendered" - But props are the same
// - "Context changed" - But component doesn't use the changed value
// - "Props changed" - But the "change" is a new object with same values</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Pro Tip: The "Ranked" View</h4>
                <p>Switch to the "Ranked" chart view in the Profiler to see components sorted by render time. This instantly shows you where to focus your optimization efforts‚Äîstart with the slowest components at the top!</p>
            </div>
        </section>

        <section id="identifying-bottlenecks" aria-labelledby="identifying-bottlenecks-heading">
            <h2 id="identifying-bottlenecks-heading">üîç Identifying Performance Bottlenecks</h2>
            
            <p>Now that we know how to measure performance, let's learn to identify the most common bottlenecks in React applications. Understanding <em>what's</em> slow is the first step to making it fast.</p>

            <h3>üéØ Common Performance Bottlenecks</h3>

            <p>React applications typically suffer from these performance issues:</p>

            <div class="mermaid">
                mindmap
                  root((Performance<br/>Bottlenecks))
                    Rendering Issues
                      Too many re-renders
                      Large component trees
                      Expensive render logic
                      Inline function creation
                    Data Issues
                      Large lists without virtualization
                      Unoptimized state updates
                      Expensive computations
                      Memory leaks
                    Bundle Issues
                      Large JavaScript bundles
                      No code splitting
                      Unused dependencies
                      Duplicate code
                    Network Issues
                      Unoptimized images
                      No caching strategy
                      Blocking resources
                      Too many requests
            </div>

            <h3>üêå Bottleneck #1: Excessive Re-renders</h3>

            <p>The #1 cause of slow React apps is components rendering more often than necessary. Every render has a cost!</p>

            <pre><code class="language-typescript">// üò± Anti-pattern: Creating new objects in render
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // This creates a NEW object on every render!
  const config = { theme: 'dark', locale: 'en' };
  
  // This creates a NEW function on every render!
  const handleClick = () =&gt; console.log('clicked');
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      
      {/* These components re-render even though nothing changed! */}
      &lt;ChildComponent config={config} onClick={handleClick} /&gt;
    &lt;/div&gt;
  );
}

// ‚úÖ Fixed version
function ParentComponent() {
  const [count, setCount] = useState(0);
  
  // Move constant objects outside component
  const config = useMemo(() =&gt; ({ theme: 'dark', locale: 'en' }), []);
  
  // Memoize functions
  const handleClick = useCallback(() =&gt; {
    console.log('clicked');
  }, []);
  
  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Increment&lt;/button&gt;
      
      {/* Now ChildComponent only renders when props actually change */}
      &lt;MemoizedChildComponent config={config} onClick={handleClick} /&gt;
    &lt;/div&gt;
  );
}

const MemoizedChildComponent = React.memo(ChildComponent);</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° How to Spot This Issue</h4>
                <p>In the Profiler, look for:</p>
                <ul>
                    <li>Components showing "Parent rendered" as the render reason</li>
                    <li>Props that show as "changed" but have the same values</li>
                    <li>Many components rendering simultaneously when only one should</li>
                </ul>
            </div>

            <h3>üêå Bottleneck #2: Expensive Computations</h3>

            <p>Calculations that run on every render can severely impact performance:</p>

            <pre><code class="language-typescript">// üò± Expensive computation runs every render
function DataDashboard({ data }: { data: DataPoint[] }) {
  // This sorts and filters thousands of items on EVERY RENDER!
  const processedData = data
    .filter(point =&gt; point.value &gt; 0)
    .sort((a, b) =&gt; b.value - a.value)
    .slice(0, 100);
  
  const average = processedData.reduce((sum, point) =&gt; sum + point.value, 0) / processedData.length;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Average: {average.toFixed(2)}&lt;/h2&gt;
      &lt;DataTable data={processedData} /&gt;
    &lt;/div&gt;
  );
}

// ‚úÖ Memoized version - only recalculates when data changes
function DataDashboard({ data }: { data: DataPoint[] }) {
  const processedData = useMemo(() =&gt; {
    console.log('Computing processed data...');
    return data
      .filter(point =&gt; point.value &gt; 0)
      .sort((a, b) =&gt; b.value - a.value)
      .slice(0, 100);
  }, [data]); // Only recompute when data changes
  
  const average = useMemo(() =&gt; {
    console.log('Computing average...');
    return processedData.reduce((sum, point) =&gt; sum + point.value, 0) / processedData.length;
  }, [processedData]);
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Average: {average.toFixed(2)}&lt;/h2&gt;
      &lt;DataTable data={processedData} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Rule of Thumb: When to useMemo</h4>
                <p>Use <code>useMemo</code> when:</p>
                <ul>
                    <li>The computation is expensive (loops through large arrays, complex math)</li>
                    <li>The result is used as a prop to child components</li>
                    <li>The computation happens frequently but dependencies change rarely</li>
                </ul>
                <p><strong>Don't use</strong> <code>useMemo</code> for simple calculations‚Äîit adds overhead!</p>
            </div>

            <h3>üêå Bottleneck #3: Large Lists</h3>

            <p>Rendering thousands of items is expensive, even if they're simple:</p>

            <pre><code class="language-typescript">// üò± Renders 10,000 items - page becomes unresponsive
function HugeList({ items }: { items: Item[] }) {
  return (
    &lt;div className="list"&gt;
      {items.map(item =&gt; (
        &lt;ListItem key={item.id} item={item} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// ‚úÖ Solution 1: Virtualization (only render visible items)
import { FixedSizeList } from 'react-window';

function VirtualizedList({ items }: { items: Item[] }) {
  return (
    &lt;FixedSizeList
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    &gt;
      {({ index, style }) =&gt; (
        &lt;div style={style}&gt;
          &lt;ListItem item={items[index]} /&gt;
        &lt;/div&gt;
      )}
    &lt;/FixedSizeList&gt;
  );
}

// ‚úÖ Solution 2: Pagination
function PaginatedList({ items }: { items: Item[] }) {
  const [page, setPage] = useState(0);
  const itemsPerPage = 50;
  
  const paginatedItems = useMemo(() =&gt; {
    const start = page * itemsPerPage;
    return items.slice(start, start + itemsPerPage);
  }, [items, page]);
  
  return (
    &lt;div&gt;
      {paginatedItems.map(item =&gt; (
        &lt;ListItem key={item.id} item={item} /&gt;
      ))}
      &lt;Pagination
        page={page}
        totalPages={Math.ceil(items.length / itemsPerPage)}
        onPageChange={setPage}
      /&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Virtualization Libraries</h4>
                <p>For large lists, use virtualization libraries that only render visible items:</p>
                <ul>
                    <li><strong>react-window</strong> - Lightweight, great for simple lists</li>
                    <li><strong>react-virtualized</strong> - More features, larger bundle</li>
                    <li><strong>@tanstack/react-virtual</strong> - Modern, flexible API</li>
                </ul>
            </div>

            <h3>üìä Performance Checklist</h3>

            <p>Use this checklist when investigating performance issues:</p>

            <table>
                <thead>
                    <tr>
                        <th>‚úÖ Check</th>
                        <th>What to Look For</th>
                        <th>Tool to Use</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Rendering frequency</td>
                        <td>Components rendering too often</td>
                        <td>React DevTools Profiler</td>
                    </tr>
                    <tr>
                        <td>Render duration</td>
                        <td>Slow component renders (&gt;16ms)</td>
                        <td>React DevTools Profiler</td>
                    </tr>
                    <tr>
                        <td>JavaScript execution</td>
                        <td>Long tasks blocking the main thread</td>
                        <td>Chrome DevTools Performance</td>
                    </tr>
                    <tr>
                        <td>Bundle size</td>
                        <td>Large JavaScript files</td>
                        <td>Bundle Analyzer</td>
                    </tr>
                    <tr>
                        <td>Network requests</td>
                        <td>Slow or blocking resources</td>
                        <td>Chrome Network tab</td>
                    </tr>
                    <tr>
                        <td>Images</td>
                        <td>Unoptimized or oversized images</td>
                        <td>Lighthouse</td>
                    </tr>
                    <tr>
                        <td>Memory leaks</td>
                        <td>Memory usage growing over time</td>
                        <td>Chrome Memory Profiler</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="render-optimization" aria-labelledby="render-optimization-heading">
            <h2 id="render-optimization-heading">‚ö° Render Optimization Strategies</h2>
            
            <p>Now let's dive into specific techniques for optimizing React component renders. These are the practical tools you'll use every day to keep your applications fast.</p>

            <h3>üéØ Strategy #1: React.memo</h3>

            <p><code>React.memo</code> is a higher-order component that prevents unnecessary re-renders by memoizing the component output:</p>

            <!-- Interactive Re-render Cascade Visualization -->
            <div class="card" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 12px; padding: 0; overflow: hidden; margin: 2rem 0;">
                <div style="background: rgba(102, 126, 234, 0.2); padding: 1rem 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <h4 style="color: #a78bfa; margin: 0; font-size: 1.1rem;">‚ö° Interactive: Re-render Cascade Visualizer</h4>
                    <p style="color: #94a3b8; margin: 0.5rem 0 0 0; font-size: 0.9rem;">Watch components flash when they re-render. See how React.memo prevents unnecessary renders.</p>
                </div>
                <div style="padding: 1.5rem;">
                    <div id="rerender-viz" style="display: flex; flex-direction: column; gap: 1.5rem;">
                        
                        <!-- Control Panel -->
                        <div style="display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; justify-content: center;">
                            <button onclick="triggerParentRender()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 0.95rem; transition: transform 0.15s, box-shadow 0.15s;" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(102,126,234,0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                üîÑ Update Parent State
                            </button>
                            <label style="color: #e2e8f0; display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                                <input type="checkbox" id="useMemoToggle" onchange="toggleMemoization()" style="width: 18px; height: 18px; cursor: pointer;">
                                <span>Enable React.memo</span>
                            </label>
                            <button onclick="resetRenderCounts()" style="background: rgba(255,255,255,0.1); color: #94a3b8; border: 1px solid rgba(255,255,255,0.2); padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                Reset Counts
                            </button>
                        </div>
                        
                        <!-- Component Tree Visualization -->
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem;">
                            
                            <!-- Parent Component -->
                            <div id="parent-box" style="background: rgba(239, 68, 68, 0.2); border: 2px solid #ef4444; border-radius: 12px; padding: 1rem 1.5rem; text-align: center; transition: all 0.3s ease; min-width: 200px;">
                                <div style="color: #fca5a5; font-weight: 600; font-size: 0.95rem;">App (Parent)</div>
                                <div style="color: #94a3b8; font-size: 0.8rem; margin-top: 0.25rem;">count: <span id="parent-count">0</span></div>
                                <div style="color: #64748b; font-size: 0.75rem; margin-top: 0.5rem;">Renders: <span id="parent-renders" style="color: #f87171;">0</span></div>
                            </div>
                            
                            <!-- Connector Lines -->
                            <div style="display: flex; justify-content: center; gap: 80px;">
                                <div style="width: 2px; height: 30px; background: linear-gradient(to bottom, #ef4444, #3b82f6);"></div>
                                <div style="width: 2px; height: 30px; background: linear-gradient(to bottom, #ef4444, #22c55e);"></div>
                                <div style="width: 2px; height: 30px; background: linear-gradient(to bottom, #ef4444, #f59e0b);"></div>
                            </div>
                            
                            <!-- Child Components -->
                            <div style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
                                
                                <!-- Child A (receives count as prop) -->
                                <div id="child-a-box" style="background: rgba(59, 130, 246, 0.2); border: 2px solid #3b82f6; border-radius: 10px; padding: 0.75rem 1rem; text-align: center; transition: all 0.3s ease; min-width: 120px;">
                                    <div style="color: #93c5fd; font-weight: 600; font-size: 0.85rem;">Counter</div>
                                    <div style="color: #94a3b8; font-size: 0.75rem;">props: count</div>
                                    <div style="color: #64748b; font-size: 0.7rem; margin-top: 0.5rem;">Renders: <span id="child-a-renders" style="color: #60a5fa;">0</span></div>
                                    <div id="child-a-memo" style="color: #10b981; font-size: 0.65rem; margin-top: 0.25rem; display: none;">‚úì memo (renders)</div>
                                </div>
                                
                                <!-- Child B (static props) -->
                                <div id="child-b-box" style="background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; border-radius: 10px; padding: 0.75rem 1rem; text-align: center; transition: all 0.3s ease; min-width: 120px;">
                                    <div style="color: #86efac; font-weight: 600; font-size: 0.85rem;">Header</div>
                                    <div style="color: #94a3b8; font-size: 0.75rem;">props: title</div>
                                    <div style="color: #64748b; font-size: 0.7rem; margin-top: 0.5rem;">Renders: <span id="child-b-renders" style="color: #4ade80;">0</span></div>
                                    <div id="child-b-memo" style="color: #10b981; font-size: 0.65rem; margin-top: 0.25rem; display: none;">‚úì memo (skipped!)</div>
                                </div>
                                
                                <!-- Child C (static props) -->
                                <div id="child-c-box" style="background: rgba(245, 158, 11, 0.2); border: 2px solid #f59e0b; border-radius: 10px; padding: 0.75rem 1rem; text-align: center; transition: all 0.3s ease; min-width: 120px;">
                                    <div style="color: #fcd34d; font-weight: 600; font-size: 0.85rem;">Footer</div>
                                    <div style="color: #94a3b8; font-size: 0.75rem;">props: year</div>
                                    <div style="color: #64748b; font-size: 0.7rem; margin-top: 0.5rem;">Renders: <span id="child-c-renders" style="color: #fbbf24;">0</span></div>
                                    <div id="child-c-memo" style="color: #10b981; font-size: 0.65rem; margin-top: 0.25rem; display: none;">‚úì memo (skipped!)</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Stats Panel -->
                        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 1rem; display: flex; flex-wrap: wrap; gap: 1.5rem; justify-content: center;">
                            <div style="text-align: center;">
                                <div style="color: #64748b; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Total Renders</div>
                                <div id="total-renders" style="color: #f87171; font-size: 1.5rem; font-weight: 700;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #64748b; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Renders Saved</div>
                                <div id="renders-saved" style="color: #4ade80; font-size: 1.5rem; font-weight: 700;">0</div>
                            </div>
                            <div style="text-align: center;">
                                <div style="color: #64748b; font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px;">Efficiency</div>
                                <div id="efficiency" style="color: #a78bfa; font-size: 1.5rem; font-weight: 700;">0%</div>
                            </div>
                        </div>
                        
                        <!-- Explanation -->
                        <div id="explanation-panel" style="background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.3); border-radius: 8px; padding: 1rem;">
                            <div style="color: #93c5fd; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem;">üí° Without React.memo:</div>
                            <div style="color: #94a3b8; font-size: 0.85rem; line-height: 1.5;">Every time the parent updates its state, <strong style="color: #f87171;">all children re-render</strong>‚Äîeven Header and Footer whose props never change. This is wasted work!</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <script>
            (function() {
                let parentCount = 0;
                let parentRenders = 0;
                let childARenders = 0;
                let childBRenders = 0;
                let childCRenders = 0;
                let totalRenders = 0;
                let rendersSaved = 0;
                let useMemo = false;
                
                function flashElement(id, color) {
                    const el = document.getElementById(id);
                    if (!el) return;
                    el.style.boxShadow = `0 0 20px ${color}, 0 0 40px ${color}`;
                    el.style.transform = 'scale(1.05)';
                    setTimeout(() => {
                        el.style.boxShadow = 'none';
                        el.style.transform = 'scale(1)';
                    }, 300);
                }
                
                function updateStats() {
                    document.getElementById('parent-count').textContent = parentCount;
                    document.getElementById('parent-renders').textContent = parentRenders;
                    document.getElementById('child-a-renders').textContent = childARenders;
                    document.getElementById('child-b-renders').textContent = childBRenders;
                    document.getElementById('child-c-renders').textContent = childCRenders;
                    document.getElementById('total-renders').textContent = totalRenders;
                    document.getElementById('renders-saved').textContent = rendersSaved;
                    
                    const maxPossible = parentRenders * 4; // parent + 3 children
                    const efficiency = maxPossible > 0 ? Math.round((rendersSaved / maxPossible) * 100) : 0;
                    document.getElementById('efficiency').textContent = efficiency + '%';
                }
                
                window.triggerParentRender = function() {
                    parentCount++;
                    parentRenders++;
                    totalRenders++;
                    flashElement('parent-box', '#ef4444');
                    
                    // Child A always renders (props changed - count)
                    setTimeout(() => {
                        childARenders++;
                        totalRenders++;
                        flashElement('child-a-box', '#3b82f6');
                    }, 100);
                    
                    // Child B and C depend on memo setting
                    setTimeout(() => {
                        if (useMemo) {
                            // With memo - skip render, props unchanged
                            rendersSaved += 2;
                        } else {
                            // Without memo - render anyway
                            childBRenders++;
                            childCRenders++;
                            totalRenders += 2;
                            flashElement('child-b-box', '#22c55e');
                            flashElement('child-c-box', '#f59e0b');
                        }
                        updateStats();
                    }, 200);
                    
                    updateStats();
                };
                
                window.toggleMemoization = function() {
                    useMemo = document.getElementById('useMemoToggle').checked;
                    
                    const memoLabels = ['child-a-memo', 'child-b-memo', 'child-c-memo'];
                    memoLabels.forEach(id => {
                        document.getElementById(id).style.display = useMemo ? 'block' : 'none';
                    });
                    
                    const explanationPanel = document.getElementById('explanation-panel');
                    if (useMemo) {
                        explanationPanel.style.background = 'rgba(34, 197, 94, 0.1)';
                        explanationPanel.style.borderColor = 'rgba(34, 197, 94, 0.3)';
                        explanationPanel.innerHTML = `
                            <div style="color: #86efac; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem;">‚úÖ With React.memo:</div>
                            <div style="color: #94a3b8; font-size: 0.85rem; line-height: 1.5;">Counter still re-renders because its <code style="background: rgba(255,255,255,0.1); padding: 0.1rem 0.3rem; border-radius: 3px;">count</code> prop changes. But Header and Footer are <strong style="color: #4ade80;">skipped</strong>‚Äîtheir props are the same, so React.memo prevents wasted renders!</div>
                        `;
                    } else {
                        explanationPanel.style.background = 'rgba(59, 130, 246, 0.1)';
                        explanationPanel.style.borderColor = 'rgba(59, 130, 246, 0.3)';
                        explanationPanel.innerHTML = `
                            <div style="color: #93c5fd; font-weight: 600; font-size: 0.9rem; margin-bottom: 0.5rem;">üí° Without React.memo:</div>
                            <div style="color: #94a3b8; font-size: 0.85rem; line-height: 1.5;">Every time the parent updates its state, <strong style="color: #f87171;">all children re-render</strong>‚Äîeven Header and Footer whose props never change. This is wasted work!</div>
                        `;
                    }
                };
                
                window.resetRenderCounts = function() {
                    parentCount = 0;
                    parentRenders = 0;
                    childARenders = 0;
                    childBRenders = 0;
                    childCRenders = 0;
                    totalRenders = 0;
                    rendersSaved = 0;
                    updateStats();
                };
            })();
            </script>

            <pre><code class="language-typescript">// Without React.memo
function ExpensiveComponent({ data }: { data: ComplexData }) {
  console.log('ExpensiveComponent rendering');
  
  // Imagine this has expensive rendering logic
  return (
    &lt;div&gt;
      &lt;h3&gt;{data.title}&lt;/h3&gt;
      &lt;ComplexVisualization data={data} /&gt;
    &lt;/div&gt;
  );
}

// With React.memo - only re-renders if props change
const MemoizedExpensiveComponent = React.memo(ExpensiveComponent);

// Usage
function ParentComponent() {
  const [count, setCount] = useState(0);
  const complexData = { title: 'Chart', values: [1, 2, 3] };
  
  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Count: {count}
      &lt;/button&gt;
      
      {/* This won't re-render when count changes */}
      &lt;MemoizedExpensiveComponent data={complexData} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è React.memo Gotcha: Reference Equality</h4>
                <p>React.memo uses shallow comparison. If you pass objects or functions as props, they need to be memoized too, or React.memo won't help:</p>
                <pre><code class="language-typescript">// üò± Still re-renders because data is a new object each time
function Parent() {
  const [count, setCount] = useState(0);
  
  return (
    &lt;MemoizedChild data={{ value: 123 }} /&gt; // New object every render!
  );
}

// ‚úÖ Fixed with useMemo
function Parent() {
  const [count, setCount] = useState(0);
  const data = useMemo(() =&gt; ({ value: 123 }), []);
  
  return &lt;MemoizedChild data={data} /&gt;;
}</code></pre>
            </div>

            <h3>üéØ Strategy #2: useMemo for Expensive Calculations</h3>

            <p>We've seen <code>useMemo</code> briefly. Let's explore it in depth:</p>

            <pre><code class="language-typescript">// Example: Filtering and sorting a large dataset
interface Product {
  id: number;
  name: string;
  price: number;
  category: string;
  rating: number;
}

function ProductFilter({ products }: { products: Product[] }) {
  const [searchTerm, setSearchTerm] = useState('');
  const [category, setCategory] = useState('all');
  const [sortBy, setSortBy] = useState&lt;'name' | 'price' | 'rating'&gt;('name');
  
  // üò± Without useMemo - runs on every render (even when typing!)
  const filteredAndSorted = products
    .filter(p =&gt; 
      (category === 'all' || p.category === category) &amp;&amp;
      p.name.toLowerCase().includes(searchTerm.toLowerCase())
    )
    .sort((a, b) =&gt; {
      if (sortBy === 'name') return a.name.localeCompare(b.name);
      if (sortBy === 'price') return a.price - b.price;
      return b.rating - a.rating;
    });
  
  // ‚úÖ With useMemo - only recalculates when dependencies change
  const filteredAndSortedMemo = useMemo(() =&gt; {
    console.log('Filtering and sorting...');
    
    return products
      .filter(p =&gt; 
        (category === 'all' || p.category === category) &amp;&amp;
        p.name.toLowerCase().includes(searchTerm.toLowerCase())
      )
      .sort((a, b) =&gt; {
        if (sortBy === 'name') return a.name.localeCompare(b.name);
        if (sortBy === 'price') return a.price - b.price;
        return b.rating - a.rating;
      });
  }, [products, category, searchTerm, sortBy]);
  
  return (
    &lt;div&gt;
      &lt;input
        value={searchTerm}
        onChange={(e) =&gt; setSearchTerm(e.target.value)}
        placeholder="Search products..."
      /&gt;
      &lt;select value={category} onChange={(e) =&gt; setCategory(e.target.value)}&gt;
        &lt;option value="all"&gt;All Categories&lt;/option&gt;
        &lt;option value="electronics"&gt;Electronics&lt;/option&gt;
        &lt;option value="clothing"&gt;Clothing&lt;/option&gt;
      &lt;/select&gt;
      &lt;select value={sortBy} onChange={(e) =&gt; setSortBy(e.target.value as any)}&gt;
        &lt;option value="name"&gt;Name&lt;/option&gt;
        &lt;option value="price"&gt;Price&lt;/option&gt;
        &lt;option value="rating"&gt;Rating&lt;/option&gt;
      &lt;/select&gt;
      
      &lt;ProductList products={filteredAndSortedMemo} /&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ useMemo Best Practices</h4>
                <ul>
                    <li><strong>Do use</strong> for expensive computations (array operations on large data, complex math)</li>
                    <li><strong>Do use</strong> when the result is passed to child components</li>
                    <li><strong>Don't use</strong> for simple calculations (it adds overhead)</li>
                    <li><strong>Don't use</strong> as a semantic guarantee (React may still recalculate)</li>
                    <li><strong>Always</strong> include all dependencies in the dependency array</li>
                </ul>
            </div>

            <h3>üéØ Strategy #3: useCallback for Function Memoization</h3>

            <p><code>useCallback</code> is like <code>useMemo</code> for functions:</p>

            <pre><code class="language-typescript">// Example: Passing callbacks to memoized children
interface TodoItemProps {
  todo: Todo;
  onToggle: (id: number) =&gt; void;
  onDelete: (id: number) =&gt; void;
}

const TodoItem = React.memo(({ todo, onToggle, onDelete }: TodoItemProps) =&gt; {
  console.log('TodoItem rendering:', todo.text);
  
  return (
    &lt;div&gt;
      &lt;input
        type="checkbox"
        checked={todo.completed}
        onChange={() =&gt; onToggle(todo.id)}
      /&gt;
      &lt;span&gt;{todo.text}&lt;/span&gt;
      &lt;button onClick={() =&gt; onDelete(todo.id)}&gt;Delete&lt;/button&gt;
    &lt;/div&gt;
  );
});

function TodoList() {
  const [todos, setTodos] = useState&lt;Todo[]&gt;([]);
  
  // üò± Without useCallback - new functions every render
  const handleToggle = (id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt;
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };
  
  const handleDelete = (id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  };
  
  // ‚úÖ With useCallback - functions stay the same
  const handleToggleMemo = useCallback((id: number) =&gt; {
    setTodos(prev =&gt; prev.map(todo =&gt;
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  }, []); // No dependencies needed - uses functional update
  
  const handleDeleteMemo = useCallback((id: number) =&gt; {
    setTodos(prev =&gt; prev.filter(todo =&gt; todo.id !== id));
  }, []);
  
  return (
    &lt;div&gt;
      {todos.map(todo =&gt; (
        &lt;TodoItem
          key={todo.id}
          todo={todo}
          onToggle={handleToggleMemo}
          onDelete={handleDeleteMemo}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>

            <p><strong>Key insight:</strong> <code>useCallback</code> is only useful when passing functions to memoized child components. If the child isn't memoized with <code>React.memo</code>, <code>useCallback</code> provides no benefit.</p>

            <h3>üéØ Strategy #4: Component Lazy Loading</h3>

            <p>Not all components need to be loaded immediately. Use <code>React.lazy</code> and <code>Suspense</code> to split code and load components on demand:</p>

            <pre><code class="language-typescript">// Without lazy loading - entire app loads at once
import { HeavyChart } from './components/HeavyChart';
import { ComplexEditor } from './components/ComplexEditor';
import { VideoPlayer } from './components/VideoPlayer';

function Dashboard() {
  const [activeTab, setActiveTab] = useState('overview');
  
  return (
    &lt;div&gt;
      &lt;Tabs value={activeTab} onChange={setActiveTab}&gt;
        &lt;Tab value="overview"&gt;Overview&lt;/Tab&gt;
        &lt;Tab value="charts"&gt;Charts&lt;/Tab&gt;
        &lt;Tab value="editor"&gt;Editor&lt;/Tab&gt;
      &lt;/Tabs&gt;
      
      {activeTab === 'overview' &amp;&amp; &lt;Overview /&gt;}
      {activeTab === 'charts' &amp;&amp; &lt;HeavyChart /&gt;}
      {activeTab === 'editor' &amp;&amp; &lt;ComplexEditor /&gt;}
    &lt;/div&gt;
  );
}

// ‚úÖ With lazy loading - components load only when needed
const HeavyChart = lazy(() =&gt; import('./components/HeavyChart'));
const ComplexEditor = lazy(() =&gt; import('./components/ComplexEditor'));
const VideoPlayer = lazy(() =&gt; import('./components/VideoPlayer'));

function Dashboard() {
  const [activeTab, setActiveTab] = useState('overview');
  
  return (
    &lt;div&gt;
      &lt;Tabs value={activeTab} onChange={setActiveTab}&gt;
        &lt;Tab value="overview"&gt;Overview&lt;/Tab&gt;
        &lt;Tab value="charts"&gt;Charts&lt;/Tab&gt;
        &lt;Tab value="editor"&gt;Editor&lt;/Tab&gt;
      &lt;/Tabs&gt;
      
      &lt;Suspense fallback={&lt;LoadingSpinner /&gt;}&gt;
        {activeTab === 'overview' &amp;&amp; &lt;Overview /&gt;}
        {activeTab === 'charts' &amp;&amp; &lt;HeavyChart /&gt;}
        {activeTab === 'editor' &amp;&amp; &lt;ComplexEditor /&gt;}
      &lt;/Suspense&gt;
    &lt;/div&gt;
  );
}</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° When to Use Lazy Loading</h4>
                <ul>
                    <li><strong>Route-based splits</strong> - Different routes can load their own code</li>
                    <li><strong>Modal dialogs</strong> - Only load when the modal opens</li>
                    <li><strong>Heavy components</strong> - Charts, editors, video players</li>
                    <li><strong>Below-the-fold content</strong> - Content users might not scroll to</li>
                    <li><strong>Admin features</strong> - Code that only some users need</li>
                </ul>
            </div>

            <h3>üéØ Strategy #5: Windowing Large Lists</h3>

            <p>For long lists, render only what's visible on screen using virtualization:</p>

            <pre><code class="language-typescript">// Installing react-window
// npm install react-window @types/react-window

import { FixedSizeList } from 'react-window';

interface Message {
  id: number;
  author: string;
  text: string;
  timestamp: Date;
}

// üò± Without windowing - renders all 10,000 messages
function ChatHistory({ messages }: { messages: Message[] }) {
  return (
    &lt;div className="chat-history"&gt;
      {messages.map(message =&gt; (
        &lt;MessageItem key={message.id} message={message} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// ‚úÖ With windowing - only renders visible messages
function VirtualizedChatHistory({ messages }: { messages: Message[] }) {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) =&gt; {
    const message = messages[index];
    
    return (
      &lt;div style={style}&gt;
        &lt;MessageItem message={message} /&gt;
      &lt;/div&gt;
    );
  };
  
  return (
    &lt;FixedSizeList
      height={600}           // Visible height in pixels
      itemCount={messages.length}
      itemSize={80}          // Height of each message
      width="100%"
    &gt;
      {Row}
    &lt;/FixedSizeList&gt;
  );
}

// For variable height items, use VariableSizeList
import { VariableSizeList } from 'react-window';

function VariableHeightList({ items }: { items: Item[] }) {
  const listRef = useRef&lt;VariableSizeList&gt;(null);
  const rowHeights = useRef&lt;{ [key: number]: number }&gt;({});
  
  const getItemSize = (index: number) =&gt; {
    return rowHeights.current[index] || 50; // Default height
  };
  
  const setRowHeight = (index: number, size: number) =&gt; {
    listRef.current?.resetAfterIndex(0);
    rowHeights.current[index] = size;
  };
  
  const Row = ({ index, style }: any) =&gt; {
    const rowRef = useRef&lt;HTMLDivElement&gt;(null);
    
    useEffect(() =&gt; {
      if (rowRef.current) {
        setRowHeight(index, rowRef.current.clientHeight);
      }
    }, [index]);
    
    return (
      &lt;div style={style}&gt;
        &lt;div ref={rowRef}&gt;
          &lt;VariableHeightItem item={items[index]} /&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    );
  };
  
  return (
    &lt;VariableSizeList
      ref={listRef}
      height={600}
      itemCount={items.length}
      itemSize={getItemSize}
      width="100%"
    &gt;
      {Row}
    &lt;/VariableSizeList&gt;
  );
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Windowing Performance Impact</h4>
                <p>Windowing can provide dramatic improvements:</p>
                <ul>
                    <li><strong>1,000 items:</strong> Renders ~20 instead of 1,000 (50x faster)</li>
                    <li><strong>10,000 items:</strong> Renders ~20 instead of 10,000 (500x faster)</li>
                    <li><strong>100,000 items:</strong> Renders ~20 instead of 100,000 (5000x faster)</li>
                </ul>
                <p>The performance is constant regardless of list size!</p>
            </div>

            <h3>üéØ Strategy #6: Debouncing and Throttling</h3>

            <p>Limit how often expensive operations run in response to user input:</p>

            <pre><code class="language-typescript">// Debounce - wait until user stops typing
function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
  
  useEffect(() =&gt; {
    const handler = setTimeout(() =&gt; {
      setDebouncedValue(value);
    }, delay);
    
    return () =&gt; {
      clearTimeout(handler);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// Using debounce for search
function SearchBar() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  
  // This only runs when user stops typing for 300ms
  useEffect(() =&gt; {
    if (debouncedSearchTerm) {
      fetchSearchResults(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);
  
  return (
    &lt;input
      type="search"
      value={searchTerm}
      onChange={(e) =&gt; setSearchTerm(e.target.value)}
      placeholder="Search..."
    /&gt;
  );
}

// Throttle - limit how often a function can run
function useThrottle&lt;T&gt;(value: T, limit: number): T {
  const [throttledValue, setThrottledValue] = useState&lt;T&gt;(value);
  const lastRan = useRef(Date.now());
  
  useEffect(() =&gt; {
    const handler = setTimeout(() =&gt; {
      if (Date.now() - lastRan.current &gt;= limit) {
        setThrottledValue(value);
        lastRan.current = Date.now();
      }
    }, limit - (Date.now() - lastRan.current));
    
    return () =&gt; {
      clearTimeout(handler);
    };
  }, [value, limit]);
  
  return throttledValue;
}

// Using throttle for scroll events
function ScrollTracker() {
  const [scrollPosition, setScrollPosition] = useState(0);
  const throttledPosition = useThrottle(scrollPosition, 100);
  
  useEffect(() =&gt; {
    const handleScroll = () =&gt; {
      setScrollPosition(window.scrollY);
    };
    
    window.addEventListener('scroll', handleScroll);
    return () =&gt; window.removeEventListener('scroll', handleScroll);
  }, []);
  
  // This only updates every 100ms instead of every frame
  useEffect(() =&gt; {
    updateScrollIndicator(throttledPosition);
  }, [throttledPosition]);
  
  return &lt;div&gt;Scroll position: {throttledPosition}&lt;/div&gt;;
}</code></pre>

            <div class="mermaid">
                sequenceDiagram
                    participant User
                    participant Input
                    participant Debounce
                    participant API
                    
                    User->>Input: Types "h"
                    Input->>Debounce: Start timer
                    User->>Input: Types "e"
                    Debounce->>Debounce: Cancel previous timer
                    Input->>Debounce: Start new timer
                    User->>Input: Types "l"
                    Debounce->>Debounce: Cancel previous timer
                    Input->>Debounce: Start new timer
                    User->>Input: Types "l"
                    Debounce->>Debounce: Cancel previous timer
                    Input->>Debounce: Start new timer
                    User->>Input: Types "o"
                    Debounce->>Debounce: Cancel previous timer
                    Input->>Debounce: Start new timer
                    Note over Debounce: User stops typing<br/>Wait 300ms
                    Debounce->>API: Search for "hello"
                    API->>User: Show results
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Debounce vs Throttle</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Technique</th>
                            <th>When It Runs</th>
                            <th>Use Cases</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Debounce</strong></td>
                            <td>After user stops triggering events</td>
                            <td>Search input, resize events, form validation</td>
                        </tr>
                        <tr>
                            <td><strong>Throttle</strong></td>
                            <td>At most once per time interval</td>
                            <td>Scroll events, mouse movements, API polling</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <section id="code-splitting" aria-labelledby="code-splitting-heading">
            <h2 id="code-splitting-heading">üì¶ Code Splitting and Bundle Optimization</h2>
            
            <p>One of the biggest impacts on initial load time is JavaScript bundle size. Let's learn how to split your code into smaller chunks that load only when needed.</p>

            <h3>üéØ Understanding Bundle Size</h3>

            <p>Modern React applications can easily balloon to megabytes of JavaScript. Every kilobyte must be downloaded, parsed, and executed before your app becomes interactive.</p>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è The Real Cost of JavaScript</h4>
                <p>JavaScript is the most expensive resource on the web:</p>
                <ul>
                    <li><strong>Download:</strong> Time spent transferring over the network</li>
                    <li><strong>Parse:</strong> Browser must parse the code (can take 50-100ms per MB)</li>
                    <li><strong>Compile:</strong> JIT compilation to machine code</li>
                    <li><strong>Execute:</strong> Running your code</li>
                </ul>
                <p>A 1MB image only needs to be downloaded and decoded. A 1MB JavaScript file goes through all four steps and blocks interactivity!</p>
            </div>

            <h3>üìä Analyzing Your Bundle</h3>

            <p>First, let's see what's in your bundle:</p>

            <pre><code class="language-bash"># Install bundle analyzer
npm install --save-dev @rollup/plugin-visualizer

# For Vite projects, add to vite.config.ts:
import { visualizer } from '@rollup/plugin-visualizer';

export default defineConfig({
  plugins: [
    react(),
    visualizer({
      open: true,
      gzipSize: true,
      brotliSize: true,
    })
  ]
});

# Build and analyze
npm run build</code></pre>

            <p>This generates a visual treemap showing what's taking up space in your bundle:</p>

            <div class="mermaid">
                graph TD
                    A[Total Bundle: 850KB] --> B[Your Code: 250KB]
                    A --> C[node_modules: 600KB]
                    
                    B --> B1[Components: 120KB]
                    B --> B2[Utils: 80KB]
                    B --> B3[Assets: 50KB]
                    
                    C --> C1[React: 140KB]
                    C --> C2[date-fns: 200KB WARNING]
                    C --> C3[lodash: 150KB WARNING]
                    C --> C4[Other: 110KB]
                    
                    style A fill:#ffcdd2
                    style C2 fill:#ffcdd2
                    style C3 fill:#ffcdd2
                    style B fill:#c8e6c9
                    style C1 fill:#c8e6c9
            </div>

            <h3>üéØ Route-Based Code Splitting</h3>

            <p>The most effective code splitting strategy is to split by route:</p>

            <pre><code class="language-typescript">// Before: All routes load at once
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import Home from './pages/Home';
import About from './pages/About';
import Dashboard from './pages/Dashboard';
import Settings from './pages/Settings';

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
        &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
        &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
        &lt;Route path="/settings" element={&lt;Settings /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}

// ‚úÖ After: Each route loads on demand
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { lazy, Suspense } from 'react';

const Home = lazy(() =&gt; import('./pages/Home'));
const About = lazy(() =&gt; import('./pages/About'));
const Dashboard = lazy(() =&gt; import('./pages/Dashboard'));
const Settings = lazy(() =&gt; import('./pages/Settings'));

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Suspense fallback={&lt;LoadingScreen /&gt;}&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
          &lt;Route path="/dashboard" element={&lt;Dashboard /&gt;} /&gt;
          &lt;Route path="/settings" element={&lt;Settings /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Suspense&gt;
    &lt;/BrowserRouter&gt;
  );
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Code Splitting Impact</h4>
                <p>Route-based splitting typically:</p>
                <ul>
                    <li>Reduces initial bundle by 40-60%</li>
                    <li>Improves Time to Interactive by 2-4 seconds</li>
                    <li>Better caching (unchanged routes stay cached)</li>
                </ul>
            </div>

            <h3>üéØ Component-Based Code Splitting</h3>

            <p>Split heavy components that aren't immediately needed:</p>

            <pre><code class="language-typescript">// Split heavy third-party components
import { lazy, Suspense } from 'react';

const ChartComponent = lazy(() =&gt; import('react-chartjs-2'));
const MarkdownEditor = lazy(() =&gt; import('react-markdown-editor'));
const CodeEditor = lazy(() =&gt; import('@monaco-editor/react'));

function Dashboard() {
  const [showChart, setShowChart] = useState(false);
  const [showEditor, setShowEditor] = useState(false);
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      
      &lt;button onClick={() =&gt; setShowChart(true)}&gt;
        Show Analytics Chart
      &lt;/button&gt;
      
      {showChart &amp;&amp; (
        &lt;Suspense fallback={&lt;p&gt;Loading chart...&lt;/p&gt;}&gt;
          &lt;ChartComponent data={analyticsData} /&gt;
        &lt;/Suspense&gt;
      )}
      
      &lt;button onClick={() =&gt; setShowEditor(true)}&gt;
        Open Editor
      &lt;/button&gt;
      
      {showEditor &amp;&amp; (
        &lt;Suspense fallback={&lt;p&gt;Loading editor...&lt;/p&gt;}&gt;
          &lt;CodeEditor defaultValue="// Start coding..." /&gt;
        &lt;/Suspense&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

            <h3>üéØ Optimizing Dependencies</h3>

            <p>Many bundle size issues come from dependencies. Here's how to optimize them:</p>

            <pre><code class="language-typescript">// ‚ùå Bad: Importing entire lodash (70KB)
import _ from 'lodash';
const result = _.debounce(fn, 300);

// ‚úÖ Good: Import only what you need (5KB)
import debounce from 'lodash/debounce';
const result = debounce(fn, 300);

// ‚ùå Bad: Importing entire date-fns (200KB+)
import { format } from 'date-fns';

// ‚úÖ Good: Use the smaller date-fns/format (15KB)
import format from 'date-fns/format';

// ‚ùå Bad: Importing massive icon library
import { FaUser, FaHome, FaCog } from 'react-icons/fa';

// ‚úÖ Good: Import specific icons
import FaUser from 'react-icons/fa/FaUser';
import FaHome from 'react-icons/fa/FaHome';
import FaCog from 'react-icons/fa/FaCog';

// Or better: Use smaller icon library
import { User, Home, Settings } from 'lucide-react'; // Much smaller!</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Alternative Lightweight Libraries</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Instead of...</th>
                            <th>Try...</th>
                            <th>Size Savings</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>moment.js (289KB)</td>
                            <td>date-fns (15-20KB) or dayjs (7KB)</td>
                            <td>93-97% smaller</td>
                        </tr>
                        <tr>
                            <td>lodash (70KB)</td>
                            <td>Individual imports or native JS</td>
                            <td>90%+ smaller</td>
                        </tr>
                        <tr>
                            <td>axios (13KB)</td>
                            <td>fetch API (built-in)</td>
                            <td>100% smaller</td>
                        </tr>
                        <tr>
                            <td>react-icons (1MB+)</td>
                            <td>lucide-react (50KB)</td>
                            <td>95% smaller</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3>üéØ Tree Shaking</h3>

            <p>Modern bundlers automatically remove unused code, but you need to write code that's "tree-shakeable":</p>

            <pre><code class="language-typescript">// ‚úÖ Tree-shakeable: ES6 modules with named exports
export const add = (a: number, b: number) =&gt; a + b;
export const subtract = (a: number, b: number) =&gt; a - b;
export const multiply = (a: number, b: number) =&gt; a * b;

// Usage - only 'add' is bundled
import { add } from './math';

// ‚ùå Not tree-shakeable: Default export of object
export default {
  add: (a: number, b: number) =&gt; a + b,
  subtract: (a: number, b: number) =&gt; a - b,
  multiply: (a: number, b: number) =&gt; a * b,
};

// Usage - entire object is bundled even if you only use 'add'
import math from './math';
math.add(1, 2);</code></pre>

            <h3>üéØ Prefetching and Preloading</h3>

            <p>Load code before it's needed to make transitions feel instant:</p>

            <pre><code class="language-typescript">// Prefetch on hover - loads when user hovers over link
import { lazy, Suspense } from 'react';

const AdminPanel = lazy(() =&gt; import('./pages/AdminPanel'));

// Preload function
const preloadAdminPanel = () =&gt; {
  import('./pages/AdminPanel');
};

function Navigation() {
  return (
    &lt;nav&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
      &lt;Link 
        to="/admin" 
        onMouseEnter={preloadAdminPanel}  // Prefetch on hover
        onFocus={preloadAdminPanel}       // Prefetch on focus (keyboard)
      &gt;
        Admin Panel
      &lt;/Link&gt;
    &lt;/nav&gt;
  );
}

// Prefetch on idle - loads when browser is idle
function App() {
  useEffect(() =&gt; {
    // Prefetch routes user is likely to visit
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() =&gt; {
        import('./pages/Dashboard');
        import('./pages/Settings');
      });
    } else {
      // Fallback for browsers without requestIdleCallback
      setTimeout(() =&gt; {
        import('./pages/Dashboard');
        import('./pages/Settings');
      }, 1000);
    }
  }, []);
  
  return &lt;YourApp /&gt;;
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Prefetching Strategy</h4>
                <ul>
                    <li><strong>Critical:</strong> Load immediately (homepage, shell)</li>
                    <li><strong>High priority:</strong> Prefetch on hover/focus (likely next pages)</li>
                    <li><strong>Medium priority:</strong> Load on idle (common destinations)</li>
                    <li><strong>Low priority:</strong> Load on demand (rare admin features)</li>
                </ul>
            </div>
        </section>

        <section id="image-optimization" aria-labelledby="image-optimization-heading">
            <h2 id="image-optimization-heading">üñºÔ∏è Image Optimization</h2>
            
            <p>Images are often the largest assets on a webpage. Optimizing them can dramatically improve load times and Core Web Vitals scores.</p>

            <h3>üìä The Image Problem</h3>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è Common Image Mistakes</h4>
                <ul>
                    <li>Serving 4000√ó3000 images when displaying at 400√ó300</li>
                    <li>Using PNG for photos instead of JPG</li>
                    <li>Not using modern formats like WebP or AVIF</li>
                    <li>No lazy loading for below-the-fold images</li>
                    <li>Images without dimensions causing layout shifts</li>
                </ul>
            </div>

            <h3>üéØ Modern Image Formats</h3>

            <table>
                <thead>
                    <tr>
                        <th>Format</th>
                        <th>Best For</th>
                        <th>File Size</th>
                        <th>Browser Support</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>WebP</strong></td>
                        <td>Most images</td>
                        <td>25-35% smaller than JPEG/PNG</td>
                        <td>97% (IE no support)</td>
                    </tr>
                    <tr>
                        <td><strong>AVIF</strong></td>
                        <td>High quality photos</td>
                        <td>50% smaller than JPEG</td>
                        <td>90% (older browsers no support)</td>
                    </tr>
                    <tr>
                        <td><strong>JPEG</strong></td>
                        <td>Photos (fallback)</td>
                        <td>Baseline</td>
                        <td>100%</td>
                    </tr>
                    <tr>
                        <td><strong>PNG</strong></td>
                        <td>Graphics with transparency</td>
                        <td>Large for photos</td>
                        <td>100%</td>
                    </tr>
                    <tr>
                        <td><strong>SVG</strong></td>
                        <td>Icons, logos, graphics</td>
                        <td>Tiny, scalable</td>
                        <td>100%</td>
                    </tr>
                </tbody>
            </table>

            <h3>üéØ Responsive Images</h3>

            <p>Serve different image sizes for different screen sizes:</p>

            <pre><code class="language-typescript">// ‚úÖ Using srcset for responsive images
function ProductImage({ product }: { product: Product }) {
  return (
    &lt;img
      src={product.image.medium}
      srcSet={`
        ${product.image.small} 480w,
        ${product.image.medium} 800w,
        ${product.image.large} 1200w,
        ${product.image.xlarge} 1600w
      `}
      sizes="(max-width: 600px) 480px,
             (max-width: 1000px) 800px,
             (max-width: 1400px) 1200px,
             1600px"
      alt={product.name}
      loading="lazy"
      width={800}
      height={600}
    /&gt;
  );
}

// ‚úÖ Using &lt;picture&gt; for art direction and format fallbacks
function HeroImage() {
  return (
    &lt;picture&gt;
      {/* Modern format for supported browsers */}
      &lt;source
        type="image/avif"
        srcSet="/hero-small.avif 480w, /hero-large.avif 1200w"
        sizes="100vw"
      /&gt;
      
      &lt;source
        type="image/webp"
        srcSet="/hero-small.webp 480w, /hero-large.webp 1200w"
        sizes="100vw"
      /&gt;
      
      {/* Fallback for older browsers */}
      &lt;img
        src="/hero-large.jpg"
        srcSet="/hero-small.jpg 480w, /hero-large.jpg 1200w"
        sizes="100vw"
        alt="Hero image"
        loading="eager"
        width={1200}
        height={600}
      /&gt;
    &lt;/picture&gt;
  );
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Always Include Dimensions</h4>
                <p>Always specify <code>width</code> and <code>height</code> attributes to prevent Cumulative Layout Shift (CLS):</p>
                <pre><code class="language-tsx">// ‚ùå Bad: No dimensions = layout shift when image loads
&lt;img src="/photo.jpg" alt="Photo" /&gt;

// ‚úÖ Good: Browser reserves space
&lt;img src="/photo.jpg" alt="Photo" width={800} height={600} /&gt;

// ‚úÖ Also good: Use aspect-ratio CSS
&lt;img 
  src="/photo.jpg" 
  alt="Photo"
  style={{ aspectRatio: '16/9', width: '100%' }}
/&gt;</code></pre>
            </div>

            <h3>üéØ Lazy Loading Images</h3>

            <p>Don't load images until they're about to enter the viewport:</p>

            <pre><code class="language-typescript">// ‚úÖ Native lazy loading (simple and effective!)
function Gallery({ images }: { images: Image[] }) {
  return (
    &lt;div className="gallery"&gt;
      {images.map((image, index) =&gt; (
        &lt;img
          key={image.id}
          src={image.url}
          alt={image.alt}
          loading={index &lt; 3 ? 'eager' : 'lazy'} // Load first 3 immediately
          width={400}
          height={300}
        /&gt;
      ))}
    &lt;/div&gt;
  );
}

// ‚úÖ Advanced: Intersection Observer for more control
function LazyImage({ src, alt, ...props }: ImageProps) {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isInView, setIsInView] = useState(false);
  const imgRef = useRef&lt;HTMLImageElement&gt;(null);
  
  useEffect(() =&gt; {
    if (!imgRef.current) return;
    
    const observer = new IntersectionObserver(
      ([entry]) =&gt; {
        if (entry.isIntersecting) {
          setIsInView(true);
          observer.disconnect();
        }
      },
      {
        rootMargin: '200px', // Start loading 200px before entering viewport
      }
    );
    
    observer.observe(imgRef.current);
    
    return () =&gt; observer.disconnect();
  }, []);
  
  return (
    &lt;img
      ref={imgRef}
      src={isInView ? src : undefined}
      alt={alt}
      onLoad={() =&gt; setIsLoaded(true)}
      style={{
        opacity: isLoaded ? 1 : 0,
        transition: 'opacity 0.3s',
      }}
      {...props}
    /&gt;
  );
}</code></pre>

            <h3>üéØ Image CDN and Optimization Services</h3>

            <p>Consider using image CDNs that automatically optimize images:</p>

            <pre><code class="language-typescript">// Using Cloudinary for automatic optimization
function OptimizedImage({ src, alt, width, height }: ImageProps) {
  const cloudinaryUrl = `https://res.cloudinary.com/your-cloud/image/upload/f_auto,q_auto,w_${width}/${src}`;
  
  return (
    &lt;img
      src={cloudinaryUrl}
      alt={alt}
      width={width}
      height={height}
      loading="lazy"
    /&gt;
  );
}

// f_auto: Automatically choose best format (WebP, AVIF, etc.)
// q_auto: Automatically choose optimal quality
// w_${width}: Resize to exact width needed</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Popular Image CDN Services</h4>
                <ul>
                    <li><strong>Cloudinary</strong> - Full-featured, automatic optimization</li>
                    <li><strong>Imgix</strong> - Real-time image processing</li>
                    <li><strong>Cloudflare Images</strong> - Simple, integrated with CF</li>
                    <li><strong>ImageKit</strong> - Good free tier</li>
                </ul>
            </div>

            <h3>üìä Image Optimization Checklist</h3>

            <table>
                <thead>
                    <tr>
                        <th>‚úÖ Optimization</th>
                        <th>Impact</th>
                        <th>Difficulty</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Use WebP/AVIF formats</td>
                        <td>25-50% smaller files</td>
                        <td>Easy</td>
                    </tr>
                    <tr>
                        <td>Add width/height attributes</td>
                        <td>Prevents CLS</td>
                        <td>Easy</td>
                    </tr>
                    <tr>
                        <td>Lazy load images</td>
                        <td>Faster initial load</td>
                        <td>Easy</td>
                    </tr>
                    <tr>
                        <td>Use responsive images (srcset)</td>
                        <td>Save bandwidth</td>
                        <td>Medium</td>
                    </tr>
                    <tr>
                        <td>Compress images</td>
                        <td>20-40% smaller</td>
                        <td>Easy</td>
                    </tr>
                    <tr>
                        <td>Use CDN for images</td>
                        <td>Faster delivery</td>
                        <td>Medium</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="web-vitals" aria-labelledby="web-vitals-heading">
            <h2 id="web-vitals-heading">üìà Improving Core Web Vitals</h2>
            
            <p>Now let's put everything together and focus specifically on improving the three Core Web Vitals metrics that Google uses to measure user experience.</p>

            <h3>üéØ Improving Largest Contentful Paint (LCP)</h3>

            <p>LCP measures how quickly the main content loads. Target: <strong>&lt; 2.5 seconds</strong></p>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° What Counts as LCP?</h4>
                <p>The largest element visible in the viewport, typically:</p>
                <ul>
                    <li>Hero images or banners</li>
                    <li>Large text blocks</li>
                    <li>Video thumbnails</li>
                    <li>Background images loaded via CSS</li>
                </ul>
            </div>

            <h4>üîß LCP Optimization Strategies</h4>

            <pre><code class="language-typescript">// 1. Preload critical images
function App() {
  return (
    &lt;&gt;
      &lt;Helmet&gt;
        &lt;link
          rel="preload"
          as="image"
          href="/hero-image.webp"
          imagesrcset="/hero-small.webp 480w, /hero-large.webp 1200w"
          imagesizes="100vw"
        /&gt;
      &lt;/Helmet&gt;
      
      &lt;HeroSection /&gt;
    &lt;/&gt;
  );
}

// 2. Optimize hero images
function HeroSection() {
  return (
    &lt;section className="hero"&gt;
      &lt;img
        src="/hero-large.webp"
        srcSet="/hero-small.webp 480w, /hero-large.webp 1200w"
        sizes="100vw"
        alt="Hero"
        width={1200}
        height={600}
        loading="eager"           // Don't lazy load the hero!
        fetchPriority="high"      // Tell browser this is important
      /&gt;
    &lt;/section&gt;
  );
}

// 3. Server-side rendering for faster initial content
// Using frameworks like Next.js, Remix, or Gatsby
export async function getServerSideProps() {
  const data = await fetchInitialData();
  
  return {
    props: { data }
  };
}

// 4. Inline critical CSS
// In your build process, inline CSS for above-the-fold content
&lt;style&gt;
  {/* Critical CSS for hero section */}
  .hero { 
    min-height: 400px; 
    background: #f0f0f0;
  }
&lt;/style&gt;</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ LCP Quick Wins</h4>
                <ol>
                    <li>Use a CDN for faster asset delivery</li>
                    <li>Optimize server response times (TTFB &lt; 600ms)</li>
                    <li>Preload the LCP image</li>
                    <li>Use modern image formats (WebP, AVIF)</li>
                    <li>Remove render-blocking JavaScript and CSS</li>
                    <li>Consider using SSR for critical content</li>
                </ol>
            </div>

            <h3>üéØ Improving First Input Delay (FID)</h3>

            <p>FID measures interactivity. Target: <strong>&lt; 100 milliseconds</strong></p>

            <p>FID is caused by long JavaScript tasks blocking the main thread. When the browser is busy executing JavaScript, it can't respond to user interactions.</p>

            <h4>üîß FID Optimization Strategies</h4>

            <pre><code class="language-typescript">// 1. Break up long tasks
// ‚ùå Bad: Long synchronous task blocks thread
function processLargeDataset(data: Item[]) {
  const results = data.map(item =&gt; {
    // Complex processing...
    return expensiveCalculation(item);
  });
  
  displayResults(results);
}

// ‚úÖ Good: Break into chunks with requestIdleCallback
async function processLargeDataset(data: Item[]) {
  const results: ProcessedItem[] = [];
  const chunkSize = 100;
  
  for (let i = 0; i &lt; data.length; i += chunkSize) {
    const chunk = data.slice(i, i + chunkSize);
    
    // Process chunk
    const processedChunk = chunk.map(item =&gt; expensiveCalculation(item));
    results.push(...processedChunk);
    
    // Yield to browser
    await new Promise(resolve =&gt; {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(resolve);
      } else {
        setTimeout(resolve, 0);
      }
    });
  }
  
  displayResults(results);
}

// 2. Use Web Workers for heavy computations
// worker.ts
self.addEventListener('message', (e) =&gt; {
  const result = expensiveCalculation(e.data);
  self.postMessage(result);
});

// Component.tsx
function DataProcessor() {
  const [result, setResult] = useState&lt;Result | null&gt;(null);
  
  useEffect(() =&gt; {
    const worker = new Worker(new URL('./worker.ts', import.meta.url));
    
    worker.postMessage(largeDataset);
    
    worker.onmessage = (e) =&gt; {
      setResult(e.data);
      worker.terminate();
    };
    
    return () =&gt; worker.terminate();
  }, []);
  
  return &lt;ResultDisplay data={result} /&gt;;
}

// 3. Defer non-critical JavaScript
function App() {
  useEffect(() =&gt; {
    // Load analytics after page is interactive
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() =&gt; {
        import('./analytics').then(({ initAnalytics }) =&gt; {
          initAnalytics();
        });
      });
    }
  }, []);
  
  return &lt;YourApp /&gt;;
}</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ FID Quick Wins</h4>
                <ol>
                    <li>Code split to reduce JavaScript execution time</li>
                    <li>Break up long tasks into smaller chunks</li>
                    <li>Use Web Workers for CPU-intensive work</li>
                    <li>Defer third-party scripts (analytics, chat widgets)</li>
                    <li>Remove unused JavaScript</li>
                    <li>Use modern, smaller libraries</li>
                </ol>
            </div>

            <h3>üéØ Improving Cumulative Layout Shift (CLS)</h3>

            <p>CLS measures visual stability. Target: <strong>&lt; 0.1</strong></p>

            <p>Layout shifts happen when visible page content moves unexpectedly. This is incredibly frustrating for users!</p>

            <h4>üîß CLS Optimization Strategies</h4>

            <pre><code class="language-typescript">// 1. Always include size attributes for images
// ‚ùå Bad: Image loads and pushes content down
&lt;img src="/photo.jpg" alt="Photo" /&gt;

// ‚úÖ Good: Space reserved, no layout shift
&lt;img src="/photo.jpg" alt="Photo" width={800} height={600} /&gt;

// ‚úÖ Also good: aspect-ratio
&lt;img 
  src="/photo.jpg" 
  alt="Photo"
  style={{ width: '100%', aspectRatio: '16/9' }}
/&gt;

// 2. Reserve space for dynamic content
// ‚ùå Bad: Ad or widget loads and shifts content
function Sidebar() {
  const [ad, setAd] = useState&lt;Ad | null&gt;(null);
  
  useEffect(() =&gt; {
    loadAd().then(setAd);
  }, []);
  
  return (
    &lt;aside&gt;
      {ad &amp;&amp; &lt;AdWidget ad={ad} /&gt;} {/* Suddenly appears! */}
      &lt;SidebarContent /&gt;
    &lt;/aside&gt;
  );
}

// ‚úÖ Good: Reserve space with skeleton
function Sidebar() {
  const [ad, setAd] = useState&lt;Ad | null&gt;(null);
  
  useEffect(() =&gt; {
    loadAd().then(setAd);
  }, []);
  
  return (
    &lt;aside&gt;
      &lt;div style={{ minHeight: '250px' }}&gt;
        {ad ? (
          &lt;AdWidget ad={ad} /&gt;
        ) : (
          &lt;AdSkeleton /&gt; {/* Placeholder with same size */}
        )}
      &lt;/div&gt;
      &lt;SidebarContent /&gt;
    &lt;/aside&gt;
  );
}

// 3. Avoid inserting content above existing content
// ‚ùå Bad: New message appears above and shifts everything down
function ChatMessages({ messages }: { messages: Message[] }) {
  return (
    &lt;div&gt;
      {messages.map(msg =&gt; (
        &lt;Message key={msg.id} message={msg} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// ‚úÖ Good: Scroll to keep position stable
function ChatMessages({ messages }: { messages: Message[] }) {
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const prevHeightRef = useRef(0);
  
  useLayoutEffect(() =&gt; {
    if (containerRef.current) {
      const newHeight = containerRef.current.scrollHeight;
      const heightDiff = newHeight - prevHeightRef.current;
      
      // Adjust scroll to maintain position
      if (heightDiff &gt; 0) {
        containerRef.current.scrollTop += heightDiff;
      }
      
      prevHeightRef.current = newHeight;
    }
  }, [messages]);
  
  return (
    &lt;div ref={containerRef}&gt;
      {messages.map(msg =&gt; (
        &lt;Message key={msg.id} message={msg} /&gt;
      ))}
    &lt;/div&gt;
  );
}

// 4. Use font-display for web fonts
// In your CSS
@font-face {
  font-family: 'CustomFont';
  src: url('/fonts/custom.woff2') format('woff2');
  font-display: swap; /* Show fallback font immediately */
}

// Or preload fonts
&lt;link
  rel="preload"
  as="font"
  type="font/woff2"
  href="/fonts/custom.woff2"
  crossOrigin="anonymous"
/&gt;</code></pre>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ CLS Quick Wins</h4>
                <ol>
                    <li>Set dimensions for all images and videos</li>
                    <li>Reserve space for ads and embeds</li>
                    <li>Use skeleton screens for loading states</li>
                    <li>Avoid inserting content above existing content</li>
                    <li>Use <code>font-display: swap</code> for web fonts</li>
                    <li>Preload critical fonts</li>
                    <li>Avoid animations that change layout</li>
                </ol>
            </div>

            <h3>üìä Monitoring Web Vitals in Production</h3>

            <p>It's crucial to monitor real user performance, not just lab tests:</p>

            <pre><code class="language-typescript">// Install web-vitals library
// npm install web-vitals

import { onCLS, onFID, onLCP, onFCP, onTTFB } from 'web-vitals';

// Send metrics to analytics
function sendToAnalytics(metric: Metric) {
  // Send to your analytics service
  const body = JSON.stringify(metric);
  
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`
  if (navigator.sendBeacon) {
    navigator.sendBeacon('/analytics', body);
  } else {
    fetch('/analytics', { body, method: 'POST', keepalive: true });
  }
}

// Track all Core Web Vitals
export function initWebVitals() {
  onCLS(sendToAnalytics);
  onFID(sendToAnalytics);
  onLCP(sendToAnalytics);
  onFCP(sendToAnalytics);
  onTTFB(sendToAnalytics);
}

// Usage in your app
function App() {
  useEffect(() =&gt; {
    if (process.env.NODE_ENV === 'production') {
      initWebVitals();
    }
  }, []);
  
  return &lt;YourApp /&gt;;
}

// Advanced: Track by route
import { useLocation } from 'react-router-dom';

function WebVitalsReporter() {
  const location = useLocation();
  
  useEffect(() =&gt; {
    const sendMetric = (metric: Metric) =&gt; {
      sendToAnalytics({
        ...metric,
        route: location.pathname,
      });
    };
    
    onCLS(sendMetric);
    onFID(sendMetric);
    onLCP(sendMetric);
  }, [location]);
  
  return null;
}</code></pre>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h4>üí° Real User Monitoring (RUM) Services</h4>
                <ul>
                    <li><strong>Google Analytics 4</strong> - Built-in Web Vitals reporting</li>
                    <li><strong>Vercel Analytics</strong> - Automatic for Vercel deployments</li>
                    <li><strong>Sentry Performance</strong> - Detailed performance monitoring</li>
                    <li><strong>New Relic</strong> - Enterprise monitoring solution</li>
                    <li><strong>Datadog RUM</strong> - Comprehensive monitoring</li>
                </ul>
            </div>
        </section>

        <section id="exercises" aria-labelledby="exercises-heading">
            <h2 id="exercises-heading">üèãÔ∏è Practice Exercises</h2>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Exercise 1: Profile and Optimize a Slow Component</h3>
                <p><strong>Objective:</strong> Use React DevTools Profiler to find and fix performance issues</p>
                
                <p><strong>Task:</strong> Create a product listing page that renders slowly, profile it, then optimize it.</p>
                
                <details>
                    <summary>üí° Hints</summary>
                    <ul>
                        <li>Create a ProductList component with 500+ products</li>
                        <li>Add filters and sorting that cause re-renders</li>
                        <li>Use React DevTools Profiler to record interactions</li>
                        <li>Look for components rendering unnecessarily</li>
                        <li>Apply React.memo, useMemo, and useCallback</li>
                        <li>Consider virtualization for the long list</li>
                    </ul>
                </details>
                
                <details>
                    <summary>‚úÖ Solution Approach</summary>
                    <pre><code class="language-typescript">// Start with slow version
function ProductList({ products }: Props) {
  const [filter, setFilter] = useState('');
  const [sort, setSort] = useState('name');
  
  const filtered = products.filter(p =&gt; 
    p.name.toLowerCase().includes(filter.toLowerCase())
  );
  
  const sorted = [...filtered].sort((a, b) =&gt; {
    if (sort === 'name') return a.name.localeCompare(b.name);
    return a.price - b.price;
  });
  
  return (
    &lt;div&gt;
      &lt;input value={filter} onChange={e =&gt; setFilter(e.target.value)} /&gt;
      {sorted.map(p =&gt; &lt;ProductCard key={p.id} product={p} /&gt;)}
    &lt;/div&gt;
  );
}

// Optimize with memoization and virtualization
const ProductCard = React.memo(({ product }: Props) =&gt; {
  return &lt;div&gt;{product.name} - ${product.price}&lt;/div&gt;;
});

function ProductList({ products }: Props) {
  const [filter, setFilter] = useState('');
  const [sort, setSort] = useState('name');
  
  const filtered = useMemo(() =&gt; 
    products.filter(p =&gt; 
      p.name.toLowerCase().includes(filter.toLowerCase())
    ),
    [products, filter]
  );
  
  const sorted = useMemo(() =&gt; 
    [...filtered].sort((a, b) =&gt; {
      if (sort === 'name') return a.name.localeCompare(b.name);
      return a.price - b.price;
    }),
    [filtered, sort]
  );
  
  return (
    &lt;div&gt;
      &lt;input value={filter} onChange={e =&gt; setFilter(e.target.value)} /&gt;
      &lt;FixedSizeList
        height={600}
        itemCount={sorted.length}
        itemSize={80}
        width="100%"
      &gt;
        {({ index, style }) =&gt; (
          &lt;div style={style}&gt;
            &lt;ProductCard product={sorted[index]} /&gt;
          &lt;/div&gt;
        )}
      &lt;/FixedSizeList&gt;
    &lt;/div&gt;
  );
}</code></pre>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Exercise 2: Implement Route-Based Code Splitting</h3>
                <p><strong>Objective:</strong> Split a multi-route application into separate bundles</p>
                
                <p><strong>Task:</strong> Take an application with 5+ routes and implement lazy loading for each route.</p>
                
                <details>
                    <summary>üí° Hints</summary>
                    <ul>
                        <li>Use React.lazy() and Suspense</li>
                        <li>Create a loading component for the Suspense fallback</li>
                        <li>Check bundle sizes before and after</li>
                        <li>Implement prefetching on navigation hover</li>
                        <li>Test that routes load correctly</li>
                    </ul>
                </details>
                
                <details>
                    <summary>‚úÖ Solution Approach</summary>
                    <pre><code class="language-typescript">// Before: All routes load upfront
import Home from './pages/Home';
import About from './pages/About';
import Products from './pages/Products';
import Contact from './pages/Contact';
import Admin from './pages/Admin';

// After: Lazy load routes
const Home = lazy(() =&gt; import('./pages/Home'));
const About = lazy(() =&gt; import('./pages/About'));
const Products = lazy(() =&gt; import('./pages/Products'));
const Contact = lazy(() =&gt; import('./pages/Contact'));
const Admin = lazy(() =&gt; import('./pages/Admin'));

// Loading component
function LoadingScreen() {
  return (
    &lt;div style={{ padding: '2rem', textAlign: 'center' }}&gt;
      &lt;div className="spinner" /&gt;
      &lt;p&gt;Loading...&lt;/p&gt;
    &lt;/div&gt;
  );
}

// App with lazy routes
function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Navigation /&gt;
      &lt;Suspense fallback={&lt;LoadingScreen /&gt;}&gt;
        &lt;Routes&gt;
          &lt;Route path="/" element={&lt;Home /&gt;} /&gt;
          &lt;Route path="/about" element={&lt;About /&gt;} /&gt;
          &lt;Route path="/products" element={&lt;Products /&gt;} /&gt;
          &lt;Route path="/contact" element={&lt;Contact /&gt;} /&gt;
          &lt;Route path="/admin" element={&lt;Admin /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/Suspense&gt;
    &lt;/BrowserRouter&gt;
  );
}

// Add prefetching
function Navigation() {
  const preloadAbout = () =&gt; import('./pages/About');
  const preloadProducts = () =&gt; import('./pages/Products');
  
  return (
    &lt;nav&gt;
      &lt;Link to="/"&gt;Home&lt;/Link&gt;
      &lt;Link 
        to="/about" 
        onMouseEnter={preloadAbout}
        onFocus={preloadAbout}
      &gt;
        About
      &lt;/Link&gt;
      &lt;Link 
        to="/products"
        onMouseEnter={preloadProducts}
        onFocus={preloadProducts}
      &gt;
        Products
      &lt;/Link&gt;
    &lt;/nav&gt;
  );
}</code></pre>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Exercise 3: Optimize Images for Performance</h3>
                <p><strong>Objective:</strong> Implement responsive, lazy-loaded images with modern formats</p>
                
                <p><strong>Task:</strong> Create an image gallery with proper optimization techniques.</p>
                
                <details>
                    <summary>üí° Hints</summary>
                    <ul>
                        <li>Use multiple image sizes (small, medium, large)</li>
                        <li>Implement lazy loading (native or Intersection Observer)</li>
                        <li>Add proper width and height attributes</li>
                        <li>Use WebP with fallbacks</li>
                        <li>Measure CLS score before and after</li>
                    </ul>
                </details>
                
                <details>
                    <summary>‚úÖ Solution Approach</summary>
                    <pre><code class="language-typescript">interface GalleryImage {
  id: string;
  alt: string;
  small: string;
  medium: string;
  large: string;
  width: number;
  height: number;
}

function Gallery({ images }: { images: GalleryImage[] }) {
  return (
    &lt;div className="gallery"&gt;
      {images.map((image, index) =&gt; (
        &lt;picture key={image.id}&gt;
          &lt;source
            type="image/webp"
            srcSet={`
              ${image.small} 480w,
              ${image.medium} 800w,
              ${image.large} 1200w
            `}
            sizes="(max-width: 600px) 100vw, (max-width: 1000px) 50vw, 33vw"
          /&gt;
          
          &lt;img
            src={image.medium}
            srcSet={`
              ${image.small} 480w,
              ${image.medium} 800w,
              ${image.large} 1200w
            `}
            sizes="(max-width: 600px) 100vw, (max-width: 1000px) 50vw, 33vw"
            alt={image.alt}
            width={image.width}
            height={image.height}
            loading={index &lt; 6 ? 'eager' : 'lazy'}
            style={{
              aspectRatio: `${image.width}/${image.height}`,
              width: '100%',
              height: 'auto',
            }}
          /&gt;
        &lt;/picture&gt;
      ))}
    &lt;/div&gt;
  );
}</code></pre>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Exercise 4: Improve Core Web Vitals</h3>
                <p><strong>Objective:</strong> Take a slow app and improve all three Core Web Vitals metrics</p>
                
                <p><strong>Task:</strong> Run Lighthouse on an app, identify issues, and fix them to achieve good scores.</p>
                
                <details>
                    <summary>üí° Hints</summary>
                    <ul>
                        <li>Run Lighthouse in Chrome DevTools</li>
                        <li>Focus on the three Core Web Vitals</li>
                        <li>Implement recommendations from Lighthouse report</li>
                        <li>Measure before and after scores</li>
                        <li>Test on real device with network throttling</li>
                    </ul>
                </details>
                
                <details>
                    <summary>‚úÖ Solution Checklist</summary>
                    <ul>
                        <li><strong>For LCP:</strong>
                            <ul>
                                <li>Preload hero image</li>
                                <li>Use WebP format</li>
                                <li>Implement CDN</li>
                                <li>Remove render-blocking resources</li>
                            </ul>
                        </li>
                        <li><strong>For FID:</strong>
                            <ul>
                                <li>Code split routes</li>
                                <li>Defer third-party scripts</li>
                                <li>Break up long tasks</li>
                                <li>Reduce JavaScript execution time</li>
                            </ul>
                        </li>
                        <li><strong>For CLS:</strong>
                            <ul>
                                <li>Add dimensions to all images</li>
                                <li>Reserve space for ads/embeds</li>
                                <li>Use font-display: swap</li>
                                <li>Avoid inserting content above viewport</li>
                            </ul>
                        </li>
                    </ul>
                </details>
            </div>
        </section>

        <section id="quiz" aria-labelledby="quiz-heading">
            <h2 id="quiz-heading">üìù Knowledge Check</h2>
            
            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 1: What does React.memo do?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong> React.memo is a higher-order component that memoizes a component's output. It prevents re-renders when props haven't changed by doing a shallow comparison of props. This is useful for optimizing expensive components that receive the same props frequently.</p>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 2: What's the difference between useMemo and useCallback?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong></p>
                    <ul>
                        <li><strong>useMemo:</strong> Memoizes the <em>result</em> of a computation. Returns a cached value.</li>
                        <li><strong>useCallback:</strong> Memoizes a <em>function</em> itself. Returns a cached function reference.</li>
                    </ul>
                    <p><code>useCallback(fn, deps)</code> is equivalent to <code>useMemo(() =&gt; fn, deps)</code></p>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 3: What are the three Core Web Vitals?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong></p>
                    <ol>
                        <li><strong>LCP (Largest Contentful Paint):</strong> Loading performance - should be &lt; 2.5s</li>
                        <li><strong>FID (First Input Delay):</strong> Interactivity - should be &lt; 100ms</li>
                        <li><strong>CLS (Cumulative Layout Shift):</strong> Visual stability - should be &lt; 0.1</li>
                    </ol>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 4: When should you use virtualization/windowing?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong> Use virtualization when rendering long lists (typically 100+ items) where only a portion is visible at once. Virtualization only renders items in the viewport, dramatically improving performance for lists with hundreds or thousands of items. Libraries like react-window or @tanstack/react-virtual make this easy.</p>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 5: What's the difference between debouncing and throttling?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong></p>
                    <ul>
                        <li><strong>Debouncing:</strong> Waits for a pause in events before executing. Fires after user stops triggering events. Good for search inputs.</li>
                        <li><strong>Throttling:</strong> Executes at most once per time interval regardless of how many times it's triggered. Good for scroll/resize handlers.</li>
                    </ul>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 6: Why is code splitting important?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong> Code splitting breaks your JavaScript bundle into smaller chunks that load on demand. This reduces initial bundle size, leading to faster initial page loads and improved Time to Interactive. Users only download the code they need, when they need it. Route-based splitting is the most effective strategy.</p>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 7: What attributes should every image have to prevent layout shift?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong> Every image should have:</p>
                    <ul>
                        <li><code>width</code> and <code>height</code> attributes (even if styled with CSS)</li>
                        <li>Or use <code>aspect-ratio</code> CSS property</li>
                    </ul>
                    <p>This allows the browser to reserve space before the image loads, preventing Cumulative Layout Shift (CLS).</p>
                </details>
            </div>

            <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                <h3>Question 8: When should you NOT use React.memo?</h3>
                <details>
                    <summary>Show Answer</summary>
                    <p><strong>Answer:</strong> Don't use React.memo when:</p>
                    <ul>
                        <li>The component is already fast to render</li>
                        <li>Props change frequently (memoization overhead not worth it)</li>
                        <li>Props are always different objects/functions (needs useMemo/useCallback)</li>
                        <li>The component has very few instances</li>
                    </ul>
                    <p>React.memo adds overhead, so only use it when profiling shows it helps.</p>
                </details>
            </div>
        </section>

        <section id="summary" aria-labelledby="summary-heading">
            <h2 id="summary-heading">üéØ Lesson Summary</h2>
            
            <p>Congratulations! You've learned the essential techniques for building fast, performant React applications with TypeScript. Let's recap the key concepts:</p>

            <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <h3 style="color: white; margin-top: 0;">üìö Key Takeaways</h3>
                <ul style="color: white;">
                    <li><strong>Measure First:</strong> Use React DevTools Profiler, Lighthouse, and Web Vitals to identify real issues</li>
                    <li><strong>Optimize Renders:</strong> React.memo, useMemo, and useCallback prevent unnecessary work</li>
                    <li><strong>Split Code:</strong> Lazy load routes and heavy components to reduce bundle size</li>
                    <li><strong>Optimize Images:</strong> Use modern formats, responsive images, and lazy loading</li>
                    <li><strong>Improve Web Vitals:</strong> Focus on LCP, FID, and CLS for better user experience</li>
                    <li><strong>Monitor Production:</strong> Track real user metrics to catch regressions</li>
                </ul>
            </div>

    <div class="mermaid">
mindmap
  root((Performance<br/>Optimization))
    Measurement
      React DevTools Profiler
      Lighthouse
      Web Vitals
      Bundle Analyzer
    Rendering
      React.memo
      useMemo
      useCallback
      Virtualization
    Code
      Code splitting
      Tree shaking
      Lazy loading
      Prefetching
    Assets
      Image optimization
      Modern formats
      Lazy loading
      CDN
    Monitoring
      Real user metrics
      Core Web Vitals
      Error tracking
      Performance budgets
</div>

            <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                <h4>‚úÖ Performance Optimization Workflow</h4>
                <ol>
                    <li><strong>Establish Baseline:</strong> Measure current performance with Lighthouse and React Profiler</li>
                    <li><strong>Identify Bottlenecks:</strong> Find the slowest components and largest bundles</li>
                    <li><strong>Apply Optimizations:</strong> Use the appropriate technique for each issue</li>
                    <li><strong>Measure Impact:</strong> Verify improvements with hard numbers</li>
                    <li><strong>Monitor Continuously:</strong> Track real user metrics in production</li>
                    <li><strong>Set Budgets:</strong> Define performance budgets and prevent regressions</li>
                </ol>
            </div>

            <h3>üöÄ Next Steps</h3>

            <p>Now that you understand performance optimization, you're ready to:</p>
            
            <ul>
                <li>Learn advanced TypeScript patterns in Lesson 10.2</li>
                <li>Explore accessibility best practices in Lesson 10.3</li>
                <li>Master build and deployment strategies in Lesson 10.4</li>
                <li>Apply these techniques to your projects</li>
            </ul>

            <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                <h4>‚ö†Ô∏è Remember</h4>
                <p>Premature optimization is the root of all evil. Always:</p>
                <ul>
                    <li>Profile before optimizing</li>
                    <li>Focus on what matters most to users</li>
                    <li>Measure the impact of your changes</li>
                    <li>Balance performance with code maintainability</li>
                </ul>
            </div>
        </section>
        </div>
    </main>

    <nav class="lesson-nav" aria-label="Lesson navigation">
        <a href="lesson_9_5_integration_testing.html" class="prev-lesson">
            <span class="nav-arrow">‚Üê</span>
            <span class="nav-text">
                <span class="nav-label">Previous Lesson</span>
                <span class="nav-title">9.5: Integration and E2E Testing</span>
            </span>
        </a>
        <a href="index.html" class="home-link">
            <span class="nav-text">
                <span class="nav-label">Back to</span>
                <span class="nav-title">Course Home</span>
            </span>
        </a>
        <a href="lesson_10_2_typescript_advanced_patterns.html" class="next-lesson">
            <span class="nav-text">
                <span class="nav-label">Next Lesson</span>
                <span class="nav-title">10.2: TypeScript Advanced Patterns</span>
            </span>
            <span class="nav-arrow">‚Üí</span>
        </a>
    </nav>

    <footer>
        <div class="container">
            <p>&copy; 2024 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html#about">About</a> |
                <a href="index.html#contact">Contact</a> |
                <a href="index.html#resources">Resources</a>
            </p>
        </div>
    </footer>

    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
