<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn the fundamentals of testing React applications with TypeScript. Understand why testing matters, explore different types of tests, and write your first unit tests with Jest.">
    <meta name="author" content="Ray">
    <title>Lesson 9.1: Testing Fundamentals - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 9: Testing React Applications</a></li>
            <li aria-current="page">Lesson 9.1: Testing Fundamentals</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üß™ Lesson 9.1: Testing Fundamentals</h1>
                <p class="lead">Master the foundations of testing React applications with TypeScript. Learn why testing matters, understand different types of tests, and write your first unit tests with confidence.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Explain why testing is essential for modern web applications</li>
                        <li>Identify and describe different types of tests (unit, integration, E2E)</li>
                        <li>Understand the testing pyramid and how to balance your test suite</li>
                        <li>Set up Jest for testing TypeScript code</li>
                        <li>Write your first unit tests using the AAA (Arrange-Act-Assert) pattern</li>
                        <li>Apply proper TypeScript typing to test functions and expectations</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Write comprehensive unit tests for utility functions</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Introduction to Testing</a></li>
                        <li><a href="#why-test" class="toc-link">Why Testing Matters</a></li>
                        <li><a href="#types-of-tests" class="toc-link">Types of Tests</a></li>
                        <li><a href="#testing-pyramid" class="toc-link">The Testing Pyramid</a></li>
                        <li><a href="#jest-setup" class="toc-link">Setting Up Jest</a></li>
                        <li><a href="#first-test" class="toc-link">Writing Your First Test</a></li>
                        <li><a href="#aaa-pattern" class="toc-link">The AAA Pattern</a></li>
                        <li><a href="#testing-utilities" class="toc-link">Testing Utility Functions</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#best-practices" class="toc-link">Best Practices</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Introduction to Testing</h2>
                <p>Welcome to Module 9! You've built amazing React applications with sophisticated features like forms, routing, state management, and data fetching. But there's a crucial skill that separates good developers from great ones: <strong>testing</strong>.</p>
                
                <p>Testing isn't just about finding bugs (though it does that too). It's about building <em>confidence</em> in your code. It's about creating a safety net that allows you to refactor fearlessly, add new features quickly, and sleep well at night knowing your application works as expected.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What is Testing?</h4>
                    <p style="color: white;"><strong>Testing</strong> is the process of executing your code with specific inputs and verifying that it produces the expected outputs and behaviors. In software development, automated tests are programs that check if your application code works correctly.</p>
                </div>

                <p>Think of testing like this: Imagine you're building a bridge. You wouldn't just build it and hope it holds up. You'd test the materials, test the design with models, test the construction at each stage, and finally test the complete bridge before opening it to traffic. Software testing works the same way‚Äîwe verify our code at multiple levels to ensure it works correctly.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Testing Mindset</h4>
                    <p>Testing changes how you write code. When you know you'll need to test your functions, you naturally write them to be more modular, focused, and easier to reason about. This makes your entire codebase better‚Äîeven if you never ran a single test!</p>
                </div>
            </section>

            <!-- Section 2: Why Testing Matters -->
            <section id="why-test" class="lesson-section">
                <h2>ü§î Why Testing Matters</h2>
                
                <p>Let's be honest: writing tests takes time. So why should you invest that time instead of just building more features? Here are compelling reasons why testing is essential:</p>

                <h3>üõ°Ô∏è Confidence and Safety</h3>
                <p>Tests act as a safety net. When you modify code, tests immediately tell you if you broke something. This confidence allows you to:</p>
                <ul>
                    <li><strong>Refactor boldly:</strong> Improve your code structure without fear</li>
                    <li><strong>Add features quickly:</strong> Know that new code doesn't break existing functionality</li>
                    <li><strong>Upgrade dependencies:</strong> Update libraries with confidence that everything still works</li>
                </ul>

                <h3>üìù Documentation</h3>
                <p>Good tests serve as living documentation. They show other developers (and future you) exactly how your code is supposed to work. Instead of reading through implementation details, developers can look at tests to understand:</p>
                <ul>
                    <li>What inputs a function expects</li>
                    <li>What outputs it produces</li>
                    <li>How edge cases are handled</li>
                    <li>What errors might be thrown</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Real-World Example</h4>
                    <p>At a major tech company, a developer needed to refactor a critical payment processing function. Without tests, this would have been terrifying‚Äîone mistake could mean charging customers incorrectly. But because the function had comprehensive tests, the refactoring took just a few hours, and the tests confirmed that all payment scenarios still worked perfectly.</p>
                </div>

                <h3>üêõ Catch Bugs Early</h3>
                <p>Finding bugs during development is <strong>exponentially cheaper</strong> than finding them in production. Consider the cost of a bug at different stages:</p>
                
                <table>
                    <thead>
                        <tr>
                            <th>Stage</th>
                            <th>Time to Fix</th>
                            <th>Impact</th>
                            <th>Cost</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>During development (caught by tests)</td>
                            <td>Minutes</td>
                            <td>Developer only</td>
                            <td>Very Low</td>
                        </tr>
                        <tr>
                            <td>During code review</td>
                            <td>Hours</td>
                            <td>Multiple developers</td>
                            <td>Low</td>
                        </tr>
                        <tr>
                            <td>During QA testing</td>
                            <td>Hours to days</td>
                            <td>Development team blocked</td>
                            <td>Medium</td>
                        </tr>
                        <tr>
                            <td>In production</td>
                            <td>Days to weeks</td>
                            <td>Users affected, reputation damage</td>
                            <td>Very High</td>
                        </tr>
                    </tbody>
                </table>

                <h3>üöÄ Better Design</h3>
                <p>When you write code with testing in mind (or better yet, write tests first), you naturally create better designs:</p>
                <ul>
                    <li><strong>Smaller functions:</strong> Easier to test, easier to understand</li>
                    <li><strong>Clear dependencies:</strong> Functions that are easy to test have clear inputs and outputs</li>
                    <li><strong>Loose coupling:</strong> Testable code isn't tangled up with other systems</li>
                    <li><strong>Single responsibility:</strong> Each function does one thing well</li>
                </ul>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Common Misconception</h4>
                    <p><strong>Myth:</strong> "Testing slows down development."</p>
                    <p><strong>Reality:</strong> Tests slow down initial feature development by about 15-30%, but they speed up overall development by preventing bugs, enabling faster refactoring, and reducing debugging time. Over the lifetime of a project, tests save tremendous amounts of time.</p>
                </div>

                <h3>üë• Team Collaboration</h3>
                <p>Tests make it easier for teams to work together:</p>
                <ul>
                    <li><strong>Onboarding:</strong> New team members can understand how code works by reading tests</li>
                    <li><strong>Code reviews:</strong> Reviewers can verify behavior without manually testing</li>
                    <li><strong>Parallel development:</strong> Multiple developers can work on the same codebase without stepping on each other's toes</li>
                    <li><strong>Trust:</strong> Team members trust that changes won't break their work</li>
                </ul>

                <blockquote>
                    <strong>üí¨ Industry Perspective:</strong> "The best time to start writing tests is at the beginning of a project. The second-best time is right now." ‚Äì Every experienced developer who learned this lesson the hard way
                </blockquote>
            </section>

            <!-- Section 3: Types of Tests -->
            <section id="types-of-tests" class="lesson-section">
                <h2>üéØ Types of Tests</h2>
                
                <p>Not all tests are created equal. Different types of tests serve different purposes and test different aspects of your application. Understanding these differences helps you choose the right tool for the job.</p>

                <h3>1. Unit Tests üî¨</h3>
                <p>Unit tests are the foundation of your test suite. They test individual units of code in isolation‚Äîtypically a single function or method.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Unit Test</h4>
                    <p style="color: white;"><strong>Unit Test:</strong> A test that verifies a small, isolated piece of code (a "unit") works correctly. Unit tests focus on a single function, method, or component in complete isolation from the rest of the application.</p>
                </div>

                <p><strong>Characteristics of Unit Tests:</strong></p>
                <ul>
                    <li><strong>Fast:</strong> Run in milliseconds</li>
                    <li><strong>Isolated:</strong> No dependencies on databases, APIs, or file systems</li>
                    <li><strong>Focused:</strong> Test one thing at a time</li>
                    <li><strong>Deterministic:</strong> Always produce the same result given the same input</li>
                    <li><strong>Numerous:</strong> You'll have hundreds or thousands of these</li>
                </ul>

                <p><strong>Example scenarios for unit tests:</strong></p>
                <ul>
                    <li>Testing a function that formats currency: <code>formatCurrency(1234.56)</code> should return <code>"$1,234.56"</code></li>
                    <li>Testing a validation function: <code>isValidEmail("test@example.com")</code> should return <code>true</code></li>
                    <li>Testing a calculation: <code>calculateTotal([10, 20, 30])</code> should return <code>60</code></li>
                    <li>Testing a React component that displays a user's name</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use Unit Tests</h4>
                    <p>Use unit tests for business logic, utility functions, data transformations, validation, calculations, and pure components. These are your first line of defense and should make up 70-80% of your test suite.</p>
                </div>

                <h3>2. Integration Tests üîó</h3>
                <p>Integration tests verify that multiple units work together correctly. They test the interactions between different parts of your application.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Integration Test</h4>
                    <p style="color: white;"><strong>Integration Test:</strong> A test that verifies multiple components or modules work together correctly. Integration tests focus on the interfaces between units and ensure they cooperate as expected.</p>
                </div>

                <p><strong>Characteristics of Integration Tests:</strong></p>
                <ul>
                    <li><strong>Moderate speed:</strong> Slower than unit tests, but still relatively fast</li>
                    <li><strong>Some real dependencies:</strong> May use real databases or APIs (or realistic mocks)</li>
                    <li><strong>Broader scope:</strong> Test multiple components working together</li>
                    <li><strong>More realistic:</strong> Closer to how users actually interact with your app</li>
                    <li><strong>Moderate quantity:</strong> You'll have dozens to hundreds of these</li>
                </ul>

                <p><strong>Example scenarios for integration tests:</strong></p>
                <ul>
                    <li>Testing a form that validates input and submits to an API</li>
                    <li>Testing a shopping cart that updates quantities and calculates totals</li>
                    <li>Testing a search feature that filters results and updates the UI</li>
                    <li>Testing navigation between pages in your app</li>
                    <li>Testing that multiple React components work together to display a dashboard</li>
                </ul>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Key Difference</h4>
                    <p><strong>Unit tests</strong> ask: "Does this function work correctly by itself?"<br>
                    <strong>Integration tests</strong> ask: "Do these components work correctly together?"</p>
                </div>

                <h3>3. End-to-End (E2E) Tests üé≠</h3>
                <p>End-to-End tests simulate real user scenarios from start to finish. They test your entire application stack as a user would experience it.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ End-to-End Test</h4>
                    <p style="color: white;"><strong>E2E Test:</strong> A test that simulates a complete user workflow through your application from beginning to end. E2E tests interact with your app just like a real user would, clicking buttons, filling forms, and verifying results.</p>
                </div>

                <p><strong>Characteristics of E2E Tests:</strong></p>
                <ul>
                    <li><strong>Slow:</strong> Can take seconds or minutes to run</li>
                    <li><strong>Full stack:</strong> Test everything together‚Äîfrontend, backend, database</li>
                    <li><strong>User-centric:</strong> Test complete user workflows</li>
                    <li><strong>Can be brittle:</strong> Small UI changes can break tests</li>
                    <li><strong>Few but important:</strong> You'll have a handful to a few dozen of these</li>
                </ul>

                <p><strong>Example scenarios for E2E tests:</strong></p>
                <ul>
                    <li>Testing a complete user registration flow: sign up ‚Üí verify email ‚Üí log in ‚Üí see dashboard</li>
                    <li>Testing an e-commerce purchase: browse products ‚Üí add to cart ‚Üí checkout ‚Üí payment ‚Üí confirmation</li>
                    <li>Testing a blog workflow: log in ‚Üí create post ‚Üí publish ‚Üí verify it appears on homepage</li>
                    <li>Testing critical user journeys that must always work</li>
                </ul>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è E2E Test Considerations</h4>
                    <p>E2E tests are powerful but expensive to write and maintain. Use them sparingly for critical user paths. Don't try to test every scenario with E2E tests‚Äîthat's what unit and integration tests are for!</p>
                </div>

                <h3>Comparison Table</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Aspect</th>
                            <th>Unit Tests</th>
                            <th>Integration Tests</th>
                            <th>E2E Tests</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Single function/component</td>
                            <td>Multiple components together</td>
                            <td>Entire application</td>
                        </tr>
                        <tr>
                            <td><strong>Speed</strong></td>
                            <td>Very fast (milliseconds)</td>
                            <td>Moderate (seconds)</td>
                            <td>Slow (seconds to minutes)</td>
                        </tr>
                        <tr>
                            <td><strong>Cost to Write</strong></td>
                            <td>Low</td>
                            <td>Medium</td>
                            <td>High</td>
                        </tr>
                        <tr>
                            <td><strong>Maintenance</strong></td>
                            <td>Easy</td>
                            <td>Moderate</td>
                            <td>Difficult</td>
                        </tr>
                        <tr>
                            <td><strong>Confidence</strong></td>
                            <td>Low to Medium</td>
                            <td>Medium to High</td>
                            <td>Very High</td>
                        </tr>
                        <tr>
                            <td><strong>Quantity</strong></td>
                            <td>Hundreds to thousands</td>
                            <td>Dozens to hundreds</td>
                            <td>Handful to few dozen</td>
                        </tr>
                        <tr>
                            <td><strong>Failures</strong></td>
                            <td>Pinpoint exact issue</td>
                            <td>Narrow down to area</td>
                            <td>Know something is broken</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 4: Testing Pyramid -->
            <section id="testing-pyramid" class="lesson-section">
                <h2>üî∫ The Testing Pyramid</h2>
                
                <p>The testing pyramid is a foundational concept in test strategy. It visualizes how to balance different types of tests to create an effective, efficient, and maintainable test suite.</p>

                <div class="mermaid">
                    graph TD
                    E2E["E2E Tests<br/>üé≠<br/>10-20%<br/>Complete user workflows"]
                    INT["Integration Tests<br/>üîó<br/>20-30%<br/>Components working together"]
                    UNIT["Unit Tests<br/>üî¨<br/>50-70%<br/>Individual functions"]
                    
                    E2E --> INT
                    INT --> UNIT
                    
                    style E2E fill:#ff6b6b,stroke:#c92a2a,stroke-width:2px,color:#fff
                    style INT fill:#4dabf7,stroke:#1971c2,stroke-width:2px,color:#fff
                    style UNIT fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                </div>

                <h3>Understanding the Pyramid</h3>
                
                <h4>üî¨ Base: Unit Tests (50-70% of your tests)</h4>
                <p>Unit tests form the foundation of your testing pyramid. They should be:</p>
                <ul>
                    <li><strong>Numerous:</strong> Test every important function and edge case</li>
                    <li><strong>Fast:</strong> Your entire unit test suite should run in seconds</li>
                    <li><strong>Comprehensive:</strong> Cover all business logic thoroughly</li>
                    <li><strong>Easy to write:</strong> If they're hard to write, your code might need refactoring</li>
                </ul>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why So Many Unit Tests?</h4>
                    <p>Unit tests are cheap to write and maintain, run instantly, and pinpoint exactly what's broken. They give you rapid feedback during development and catch bugs before they spread to other parts of your application.</p>
                </div>

                <h4>üîó Middle: Integration Tests (20-30% of your tests)</h4>
                <p>Integration tests verify that your components work together correctly. They should:</p>
                <ul>
                    <li><strong>Test boundaries:</strong> Focus on how units interact at their interfaces</li>
                    <li><strong>Be realistic:</strong> Use real implementations when possible</li>
                    <li><strong>Cover workflows:</strong> Test common user scenarios</li>
                    <li><strong>Balance speed and realism:</strong> Fast enough to run frequently, realistic enough to catch real issues</li>
                </ul>

                <h4>üé≠ Top: E2E Tests (10-20% of your tests)</h4>
                <p>E2E tests validate critical user journeys. They should:</p>
                <ul>
                    <li><strong>Test happy paths:</strong> Focus on the most important user workflows</li>
                    <li><strong>Simulate real users:</strong> Click, type, navigate like actual users would</li>
                    <li><strong>Be selective:</strong> Only test the most critical features</li>
                    <li><strong>Be resilient:</strong> Written to survive minor UI changes</li>
                </ul>

                <h3>Why the Pyramid Shape?</h3>
                <p>The pyramid shape exists for good reasons:</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Math Behind the Pyramid</h4>
                    <p><strong>Speed:</strong> 1,000 unit tests might run in 5 seconds. 100 integration tests might take 30 seconds. 10 E2E tests could take 5 minutes. The pyramid keeps your total test runtime manageable.</p>
                    <p><strong>Maintenance:</strong> Unit tests rarely break when you change unrelated code. E2E tests can break from any UI change. More unit tests = less maintenance burden.</p>
                    <p><strong>Debugging:</strong> When a unit test fails, you know exactly which function is broken. When an E2E test fails, you might need to debug the entire application to find the issue.</p>
                </div>

                <h3>‚ùå Anti-Pattern: The Ice Cream Cone</h3>
                <p>Some teams accidentally create an inverted pyramid‚Äîlots of E2E tests, few unit tests. This is called the "ice cream cone" anti-pattern, and it's problematic:</p>

                <div class="mermaid">
                    graph TD
                    UNIT2["Unit Tests<br/>üî¨<br/>10-20%<br/>Not enough!"]
                    INT2["Integration Tests<br/>üîó<br/>20-30%"]
                    E2E2["E2E Tests<br/>üé≠<br/>50-70%<br/>Too many!"]
                    
                    UNIT2 --> INT2
                    INT2 --> E2E2
                    
                    style UNIT2 fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                    style INT2 fill:#4dabf7,stroke:#1971c2,stroke-width:2px,color:#fff
                    style E2E2 fill:#ff6b6b,stroke:#c92a2a,stroke-width:2px,color:#fff
                </div>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with the Ice Cream Cone</h4>
                    <ul>
                        <li><strong>Slow feedback:</strong> Tests take forever to run</li>
                        <li><strong>Difficult debugging:</strong> When tests fail, it's hard to find the root cause</li>
                        <li><strong>High maintenance:</strong> UI changes break many tests</li>
                        <li><strong>Flaky tests:</strong> E2E tests are prone to random failures</li>
                        <li><strong>Developer frustration:</strong> Teams stop trusting or running tests</li>
                    </ul>
                </div>

                <h3>Practical Application</h3>
                <p>Let's say you're building a task management app. Here's how you might apply the testing pyramid:</p>

                <div class="card" style="background: #f0f0f0; border-left: 4px solid #667eea;">
                    <h4>üìã Example: Task Manager Testing Strategy</h4>
                    
                    <p><strong>Unit Tests (70%):</strong></p>
                    <ul>
                        <li>Date formatting functions</li>
                        <li>Task validation logic</li>
                        <li>Priority calculation</li>
                        <li>Individual React components</li>
                        <li>Custom hooks</li>
                    </ul>

                    <p><strong>Integration Tests (25%):</strong></p>
                    <ul>
                        <li>Adding a task updates the list</li>
                        <li>Filtering works with the task list</li>
                        <li>Form validation integrates with submit</li>
                        <li>State management works across components</li>
                    </ul>

                    <p><strong>E2E Tests (5%):</strong></p>
                    <ul>
                        <li>Complete flow: Create account ‚Üí Add task ‚Üí Mark complete ‚Üí View in completed list</li>
                        <li>Critical path: Login ‚Üí Create project ‚Üí Add tasks ‚Üí Share with team</li>
                    </ul>
                </div>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Start with the pyramid in mind, but don't be dogmatic about the exact percentages. The right balance depends on your application. A simple utility library might be 95% unit tests, while a complex UI-heavy app might have more integration tests.
                </blockquote>
            </section>
            <!-- Section 5: Setting Up Jest -->
            <section id="jest-setup" class="lesson-section">
                <h2>‚öôÔ∏è Setting Up Jest</h2>
                
                <p>Jest is a delightful JavaScript testing framework created by Facebook. It's the most popular choice for testing React applications because it's fast, has great developer experience, and comes with everything you need built-in.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What is Jest?</h4>
                    <p style="color: white;"><strong>Jest</strong> is a JavaScript testing framework that provides test runners, assertion libraries, mocking capabilities, and code coverage tools all in one package. It works seamlessly with TypeScript and React.</p>
                </div>

                <h3>Why Jest?</h3>
                <p>Jest has become the go-to testing framework for React applications for several compelling reasons:</p>
                
                <ul>
                    <li><strong>Zero Configuration:</strong> Works out of the box with most setups</li>
                    <li><strong>Fast:</strong> Runs tests in parallel for speed</li>
                    <li><strong>Snapshot Testing:</strong> Great for testing React components</li>
                    <li><strong>Built-in Mocking:</strong> Powerful mocking capabilities without extra libraries</li>
                    <li><strong>Code Coverage:</strong> Built-in coverage reports</li>
                    <li><strong>Great Error Messages:</strong> Clear, helpful feedback when tests fail</li>
                    <li><strong>Watch Mode:</strong> Automatically re-runs tests as you code</li>
                </ul>

                <h3>Installing Jest with TypeScript</h3>
                <p>Let's set up Jest in a React TypeScript project. If you're using Vite (which we've been using throughout this course), here's how to add Jest:</p>

                <pre><code class="language-bash">
# Install Jest and TypeScript support
npm install --save-dev jest @types/jest ts-jest

# Install testing utilities for React
npm install --save-dev @testing-library/react @testing-library/jest-dom
npm install --save-dev @testing-library/user-event

# If using Vite, also install
npm install --save-dev @vitest/ui vitest jsdom
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Vitest vs Jest</h4>
                    <p>If you're using Vite, you might want to use <strong>Vitest</strong> instead of Jest. Vitest is a newer testing framework designed specifically for Vite projects. It has a Jest-compatible API, so everything you learn here applies to both! For this lesson, we'll focus on Jest concepts that work with both frameworks.</p>
                </div>

                <h3>Configuring Jest</h3>
                <p>Create a <code>jest.config.js</code> file in your project root:</p>

                <pre><code class="language-javascript">
module.exports = {
  // Use ts-jest for TypeScript files
  preset: 'ts-jest',
  
  // Set the test environment to jsdom (simulates a browser)
  testEnvironment: 'jsdom',
  
  // Setup files to run before tests
  setupFilesAfterEnv: ['&lt;rootDir&gt;/jest.setup.js'],
  
  // Module name mapping for CSS and asset imports
  moduleNameMapper: {
    '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
    '\\.(jpg|jpeg|png|gif|svg)$': '&lt;rootDir&gt;/__mocks__/fileMock.js'
  },
  
  // Coverage configuration
  collectCoverageFrom: [
    'src/**/*.{ts,tsx}',
    '!src/**/*.d.ts',
    '!src/main.tsx',
    '!src/vite-env.d.ts'
  ],
  
  // Transform files
  transform: {
    '^.+\\.tsx?$': 'ts-jest'
  }
};
                </code></pre>

                <h3>Setup File</h3>
                <p>Create a <code>jest.setup.js</code> file to configure testing utilities:</p>

                <pre><code class="language-javascript">
// Add custom jest matchers from jest-dom
import '@testing-library/jest-dom';

// Optional: Configure testing library
import { configure } from '@testing-library/react';

configure({ testIdAttribute: 'data-testid' });
                </code></pre>

                <h3>Update package.json</h3>
                <p>Add test scripts to your <code>package.json</code>:</p>

                <pre><code class="language-json">
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Quick Setup Verification</h4>
                    <p>After setup, run <code>npm test</code> to verify everything works. You should see a message like "No tests found" if you haven't written any tests yet‚Äîthat's perfect!</p>
                </div>

                <h3>File Naming Conventions</h3>
                <p>Jest automatically finds test files using these naming patterns:</p>

                <ul>
                    <li><code>*.test.ts</code> or <code>*.test.tsx</code> - Right next to your source files</li>
                    <li><code>*.spec.ts</code> or <code>*.spec.tsx</code> - Alternative convention</li>
                    <li><code>__tests__/*.ts</code> or <code>__tests__/*.tsx</code> - In a __tests__ folder</li>
                </ul>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Recommended Structure</h4>
                    <p>For React components, place test files next to the component:</p>
                    <pre><code>src/
  components/
    Button/
      Button.tsx
      Button.test.tsx
      Button.css</code></pre>
                    <p>For utility functions, you can use either approach (co-located or __tests__ folder).</p>
                </div>
            </section>

            <!-- Section 6: Writing Your First Test -->
            <section id="first-test" class="lesson-section">
                <h2>‚úçÔ∏è Writing Your First Test</h2>
                
                <p>Let's write our very first test! We'll start simple with a utility function, then build up to more complex scenarios.</p>

                <h3>A Simple Function to Test</h3>
                <p>Create a file called <code>utils.ts</code>:</p>

                <pre><code class="language-typescript">
// utils.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function subtract(a: number, b: number): number {
  return a - b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}
                </code></pre>

                <h3>Your First Test File</h3>
                <p>Now create <code>utils.test.ts</code> in the same directory:</p>

                <pre><code class="language-typescript">
// utils.test.ts
import { add, subtract, multiply } from './utils';

test('adds two numbers correctly', () => {
  const result = add(2, 3);
  expect(result).toBe(5);
});

test('subtracts two numbers correctly', () => {
  const result = subtract(10, 4);
  expect(result).toBe(6);
});

test('multiplies two numbers correctly', () => {
  const result = multiply(3, 4);
  expect(result).toBe(12);
});
                </code></pre>

                <h3>Understanding Test Syntax</h3>
                <p>Let's break down what's happening in these tests:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Test Anatomy</h4>
                    <pre style="color: white;"><code>test('description of what you're testing', () => {
  // Test code goes here
  expect(actualValue).toBe(expectedValue);
});</code></pre>
                </div>

                <ul>
                    <li><strong><code>test()</code>:</strong> Defines a test (you can also use <code>it()</code>‚Äîthey're identical)</li>
                    <li><strong>Description string:</strong> Explains what the test does in plain English</li>
                    <li><strong>Callback function:</strong> Contains the actual test code</li>
                    <li><strong><code>expect()</code>:</strong> Creates an assertion about a value</li>
                    <li><strong><code>.toBe()</code>:</strong> A "matcher" that checks if values are equal</li>
                </ul>

                <h3>Running Your Tests</h3>
                <p>Run your tests with:</p>

                <pre><code class="language-bash">
npm test
                </code></pre>

                <p>You should see output like this:</p>

                <pre><code class="language-plaintext">
 PASS  ./utils.test.ts
  ‚úì adds two numbers correctly (2 ms)
  ‚úì subtracts two numbers correctly (1 ms)
  ‚úì multiplies two numbers correctly (1 ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Time:        1.234 s
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéâ Congratulations!</h4>
                    <p>You just wrote and ran your first automated tests! That green checkmark feeling is addictive‚Äîyou'll want to see it all the time.</p>
                </div>

                <h3>Common Jest Matchers</h3>
                <p>Jest provides many matchers for different types of assertions:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Matcher</th>
                            <th>Use Case</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>.toBe()</code></td>
                            <td>Exact equality (===)</td>
                            <td><code>expect(2 + 2).toBe(4)</code></td>
                        </tr>
                        <tr>
                            <td><code>.toEqual()</code></td>
                            <td>Deep equality for objects/arrays</td>
                            <td><code>expect(obj).toEqual({a: 1})</code></td>
                        </tr>
                        <tr>
                            <td><code>.toBeTruthy()</code></td>
                            <td>Value is truthy</td>
                            <td><code>expect("hello").toBeTruthy()</code></td>
                        </tr>
                        <tr>
                            <td><code>.toBeFalsy()</code></td>
                            <td>Value is falsy</td>
                            <td><code>expect(0).toBeFalsy()</code></td>
                        </tr>
                        <tr>
                            <td><code>.toBeNull()</code></td>
                            <td>Value is null</td>
                            <td><code>expect(value).toBeNull()</code></td>
                        </tr>
                        <tr>
                            <td><code>.toBeUndefined()</code></td>
                            <td>Value is undefined</td>
                            <td><code>expect(value).toBeUndefined()</code></td>
                        </tr>
                        <tr>
                            <td><code>.toContain()</code></td>
                            <td>Array/string contains item</td>
                            <td><code>expect([1,2,3]).toContain(2)</code></td>
                        </tr>
                        <tr>
                            <td><code>.toHaveLength()</code></td>
                            <td>Array/string length</td>
                            <td><code>expect(arr).toHaveLength(3)</code></td>
                        </tr>
                        <tr>
                            <td><code>.toThrow()</code></td>
                            <td>Function throws error</td>
                            <td><code>expect(fn).toThrow()</code></td>
                        </tr>
                        <tr>
                            <td><code>.toBeGreaterThan()</code></td>
                            <td>Numeric comparison</td>
                            <td><code>expect(10).toBeGreaterThan(5)</code></td>
                        </tr>
                    </tbody>
                </table>

                <h3>Negating Matchers</h3>
                <p>You can negate any matcher with <code>.not</code>:</p>

                <pre><code class="language-typescript">
test('number is not zero', () => {
  expect(5).not.toBe(0);
});

test('array does not contain item', () => {
  expect([1, 2, 3]).not.toContain(4);
});
                </code></pre>
            </section>

            <!-- Section 7: The AAA Pattern -->
            <section id="aaa-pattern" class="lesson-section">
                <h2>üéØ The AAA Pattern</h2>
                
                <p>The AAA (Arrange-Act-Assert) pattern is a widely-used structure for writing clear, maintainable tests. It helps organize your test code and makes tests easier to understand.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ AAA Pattern</h4>
                    <p style="color: white;"><strong>Arrange-Act-Assert (AAA)</strong> is a pattern for structuring tests:</p>
                    <ul style="color: white;">
                        <li><strong>Arrange:</strong> Set up the test data and conditions</li>
                        <li><strong>Act:</strong> Execute the code being tested</li>
                        <li><strong>Assert:</strong> Verify the results are correct</li>
                    </ul>
                </div>

                <h3>Breaking Down the Pattern</h3>

                <h4>1Ô∏è‚É£ Arrange</h4>
                <p>Set up everything needed for the test:</p>
                <ul>
                    <li>Create test data</li>
                    <li>Configure mocks</li>
                    <li>Set initial state</li>
                    <li>Prepare any dependencies</li>
                </ul>

                <h4>2Ô∏è‚É£ Act</h4>
                <p>Execute the specific behavior you're testing:</p>
                <ul>
                    <li>Call the function</li>
                    <li>Trigger the event</li>
                    <li>Perform the action</li>
                </ul>

                <h4>3Ô∏è‚É£ Assert</h4>
                <p>Verify the outcome matches expectations:</p>
                <ul>
                    <li>Check return values</li>
                    <li>Verify state changes</li>
                    <li>Confirm side effects</li>
                </ul>

                <h3>Example: Without AAA Pattern</h3>
                <p>Here's a test without clear structure:</p>

                <pre><code class="language-typescript">
// ‚ùå Hard to read and understand
test('calculates user discount', () => {
  expect(calculateDiscount({ isPremium: true, cartTotal: 100 })).toBe(90);
});
                </code></pre>

                <h3>Example: With AAA Pattern</h3>
                <p>Now let's apply the AAA pattern:</p>

                <pre><code class="language-typescript">
// ‚úÖ Clear and easy to understand
test('calculates 10% discount for premium users', () => {
  // Arrange - Set up test data
  const user = {
    isPremium: true,
    cartTotal: 100
  };
  
  // Act - Execute the function
  const discountedTotal = calculateDiscount(user);
  
  // Assert - Verify the result
  expect(discountedTotal).toBe(90);
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of AAA Pattern</h4>
                    <ul>
                        <li><strong>Clarity:</strong> Anyone can understand what the test does</li>
                        <li><strong>Maintainability:</strong> Easy to modify and update</li>
                        <li><strong>Debugging:</strong> Quick to identify which part failed</li>
                        <li><strong>Consistency:</strong> All tests follow the same structure</li>
                    </ul>
                </div>

                <h3>More Complex Example</h3>
                <p>Let's see AAA with a more realistic scenario:</p>

                <pre><code class="language-typescript">
// Test a function that formats user data
interface User {
  firstName: string;
  lastName: string;
  email: string;
}

function formatUserDisplay(user: User): string {
  return `${user.firstName} ${user.lastName} (${user.email})`;
}

test('formats user display with all information', () => {
  // Arrange - Create test user
  const testUser: User = {
    firstName: 'Alice',
    lastName: 'Johnson',
    email: 'alice@example.com'
  };
  
  // Act - Format the user
  const displayString = formatUserDisplay(testUser);
  
  // Assert - Verify correct format
  expect(displayString).toBe('Alice Johnson (alice@example.com)');
});
                </code></pre>

                <h3>AAA with Multiple Assertions</h3>
                <p>Sometimes you need multiple assertions. That's fine, as long as they're all testing the same behavior:</p>

                <pre><code class="language-typescript">
interface ShoppingCart {
  items: Array&lt;{ name: string; price: number }&gt;;
  total: number;
  itemCount: number;
}

function addItemToCart(
  cart: ShoppingCart, 
  item: { name: string; price: number }
): ShoppingCart {
  return {
    items: [...cart.items, item],
    total: cart.total + item.price,
    itemCount: cart.itemCount + 1
  };
}

test('adding item updates cart correctly', () => {
  // Arrange
  const initialCart: ShoppingCart = {
    items: [],
    total: 0,
    itemCount: 0
  };
  
  const newItem = {
    name: 'Widget',
    price: 29.99
  };
  
  // Act
  const updatedCart = addItemToCart(initialCart, newItem);
  
  // Assert - Multiple related assertions are OK
  expect(updatedCart.items).toHaveLength(1);
  expect(updatedCart.items[0]).toEqual(newItem);
  expect(updatedCart.total).toBe(29.99);
  expect(updatedCart.itemCount).toBe(1);
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Pro Tip: Comments Are Optional</h4>
                    <p>Once you're comfortable with AAA, you don't need to write the comments. The pattern should be evident from the code structure itself. Use blank lines to separate the three sections visually.</p>
                </div>

                <h3>Using describe() for Organization</h3>
                <p>For related tests, use <code>describe()</code> blocks to group them:</p>

                <pre><code class="language-typescript">
describe('ShoppingCart', () => {
  describe('addItemToCart', () => {
    test('adds item to empty cart', () => {
      // Arrange
      const cart: ShoppingCart = { items: [], total: 0, itemCount: 0 };
      const item = { name: 'Widget', price: 10 };
      
      // Act
      const result = addItemToCart(cart, item);
      
      // Assert
      expect(result.itemCount).toBe(1);
    });
    
    test('adds item to cart with existing items', () => {
      // Arrange
      const cart: ShoppingCart = { 
        items: [{ name: 'Existing', price: 5 }], 
        total: 5, 
        itemCount: 1 
      };
      const item = { name: 'Widget', price: 10 };
      
      // Act
      const result = addItemToCart(cart, item);
      
      // Assert
      expect(result.itemCount).toBe(2);
      expect(result.total).toBe(15);
    });
  });
});
                </code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Watch Out: Too Many Assertions</h4>
                    <p>If you find yourself writing many unrelated assertions in a single test, you might be testing too much at once. Consider splitting into multiple tests, each focused on one behavior.</p>
                </div>
            </section>

            <!-- Section 8: Testing Utility Functions -->
            <section id="testing-utilities" class="lesson-section">
                <h2>üîß Testing Utility Functions</h2>
                
                <p>Utility functions are the perfect starting point for testing because they're typically pure functions‚Äîsame input always produces the same output. Let's test some real-world utilities.</p>

                <h3>Example 1: Email Validation</h3>

                <p>First, let's create the utility function:</p>

                <pre><code class="language-typescript">
// validators.ts
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
                </code></pre>

                <p>Now let's write comprehensive tests:</p>

                <pre><code class="language-typescript">
// validators.test.ts
import { isValidEmail } from './validators';

describe('isValidEmail', () => {
  test('returns true for valid email', () => {
    // Arrange
    const email = 'user@example.com';
    
    // Act
    const result = isValidEmail(email);
    
    // Assert
    expect(result).toBe(true);
  });
  
  test('returns false for email without @', () => {
    const email = 'userexample.com';
    const result = isValidEmail(email);
    expect(result).toBe(false);
  });
  
  test('returns false for email without domain', () => {
    const email = 'user@';
    const result = isValidEmail(email);
    expect(result).toBe(false);
  });
  
  test('returns false for email without local part', () => {
    const email = '@example.com';
    const result = isValidEmail(email);
    expect(result).toBe(false);
  });
  
  test('returns false for email with spaces', () => {
    const email = 'user @example.com';
    const result = isValidEmail(email);
    expect(result).toBe(false);
  });
  
  test('returns true for email with subdomain', () => {
    const email = 'user@mail.example.com';
    const result = isValidEmail(email);
    expect(result).toBe(true);
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Testing Edge Cases</h4>
                    <p>Notice how we test both valid inputs and various invalid inputs. Good tests cover:</p>
                    <ul>
                        <li><strong>Happy path:</strong> Valid, expected inputs</li>
                        <li><strong>Edge cases:</strong> Boundary conditions</li>
                        <li><strong>Invalid inputs:</strong> What happens with bad data</li>
                    </ul>
                </div>

                <h3>Example 2: Currency Formatting</h3>

                <pre><code class="language-typescript">
// formatters.ts
export function formatCurrency(
  amount: number, 
  currency: string = 'USD'
): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency
  }).format(amount);
}
                </code></pre>

                <pre><code class="language-typescript">
// formatters.test.ts
import { formatCurrency } from './formatters';

describe('formatCurrency', () => {
  test('formats positive amount in USD', () => {
    const result = formatCurrency(1234.56);
    expect(result).toBe('$1,234.56');
  });
  
  test('formats zero correctly', () => {
    const result = formatCurrency(0);
    expect(result).toBe('$0.00');
  });
  
  test('formats negative amount', () => {
    const result = formatCurrency(-50.25);
    expect(result).toBe('-$50.25');
  });
  
  test('rounds to two decimal places', () => {
    const result = formatCurrency(10.999);
    expect(result).toBe('$11.00');
  });
  
  test('formats large numbers with commas', () => {
    const result = formatCurrency(1000000);
    expect(result).toBe('$1,000,000.00');
  });
  
  test('accepts different currency codes', () => {
    const result = formatCurrency(100, 'EUR');
    expect(result).toBe('‚Ç¨100.00');
  });
});
                </code></pre>

                <h3>Example 3: Array Utilities</h3>

                <pre><code class="language-typescript">
// arrayUtils.ts
export function removeDuplicates&lt;T&gt;(array: T[]): T[] {
  return [...new Set(array)];
}

export function chunk&lt;T&gt;(array: T[], size: number): T[][] {
  const chunks: T[][] = [];
  for (let i = 0; i &lt; array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
                </code></pre>

                <pre><code class="language-typescript">
// arrayUtils.test.ts
import { removeDuplicates, chunk } from './arrayUtils';

describe('removeDuplicates', () => {
  test('removes duplicate numbers', () => {
    // Arrange
    const numbers = [1, 2, 2, 3, 3, 3, 4];
    
    // Act
    const result = removeDuplicates(numbers);
    
    // Assert
    expect(result).toEqual([1, 2, 3, 4]);
  });
  
  test('removes duplicate strings', () => {
    const strings = ['a', 'b', 'a', 'c', 'b'];
    const result = removeDuplicates(strings);
    expect(result).toEqual(['a', 'b', 'c']);
  });
  
  test('returns empty array for empty input', () => {
    const result = removeDuplicates([]);
    expect(result).toEqual([]);
  });
  
  test('returns same array if no duplicates', () => {
    const numbers = [1, 2, 3, 4];
    const result = removeDuplicates(numbers);
    expect(result).toEqual([1, 2, 3, 4]);
  });
});

describe('chunk', () => {
  test('splits array into chunks of specified size', () => {
    const array = [1, 2, 3, 4, 5, 6];
    const result = chunk(array, 2);
    expect(result).toEqual([[1, 2], [3, 4], [5, 6]]);
  });
  
  test('handles last chunk with fewer elements', () => {
    const array = [1, 2, 3, 4, 5];
    const result = chunk(array, 2);
    expect(result).toEqual([[1, 2], [3, 4], [5]]);
  });
  
  test('returns single chunk if size larger than array', () => {
    const array = [1, 2, 3];
    const result = chunk(array, 5);
    expect(result).toEqual([[1, 2, 3]]);
  });
  
  test('returns empty array for empty input', () => {
    const result = chunk([], 2);
    expect(result).toEqual([]);
  });
});
                </code></pre>

                <h3>TypeScript-Specific Testing</h3>
                <p>When testing TypeScript code, make sure your tests are properly typed:</p>

                <pre><code class="language-typescript">
// Type-safe test
test('function returns correct type', () => {
  interface User {
    id: number;
    name: string;
  }
  
  function getUser(id: number): User {
    return { id, name: 'Test User' };
  }
  
  // Arrange
  const userId = 1;
  
  // Act
  const user: User = getUser(userId); // TypeScript ensures return type
  
  // Assert
  expect(user).toHaveProperty('id');
  expect(user).toHaveProperty('name');
  expect(user.id).toBe(userId);
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Test Coverage Goal</h4>
                    <p>Aim for high coverage on utility functions since they're used throughout your application. A bug in a utility function can affect many features, so thorough testing here pays dividends.</p>
                </div>
            </section>

            <!-- Section 9: Hands-on Exercises -->
            <section id="exercises" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Exercises</h2>
                
                <p>Now it's time to practice! These exercises will help you solidify your understanding of testing fundamentals. Work through each one, and don't peek at the solutions until you've tried yourself.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: String Utilities</h3>
                    <p><strong>Objective:</strong> Write tests for string manipulation functions.</p>
                    
                    <h4>Instructions:</h4>
                    <ol>
                        <li>Create a file called <code>stringUtils.ts</code></li>
                        <li>Implement the following functions:
                            <ul>
                                <li><code>capitalize(str: string): string</code> - Capitalizes first letter</li>
                                <li><code>truncate(str: string, maxLength: number): string</code> - Truncates string with "..."</li>
                                <li><code>isPalindrome(str: string): boolean</code> - Checks if string is palindrome (ignore case/spaces)</li>
                            </ul>
                        </li>
                        <li>Create <code>stringUtils.test.ts</code> and write tests for each function</li>
                        <li>Test edge cases: empty strings, special characters, very long strings</li>
                    </ol>
                    
                    <h4>Starter Code:</h4>
                    <pre><code class="language-typescript">
// stringUtils.ts
export function capitalize(str: string): string {
  // TODO: Implement
  return '';
}

export function truncate(str: string, maxLength: number): string {
  // TODO: Implement
  return '';
}

export function isPalindrome(str: string): boolean {
  // TODO: Implement
  return false;
}
                    </code></pre>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>For <code>capitalize()</code>, handle empty strings and already-capitalized strings.</p>
                        <p>For <code>truncate()</code>, only add "..." if the string is actually longer than maxLength.</p>
                        <p>For <code>isPalindrome()</code>, normalize the string (lowercase, remove spaces) before comparing.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">
// stringUtils.ts
export function capitalize(str: string): string {
  if (!str) return '';
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}

export function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength) + '...';
}

export function isPalindrome(str: string): boolean {
  const normalized = str.toLowerCase().replace(/\s/g, '');
  return normalized === normalized.split('').reverse().join('');
}

// stringUtils.test.ts
import { capitalize, truncate, isPalindrome } from './stringUtils';

describe('capitalize', () => {
  test('capitalizes first letter of lowercase word', () => {
    expect(capitalize('hello')).toBe('Hello');
  });
  
  test('handles already capitalized word', () => {
    expect(capitalize('Hello')).toBe('Hello');
  });
  
  test('handles empty string', () => {
    expect(capitalize('')).toBe('');
  });
  
  test('lowercases rest of word', () => {
    expect(capitalize('hELLO')).toBe('Hello');
  });
});

describe('truncate', () => {
  test('truncates long string', () => {
    const result = truncate('This is a long string', 10);
    expect(result).toBe('This is a ...');
  });
  
  test('returns short string unchanged', () => {
    const result = truncate('Short', 10);
    expect(result).toBe('Short');
  });
  
  test('returns string of exact max length unchanged', () => {
    const result = truncate('Exactly10!', 10);
    expect(result).toBe('Exactly10!');
  });
});

describe('isPalindrome', () => {
  test('returns true for simple palindrome', () => {
    expect(isPalindrome('racecar')).toBe(true);
  });
  
  test('returns true ignoring case', () => {
    expect(isPalindrome('RaceCar')).toBe(true);
  });
  
  test('returns true ignoring spaces', () => {
    expect(isPalindrome('race car')).toBe(true);
  });
  
  test('returns false for non-palindrome', () => {
    expect(isPalindrome('hello')).toBe(false);
  });
  
  test('returns true for single character', () => {
    expect(isPalindrome('a')).toBe(true);
  });
});
                        </code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Date Utilities</h3>
                    <p><strong>Objective:</strong> Test date manipulation functions with proper TypeScript typing.</p>
                    
                    <h4>Instructions:</h4>
                    <ol>
                        <li>Create <code>dateUtils.ts</code> with these functions:
                            <ul>
                                <li><code>formatDate(date: Date): string</code> - Format as "YYYY-MM-DD"</li>
                                <li><code>isWeekend(date: Date): boolean</code> - Check if Saturday or Sunday</li>
                                <li><code>daysBetween(date1: Date, date2: Date): number</code> - Calculate days between dates</li>
                            </ul>
                        </li>
                        <li>Write comprehensive tests in <code>dateUtils.test.ts</code></li>
                        <li>Use the AAA pattern for all tests</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>For <code>formatDate()</code>, use <code>toISOString()</code> and string manipulation, or create your own formatter.</p>
                        <p>For <code>isWeekend()</code>, remember <code>getDay()</code> returns 0 for Sunday and 6 for Saturday.</p>
                        <p>For <code>daysBetween()</code>, convert dates to milliseconds, find difference, and convert back to days.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">
// dateUtils.ts
export function formatDate(date: Date): string {
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

export function isWeekend(date: Date): boolean {
  const dayOfWeek = date.getDay();
  return dayOfWeek === 0 || dayOfWeek === 6;
}

export function daysBetween(date1: Date, date2: Date): number {
  const msPerDay = 24 * 60 * 60 * 1000;
  const diffMs = Math.abs(date2.getTime() - date1.getTime());
  return Math.floor(diffMs / msPerDay);
}

// dateUtils.test.ts
import { formatDate, isWeekend, daysBetween } from './dateUtils';

describe('formatDate', () => {
  test('formats date correctly', () => {
    // Arrange
    const date = new Date('2024-03-15');
    
    // Act
    const result = formatDate(date);
    
    // Assert
    expect(result).toBe('2024-03-15');
  });
  
  test('pads single-digit months and days', () => {
    const date = new Date('2024-01-05');
    const result = formatDate(date);
    expect(result).toBe('2024-01-05');
  });
});

describe('isWeekend', () => {
  test('returns true for Saturday', () => {
    // Arrange - March 16, 2024 is a Saturday
    const saturday = new Date('2024-03-16');
    
    // Act
    const result = isWeekend(saturday);
    
    // Assert
    expect(result).toBe(true);
  });
  
  test('returns true for Sunday', () => {
    const sunday = new Date('2024-03-17');
    const result = isWeekend(sunday);
    expect(result).toBe(true);
  });
  
  test('returns false for weekday', () => {
    const monday = new Date('2024-03-18');
    const result = isWeekend(monday);
    expect(result).toBe(false);
  });
});

describe('daysBetween', () => {
  test('calculates days between dates', () => {
    // Arrange
    const date1 = new Date('2024-01-01');
    const date2 = new Date('2024-01-11');
    
    // Act
    const result = daysBetween(date1, date2);
    
    // Assert
    expect(result).toBe(10);
  });
  
  test('handles dates in reverse order', () => {
    const date1 = new Date('2024-01-11');
    const date2 = new Date('2024-01-01');
    const result = daysBetween(date1, date2);
    expect(result).toBe(10);
  });
  
  test('returns zero for same date', () => {
    const date = new Date('2024-01-01');
    const result = daysBetween(date, date);
    expect(result).toBe(0);
  });
});
                        </code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Shopping Cart Logic</h3>
                    <p><strong>Objective:</strong> Test more complex business logic with objects and arrays.</p>
                    
                    <h4>Instructions:</h4>
                    <ol>
                        <li>Create <code>cart.ts</code> with these interfaces and functions:
                            <pre><code class="language-typescript">
interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface Cart {
  items: CartItem[];
  subtotal: number;
  tax: number;
  total: number;
}

// Implement these:
function addItem(cart: Cart, item: CartItem): Cart
function removeItem(cart: Cart, itemId: string): Cart
function calculateTotals(cart: Cart, taxRate: number): Cart
function getItemCount(cart: Cart): number
                            </code></pre>
                        </li>
                        <li>Write tests for each function</li>
                        <li>Test edge cases: empty cart, removing non-existent items, zero prices</li>
                        <li>Ensure functions return new objects (immutability)</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use spread operators to create new objects/arrays instead of mutating existing ones.</p>
                        <p>For <code>calculateTotals()</code>, remember: <code>total = subtotal + tax</code> where <code>tax = subtotal * taxRate</code></p>
                        <p>For <code>getItemCount()</code>, sum up all quantities, not just array length.</p>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">
// cart.ts
export interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

export interface Cart {
  items: CartItem[];
  subtotal: number;
  tax: number;
  total: number;
}

export function addItem(cart: Cart, item: CartItem): Cart {
  const newItems = [...cart.items, item];
  const subtotal = newItems.reduce((sum, i) => sum + (i.price * i.quantity), 0);
  
  return {
    ...cart,
    items: newItems,
    subtotal,
    total: subtotal + cart.tax
  };
}

export function removeItem(cart: Cart, itemId: string): Cart {
  const newItems = cart.items.filter(item => item.id !== itemId);
  const subtotal = newItems.reduce((sum, i) => sum + (i.price * i.quantity), 0);
  
  return {
    ...cart,
    items: newItems,
    subtotal,
    total: subtotal + cart.tax
  };
}

export function calculateTotals(cart: Cart, taxRate: number): Cart {
  const subtotal = cart.items.reduce((sum, i) => sum + (i.price * i.quantity), 0);
  const tax = subtotal * taxRate;
  
  return {
    ...cart,
    subtotal,
    tax,
    total: subtotal + tax
  };
}

export function getItemCount(cart: Cart): number {
  return cart.items.reduce((sum, item) => sum + item.quantity, 0);
}

// cart.test.ts
import { addItem, removeItem, calculateTotals, getItemCount, Cart, CartItem } from './cart';

describe('Shopping Cart', () => {
  describe('addItem', () => {
    test('adds item to empty cart', () => {
      // Arrange
      const emptyCart: Cart = { items: [], subtotal: 0, tax: 0, total: 0 };
      const item: CartItem = { id: '1', name: 'Widget', price: 10, quantity: 2 };
      
      // Act
      const result = addItem(emptyCart, item);
      
      // Assert
      expect(result.items).toHaveLength(1);
      expect(result.items[0]).toEqual(item);
      expect(result.subtotal).toBe(20);
    });
    
    test('adds item to cart with existing items', () => {
      const cart: Cart = {
        items: [{ id: '1', name: 'First', price: 10, quantity: 1 }],
        subtotal: 10,
        tax: 0,
        total: 10
      };
      const newItem: CartItem = { id: '2', name: 'Second', price: 15, quantity: 1 };
      
      const result = addItem(cart, newItem);
      
      expect(result.items).toHaveLength(2);
      expect(result.subtotal).toBe(25);
    });
    
    test('does not mutate original cart', () => {
      const cart: Cart = { items: [], subtotal: 0, tax: 0, total: 0 };
      const item: CartItem = { id: '1', name: 'Widget', price: 10, quantity: 1 };
      
      addItem(cart, item);
      
      expect(cart.items).toHaveLength(0); // Original unchanged
    });
  });
  
  describe('removeItem', () => {
    test('removes item from cart', () => {
      // Arrange
      const cart: Cart = {
        items: [
          { id: '1', name: 'Item1', price: 10, quantity: 1 },
          { id: '2', name: 'Item2', price: 20, quantity: 1 }
        ],
        subtotal: 30,
        tax: 0,
        total: 30
      };
      
      // Act
      const result = removeItem(cart, '1');
      
      // Assert
      expect(result.items).toHaveLength(1);
      expect(result.items[0].id).toBe('2');
      expect(result.subtotal).toBe(20);
    });
    
    test('handles removing non-existent item', () => {
      const cart: Cart = {
        items: [{ id: '1', name: 'Item', price: 10, quantity: 1 }],
        subtotal: 10,
        tax: 0,
        total: 10
      };
      
      const result = removeItem(cart, '999');
      
      expect(result.items).toHaveLength(1);
      expect(result.subtotal).toBe(10);
    });
  });
  
  describe('calculateTotals', () => {
    test('calculates subtotal, tax, and total', () => {
      // Arrange
      const cart: Cart = {
        items: [
          { id: '1', name: 'Item', price: 100, quantity: 2 }
        ],
        subtotal: 0,
        tax: 0,
        total: 0
      };
      const taxRate = 0.08; // 8% tax
      
      // Act
      const result = calculateTotals(cart, taxRate);
      
      // Assert
      expect(result.subtotal).toBe(200);
      expect(result.tax).toBe(16);
      expect(result.total).toBe(216);
    });
    
    test('handles zero tax rate', () => {
      const cart: Cart = {
        items: [{ id: '1', name: 'Item', price: 50, quantity: 1 }],
        subtotal: 0,
        tax: 0,
        total: 0
      };
      
      const result = calculateTotals(cart, 0);
      
      expect(result.subtotal).toBe(50);
      expect(result.tax).toBe(0);
      expect(result.total).toBe(50);
    });
  });
  
  describe('getItemCount', () => {
    test('returns total quantity of items', () => {
      // Arrange
      const cart: Cart = {
        items: [
          { id: '1', name: 'Item1', price: 10, quantity: 2 },
          { id: '2', name: 'Item2', price: 20, quantity: 3 }
        ],
        subtotal: 0,
        tax: 0,
        total: 0
      };
      
      // Act
      const count = getItemCount(cart);
      
      // Assert
      expect(count).toBe(5); // 2 + 3
    });
    
    test('returns zero for empty cart', () => {
      const cart: Cart = { items: [], subtotal: 0, tax: 0, total: 0 };
      const count = getItemCount(cart);
      expect(count).toBe(0);
    });
  });
});
                        </code></pre>
                    </details>
                </div>

                <div class="card quiz-container">
                    <h3>üéØ Quick Quiz</h3>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What does the "Arrange" phase of the AAA pattern involve?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="That's the Assert phase">
                                A) Verifying the results are correct
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Arrange is where you set up test data and initial conditions.">
                                B) Setting up test data and conditions
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="That's the Act phase">
                                C) Executing the code being tested
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                    
                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> In the testing pyramid, which type of test should you have the MOST of?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="E2E tests should be the smallest portion">
                                A) End-to-End tests
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Integration tests are the middle layer">
                                B) Integration tests
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Unit tests form the foundation and should be 50-70% of your test suite.">
                                C) Unit tests
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                    
                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> What Jest matcher should you use to compare objects for equality?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="toBe() uses === which doesn't work for objects">
                                A) .toBe()
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! toEqual() performs deep equality checks for objects and arrays.">
                                B) .toEqual()
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="toMatch() is for strings and regular expressions">
                                C) .toMatch()
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                    
                    <div class="quiz-question">
                        <p><strong>Question 4:</strong> Which characteristic is TRUE about unit tests?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="That describes E2E tests">
                                A) They test the entire application from end to end
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! Unit tests are fast, isolated, and test one small piece of code.">
                                B) They test a single function in isolation
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="That describes integration tests">
                                C) They test multiple components working together
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="best-practices" class="lesson-section">
                <h2>‚ú® Best Practices</h2>
                
                <p>Following these best practices will help you write effective, maintainable tests that provide real value to your codebase.</p>

                <h3>‚úÖ Do's</h3>

                <h4>1. Write Descriptive Test Names</h4>
                <p>Test names should clearly describe what's being tested and what the expected outcome is.</p>
                
                <pre><code class="language-typescript">
// ‚ùå Bad - Vague test name
test('test user', () => { ... });

// ‚úÖ Good - Clear and descriptive
test('returns user object with all required fields when given valid ID', () => { ... });
                </code></pre>

                <h4>2. Test One Thing at a Time</h4>
                <p>Each test should verify a single behavior or scenario.</p>

                <pre><code class="language-typescript">
// ‚ùå Bad - Testing multiple unrelated things
test('user functions', () => {
  expect(createUser()).toBeDefined();
  expect(deleteUser()).toBe(true);
  expect(updateUser()).not.toThrow();
});

// ‚úÖ Good - Separate tests for each behavior
test('createUser returns defined user object', () => { ... });
test('deleteUser returns true on successful deletion', () => { ... });
test('updateUser does not throw error', () => { ... });
                </code></pre>

                <h4>3. Keep Tests Independent</h4>
                <p>Tests should not depend on each other or share state.</p>

                <pre><code class="language-typescript">
// ‚ùå Bad - Tests depend on execution order
let user: User;

test('creates user', () => {
  user = createUser();
  expect(user).toBeDefined();
});

test('updates user', () => {
  // Depends on previous test!
  const updated = updateUser(user, { name: 'New Name' });
  expect(updated.name).toBe('New Name');
});

// ‚úÖ Good - Each test is independent
test('creates user', () => {
  const user = createUser();
  expect(user).toBeDefined();
});

test('updates user', () => {
  // Create fresh user for this test
  const user = createUser();
  const updated = updateUser(user, { name: 'New Name' });
  expect(updated.name).toBe('New Name');
});
                </code></pre>

                <h4>4. Use Meaningful Test Data</h4>
                <p>Choose test data that makes the test's purpose clear.</p>

                <pre><code class="language-typescript">
// ‚ùå Bad - Unclear what's being tested
test('validates email', () => {
  expect(isValidEmail('test@test.com')).toBe(true);
});

// ‚úÖ Good - Test data illustrates the scenario
test('accepts email with subdomain', () => {
  expect(isValidEmail('user@mail.example.com')).toBe(true);
});

test('rejects email without domain extension', () => {
  expect(isValidEmail('user@example')).toBe(false);
});
                </code></pre>

                <h4>5. Use Setup and Teardown Appropriately</h4>
                <p>Extract common setup into <code>beforeEach()</code> hooks when appropriate.</p>

                <pre><code class="language-typescript">
describe('ShoppingCart', () => {
  let cart: Cart;
  
  beforeEach(() => {
    // Fresh cart for each test
    cart = {
      items: [],
      subtotal: 0,
      tax: 0,
      total: 0
    };
  });
  
  test('starts empty', () => {
    expect(cart.items).toHaveLength(0);
  });
  
  test('can add items', () => {
    const item = { id: '1', name: 'Widget', price: 10, quantity: 1 };
    const result = addItem(cart, item);
    expect(result.items).toHaveLength(1);
  });
});
                </code></pre>

                <h3>‚ùå Don'ts</h3>

                <h4>1. Don't Test Implementation Details</h4>
                <p>Test behavior, not internal implementation.</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Why This Matters</h4>
                    <p>If you test implementation details, your tests will break every time you refactor‚Äîeven when the behavior stays the same. This makes refactoring painful and discourages improving code.</p>
                </div>

                <pre><code class="language-typescript">
// ‚ùå Bad - Testing internal implementation
test('uses array.map internally', () => {
  const spy = jest.spyOn(Array.prototype, 'map');
  processItems([1, 2, 3]);
  expect(spy).toHaveBeenCalled();
});

// ‚úÖ Good - Testing behavior/output
test('doubles all numbers in array', () => {
  const result = processItems([1, 2, 3]);
  expect(result).toEqual([2, 4, 6]);
});
                </code></pre>

                <h4>2. Don't Write Tests That Can't Fail</h4>
                <p>If a test always passes, it's not providing value.</p>

                <pre><code class="language-typescript">
// ‚ùå Bad - This test can never fail
test('function is defined', () => {
  expect(myFunction).toBeDefined();
});

// ‚úÖ Good - Actually tests behavior
test('function returns correct result', () => {
  const result = myFunction(5);
  expect(result).toBe(10);
});
                </code></pre>

                <h4>3. Don't Use Magic Numbers Without Context</h4>
                <p>Make test values meaningful and self-documenting.</p>

                <pre><code class="language-typescript">
// ‚ùå Bad - What do these numbers mean?
test('calculates price', () => {
  expect(calculatePrice(5, 10)).toBe(52.5);
});

// ‚úÖ Good - Clear what's being tested
test('calculates total price with tax', () => {
  const quantity = 5;
  const pricePerItem = 10;
  const taxRate = 0.05; // 5% tax
  const expectedTotal = 50 * 1.05; // 52.5
  
  const result = calculatePrice(quantity, pricePerItem, taxRate);
  expect(result).toBe(expectedTotal);
});
                </code></pre>

                <h4>4. Don't Ignore Flaky Tests</h4>
                <p>Fix or remove tests that randomly fail. Flaky tests erode trust in your entire test suite.</p>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Dealing with Flaky Tests</h4>
                    <p>Common causes of flaky tests:</p>
                    <ul>
                        <li>Timing issues (use proper async handling)</li>
                        <li>Shared state between tests</li>
                        <li>External dependencies (mock them)</li>
                        <li>Random data (use fixed test data)</li>
                    </ul>
                </div>

                <h4>5. Don't Skip Writing Tests for "Simple" Code</h4>
                <p>Even simple code can have bugs. Plus, tests serve as documentation.</p>

                <pre><code class="language-typescript">
// "Too simple to test?" Think again!
function isEven(num: number): boolean {
  return num % 2 === 0;
}

// Test anyway - catches edge cases and documents behavior
test('returns true for even numbers', () => {
  expect(isEven(2)).toBe(true);
  expect(isEven(0)).toBe(true);
  expect(isEven(-4)).toBe(true);
});

test('returns false for odd numbers', () => {
  expect(isEven(1)).toBe(false);
  expect(isEven(-3)).toBe(false);
});
                </code></pre>

                <h3>üí° Pro Tips</h3>

                <h4>1. Follow the F.I.R.S.T. Principles</h4>
                <p>Good tests are:</p>
                <ul>
                    <li><strong>F</strong>ast - Run quickly (milliseconds)</li>
                    <li><strong>I</strong>solated - Don't depend on other tests</li>
                    <li><strong>R</strong>epeatable - Same result every time</li>
                    <li><strong>S</strong>elf-validating - Pass or fail, no manual checking</li>
                    <li><strong>T</strong>imely - Written close to when code is written</li>
                </ul>

                <h4>2. Use Test Coverage as a Guide, Not a Goal</h4>
                <p>100% code coverage doesn't mean perfect tests. Focus on testing important behaviors.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Coverage Sweet Spot</h4>
                    <p>Aim for:</p>
                    <ul>
                        <li><strong>80-90% coverage</strong> for utility functions and business logic</li>
                        <li><strong>60-80% coverage</strong> overall is often good enough</li>
                        <li><strong>100% coverage</strong> of critical paths (payment, authentication, etc.)</li>
                    </ul>
                </div>

                <h4>3. Read Test Failures Carefully</h4>
                <p>Jest provides excellent error messages. Read them fully‚Äîthey often tell you exactly what's wrong.</p>

                <h4>4. Refactor Tests Like Production Code</h4>
                <p>Test code deserves the same care as production code. Keep it clean, DRY, and maintainable.</p>

                <h4>5. Use Descriptive Helper Functions</h4>
                <p>Extract common test patterns into well-named helpers.</p>

                <pre><code class="language-typescript">
// Helper function makes tests clearer
function createTestUser(overrides = {}): User {
  return {
    id: '1',
    name: 'Test User',
    email: 'test@example.com',
    ...overrides
  };
}

test('handles premium user', () => {
  const premiumUser = createTestUser({ isPremium: true });
  expect(calculateDiscount(premiumUser)).toBe(0.10);
});
                </code></pre>
            </section>

            <!-- Section 11: Summary -->
            <section id="summary" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Testing matters:</strong> Tests provide confidence, documentation, catch bugs early, improve design, and enable team collaboration</li>
                        <li><strong>Three types of tests:</strong> Unit tests (70%), integration tests (20-30%), E2E tests (10-20%) form the testing pyramid</li>
                        <li><strong>Jest is powerful:</strong> It provides everything you need for testing JavaScript/TypeScript applications</li>
                        <li><strong>AAA pattern works:</strong> Arrange-Act-Assert provides clear structure for writing tests</li>
                        <li><strong>Start simple:</strong> Begin with unit tests for utility functions before moving to complex scenarios</li>
                        <li><strong>Test behavior, not implementation:</strong> Focus on what code does, not how it does it</li>
                        <li><strong>Keep tests independent:</strong> Each test should run successfully in isolation</li>
                        <li><strong>Use descriptive names:</strong> Test names should clearly explain what's being verified</li>
                    </ul>
                </div>
                
                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://jestjs.io/docs/getting-started" target="_blank">Jest Official Documentation</a> - Comprehensive guide to Jest features</li>
                    <li><a href="https://testing-library.com/docs/react-testing-library/intro/" target="_blank">React Testing Library</a> - Learn to test React components (coming in next lesson!)</li>
                    <li><a href="https://martinfowler.com/bliki/TestPyramid.html" target="_blank">Martin Fowler on Test Pyramid</a> - Deep dive into testing strategy</li>
                    <li><a href="https://kentcdodds.com/blog/write-tests" target="_blank">Kent C. Dodds on Testing</a> - Excellent articles on testing philosophy</li>
                    <li><a href="https://github.com/goldbergyoni/javascript-testing-best-practices" target="_blank">JavaScript Testing Best Practices</a> - Comprehensive testing guide</li>
                </ul>
                
                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll dive into <strong>React Testing Library</strong> and learn how to test React components. You'll discover:</p>
                <ul>
                    <li>Testing Library's philosophy of testing user behavior</li>
                    <li>Rendering components in tests</li>
                    <li>Querying elements (getBy, findBy, queryBy)</li>
                    <li>Simulating user interactions</li>
                    <li>Testing asynchronous components</li>
                    <li>Best practices for component testing</li>
                </ul>

                <blockquote>
                    <strong>üí° Remember:</strong> Testing is a skill that improves with practice. Don't worry if your first tests feel awkward or take time to write. Every test you write makes you a better developer. Start small, test often, and gradually build your testing confidence!
                </blockquote>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've completed Testing Fundamentals! You now understand why testing matters, know the different types of tests, can set up Jest, and write your first unit tests with confidence. You're building a critical skill that will serve you throughout your entire career as a developer.</p>
                    <p style="color: white; margin-top: 1rem;">Keep practicing, and remember: the best time to start writing tests is now!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="module_project_8_social_media_feed.html" class="prev-lesson">‚Üê Previous: Module 8 Project</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_9_2_react_testing_library.html" class="next-lesson">Next: Lesson 9.2 - React Testing Library ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 Ray. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals through quality education.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
