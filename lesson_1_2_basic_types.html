<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master TypeScript's basic types - Learn about strings, numbers, booleans, arrays, tuples, and special types like any, unknown, never, and void.">
    <meta name="author" content="PracticalAce">
    <title>Basic Types - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module1">Module 1: TypeScript Fundamentals</a></li>
            <li aria-current="page">Lesson 1.2: Basic Types</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üé® Basic Types in TypeScript</h1>
                <p class="lead">Welcome to the colorful world of TypeScript types! Think of types as different colored LEGO bricks - each one has its purpose, and knowing which brick to use makes building amazing things so much easier. In this lesson, we'll explore TypeScript's fundamental building blocks and learn how to use them like a pro! üß±</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Master TypeScript's primitive types: string, number, boolean</li>
                        <li>Work confidently with arrays and understand different array syntax</li>
                        <li>Use tuples to represent fixed-length arrays with mixed types</li>
                        <li>Understand when to use any, unknown, never, and void</li>
                        <li>Leverage type inference to write cleaner code</li>
                        <li>Create union types for flexible, type-safe code</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 60-75 minutes</p>
                    <p><strong>Project:</strong> Build a type-safe inventory system using all the basic types</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Primitive Types</a></li>
                        <li><a href="#section2" class="toc-link">Arrays and Tuples</a></li>
                        <li><a href="#section3" class="toc-link">Type Inference</a></li>
                        <li><a href="#section4" class="toc-link">Union Types</a></li>
                        <li><a href="#section5" class="toc-link">Literal Types</a></li>
                        <li><a href="#section6" class="toc-link">Special Types</a></li>
                        <li><a href="#section7" class="toc-link">Hands-on Practice</a></li>
                        <li><a href="#section8" class="toc-link">Best Practices</a></li>
                        <li><a href="#section9" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Primitive Types -->
            <section id="section1" class="lesson-section">
                <h2>Primitive Types: The Foundation</h2>
                
                <p>Just like learning the alphabet before writing words, we need to understand TypeScript's primitive types before building complex applications. These are the fundamental building blocks - simple, atomic types that can't be broken down further. Let's meet the main characters! üé≠</p>

                <h3>String: Working with Text</h3>
                <p>Think of a string as any text you can type - names, messages, descriptions, you name it! In TypeScript, we use the <code>string</code> type for all text data.</p>

                <pre><code class="language-typescript">// Declare a string variable
let userName: string = "Alice";
let greeting: string = 'Hello, World!';
let message: string = `Welcome, ${userName}!`;  // Template literals work great!

// Strings can be reassigned to other strings
userName = "Bob";           // ‚úÖ OK
userName = 123;             // ‚ùå Error! Type 'number' is not assignable to type 'string'
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üí° String Tips</h4>
                    <ul>
                        <li>Use template literals (backticks) for strings with variables: <code>`Hello, ${name}!`</code></li>
                        <li>Both single quotes and double quotes work - pick one style and stick with it</li>
                        <li>Multi-line strings are easy with template literals</li>
                    </ul>
                </div>

                <h3>Number: All Your Math Needs</h3>
                <p>Unlike some languages that have separate types for integers and decimals, TypeScript (like JavaScript) has just one <code>number</code> type. It's like a Swiss Army knife for all numeric needs! üî¢</p>

                <pre><code class="language-typescript">// All these are type 'number'
let age: number = 25;                    // Integer
let price: number = 19.99;               // Decimal
let temperature: number = -5;            // Negative
let bigNumber: number = 1_000_000;       // With underscores for readability
let hex: number = 0xFF;                  // Hexadecimal
let binary: number = 0b1010;             // Binary
let octal: number = 0o744;               // Octal

// Math operations work as expected
let total: number = price * 2;           // 39.98
let average: number = (10 + 20) / 2;     // 15

// Special numeric values
let infinite: number = Infinity;
let notANumber: number = NaN;
</code></pre>

                <blockquote>
                    <strong>üéØ Real-World Example:</strong> You're building an e-commerce site. Prices, quantities, ratings, shipping weights - they're all <code>number</code> types. One type to rule them all!
                </blockquote>

                <h3>Boolean: True or False</h3>
                <p>The <code>boolean</code> type is your yes/no, on/off, true/false switch. It's the simplest type but incredibly powerful for logic! Think of it as a light switch - it's either on (true) or off (false). üí°</p>

                <pre><code class="language-typescript">// Boolean values
let isLoggedIn: boolean = true;
let hasPermission: boolean = false;
let isEmailVerified: boolean = true;

// Booleans from comparisons
let isAdult: boolean = age >= 18;        // true if age is 18 or more
let isEmpty: boolean = userName.length === 0;
let isValid: boolean = price > 0 && price < 1000;

// Using booleans in logic
if (isLoggedIn && hasPermission) {
    console.log("Access granted!");
}

// Common mistake - don't compare booleans with === true
if (isLoggedIn === true) {  // ‚ùå Redundant
    // do something
}

if (isLoggedIn) {           // ‚úÖ Better - it's already a boolean!
    // do something
}
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Truthiness vs Boolean</h4>
                    <p>In JavaScript, many values are "truthy" or "falsy" (like empty strings, 0, null), but that doesn't make them booleans. TypeScript keeps these concepts separate:</p>
                    <pre><code class="language-typescript">let count: number = 0;
let message: string = "";

// These are NOT booleans, even though they're "falsy"
let isFalsy: boolean = count;    // ‚ùå Error!
let isEmpty: boolean = message;   // ‚ùå Error!

// Convert explicitly if needed
let isFalsy: boolean = count === 0;      // ‚úÖ Correct
let isEmpty: boolean = message === "";   // ‚úÖ Correct
</code></pre>
                </div>

                <h3>Comparing the Primitives</h3>
                <p>Let's see these types in action with a practical example:</p>

                <pre><code class="language-typescript">// A user profile using primitive types
let userId: number = 12345;
let username: string = "codecraftsman";
let email: string = "user@example.com";
let age: number = 28;
let isVerified: boolean = true;
let isPremium: boolean = false;
let accountBalance: number = 1599.50;

// Function using all primitive types
function displayUserInfo(
    id: number,
    name: string,
    verified: boolean,
    balance: number
): string {
    return `User #${id}: ${name} | Verified: ${verified} | Balance: $${balance}`;
}

console.log(displayUserInfo(userId, username, isVerified, accountBalance));
// Output: User #12345: codecraftsman | Verified: true | Balance: $1599.5
</code></pre>

                <h3>Primitive Types Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Purpose</th>
                            <th>Examples</th>
                            <th>Common Uses</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>string</code></td>
                            <td>Text data</td>
                            <td>"Hello", 'World', `Hi ${name}`</td>
                            <td>Names, messages, descriptions, IDs</td>
                        </tr>
                        <tr>
                            <td><code>number</code></td>
                            <td>Numeric data</td>
                            <td>42, 3.14, -5, Infinity, NaN</td>
                            <td>Counts, prices, calculations, ages</td>
                        </tr>
                        <tr>
                            <td><code>boolean</code></td>
                            <td>True/False values</td>
                            <td>true, false</td>
                            <td>Flags, conditions, states, toggles</td>
                        </tr>
                    </tbody>
                </table>

                <div class="mermaid">
                    graph TD
                        A[Primitive Types] --> B[string]
                        A --> C[number]
                        A --> D[boolean]
                        
                        B --> B1["Text: 'Hello'"]
                        B --> B2["IDs: 'user_123'"]
                        B --> B3["Messages"]
                        
                        C --> C1["Integers: 42"]
                        C --> C2["Decimals: 3.14"]
                        C --> C3["Special: NaN, Infinity"]
                        
                        D --> D1["true"]
                        D --> D2["false"]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style B fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style C fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                        style D fill:#FF9800,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 2: Arrays and Tuples -->
            <section id="section2" class="lesson-section">
                <h2>Arrays and Tuples: Collections of Values</h2>
                
                <p>Now that we know the basic building blocks, let's learn how to organize them! Think of arrays as shopping lists and tuples as specifically ordered packages. Both are incredibly useful in real applications! üì¶</p>

                <h3>Arrays: Lists of the Same Type</h3>
                <p>An array is a collection of values of the same type. It's like a container that only holds one kind of item - a fruit bowl that only holds apples, or a parking lot that only holds cars. üçéüöó</p>

                <h4>Two Ways to Declare Arrays</h4>
                <p>TypeScript gives you two syntaxes for arrays. They're completely equivalent - use whichever feels more natural to you!</p>

                <pre><code class="language-typescript">// Method 1: Type followed by []
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];
let flags: boolean[] = [true, false, true];

// Method 2: Array&lt;Type&gt; (generic syntax)
let scores: Array&lt;number&gt; = [95, 87, 92, 88];
let colors: Array&lt;string&gt; = ["red", "green", "blue"];

// Both mean the same thing! Pick your favorite and stick with it.
// Most developers prefer the [] syntax because it's shorter
</code></pre>

                <h4>Working with Arrays</h4>
                <p>Once you have a typed array, TypeScript ensures you only put the right type of items in it:</p>

                <pre><code class="language-typescript">let prices: number[] = [9.99, 19.99, 29.99];

// Adding items - must match the type
prices.push(39.99);        // ‚úÖ OK - 39.99 is a number
prices.push("49.99");      // ‚ùå Error! String is not assignable to number

// Accessing items - TypeScript knows the type
let firstPrice: number = prices[0];        // TypeScript knows this is a number
let upperPrice = prices[1].toFixed(2);     // Can use number methods!

// Array methods work as expected
let total = prices.reduce((sum, price) => sum + price, 0);
let discounted = prices.map(price => price * 0.9);  // 10% off!
let expensive = prices.filter(price => price > 20);
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Real-World Example: Shopping Cart</h4>
                    <pre><code class="language-typescript">interface CartItem {
    id: number;
    name: string;
    price: number;
}

let cart: CartItem[] = [
    { id: 1, name: "Laptop", price: 999 },
    { id: 2, name: "Mouse", price: 25 },
    { id: 3, name: "Keyboard", price: 75 }
];

// Calculate total
let cartTotal = cart.reduce((sum, item) => sum + item.price, 0);
console.log(`Total: $${cartTotal}`);  // Total: $1099
</code></pre>
                </div>

                <h4>Empty Arrays</h4>
                <p>Sometimes you start with an empty array and add items later. You still need to tell TypeScript what type of items you'll add:</p>

                <pre><code class="language-typescript">// Declare an empty array with a type
let todoList: string[] = [];

// Now you can add items
todoList.push("Learn TypeScript");     // ‚úÖ OK
todoList.push("Build a project");      // ‚úÖ OK
todoList.push(123);                    // ‚ùå Error! Expected string

// Without a type annotation, TypeScript might get confused
let mystery = [];                       // Type is any[] - not safe!
mystery.push("anything");               // No error, but no type safety either
mystery.push(123);
mystery.push(true);                     // This is dangerous!
</code></pre>

                <h3>Tuples: Fixed-Length Arrays with Mixed Types</h3>
                <p>A tuple is like a precisely packed box - it has a fixed number of items, each with a specific type, in a specific order. Think of coordinates (x, y), or a person's info (name, age, isActive). üìç</p>

                <pre><code class="language-typescript">// Tuple: [string, number]
let user: [string, number] = ["Alice", 25];

// Access by index - TypeScript knows the type at each position!
let name: string = user[0];     // TypeScript knows this is a string
let age: number = user[1];      // TypeScript knows this is a number

// Wrong order or type = error
let invalid: [string, number] = [25, "Alice"];  // ‚ùå Error! Wrong order

// Wrong number of elements = error
let tooMany: [string, number] = ["Alice", 25, true];    // ‚ùå Error!
let tooFew: [string, number] = ["Alice"];               // ‚ùå Error!
</code></pre>

                <h4>When to Use Tuples</h4>
                <p>Tuples are perfect when you have a fixed structure with mixed types:</p>

                <pre><code class="language-typescript">// RGB color: [red, green, blue]
let color: [number, number, number] = [255, 128, 0];

// Coordinates: [x, y]
let point: [number, number] = [100, 200];

// API response: [status, message, data]
let response: [number, string, any] = [200, "Success", { id: 1 }];

// Key-value pair
let setting: [string, boolean] = ["darkMode", true];

// Function that returns multiple values
function getUserInfo(): [string, number, boolean] {
    return ["Alice", 25, true];  // [name, age, isVerified]
}

let [userName, userAge, isVerified] = getUserInfo();  // Destructuring!
console.log(`${userName} is ${userAge} years old`);
</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Tuple Gotcha: Array Methods</h4>
                    <p>Tuples are actually just arrays under the hood, so array methods like <code>push()</code> still work - but they can break your tuple's structure!</p>
                    <pre><code class="language-typescript">let pair: [string, number] = ["Alice", 25];

// This works but breaks the tuple contract!
pair.push(true);  // ‚úÖ No error (unfortunately), but now it's [string, number, boolean]

// Better: Use readonly tuples if you want true immutability
let safePair: readonly [string, number] = ["Alice", 25];
safePair.push(true);  // ‚ùå Error! Property 'push' does not exist on readonly array
</code></pre>
                </div>

                <h3>Arrays vs Tuples: When to Use Which?</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Scenario</th>
                            <th>Use This</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>List of same-type items (unknown length)</td>
                            <td>Array</td>
                            <td><code>let names: string[] = ["Alice", "Bob", ...]</code></td>
                        </tr>
                        <tr>
                            <td>Fixed structure with mixed types</td>
                            <td>Tuple</td>
                            <td><code>let user: [string, number] = ["Alice", 25]</code></td>
                        </tr>
                        <tr>
                            <td>Collection that grows/shrinks</td>
                            <td>Array</td>
                            <td><code>let cart: Product[] = []</code></td>
                        </tr>
                        <tr>
                            <td>Function returning multiple values</td>
                            <td>Tuple</td>
                            <td><code>function getData(): [string, number]</code></td>
                        </tr>
                        <tr>
                            <td>Coordinates, RGB colors, pairs</td>
                            <td>Tuple</td>
                            <td><code>let point: [number, number] = [x, y]</code></td>
                        </tr>
                    </tbody>
                </table>

                <div class="mermaid">
                    graph LR
                        A[Collections] --> B[Array]
                        A --> C[Tuple]
                        
                        B --> B1["Same type items"]
                        B --> B2["Variable length"]
                        B --> B3["string[], number[]"]
                        
                        C --> C1["Mixed types"]
                        C --> C2["Fixed length"]
                        C --> C3["[string, number]"]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style B fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style C fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 3: Type Inference -->
            <section id="section3" class="lesson-section">
                <h2>Type Inference: TypeScript Reads Your Mind</h2>
                
                <p>Here's some great news: you don't always have to write type annotations! TypeScript is smart enough to figure out types based on the values you assign. It's like having an assistant who finishes your sentences. üß†‚ú®</p>

                <h3>How Type Inference Works</h3>
                <p>When you assign a value to a variable, TypeScript looks at that value and automatically determines the type:</p>

                <pre><code class="language-typescript">// TypeScript infers the type from the value
let message = "Hello!";          // TypeScript infers: string
let count = 42;                  // TypeScript infers: number
let isActive = true;             // TypeScript infers: boolean
let items = [1, 2, 3];          // TypeScript infers: number[]
let mixed = ["Alice", 25];       // TypeScript infers: (string | number)[]

// You get the same type safety without writing the type!
message = "Hi there!";           // ‚úÖ OK - string to string
message = 123;                   // ‚ùå Error! number is not assignable to string

count = 100;                     // ‚úÖ OK
count = "100";                   // ‚ùå Error!
</code></pre>

                <blockquote>
                    <strong>üí° Best Practice:</strong> Let TypeScript infer types when they're obvious. It makes your code cleaner and easier to read. Only add explicit type annotations when inference needs help or when it makes the code clearer.
                </blockquote>

                <h3>When Inference Works Best</h3>
                <p>Type inference shines in these situations:</p>

                <pre><code class="language-typescript">// ‚úÖ GOOD: Let inference work
let name = "Alice";              // Obviously a string
let age = 25;                    // Obviously a number  
let scores = [95, 87, 92];      // Obviously number[]

// Array methods maintain type safety
let doubled = scores.map(s => s * 2);  // TypeScript knows this is number[]
let high = scores.filter(s => s > 90); // Still number[]

// Object literals
let user = {
    name: "Alice",               // Inferred as string
    age: 25,                     // Inferred as number
    isActive: true               // Inferred as boolean
};

// TypeScript knows the structure!
console.log(user.name.toUpperCase());  // ‚úÖ OK - name is definitely a string
console.log(user.age.toFixed(2));      // ‚úÖ OK - age is definitely a number
console.log(user.email);                // ‚ùå Error! Property 'email' doesn't exist
</code></pre>

                <h3>When to Add Explicit Types</h3>
                <p>Sometimes you need to help TypeScript out. Add explicit types in these cases:</p>

                <h4>1. Empty Arrays</h4>
                <pre><code class="language-typescript">// ‚ùå TypeScript doesn't know what type will go in here
let items = [];                  // Type: any[] (unsafe!)

// ‚úÖ Tell TypeScript what you intend
let items: string[] = [];        // Type: string[] (safe!)
</code></pre>

                <h4>2. Function Parameters</h4>
                <pre><code class="language-typescript">// ‚ùå Parameters need explicit types (can't infer from usage)
function greet(name) {           // Error: Parameter 'name' implicitly has 'any' type
    return `Hello, ${name}!`;
}

// ‚úÖ Always type function parameters
function greet(name: string): string {
    return `Hello, ${name}!`;
}

// Return type can often be inferred, but being explicit is good practice
function add(a: number, b: number) {     // Return type inferred as number
    return a + b;
}
</code></pre>

                <h4>3. When You Want a More General Type</h4>
                <pre><code class="language-typescript">// TypeScript infers the literal type "pending"
let status = "pending";          // Type: "pending" (too specific!)

// You might want a more general type
let status: string = "pending";  // Type: string (can be any string)

// Or a union of specific values
let status: "pending" | "approved" | "rejected" = "pending";  // Best!
</code></pre>

                <h4>4. Complex Types</h4>
                <pre><code class="language-typescript">// Type inference can get messy with complex structures
let data = {
    users: [
        { name: "Alice", roles: ["admin", "user"] },
        { name: "Bob", roles: ["user"] }
    ]
};
// The inferred type is huge and hard to understand!

// Better: Define the structure explicitly
interface User {
    name: string;
    roles: string[];
}

let data: { users: User[] } = {
    users: [
        { name: "Alice", roles: ["admin", "user"] },
        { name: "Bob", roles: ["user"] }
    ]
};
// Much clearer what this structure should be!
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>üéØ The Golden Rule of Type Annotations</h4>
                    <p><strong>If the type is obvious from the value, let TypeScript infer it. If it's not obvious or you want to be explicit about contracts (like function parameters and return types), add the annotation.</strong></p>
                    <pre><code class="language-typescript">// ‚úÖ Good balance
let count = 0;                              // Inferred
let items: string[] = [];                   // Explicit (empty array)
let user = { name: "Alice", age: 25 };     // Inferred

function processUser(user: User): void {    // Explicit (function signature)
    let age = user.age;                     // Inferred
    let nextYear = age + 1;                 // Inferred
}
</code></pre>
                </div>

                <h3>Type Inference in Action</h3>
                <p>Let's see a complete example that shows good use of type inference:</p>

                <pre><code class="language-typescript">// Explicit where it matters
interface Product {
    id: number;
    name: string;
    price: number;
    inStock: boolean;
}

function calculateTotalPrice(products: Product[]): number {
    // Let inference handle local variables
    let total = 0;  // Inferred as number
    
    for (let product of products) {  // product inferred as Product
        if (product.inStock) {
            let price = product.price;     // Inferred as number
            let subtotal = price * 1.1;    // Inferred as number (with 10% markup)
            total += subtotal;
        }
    }
    
    return total;  // TypeScript verifies we return a number
}

// Usage with inferred types
let inventory = [  // Inferred as Product[]
    { id: 1, name: "Laptop", price: 999, inStock: true },
    { id: 2, name: "Mouse", price: 25, inStock: true }
];

let total = calculateTotalPrice(inventory);  // Inferred as number
console.log(`Total: $${total.toFixed(2)}`);  // Can use number methods!
</code></pre>
            </section>
            <!-- Section 4: Union Types -->
            <section id="section4" class="lesson-section">
                <h2>Union Types: This OR That</h2>
                
                <p>Sometimes a value can be more than one type. Maybe an ID can be a number OR a string. Maybe a status can be "loading" OR "success" OR "error". Union types let you express this flexibility while keeping type safety! Think of it like ordering at a restaurant: "I'll have the burger OR the pizza." üçîüçï</p>

                <h3>Creating Union Types</h3>
                <p>Use the pipe symbol (<code>|</code>) to create a union type:</p>

                <pre><code class="language-typescript">// A variable that can be string OR number
let id: string | number;

id = "abc123";        // ‚úÖ OK - string is allowed
id = 12345;           // ‚úÖ OK - number is allowed
id = true;            // ‚ùå Error! boolean is not in the union

// Union with multiple types
let result: number | string | boolean;

result = 42;          // ‚úÖ OK
result = "success";   // ‚úÖ OK
result = true;        // ‚úÖ OK
result = null;        // ‚ùå Error! null is not in the union
</code></pre>

                <h3>Working with Union Types</h3>
                <p>When you have a union type, TypeScript only lets you use operations that work for ALL types in the union. This is where type narrowing comes in handy:</p>

                <pre><code class="language-typescript">function printId(id: string | number) {
    // Can't use string methods or number methods directly
    // console.log(id.toUpperCase());  // ‚ùå Error! number doesn't have toUpperCase
    // console.log(id.toFixed(2));     // ‚ùå Error! string doesn't have toFixed
    
    // But you can use methods that work on both
    console.log(id.toString());        // ‚úÖ OK - both have toString()
    
    // Use type narrowing to access specific methods
    if (typeof id === "string") {
        // TypeScript knows id is a string here
        console.log(id.toUpperCase());  // ‚úÖ OK
    } else {
        // TypeScript knows id is a number here
        console.log(id.toFixed(2));     // ‚úÖ OK
    }
}

printId("abc123");     // Works with string
printId(12345);        // Works with number
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Real-World Example: API Response</h4>
                    <p>APIs often return either data or an error. Union types model this perfectly:</p>
                    <pre><code class="language-typescript">interface SuccessResponse {
    success: true;
    data: any;
}

interface ErrorResponse {
    success: false;
    error: string;
}

// Response is one OR the other
type ApiResponse = SuccessResponse | ErrorResponse;

function handleResponse(response: ApiResponse) {
    if (response.success) {
        // TypeScript knows this is SuccessResponse
        console.log("Data:", response.data);
    } else {
        // TypeScript knows this is ErrorResponse
        console.log("Error:", response.error);
    }
}
</code></pre>
                </div>

                <h3>Arrays with Union Types</h3>
                <p>You can create arrays that hold multiple types using unions:</p>

                <pre><code class="language-typescript">// Array that can contain strings OR numbers
let mixed: (string | number)[] = [1, "two", 3, "four"];

// Add items of either type
mixed.push(5);              // ‚úÖ OK
mixed.push("six");          // ‚úÖ OK
mixed.push(true);           // ‚ùå Error! boolean not in union

// When iterating, you get union type items
mixed.forEach(item => {
    // item is string | number
    console.log(item.toString());  // ‚úÖ Works for both
    
    if (typeof item === "string") {
        console.log(item.toUpperCase());
    }
});
</code></pre>

                <blockquote>
                    <strong>üí° Pro Tip:</strong> Use parentheses with array unions: <code>(string | number)[]</code> means "array of string-or-number". Without parentheses, <code>string | number[]</code> means "string or array-of-numbers" - very different!
                </blockquote>

                <h3>Union Types in Practice</h3>
                <p>Here are common patterns you'll use all the time:</p>

                <pre><code class="language-typescript">// Optional values: value OR null
let userName: string | null = null;
userName = "Alice";          // Can be set later

// Optional values: value OR undefined
let age: number | undefined;
age = 25;

// Multiple choice values
type Size = "small" | "medium" | "large";
let shirtSize: Size = "medium";

// Error or success
type Result = { success: true; value: number } | { success: false; error: string };

function divide(a: number, b: number): Result {
    if (b === 0) {
        return { success: false, error: "Cannot divide by zero" };
    }
    return { success: true, value: a / b };
}

// Using the result
let result = divide(10, 2);
if (result.success) {
    console.log(`Result: ${result.value}`);
} else {
    console.log(`Error: ${result.error}`);
}
</code></pre>

                <div class="mermaid">
                    graph TD
                        A[Union Type] --> B[Type A]
                        A --> C[Type B]
                        A --> D[Type C]
                        
                        B --> B1[string]
                        C --> C1[number]
                        D --> D1[boolean]
                        
                        E[Value] --> F{Which Type?}
                        F --> B
                        F --> C
                        F --> D
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style F fill:#FF9800,stroke:#333,stroke-width:2px,color:#fff
                </div>
            </section>

            <!-- Section 5: Literal Types -->
            <section id="section5" class="lesson-section">
                <h2>Literal Types: Be Specific!</h2>
                
                <p>Literal types are like ordering a specific item from a menu instead of just saying "food". Instead of saying a variable is a <code>string</code>, you can say it's specifically <code>"red"</code> or <code>"blue"</code> or <code>"green"</code>. It's TypeScript's way of saying "not just any value, this EXACT value!" üéØ</p>

                <h3>String Literal Types</h3>
                <p>The most common literal types are strings with specific values:</p>

                <pre><code class="language-typescript">// Instead of just 'string', be specific
let direction: "north" | "south" | "east" | "west";

direction = "north";      // ‚úÖ OK
direction = "south";      // ‚úÖ OK
direction = "Northeast";  // ‚ùå Error! Not one of the allowed values
direction = "NORTH";      // ‚ùå Error! Case matters!

// Great for status values
let status: "pending" | "approved" | "rejected";
status = "pending";       // ‚úÖ OK
status = "completed";     // ‚ùå Error! Not in the allowed list

// Traffic light states
let light: "red" | "yellow" | "green";
light = "red";            // ‚úÖ OK
light = "blue";           // ‚ùå Error! Blue is not a traffic light color!
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Literal Types Are Awesome</h4>
                    <ul>
                        <li><strong>Self-documenting:</strong> Your code shows exactly what values are valid</li>
                        <li><strong>Autocomplete:</strong> Your editor suggests only valid values</li>
                        <li><strong>Typo-proof:</strong> Catch misspellings instantly</li>
                        <li><strong>Refactor-safe:</strong> Change values confidently</li>
                    </ul>
                </div>

                <h3>Numeric Literal Types</h3>
                <p>Numbers can be literal types too! This is perfect for things like HTTP status codes or game scores:</p>

                <pre><code class="language-typescript">// HTTP status codes
let statusCode: 200 | 404 | 500;

statusCode = 200;     // ‚úÖ OK
statusCode = 404;     // ‚úÖ OK
statusCode = 201;     // ‚ùå Error! Not in the allowed list

// Dice roll (1-6)
let diceRoll: 1 | 2 | 3 | 4 | 5 | 6;
diceRoll = 4;         // ‚úÖ OK
diceRoll = 7;         // ‚ùå Error! A die doesn't have 7

// Version numbers
let apiVersion: 1 | 2 | 3;
apiVersion = 2;       // ‚úÖ OK
</code></pre>

                <h3>Boolean Literal Types</h3>
                <p>Even booleans can be literal types (though this is less common):</p>

                <pre><code class="language-typescript">// Only true is allowed
let alwaysTrue: true = true;
alwaysTrue = false;    // ‚ùå Error!

// Only false is allowed
let alwaysFalse: false = false;
alwaysFalse = true;    // ‚ùå Error!

// This is more useful in discriminated unions (we'll cover this later)
type SuccessResult = { success: true; data: any };
type ErrorResult = { success: false; error: string };
</code></pre>

                <h3>Type Aliases for Literal Types</h3>
                <p>Instead of repeating literal unions, create reusable type aliases:</p>

                <pre><code class="language-typescript">// Define once, use everywhere
type Direction = "north" | "south" | "east" | "west";
type Status = "pending" | "approved" | "rejected";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

// Use in multiple places
let heading: Direction = "north";
let orderStatus: Status = "pending";
let requestMethod: HttpMethod = "POST";

// Use in function signatures
function move(direction: Direction): void {
    console.log(`Moving ${direction}`);
}

function updateStatus(newStatus: Status): void {
    console.log(`Status changed to ${newStatus}`);
}

move("north");              // ‚úÖ OK
move("northeast");          // ‚ùå Error! Typo caught!

updateStatus("approved");   // ‚úÖ OK
updateStatus("complete");   // ‚ùå Error! Not a valid status!
</code></pre>

                <h3>Combining Literal Types with Other Types</h3>
                <p>You can mix literal types with regular types for ultimate flexibility:</p>

                <pre><code class="language-typescript">// A number OR the string "auto"
type Size = number | "auto";

let width: Size = 100;        // ‚úÖ OK - number
let height: Size = "auto";    // ‚úÖ OK - literal string
let depth: Size = "manual";   // ‚ùå Error! Not allowed

// A specific string OR null
type Theme = "light" | "dark" | null;

let currentTheme: Theme = "dark";    // ‚úÖ OK
currentTheme = null;                 // ‚úÖ OK (user hasn't chosen)
currentTheme = "blue";               // ‚ùå Error! Not a valid theme

// Numbers in a range OR special values
type Percentage = number | "auto" | "inherit";

let opacity: Percentage = 0.5;       // ‚úÖ OK
let margin: Percentage = "auto";     // ‚úÖ OK
let padding: Percentage = "inherit"; // ‚úÖ OK
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ Real-World Example: Button Component</h4>
                    <pre><code class="language-typescript">type ButtonVariant = "primary" | "secondary" | "danger" | "success";
type ButtonSize = "small" | "medium" | "large";

interface ButtonProps {
    variant: ButtonVariant;
    size: ButtonSize;
    disabled?: boolean;
    onClick: () => void;
}

function Button(props: ButtonProps) {
    // TypeScript ensures variant and size are valid
    console.log(`Rendering ${props.size} ${props.variant} button`);
}

// Usage
Button({
    variant: "primary",    // ‚úÖ Autocomplete suggests valid values
    size: "large",         // ‚úÖ Autocomplete suggests valid values
    onClick: () => {}
});

// This would error
Button({
    variant: "blue",       // ‚ùå Error! Not a valid variant
    size: "extra-large",   // ‚ùå Error! Not a valid size
    onClick: () => {}
});
</code></pre>
                </div>

                <h3>When to Use Literal Types</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Example</th>
                            <th>Benefit</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Fixed set of options</td>
                            <td>Status values, directions, colors</td>
                            <td>Prevents typos and invalid values</td>
                        </tr>
                        <tr>
                            <td>API endpoints</td>
                            <td>HTTP methods, status codes</td>
                            <td>Documents valid values</td>
                        </tr>
                        <tr>
                            <td>Configuration</td>
                            <td>Environment types, modes</td>
                            <td>Makes config type-safe</td>
                        </tr>
                        <tr>
                            <td>UI components</td>
                            <td>Button variants, sizes</td>
                            <td>Autocomplete in editor</td>
                        </tr>
                        <tr>
                            <td>State machines</td>
                            <td>State names, events</td>
                            <td>Ensures valid state transitions</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 6: Special Types -->
            <section id="section6" class="lesson-section">
                <h2>Special Types: any, unknown, never, and void</h2>
                
                <p>TypeScript has a few special types that handle unique situations. Think of them as the specialized tools in your toolbox - you don't use them every day, but when you need them, they're invaluable! üõ†Ô∏è</p>

                <h3>any: The Escape Hatch (Use Sparingly!)</h3>
                <p>The <code>any</code> type is like a "get out of jail free" card - it turns off all type checking. It means "I don't care what type this is." While this seems convenient, it defeats the entire purpose of TypeScript! üö´</p>

                <pre><code class="language-typescript">// any accepts ANYTHING
let anything: any;

anything = "hello";           // ‚úÖ No error
anything = 42;                // ‚úÖ No error
anything = true;              // ‚úÖ No error
anything = { x: 1 };          // ‚úÖ No error
anything = [1, 2, 3];        // ‚úÖ No error

// You can call any method (even if it doesn't exist!)
anything.toUpperCase();       // ‚úÖ No error at compile time (but crashes at runtime!)
anything.foo.bar.baz();       // ‚úÖ No error at compile time (but crashes at runtime!)

// any spreads through your code like a virus
let x: any = "hello";
let y = x;                    // y is now 'any' too!
</code></pre>

                <div class="card" style="background-color: #ffebee; border-left: 4px solid #f44336;">
                    <h4>‚ùå Why any is Dangerous</h4>
                    <ul>
                        <li>No type checking = bugs slip through</li>
                        <li>No autocomplete = slower development</li>
                        <li>No refactoring safety = things break silently</li>
                        <li>Defeats the purpose of TypeScript</li>
                    </ul>
                    <p><strong>Rule of thumb:</strong> If you're using <code>any</code>, ask yourself why. There's almost always a better alternative!</p>
                </div>

                <h3>unknown: The Safe Alternative to any</h3>
                <p><code>unknown</code> is like <code>any</code>'s responsible older sibling. It says "I don't know what type this is YET, but I'll check before using it." Much safer! üõ°Ô∏è</p>

                <pre><code class="language-typescript">// unknown accepts anything (like any)
let value: unknown;

value = "hello";              // ‚úÖ OK
value = 42;                   // ‚úÖ OK
value = true;                 // ‚úÖ OK

// But you can't use it without checking first!
value.toUpperCase();          // ‚ùå Error! Must check type first

// You must narrow the type before using it
if (typeof value === "string") {
    // Now TypeScript knows it's a string
    console.log(value.toUpperCase());  // ‚úÖ OK
}

// Type guards work great with unknown
function processValue(value: unknown) {
    // Check what type it is first
    if (typeof value === "string") {
        return value.toUpperCase();
    } else if (typeof value === "number") {
        return value.toFixed(2);
    } else if (Array.isArray(value)) {
        return value.length;
    } else {
        return "Unknown type";
    }
}
</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ When to Use unknown</h4>
                    <ul>
                        <li>Working with data from external sources (APIs, user input)</li>
                        <li>Deserializing JSON (you don't know what's in it yet)</li>
                        <li>Generic error handling</li>
                        <li>Anytime you'd be tempted to use <code>any</code> - use <code>unknown</code> instead!</li>
                    </ul>
                </div>

                <h3>void: Functions That Don't Return Anything</h3>
                <p><code>void</code> means "this function doesn't return a value" (or returns <code>undefined</code>). It's like a function that does something but doesn't give you anything back. ü§∑</p>

                <pre><code class="language-typescript">// Functions that log, save, or perform side effects
function logMessage(message: string): void {
    console.log(message);
    // No return statement, or returns undefined
}

function saveToDatabase(data: any): void {
    // Save data...
    // Doesn't return anything
}

// void functions can return undefined explicitly
function doNothing(): void {
    return undefined;  // ‚úÖ OK
    // return null;    // ‚ùå Error! null is not void
    // return 5;       // ‚ùå Error! number is not void
}

// You can't assign the result to anything meaningful
let result: void = logMessage("Hello");  // result is undefined
let x: number = logMessage("Hello");     // ‚ùå Error! void is not assignable to number
</code></pre>

                <blockquote>
                    <strong>üí° Fun Fact:</strong> In JavaScript, functions without a return statement actually return <code>undefined</code>. In TypeScript, we use <code>void</code> to indicate "this function's return value doesn't matter."
                </blockquote>

                <h3>never: The Impossible Type</h3>
                <p><code>never</code> represents values that never occur. It's like a function that never returns (because it throws an error or runs forever). Sounds weird, but it's actually useful! üé≠</p>

                <pre><code class="language-typescript">// Function that always throws an error (never returns)
function throwError(message: string): never {
    throw new Error(message);
    // Execution never reaches here
}

// Function that runs forever (never returns)
function infiniteLoop(): never {
    while (true) {
        // Do something forever
    }
    // Never exits
}

// never is useful for exhaustive checking
type Shape = "circle" | "square" | "triangle";

function getArea(shape: Shape): number {
    switch (shape) {
        case "circle":
            return Math.PI * 10 * 10;
        case "square":
            return 10 * 10;
        case "triangle":
            return 0.5 * 10 * 10;
        default:
            // If we get here, we forgot to handle a case!
            const exhaustiveCheck: never = shape;
            throw new Error(`Unhandled shape: ${exhaustiveCheck}`);
    }
}

// If we add a new shape type and forget to handle it, TypeScript errors!
</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üéØ When to Use never</h4>
                    <ul>
                        <li><strong>Error handlers:</strong> Functions that always throw</li>
                        <li><strong>Exhaustive checking:</strong> Ensure all cases are handled</li>
                        <li><strong>Impossible branches:</strong> Code that should never execute</li>
                        <li><strong>Type guards:</strong> Eliminate impossible types</li>
                    </ul>
                </div>

                <h3>Comparing Special Types</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Meaning</th>
                            <th>Use When</th>
                            <th>Safety Level</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>any</code></td>
                            <td>Could be anything (no checking)</td>
                            <td>Migrating from JS (temporarily!)</td>
                            <td>‚ö†Ô∏è Unsafe - avoid!</td>
                        </tr>
                        <tr>
                            <td><code>unknown</code></td>
                            <td>Could be anything (must check first)</td>
                            <td>External data, API responses</td>
                            <td>‚úÖ Safe - recommended</td>
                        </tr>
                        <tr>
                            <td><code>void</code></td>
                            <td>No return value</td>
                            <td>Functions with side effects</td>
                            <td>‚úÖ Safe</td>
                        </tr>
                        <tr>
                            <td><code>never</code></td>
                            <td>Never occurs</td>
                            <td>Error functions, exhaustive checks</td>
                            <td>‚úÖ Safe</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Special Types in Action</h3>
                <p>Here's how these types work together in a real scenario:</p>

                <pre><code class="language-typescript">// Fetching data from an API
async function fetchUserData(userId: number): Promise&lt;unknown&gt; {
    const response = await fetch(`/api/users/${userId}`);
    return response.json();  // We don't know what we'll get!
}

// Processing the unknown data safely
function processUserData(data: unknown): string | never {
    // Guard against invalid data
    if (!data || typeof data !== "object") {
        throw new Error("Invalid data");  // Returns never
    }
    
    // Narrow the type
    if ("name" in data && typeof data.name === "string") {
        return data.name;  // Returns string
    }
    
    throw new Error("Data missing name property");  // Returns never
}

// A function that logs (returns void)
function logUser(name: string): void {
    console.log(`User: ${name}`);
}

// Using them together
async function displayUser(userId: number): Promise&lt;void&gt; {
    try {
        const data = await fetchUserData(userId);  // unknown
        const name = processUserData(data);        // string or never
        logUser(name);                             // void
    } catch (error) {
        console.error("Failed to display user");
    }
}
</code></pre>

                <div class="mermaid">
                    graph TD
                        A[Special Types] --> B[any]
                        A --> C[unknown]
                        A --> D[void]
                        A --> E[never]
                        
                        B --> B1["No type checking<br/>AVOID!"]
                        C --> C1["Type checking required<br/>SAFE"]
                        D --> D1["No return value<br/>Common"]
                        E --> E1["Never returns<br/>Specialized"]
                        
                        style B fill:#f44336,stroke:#333,stroke-width:2px,color:#fff
                        style C fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                        style D fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
                        style E fill:#FF9800,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <blockquote>
                    <strong>üéØ Remember:</strong> Prefer <code>unknown</code> over <code>any</code>, use <code>void</code> for functions without returns, and leverage <code>never</code> for error handling and exhaustive checks. Each has its place, but they're specialized tools - use them wisely!
                </blockquote>
            </section>
            <!-- Section 7: Hands-on Practice -->
            <section id="section7" class="lesson-section">
                <h2>Hands-on Practice: Build a Type-Safe Inventory System</h2>
                
                <p>Time to put everything together! We're going to build a complete inventory management system that uses all the types we've learned. This is a real-world scenario - imagine you're building software for a warehouse. Let's make it type-safe and bulletproof! üì¶</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">üéØ Project Goal</h3>
                    <p style="color: white;">Create an inventory system that tracks products, manages stock, and processes orders using TypeScript's type system to prevent errors.</p>
                </div>

                <h3>Step 1: Define Your Types</h3>
                <p>First, let's define the structure of our data using the types we've learned:</p>

                <pre><code class="language-typescript">// Product categories as literal types
type Category = "electronics" | "clothing" | "food" | "books";

// Product status
type ProductStatus = "in-stock" | "low-stock" | "out-of-stock";

// ID can be either string or number
type ProductId = string | number;

// A complete product interface
interface Product {
    id: ProductId;
    name: string;
    category: Category;
    price: number;
    quantity: number;
    status: ProductStatus;
    tags: string[];
    supplier?: string;  // Optional - not all products have suppliers
}

// Order result types
type OrderSuccess = {
    success: true;
    orderId: string;
    total: number;
};

type OrderError = {
    success: false;
    error: string;
};

type OrderResult = OrderSuccess | OrderError;
</code></pre>

                <h3>Step 2: Create the Inventory Class</h3>
                <p>Now let's build the actual inventory system with type-safe methods:</p>

                <pre><code class="language-typescript">class Inventory {
    private products: Product[] = [];
    
    // Add a product to inventory
    addProduct(product: Product): void {
        // Check if product already exists
        const exists = this.products.some(p => p.id === product.id);
        
        if (exists) {
            console.log(`Product ${product.id} already exists`);
            return;
        }
        
        this.products.push(product);
        console.log(`Added ${product.name} to inventory`);
    }
    
    // Find a product by ID
    findProduct(id: ProductId): Product | undefined {
        return this.products.find(p => p.id === id);
    }
    
    // Get all products in a category
    getByCategory(category: Category): Product[] {
        return this.products.filter(p => p.category === category);
    }
    
    // Update product status based on quantity
    updateStatus(id: ProductId): void {
        const product = this.findProduct(id);
        
        if (!product) {
            console.log("Product not found");
            return;
        }
        
        // Determine status based on quantity
        if (product.quantity === 0) {
            product.status = "out-of-stock";
        } else if (product.quantity < 10) {
            product.status = "low-stock";
        } else {
            product.status = "in-stock";
        }
    }
    
    // Process an order
    processOrder(id: ProductId, quantity: number): OrderResult {
        const product = this.findProduct(id);
        
        // Validate product exists
        if (!product) {
            return {
                success: false,
                error: "Product not found"
            };
        }
        
        // Validate quantity
        if (quantity <= 0) {
            return {
                success: false,
                error: "Invalid quantity"
            };
        }
        
        // Check stock
        if (product.quantity < quantity) {
            return {
                success: false,
                error: `Only ${product.quantity} units available`
            };
        }
        
        // Process the order
        product.quantity -= quantity;
        this.updateStatus(id);
        
        const total = product.price * quantity;
        const orderId = `ORD-${Date.now()}`;
        
        return {
            success: true,
            orderId,
            total
        };
    }
    
    // Get inventory summary
    getSummary(): string {
        const total = this.products.length;
        const inStock = this.products.filter(p => p.status === "in-stock").length;
        const lowStock = this.products.filter(p => p.status === "low-stock").length;
        const outOfStock = this.products.filter(p => p.status === "out-of-stock").length;
        
        return `Inventory Summary:
Total Products: ${total}
In Stock: ${inStock}
Low Stock: ${lowStock}
Out of Stock: ${outOfStock}`;
    }
}
</code></pre>

                <h3>Step 3: Use the Inventory System</h3>
                <p>Let's test our type-safe inventory system:</p>

                <pre><code class="language-typescript">// Create an inventory
const inventory = new Inventory();

// Add products with full type safety
inventory.addProduct({
    id: 1,
    name: "Laptop",
    category: "electronics",
    price: 999.99,
    quantity: 15,
    status: "in-stock",
    tags: ["computer", "portable", "work"],
    supplier: "TechCorp"
});

inventory.addProduct({
    id: "BOOK-001",
    name: "TypeScript Handbook",
    category: "books",
    price: 39.99,
    quantity: 8,
    status: "low-stock",
    tags: ["programming", "education"]
    // No supplier - it's optional!
});

inventory.addProduct({
    id: 2,
    name: "T-Shirt",
    category: "clothing",
    price: 19.99,
    quantity: 0,
    status: "out-of-stock",
    tags: ["casual", "cotton"]
});

// Try to add invalid product (TypeScript catches these!)
/*
inventory.addProduct({
    id: 3,
    name: "Widget",
    category: "gadgets",  // ‚ùå Error! "gadgets" is not a valid category
    price: "29.99",       // ‚ùå Error! Price must be a number
    quantity: 5,
    status: "available",  // ‚ùå Error! "available" is not a valid status
    tags: "tag1, tag2"    // ‚ùå Error! tags must be an array
});
*/

// Find products
const laptop = inventory.findProduct(1);
console.log(laptop?.name);  // "Laptop"

// Get products by category
const electronics = inventory.getByCategory("electronics");
console.log(`Electronics: ${electronics.length} items`);

// Process orders
const order1 = inventory.processOrder(1, 3);

if (order1.success) {
    // TypeScript knows this has orderId and total
    console.log(`Order placed! ID: ${order1.orderId}, Total: $${order1.total}`);
} else {
    // TypeScript knows this has error
    console.log(`Order failed: ${order1.error}`);
}

// Try to order more than available
const order2 = inventory.processOrder("BOOK-001", 20);

if (order2.success) {
    console.log(`Success!`);
} else {
    console.log(`Error: ${order2.error}`);  // "Only 8 units available"
}

// Get summary
console.log(inventory.getSummary());
</code></pre>

                <div class="card" style="background-color: #f0f0f0; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Output:</h4>
                    <pre><code>Added Laptop to inventory
Added TypeScript Handbook to inventory
Added T-Shirt to inventory
Laptop
Electronics: 1 items
Order placed! ID: ORD-1234567890, Total: $2999.97
Error: Only 8 units available
Inventory Summary:
Total Products: 3
In Stock: 1
Low Stock: 1
Out of Stock: 1
</code></pre>
                </div>

                <h3>Your Turn: Extend the System</h3>
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üèãÔ∏è Exercise 1: Add Discount Functionality</h4>
                    <p><strong>Challenge:</strong> Add a method to apply discounts to products. Create a <code>Discount</code> type that can be either a percentage (number) or a fixed amount ("fixed"), and implement an <code>applyDiscount</code> method.</p>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Think about using a discriminated union for the discount type:</p>
                        <pre><code class="language-typescript">type PercentDiscount = { type: "percent"; value: number };
type FixedDiscount = { type: "fixed"; amount: number };
type Discount = PercentDiscount | FixedDiscount;
</code></pre>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">type PercentDiscount = { type: "percent"; value: number };
type FixedDiscount = { type: "fixed"; amount: number };
type Discount = PercentDiscount | FixedDiscount;

class Inventory {
    // ... previous methods ...
    
    applyDiscount(id: ProductId, discount: Discount): void {
        const product = this.findProduct(id);
        
        if (!product) {
            console.log("Product not found");
            return;
        }
        
        if (discount.type === "percent") {
            // TypeScript knows discount.value exists
            product.price = product.price * (1 - discount.value / 100);
        } else {
            // TypeScript knows discount.amount exists
            product.price = Math.max(0, product.price - discount.amount);
        }
        
        console.log(`Discount applied. New price: $${product.price.toFixed(2)}`);
    }
}

// Usage
inventory.applyDiscount(1, { type: "percent", value: 10 });  // 10% off
inventory.applyDiscount(2, { type: "fixed", amount: 5 });    // $5 off
</code></pre>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üèãÔ∏è Exercise 2: Add Search Functionality</h4>
                    <p><strong>Challenge:</strong> Create a <code>searchProducts</code> method that can search by name (string), category (Category), or price range (tuple of [min, max]).</p>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use union types and type guards to handle different search criteria:</p>
                        <pre><code class="language-typescript">type SearchCriteria = 
    | { type: "name"; value: string }
    | { type: "category"; value: Category }
    | { type: "priceRange"; min: number; max: number };
</code></pre>
                    </details>
                    
                    <details>
                        <summary>‚úÖ Solution</summary>
                        <pre><code class="language-typescript">type SearchCriteria = 
    | { type: "name"; value: string }
    | { type: "category"; value: Category }
    | { type: "priceRange"; min: number; max: number };

class Inventory {
    // ... previous methods ...
    
    searchProducts(criteria: SearchCriteria): Product[] {
        switch (criteria.type) {
            case "name":
                return this.products.filter(p => 
                    p.name.toLowerCase().includes(criteria.value.toLowerCase())
                );
            
            case "category":
                return this.products.filter(p => 
                    p.category === criteria.value
                );
            
            case "priceRange":
                return this.products.filter(p => 
                    p.price >= criteria.min && p.price <= criteria.max
                );
            
            default:
                const exhaustiveCheck: never = criteria;
                throw new Error(`Unhandled criteria: ${exhaustiveCheck}`);
        }
    }
}

// Usage
const byName = inventory.searchProducts({ type: "name", value: "shirt" });
const byCategory = inventory.searchProducts({ type: "category", value: "electronics" });
const byPrice = inventory.searchProducts({ type: "priceRange", min: 10, max: 50 });
</code></pre>
                    </details>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Amazing Work!</h3>
                    <p style="color: white; margin: 0;">You just built a complete, type-safe inventory system using primitive types, arrays, tuples, unions, literals, and special types. This is the foundation of real-world TypeScript development! üöÄ</p>
                </div>
            </section>

            <!-- Section 8: Best Practices -->
            <section id="section8" class="lesson-section">
                <h2>Best Practices for Using Basic Types</h2>
                
                <p>You now know all the basic types! Let's make sure you use them effectively. Here are the golden rules that will make your TypeScript code shine! ‚ú®</p>

                <h3>‚úÖ Do's: Good Type Habits</h3>

                <h4>1. Use the Most Specific Type Possible</h4>
                <pre><code class="language-typescript">// ‚ùå Too general
let status: string = "pending";

// ‚úÖ Specific and safe
let status: "pending" | "approved" | "rejected" = "pending";
</code></pre>

                <h4>2. Leverage Type Inference</h4>
                <pre><code class="language-typescript">// ‚ùå Redundant type annotation
let count: number = 0;
let message: string = "Hello";

// ‚úÖ Let TypeScript infer
let count = 0;              // Inferred as number
let message = "Hello";      // Inferred as string
</code></pre>

                <h4>3. Use Readonly for Tuples When Appropriate</h4>
                <pre><code class="language-typescript">// ‚ùå Tuple can be modified
let point: [number, number] = [10, 20];
point.push(30);  // Breaks the tuple!

// ‚úÖ Readonly tuple is safer
let point: readonly [number, number] = [10, 20];
// point.push(30);  // ‚ùå Error! Can't modify
</code></pre>

                <h4>4. Prefer unknown Over any</h4>
                <pre><code class="language-typescript">// ‚ùå Unsafe
function process(data: any) {
    return data.value.toUpperCase();  // Runtime error if data is wrong!
}

// ‚úÖ Safe
function process(data: unknown) {
    if (data && typeof data === "object" && "value" in data) {
        const obj = data as { value: unknown };
        if (typeof obj.value === "string") {
            return obj.value.toUpperCase();  // Safe!
        }
    }
    return "Invalid data";
}
</code></pre>

                <h4>5. Use Type Aliases for Complex Types</h4>
                <pre><code class="language-typescript">// ‚ùå Repetitive and hard to maintain
function processUser(user: { id: number; name: string; email: string }): void {}
function updateUser(user: { id: number; name: string; email: string }): void {}

// ‚úÖ Define once, use everywhere
type User = {
    id: number;
    name: string;
    email: string;
};

function processUser(user: User): void {}
function updateUser(user: User): void {}
</code></pre>

                <h3>‚ùå Don'ts: Common Mistakes to Avoid</h3>

                <h4>1. Don't Use any Unless Absolutely Necessary</h4>
                <pre><code class="language-typescript">// ‚ùå Defeats the purpose of TypeScript
let data: any = fetchData();
data.anything.can.happen();  // No type safety!

// ‚úÖ Use proper types or unknown
let data: User | null = fetchData();
if (data) {
    console.log(data.name);  // Type-safe!
}
</code></pre>

                <h4>2. Don't Forget Array Type Annotations for Empty Arrays</h4>
                <pre><code class="language-typescript">// ‚ùå TypeScript doesn't know what type will go in here
let items = [];
items.push("string");
items.push(123);  // No error, but probably a bug!

// ‚úÖ Specify the type
let items: string[] = [];
items.push("string");  // ‚úÖ OK
items.push(123);       // ‚ùå Error!
</code></pre>

                <h4>3. Don't Use String When You Mean Literal Types</h4>
                <pre><code class="language-typescript">// ‚ùå Too permissive
function setTheme(theme: string) {
    // What if someone passes "purple"?
}

// ‚úÖ Restrict to valid values
function setTheme(theme: "light" | "dark") {
    // Only valid themes allowed!
}
</code></pre>

                <h4>4. Don't Mix Up Tuples and Arrays</h4>
                <pre><code class="language-typescript">// ‚ùå Wrong: This is an array, not a tuple
let coordinates: number[] = [10, 20];
coordinates.push(30);  // Allowed, but breaks the coordinate concept

// ‚úÖ Right: Use tuple for fixed structure
let coordinates: [number, number] = [10, 20];
// coordinates.push(30);  // Would be an error with readonly
</code></pre>

                <h3>üí° Pro Tips</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 1: Use Union Types for Flexible APIs</h4>
                    <p>When a function can accept multiple types, union types make it type-safe:</p>
                    <pre><code class="language-typescript">function formatId(id: string | number): string {
    return `ID-${id}`;
}

formatId(123);      // ‚úÖ Works
formatId("abc");    // ‚úÖ Works
formatId(true);     // ‚ùå Error!
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 2: Combine Literal Types with Union Types</h4>
                    <p>This pattern is incredibly powerful for building type-safe APIs:</p>
                    <pre><code class="language-typescript">type Result&lt;T&gt; = 
    | { success: true; data: T }
    | { success: false; error: string };

function handleResult&lt;T&gt;(result: Result&lt;T&gt;): void {
    if (result.success) {
        console.log(result.data);   // TypeScript knows data exists
    } else {
        console.log(result.error);  // TypeScript knows error exists
    }
}
</code></pre>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>Tip 3: Document Your Types</h4>
                    <p>Use JSDoc comments to explain non-obvious type choices:</p>
                    <pre><code class="language-typescript">/**
 * User status in the system
 * - pending: Awaiting email verification
 * - active: Fully verified and active
 * - suspended: Temporarily blocked
 */
type UserStatus = "pending" | "active" | "suspended";
</code></pre>
                </div>

                <h3>Quick Reference Card</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Use For</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>string</code></td>
                            <td>Text data</td>
                            <td><code>let name: string = "Alice"</code></td>
                        </tr>
                        <tr>
                            <td><code>number</code></td>
                            <td>Numeric data</td>
                            <td><code>let age: number = 25</code></td>
                        </tr>
                        <tr>
                            <td><code>boolean</code></td>
                            <td>True/false values</td>
                            <td><code>let active: boolean = true</code></td>
                        </tr>
                        <tr>
                            <td><code>Type[]</code></td>
                            <td>Arrays of same type</td>
                            <td><code>let nums: number[] = [1, 2, 3]</code></td>
                        </tr>
                        <tr>
                            <td><code>[Type, Type]</code></td>
                            <td>Fixed-length mixed types</td>
                            <td><code>let point: [number, number] = [x, y]</code></td>
                        </tr>
                        <tr>
                            <td><code>Type | Type</code></td>
                            <td>One of several types</td>
                            <td><code>let id: string | number</code></td>
                        </tr>
                        <tr>
                            <td><code>"literal"</code></td>
                            <td>Exact value only</td>
                            <td><code>let status: "pending" | "done"</code></td>
                        </tr>
                        <tr>
                            <td><code>unknown</code></td>
                            <td>Unknown data (check first)</td>
                            <td><code>let data: unknown = getData()</code></td>
                        </tr>
                        <tr>
                            <td><code>void</code></td>
                            <td>No return value</td>
                            <td><code>function log(): void {}</code></td>
                        </tr>
                        <tr>
                            <td><code>never</code></td>
                            <td>Never returns</td>
                            <td><code>function fail(): never { throw }</code></td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 9: Summary -->
            <section id="section9" class="lesson-section">
                <h2>Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Primitive types</strong> (string, number, boolean) are the foundation of TypeScript</li>
                        <li><strong>Arrays</strong> hold collections of the same type: <code>Type[]</code></li>
                        <li><strong>Tuples</strong> represent fixed-length arrays with specific types at each position</li>
                        <li><strong>Type inference</strong> lets TypeScript figure out types automatically - use it!</li>
                        <li><strong>Union types</strong> (<code>Type | Type</code>) allow values to be one of several types</li>
                        <li><strong>Literal types</strong> restrict values to specific strings, numbers, or booleans</li>
                        <li><strong>unknown</strong> is the safe alternative to <code>any</code> - always prefer it</li>
                        <li><strong>void</strong> indicates functions that don't return values</li>
                        <li><strong>never</strong> represents values that never occur (errors, infinite loops)</li>
                        <li><strong>Avoid any</strong> at all costs - it defeats TypeScript's purpose</li>
                    </ul>
                </div>

                <h3>The Type Hierarchy</h3>
                <div class="mermaid">
                    graph TB
                        A[TypeScript Types] --> B[Primitive Types]
                        A --> C[Collection Types]
                        A --> D[Special Types]
                        
                        B --> B1[string]
                        B --> B2[number]
                        B --> B3[boolean]
                        
                        C --> C1[Arrays]
                        C --> C2[Tuples]
                        
                        D --> D1[any - avoid!]
                        D --> D2[unknown - prefer]
                        D --> D3[void]
                        D --> D4[never]
                        
                        E[Type Modifiers] --> E1[Union: A | B]
                        E --> E2["Literal: 'exact'"]
                        E --> E3[Optional: Type?]
                        
                        style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                        style D1 fill:#f44336,stroke:#333,stroke-width:2px,color:#fff
                        style D2 fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
                </div>

                <h3>What You've Mastered</h3>
                <p>Congratulations! You now have a solid grasp of TypeScript's type system. You can:</p>
                <ul>
                    <li>‚úÖ Use primitive types confidently in any scenario</li>
                    <li>‚úÖ Work with arrays and understand when to use tuples</li>
                    <li>‚úÖ Create flexible APIs with union types</li>
                    <li>‚úÖ Restrict values with literal types</li>
                    <li>‚úÖ Handle unknown data safely with type guards</li>
                    <li>‚úÖ Build complete, type-safe applications</li>
                </ul>

                <h3>Real-World Impact</h3>
                <p>The types you learned today prevent real bugs in production:</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üêõ Bugs You'll Prevent</h4>
                    <ul>
                        <li><strong>Type mismatches:</strong> No more "undefined is not a function" errors</li>
                        <li><strong>Invalid values:</strong> Status can't be "complted" (typo) anymore</li>
                        <li><strong>Wrong array operations:</strong> Can't add numbers to a string array</li>
                        <li><strong>Missing properties:</strong> TypeScript catches them immediately</li>
                        <li><strong>Incorrect function calls:</strong> Wrong number or type of arguments caught instantly</li>
                    </ul>
                </div>

                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html" target="_blank">TypeScript Handbook: Everyday Types</a></li>
                    <li><a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html" target="_blank">TypeScript Handbook: Narrowing</a></li>
                    <li><a href="https://www.typescriptlang.org/play" target="_blank">TypeScript Playground</a> - Practice what you learned!</li>
                    <li><a href="https://github.com/type-challenges/type-challenges" target="_blank">Type Challenges</a> - Level up your skills</li>
                </ul>

                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>Interfaces and Type Aliases</strong>. You'll learn how to:</p>
                <ul>
                    <li>Define complex object shapes with interfaces</li>
                    <li>Understand when to use interfaces vs type aliases</li>
                    <li>Extend and compose types</li>
                    <li>Create index signatures for dynamic properties</li>
                    <li>Use optional and readonly properties effectively</li>
                </ul>

                <p>This is where we start building the complex type structures you see in real applications! üèóÔ∏è</p>

                <h3>Quick Knowledge Check</h3>
                <div class="card quiz-container">
                    <h4>üéØ Test Your Understanding</h4>
                    
                    <div class="quiz-question">
                        <p><strong>Question 1:</strong> What's the difference between <code>string[]</code> and <code>[string, string]</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Think about length and flexibility">
                                A) They're the same thing
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Exactly! string[] is an array of any length, while [string, string] is a tuple with exactly 2 strings.">
                                B) First is an array (any length), second is a tuple (exactly 2 strings)
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="Both can hold strings">
                                C) First holds strings, second holds something else
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 2:</strong> When should you use <code>unknown</code> instead of <code>any</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="Actually, you should always prefer unknown!">
                                A) Never, any is better
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Correct! unknown is type-safe because it forces you to check the type before using it.">
                                B) Always - unknown is the safe alternative that requires type checking
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="unknown is useful in many scenarios">
                                C) Only in error handling
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>

                    <div class="quiz-question">
                        <p><strong>Question 3:</strong> What's better: <code>let status: string</code> or <code>let status: "pending" | "active" | "done"</code>?</p>
                        <div class="quiz-options">
                            <button class="quiz-option" data-correct="false" data-hint="More specific is usually better">
                                A) The first one - it's simpler
                            </button>
                            <button class="quiz-option" data-correct="true" data-explanation="Perfect! Literal types prevent typos and invalid values, making your code more robust.">
                                B) The second one - literal types prevent invalid values
                            </button>
                            <button class="quiz-option" data-correct="false" data-hint="There's definitely a better choice">
                                C) Doesn't matter
                            </button>
                        </div>
                        <div class="quiz-feedback"></div>
                    </div>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Outstanding Work!</h3>
                    <p style="color: white; font-size: 1.1rem;">You've mastered TypeScript's basic types! You now have the foundation to build type-safe applications. The types you learned today will be used in every single TypeScript project you work on.</p>
                    <p style="color: white; font-size: 1.1rem; margin: 0;">Keep practicing, and get ready to level up with interfaces and type aliases! üöÄ</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_1_1_intro_to_typescript_part_c.html" class="prev-lesson">‚Üê Previous: Introduction to TypeScript</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_1_3_interfaces_and_type_aliases.html" class="next-lesson">Next: Interfaces & Type Aliases ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce - React TypeScript Course. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build better applications with TypeScript and React.</p>
        <p style="margin-top: 1rem; font-size: 0.9rem;">
            <a href="index.html" style="color: white; text-decoration: underline;">Course Home</a> | 
            <a href="index.html#modules" style="color: white; text-decoration: underline;">All Modules</a> | 
            <a href="#main-content" style="color: white; text-decoration: underline;">Back to Top ‚Üë</a>
        </p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
