<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master React architecture best practices and design patterns for building scalable, maintainable applications. Learn feature-based folder structure, component organization, separation of concerns, custom hooks, service layers, and professional code organization with TypeScript.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.5: Architecture Best Practices - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                â˜°
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">ğŸŒ™</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.5: Architecture Best Practices</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>ğŸ—ï¸ Lesson 8.5: Architecture Best Practices</h1>
                <p class="lead">Welcome to the final lesson of Module 8! Great code isn't just about writing featuresâ€”it's about building applications that scale, adapt to change, and remain maintainable as your team and codebase grow. In this comprehensive lesson, you'll learn professional architecture patterns that separate great React applications from good ones. Whether you're building a small side project or an enterprise application, these architectural principles will serve you throughout your career as a React developer.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>ğŸ¯ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand the principles of scalable React architecture</li>
                        <li>Implement feature-based folder structures</li>
                        <li>Organize components by responsibility and reusability</li>
                        <li>Apply separation of concerns to React applications</li>
                        <li>Extract business logic into custom hooks</li>
                        <li>Design service layers for API communication</li>
                        <li>Structure TypeScript types and interfaces effectively</li>
                        <li>Implement proper error handling strategies</li>
                        <li>Design for testability from the start</li>
                        <li>Make architectural decisions that support growth</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 8.1-8.4 (State Management, Zustand, Redux Toolkit, React Query), All previous modules</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">ğŸ“‘ In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Principles of Good Architecture</a></li>
                        <li><a href="#section2" class="toc-link">Feature-Based Folder Structure</a></li>
                        <li><a href="#section3" class="toc-link">Component Organization Patterns</a></li>
                        <li><a href="#section4" class="toc-link">Separation of Concerns</a></li>
                        <li><a href="#section5" class="toc-link">Custom Hooks for Business Logic</a></li>
                        <li><a href="#section6" class="toc-link">Service Layer Pattern</a></li>
                        <li><a href="#section7" class="toc-link">Type Organization</a></li>
                        <li><a href="#section8" class="toc-link">Error Handling Architecture</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Principles of Good Architecture -->
            <section id="section1">
                <h2>ğŸ¯ Principles of Good Architecture</h2>
                
                <p>Before diving into specific patterns, let's understand the fundamental principles that guide architectural decisions in React applications. These principles apply regardless of project size or specific technologies used.</p>

                <h3>The Core Principles</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>ğŸ“– Architecture Principles</h4>
                    <p style="color: white;"><strong>Good architecture</strong> is about making your codebase easy to understand, modify, and extend. It prioritizes <strong>maintainability</strong> over cleverness, <strong>clarity</strong> over brevity, and <strong>consistency</strong> over individual preferences. The goal is to minimize the cognitive load required to work with your code, both for yourself in the future and for your teammates.</p>
                </div>

                <h3>1. Separation of Concerns</h3>

                <p>Each part of your application should have a single, well-defined responsibility. When components, hooks, and utilities each focus on one thing, they become easier to understand, test, and reuse.</p>

                <pre><code class="language-typescript">// âŒ BAD - Component doing too much
function UserProfile() {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    fetch('/api/user')
      .then(res => res.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      });
  }, []);
  
  const saveUser = (data) => {
    fetch('/api/user', {
      method: 'PUT',
      body: JSON.stringify(data)
    }).then(/* ... */);
  };
  
  return (
    &lt;div&gt;
      {loading ? &lt;Spinner /&gt; : (
        &lt;form onSubmit={/* validation logic */}&gt;
          {/* lots of form fields and UI logic */}
        &lt;/form&gt;
      )}
    &lt;/div&gt;
  );
}

// âœ… GOOD - Separated concerns
function UserProfile() {
  const { user, isLoading } = useUser();
  
  return (
    &lt;div&gt;
      {isLoading ? &lt;Spinner /&gt; : &lt;UserForm user={user} /&gt;}
    &lt;/div&gt;
  );
}

// Custom hook handles data fetching
function useUser() {
  return useQuery({
    queryKey: ['user'],
    queryFn: userService.getProfile
  });
}

// Service handles API calls
const userService = {
  getProfile: () => fetch('/api/user').then(r => r.json()),
  updateProfile: (data) => fetch('/api/user', { 
    method: 'PUT', 
    body: JSON.stringify(data) 
  })
};

// Component handles only UI and user interactions
function UserForm({ user }: { user: User }) {
  const updateMutation = useUpdateUser();
  // Form logic...
}</code></pre>

                <div class="mermaid">
graph TB
    A[UserProfile Component] --> B[Presentation Layer]
    A --> C[Data Layer useUser]
    A --> D[Business Logic Layer]
    
    C --> E[Service Layer]
    E --> F[API Calls]
    
    B --> G[UserForm Component]
    B --> H[Spinner Component]
    
    D --> I[Custom Hooks]
    I --> J[useUpdateUser]
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style C fill:#fff3cd
    style D fill:#f8bbd0
    style E fill:#d1c4e9
</div>

                <h3>2. DRY (Don't Repeat Yourself)</h3>

                <p>Duplicated code multiplies maintenance work and increases the chance of bugs. Extract common logic into reusable functions, hooks, and components.</p>

                <pre><code class="language-typescript">// âŒ BAD - Repeated logic
function UsersList() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/users')
      .then(res => res.json())
      .then(data => {
        setUsers(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  // ... component JSX
}

function PostsList() {
  const [posts, setPosts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    fetch('/api/posts')
      .then(res => res.json())
      .then(data => {
        setPosts(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err);
        setLoading(false);
      });
  }, []);
  
  // ... component JSX
}

// âœ… GOOD - Reusable hook
function useFetch&lt;T&gt;(url: string) {
  const [data, setData] = useState&lt;T | null&gt;(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState&lt;Error | null&gt;(null);
  
  useEffect(() => {
    let cancelled = false;
    
    setLoading(true);
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!cancelled) {
          setData(data);
          setLoading(false);
        }
      })
      .catch(err => {
        if (!cancelled) {
          setError(err);
          setLoading(false);
        }
      });
    
    return () => { cancelled = true; };
  }, [url]);
  
  return { data, loading, error };
}

// Now both components are simple
function UsersList() {
  const { data: users, loading, error } = useFetch&lt;User[]&gt;('/api/users');
  // ... component JSX
}

function PostsList() {
  const { data: posts, loading, error } = useFetch&lt;Post[]&gt;('/api/posts');
  // ... component JSX
}</code></pre>

                <h3>3. KISS (Keep It Simple, Stupid)</h3>

                <p>Simple solutions are easier to understand, test, and maintain. Avoid over-engineering and premature optimization.</p>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Signs of Good Simplicity</h4>
                    <ul>
                        <li>A new team member can understand a component in under 5 minutes</li>
                        <li>Testing feels natural, not like fighting the code</li>
                        <li>Naming clearly describes what something does</li>
                        <li>You don't need comments to explain "why" (but you might need them for "what")</li>
                        <li>Changes in one area rarely require changes in unrelated areas</li>
                    </ul>
                </div>

                <h3>4. Single Responsibility Principle</h3>

                <p>Each component, function, or module should have one reason to change. This makes code predictable and reduces the ripple effect of modifications.</p>

                <pre><code class="language-typescript">// âŒ BAD - Component has multiple responsibilities
function UserDashboard() {
  return (
    &lt;div&gt;
      {/* Analytics tracking logic */}
      {/* User data fetching */}
      {/* Navigation rendering */}
      {/* User profile display */}
      {/* Settings management */}
      {/* Notifications handling */}
    &lt;/div&gt;
  );
}

// âœ… GOOD - Each component has one responsibility
function UserDashboard() {
  useAnalytics('dashboard-view');
  const { user } = useUser();
  
  return (
    &lt;DashboardLayout&gt;
      &lt;UserHeader user={user} /&gt;
      &lt;UserStats userId={user.id} /&gt;
      &lt;RecentActivity userId={user.id} /&gt;
      &lt;QuickActions /&gt;
    &lt;/DashboardLayout&gt;
  );
}</code></pre>

                <h3>5. Composition Over Inheritance</h3>

                <p>React's component model encourages composition. Build complex UIs by combining simple, focused components rather than creating deep inheritance hierarchies.</p>

                <pre><code class="language-typescript">// âœ… GOOD - Composition pattern
function Card({ children }: { children: React.ReactNode }) {
  return &lt;div className="card"&gt;{children}&lt;/div&gt;;
}

function CardHeader({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-header"&gt;{children}&lt;/div&gt;;
}

function CardBody({ children }: { children: React.ReactNode }) {
  return &lt;div className="card-body"&gt;{children}&lt;/div&gt;;
}

// Compose them together
function UserCard({ user }: { user: User }) {
  return (
    &lt;Card&gt;
      &lt;CardHeader&gt;
        &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;/CardHeader&gt;
      &lt;CardBody&gt;
        &lt;p&gt;{user.bio}&lt;/p&gt;
      &lt;/CardBody&gt;
    &lt;/Card&gt;
  );
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ The Testing Principle</h4>
                    <p>A good architecture test: If a component is hard to test, it's probably doing too much. Difficulty testing is often a sign that you need to break things down or separate concerns better.</p>
                </div>

                <h3>Architecture Anti-Patterns to Avoid</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Anti-Pattern</th>
                            <th>Problem</th>
                            <th>Solution</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>God Components</strong></td>
                            <td>Components that do everything</td>
                            <td>Break into smaller, focused components</td>
                        </tr>
                        <tr>
                            <td><strong>Prop Drilling</strong></td>
                            <td>Passing props through many layers</td>
                            <td>Use Context, state management, or composition</td>
                        </tr>
                        <tr>
                            <td><strong>Mixed Concerns</strong></td>
                            <td>Business logic in components</td>
                            <td>Extract to custom hooks or services</td>
                        </tr>
                        <tr>
                            <td><strong>Tight Coupling</strong></td>
                            <td>Components depend on implementation details</td>
                            <td>Use interfaces and dependency injection</td>
                        </tr>
                        <tr>
                            <td><strong>Premature Abstraction</strong></td>
                            <td>Creating abstractions before needed</td>
                            <td>Wait for the third use case</td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <!-- Section 2: Feature-Based Folder Structure -->
            <section id="section2">
                <h2>ğŸ“ Feature-Based Folder Structure</h2>
                
                <p>As applications grow, organizing files by type (all components together, all hooks together) becomes unwieldy. A <strong>feature-based structure</strong> groups related files together, making it easier to understand and modify features as complete units.</p>

                <h3>Traditional vs Feature-Based Structure</h3>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin: 2rem 0;">
                    <div>
                        <h4>âŒ Type-Based (Doesn't Scale)</h4>
                        <pre><code class="language-bash">src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”œâ”€â”€ UserCard.tsx
â”‚   â”œâ”€â”€ UserForm.tsx
â”‚   â”œâ”€â”€ PostList.tsx
â”‚   â”œâ”€â”€ PostCard.tsx
â”‚   â”œâ”€â”€ PostForm.tsx
â”‚   â”œâ”€â”€ CommentList.tsx
â”‚   â””â”€â”€ ...50+ more
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useUsers.ts
â”‚   â”œâ”€â”€ usePosts.ts
â”‚   â”œâ”€â”€ useComments.ts
â”‚   â””â”€â”€ ...30+ more
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ userService.ts
â”‚   â”œâ”€â”€ postService.ts
â”‚   â””â”€â”€ ...20+ more
â””â”€â”€ types/
    â”œâ”€â”€ user.ts
    â”œâ”€â”€ post.ts
    â””â”€â”€ ...20+ more</code></pre>
                    </div>
                    <div>
                        <h4>âœ… Feature-Based (Scales Well)</h4>
                        <pre><code class="language-bash">src/
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ users/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ UserCard.tsx
â”‚   â”‚   â”‚   â””â”€â”€ UserForm.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â””â”€â”€ useUsers.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ userService.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ user.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ posts/
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ types/
â”‚   â””â”€â”€ comments/
â”‚       â””â”€â”€ ...
â””â”€â”€ shared/
    â”œâ”€â”€ components/
    â”œâ”€â”€ hooks/
    â””â”€â”€ utils/</code></pre>
                    </div>
                </div>

                <h3>Complete Feature-Based Architecture</h3>

                <pre><code class="language-bash">src/
â”œâ”€â”€ features/                    # Feature modules
â”‚   â”œâ”€â”€ auth/                   # Authentication feature
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ LoginForm.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterForm.tsx
â”‚   â”‚   â”‚   â””â”€â”€ ProtectedRoute.tsx
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”‚   â””â”€â”€ useLogin.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ authService.ts
â”‚   â”‚   â”œâ”€â”€ store/             # Feature-specific state
â”‚   â”‚   â”‚   â””â”€â”€ authStore.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ auth.types.ts
â”‚   â”‚   â”œâ”€â”€ utils/
â”‚   â”‚   â”‚   â””â”€â”€ tokenManager.ts
â”‚   â”‚   â””â”€â”€ index.ts           # Public API
â”‚   â”‚
â”‚   â”œâ”€â”€ users/                 # Users feature
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ UserList/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserList.test.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ UserList.module.css
â”‚   â”‚   â”‚   â”œâ”€â”€ UserCard/
â”‚   â”‚   â”‚   â””â”€â”€ UserProfile/
â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ useUsers.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useUser.ts
â”‚   â”‚   â”‚   â””â”€â”€ useUpdateUser.ts
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ userService.ts
â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â””â”€â”€ user.types.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ posts/
â”‚   â”œâ”€â”€ comments/
â”‚   â””â”€â”€ dashboard/
â”‚
â”œâ”€â”€ shared/                     # Shared across features
â”‚   â”œâ”€â”€ components/            # Reusable UI components
â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â””â”€â”€ Modal/
â”‚   â”œâ”€â”€ hooks/                 # Reusable hooks
â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â”œâ”€â”€ useDebounce.ts
â”‚   â”‚   â””â”€â”€ useMediaQuery.ts
â”‚   â”œâ”€â”€ utils/                 # Utility functions
â”‚   â”‚   â”œâ”€â”€ formatters.ts
â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â””â”€â”€ helpers.ts
â”‚   â”œâ”€â”€ types/                 # Shared types
â”‚   â”‚   â””â”€â”€ common.types.ts
â”‚   â””â”€â”€ constants/
â”‚       â””â”€â”€ config.ts
â”‚
â”œâ”€â”€ lib/                       # Third-party setup
â”‚   â”œâ”€â”€ react-query.ts        # React Query config
â”‚   â”œâ”€â”€ axios.ts              # Axios instance
â”‚   â””â”€â”€ i18n.ts               # Internationalization
â”‚
â”œâ”€â”€ pages/                     # Route components (or routes/)
â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”œâ”€â”€ UsersPage.tsx
â”‚   â”œâ”€â”€ UserDetailPage.tsx
â”‚   â””â”€â”€ NotFoundPage.tsx
â”‚
â”œâ”€â”€ layouts/                   # Layout components
â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â”œâ”€â”€ AuthLayout.tsx
â”‚   â””â”€â”€ DashboardLayout.tsx
â”‚
â”œâ”€â”€ styles/                    # Global styles
â”‚   â”œâ”€â”€ globals.css
â”‚   â”œâ”€â”€ variables.css
â”‚   â””â”€â”€ theme.css
â”‚
â”œâ”€â”€ App.tsx                    # Root component
â”œâ”€â”€ main.tsx                   # Entry point
â””â”€â”€ vite-env.d.ts             # Vite types</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Benefits of Feature-Based Structure</h4>
                    <ul>
                        <li><strong>Scalability:</strong> Add new features without cluttering existing folders</li>
                        <li><strong>Maintainability:</strong> All related code lives together</li>
                        <li><strong>Team collaboration:</strong> Multiple devs can work on different features</li>
                        <li><strong>Code ownership:</strong> Clear boundaries for feature teams</li>
                        <li><strong>Easier refactoring:</strong> Feature can be moved or removed as a unit</li>
                        <li><strong>Better imports:</strong> Feature's public API through index.ts</li>
                    </ul>
                </div>

                <h3>Feature Module Example</h3>

                <pre><code class="language-typescript">// features/users/index.ts - Public API
export { UserList } from './components/UserList';
export { UserCard } from './components/UserCard';
export { useUsers, useUser } from './hooks';
export type { User, UserFilters } from './types/user.types';

// Other files import from the feature
import { UserList, useUsers, User } from '@/features/users';

// NOT from internal paths
// âŒ DON'T: import { UserList } from '@/features/users/components/UserList';</code></pre>

                <h3>Shared vs Feature-Specific</h3>

                <p>Deciding what goes in <code>shared/</code> vs <code>features/</code>:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Put in shared/</th>
                            <th>Put in feature/</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Used by 3+ features</td>
                            <td>Used by only 1-2 features</td>
                        </tr>
                        <tr>
                            <td>Generic UI components (Button, Input)</td>
                            <td>Domain-specific components (UserCard)</td>
                        </tr>
                        <tr>
                            <td>Generic utilities (formatDate, debounce)</td>
                            <td>Domain logic (calculateUserScore)</td>
                        </tr>
                        <tr>
                            <td>No business logic</td>
                            <td>Contains business logic</td>
                        </tr>
                        <tr>
                            <td>Could be open-sourced</td>
                            <td>Specific to this app</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>âš ï¸ Avoid Premature Sharing</h4>
                    <p>When creating a new component, start in the feature folder. Move it to <code>shared/</code> only when you actually need it in a second place. The "Rule of Three" applies: extract to shared when you need it the third time.</p>
                </div>

            </section>

            <!-- Section 3: Component Organization Patterns -->
            <section id="section3">
                <h2>ğŸ§© Component Organization Patterns</h2>
                
                <p>Not all components are created equal. Understanding different component types and their roles helps you organize them effectively and make better architectural decisions.</p>

                <h3>The Component Hierarchy</h3>

                <div class="mermaid">
graph TB
    A[Pages/Routes] --> B[Features]
    A --> C[Layouts]
    
    B --> D[Container Components]
    D --> E[Presentational Components]
    
    E --> F[UI Components]
    F --> G[Shared Components]
    
    C --> F
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style D fill:#fff3cd
    style E fill:#f8bbd0
    style F fill:#d1c4e9
    style G fill:#ffccbc
</div>

                <h3>1. Page Components (Route Components)</h3>

                <p>Top-level components that correspond to routes. They orchestrate feature components and manage page-level concerns.</p>

                <pre><code class="language-typescript">// pages/UsersPage.tsx
import { UserList } from '@/features/users';
import { PageHeader } from '@/shared/components';
import { MainLayout } from '@/layouts';

export function UsersPage() {
  return (
    &lt;MainLayout&gt;
      &lt;PageHeader 
        title="Users" 
        description="Manage all users in your application"
      /&gt;
      &lt;UserList /&gt;
    &lt;/MainLayout&gt;
  );
}

// Characteristics:
// - Maps to a route
// - Minimal logic (mostly composition)
// - Uses layouts and features
// - Handles page-level data fetching
// - Sets page metadata (title, etc.)</code></pre>

                <h3>2. Container Components (Smart Components)</h3>

                <p>Manage state, data fetching, and business logic. They connect to stores, hooks, and APIs, then pass data down to presentational components.</p>

                <pre><code class="language-typescript">// features/users/components/UserList/UserListContainer.tsx
import { useUsers } from '../../hooks/useUsers';
import { UserListView } from './UserListView';

export function UserListContainer() {
  const { 
    users, 
    isLoading, 
    error, 
    refetch 
  } = useUsers();
  
  const [filters, setFilters] = useState&lt;UserFilters&gt;({});
  
  const handleFilterChange = (newFilters: UserFilters) => {
    setFilters(newFilters);
  };
  
  const filteredUsers = useMemo(() => {
    return users?.filter(user => {
      // Filtering logic
      return true;
    });
  }, [users, filters]);
  
  if (isLoading) return &lt;LoadingSpinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} onRetry={refetch} /&gt;;
  
  return (
    &lt;UserListView
      users={filteredUsers}
      filters={filters}
      onFilterChange={handleFilterChange}
    /&gt;
  );
}

// Characteristics:
// - Manages state and side effects
// - Connects to data sources
// - Contains business logic
// - Handles loading and error states
// - Passes data to presentational components</code></pre>

                <h3>3. Presentational Components (Dumb Components)</h3>

                <p>Focus purely on rendering UI. They receive data through props and notify parents of user interactions through callback props.</p>

                <pre><code class="language-typescript">// features/users/components/UserList/UserListView.tsx
interface UserListViewProps {
  users: User[];
  filters: UserFilters;
  onFilterChange: (filters: UserFilters) => void;
}

export function UserListView({ 
  users, 
  filters, 
  onFilterChange 
}: UserListViewProps) {
  return (
    &lt;div className="user-list"&gt;
      &lt;UserFilters 
        filters={filters} 
        onChange={onFilterChange} 
      /&gt;
      
      &lt;div className="user-grid"&gt;
        {users.map(user => (
          &lt;UserCard key={user.id} user={user} /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}

// Characteristics:
// - Pure presentation logic
// - No state or side effects
// - Easy to test
// - Reusable with different data
// - Can be used in Storybook</code></pre>
                <h3>4. UI Components (Shared Components)</h3>

                <p>Generic, reusable components that have no knowledge of business logic. These live in the <code>shared/components/</code> folder and can be used across features.</p>

                <pre><code class="language-typescript">// shared/components/Button/Button.tsx
interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  loading?: boolean;
  children: React.ReactNode;
}

export function Button({
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled,
  children,
  className = '',
  ...props
}: ButtonProps) {
  const baseClasses = 'btn';
  const variantClass = `btn-${variant}`;
  const sizeClass = `btn-${size}`;
  
  return (
    &lt;button
      className={`${baseClasses} ${variantClass} ${sizeClass} ${className}`}
      disabled={disabled || loading}
      {...props}
    &gt;
      {loading ? &lt;Spinner size="small" /&gt; : children}
    &lt;/button&gt;
  );
}

// Characteristics:
// - Generic and reusable
// - No business logic
// - Highly configurable through props
// - Can be documented in Storybook
// - Could be published as a library</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Component Organization Summary</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Component Type</th>
                                <th>Responsibility</th>
                                <th>Location</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Page</strong></td>
                                <td>Route orchestration</td>
                                <td>pages/</td>
                            </tr>
                            <tr>
                                <td><strong>Layout</strong></td>
                                <td>Shared page structure</td>
                                <td>layouts/</td>
                            </tr>
                            <tr>
                                <td><strong>Feature</strong></td>
                                <td>Domain-specific features</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Container</strong></td>
                                <td>State & data management</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Presentational</strong></td>
                                <td>Pure UI rendering</td>
                                <td>features/{feature}/components/</td>
                            </tr>
                            <tr>
                                <td><strong>Shared UI</strong></td>
                                <td>Generic reusable UI</td>
                                <td>shared/components/</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

            </section>

            <!-- Section 4: Separation of Concerns -->
            <section id="section4">
                <h2>ğŸ”€ Separation of Concerns</h2>
                
                <p>Separation of concerns is about organizing code so that each piece has a clear, focused responsibility. In React applications, this means separating presentation, business logic, and data fetching into distinct layers.</p>

                <h3>The Three Layers</h3>

                <div class="mermaid">
graph TB
    A[Presentation Layer] --> B[Business Logic Layer]
    B --> C[Data Access Layer]
    
    A1[Components] --> A
    A2[JSX/UI] --> A
    
    B1[Custom Hooks] --> B
    B2[Utility Functions] --> B
    B3[Validation] --> B
    
    C1[API Services] --> C
    C2[React Query] --> C
    C3[State Management] --> C
    
    style A fill:#e3f2fd
    style B fill:#fff3cd
    style C fill:#c8e6c9
</div>

                <h3>1. Presentation Layer (Components)</h3>

                <p>Handles only rendering and user interactions. No business logic or data fetching.</p>

                <pre><code class="language-typescript">// âœ… GOOD - Pure presentation
function ProductCard({ product, onAddToCart }: ProductCardProps) {
  return (
    &lt;Card&gt;
      &lt;img src={product.image} alt={product.name} /&gt;
      &lt;h3&gt;{product.name}&lt;/h3&gt;
      &lt;p&gt;${product.price.toFixed(2)}&lt;/p&gt;
      &lt;Button onClick={() => onAddToCart(product.id)}&gt;
        Add to Cart
      &lt;/Button&gt;
    &lt;/Card&gt;
  );
}

// âŒ BAD - Mixed concerns
function ProductCard({ productId }: { productId: string }) {
  const [product, setProduct] = useState(null);
  const [cart, setCart] = useState([]);
  
  useEffect(() => {
    // Data fetching in component
    fetch(`/api/products/${productId}`)
      .then(res => res.json())
      .then(setProduct);
  }, [productId]);
  
  const addToCart = () => {
    // Business logic in component
    if (cart.length >= 10) {
      alert('Cart is full!');
      return;
    }
    
    const tax = product.price * 0.08;
    const total = product.price + tax;
    
    setCart([...cart, { ...product, total }]);
    
    // Data mutation in component
    fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId })
    });
  };
  
  return (/* ... */);
}</code></pre>

                <h3>2. Business Logic Layer (Custom Hooks)</h3>

                <p>Encapsulates business rules, calculations, and state management logic.</p>

                <pre><code class="language-typescript">// hooks/useCart.ts
export function useCart() {
  const [cart, setCart] = useState&lt;CartItem[]&gt;([]);
  
  const addToCart = useCallback((product: Product) => {
    // Business rule: Max 10 items
    if (cart.length >= 10) {
      throw new Error('Cart is full. Maximum 10 items allowed.');
    }
    
    // Business logic: Calculate totals
    const tax = calculateTax(product.price);
    const total = product.price + tax;
    
    const cartItem: CartItem = {
      ...product,
      tax,
      total,
      addedAt: new Date()
    };
    
    setCart(prev => [...prev, cartItem]);
    return cartItem;
  }, [cart.length]);
  
  const removeFromCart = useCallback((itemId: string) => {
    setCart(prev => prev.filter(item => item.id !== itemId));
  }, []);
  
  const cartTotal = useMemo(() => {
    return cart.reduce((sum, item) => sum + item.total, 0);
  }, [cart]);
  
  const itemCount = cart.length;
  const isFull = itemCount >= 10;
  
  return {
    cart,
    cartTotal,
    itemCount,
    isFull,
    addToCart,
    removeFromCart
  };
}

// Utility function for business logic
function calculateTax(price: number): number {
  const TAX_RATE = 0.08;
  return price * TAX_RATE;
}</code></pre>

                <h3>3. Data Access Layer (Services)</h3>

                <p>Handles all communication with external systems (APIs, localStorage, etc.).</p>

                <pre><code class="language-typescript">// services/cartService.ts
import { apiClient } from '@/lib/axios';

export const cartService = {
  async getCart(userId: string): Promise&lt;CartItem[]&gt; {
    const response = await apiClient.get(`/users/${userId}/cart`);
    return response.data;
  },
  
  async addToCart(userId: string, productId: string): Promise&lt;CartItem&gt; {
    const response = await apiClient.post(`/users/${userId}/cart`, {
      productId
    });
    return response.data;
  },
  
  async removeFromCart(userId: string, itemId: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${userId}/cart/${itemId}`);
  },
  
  async clearCart(userId: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${userId}/cart`);
  }
};</code></pre>

                <h3>Putting It All Together</h3>

                <pre><code class="language-typescript">// Component uses hook (business logic)
function ProductPage({ productId }: { productId: string }) {
  const { product } = useProduct(productId);
  const { addToCart, isFull } = useCart();
  
  const handleAddToCart = async () => {
    try {
      await addToCart(product);
      toast.success('Added to cart!');
    } catch (error) {
      toast.error(error.message);
    }
  };
  
  return (
    &lt;ProductCard
      product={product}
      onAddToCart={handleAddToCart}
      disabled={isFull}
    /&gt;
  );
}

// Hook uses service (data access)
function useCart() {
  const { user } = useAuth();
  const queryClient = useQueryClient();
  
  const { data: cart = [] } = useQuery({
    queryKey: ['cart', user?.id],
    queryFn: () => cartService.getCart(user!.id),
    enabled: !!user
  });
  
  const addMutation = useMutation({
    mutationFn: (product: Product) => {
      // Business logic first
      if (cart.length >= 10) {
        throw new Error('Cart is full');
      }
      
      // Then data access
      return cartService.addToCart(user!.id, product.id);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['cart'] });
    }
  });
  
  const addToCart = async (product: Product) => {
    return addMutation.mutateAsync(product);
  };
  
  return {
    cart,
    addToCart,
    isFull: cart.length >= 10
  };
}

// Service handles API calls
const cartService = {
  async addToCart(userId: string, productId: string) {
    const response = await apiClient.post(`/users/${userId}/cart`, {
      productId
    });
    return response.data;
  }
};</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Benefits of Separation</h4>
                    <ul>
                        <li><strong>Testability:</strong> Each layer can be tested independently</li>
                        <li><strong>Reusability:</strong> Business logic can be used in multiple components</li>
                        <li><strong>Maintainability:</strong> Changes are localized to one layer</li>
                        <li><strong>Readability:</strong> Each file has a clear, focused purpose</li>
                        <li><strong>Flexibility:</strong> Easy to swap implementations (e.g., change API)</li>
                    </ul>
                </div>

            </section>

            <!-- Section 5: Custom Hooks for Business Logic -->
            <section id="section5">
                <h2>ğŸª Custom Hooks for Business Logic</h2>
                
                <p>Custom hooks are the perfect place to encapsulate business logic in React applications. They keep components clean and focused on rendering while making logic reusable and testable.</p>

                <h3>When to Create a Custom Hook</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Create a Custom Hook When...</h4>
                    <ul>
                        <li>Logic is used in multiple components</li>
                        <li>Component has complex state management</li>
                        <li>You want to test business logic independently</li>
                        <li>Logic involves multiple React hooks</li>
                        <li>You need to share stateful logic between components</li>
                    </ul>
                </div>

                <h3>Hook Patterns and Examples</h3>

                <h4>1. Data Fetching Hooks</h4>

                <pre><code class="language-typescript">// hooks/useUser.ts
export function useUser(userId: string) {
  return useQuery({
    queryKey: ['users', userId],
    queryFn: () => userService.getById(userId),
    staleTime: 1000 * 60 * 5
  });
}

// Usage
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading, error } = useUser(userId);
  
  if (isLoading) return &lt;Spinner /&gt;;
  if (error) return &lt;ErrorMessage error={error} /&gt;;
  
  return &lt;div&gt;{user.name}&lt;/div&gt;;
}</code></pre>

                <h4>2. Form Handling Hooks</h4>

                <pre><code class="language-typescript">// hooks/useForm.ts
interface UseFormOptions&lt;T&gt; {
  initialValues: T;
  onSubmit: (values: T) => void | Promise&lt;void&gt;;
  validate?: (values: T) => Record&lt;string, string&gt;;
}

export function useForm&lt;T extends Record&lt;string, any&gt;&gt;({
  initialValues,
  onSubmit,
  validate
}: UseFormOptions&lt;T&gt;) {
  const [values, setValues] = useState&lt;T&gt;(initialValues);
  const [errors, setErrors] = useState&lt;Record&lt;string, string&gt;&gt;({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const handleChange = (name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
    // Clear error when user starts typing
    if (errors[name as string]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name as string];
        return newErrors;
      });
    }
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    if (validate) {
      const validationErrors = validate(values);
      if (Object.keys(validationErrors).length > 0) {
        setErrors(validationErrors);
        return;
      }
    }
    
    // Submit
    setIsSubmitting(true);
    try {
      await onSubmit(values);
      setValues(initialValues); // Reset form
    } catch (error) {
      setErrors({ submit: error.message });
    } finally {
      setIsSubmitting(false);
    }
  };
  
  const reset = () => {
    setValues(initialValues);
    setErrors({});
  };
  
  return {
    values,
    errors,
    isSubmitting,
    handleChange,
    handleSubmit,
    reset
  };
}

// Usage
function LoginForm() {
  const { values, errors, handleChange, handleSubmit, isSubmitting } = useForm({
    initialValues: { email: '', password: '' },
    onSubmit: async (values) => {
      await authService.login(values);
    },
    validate: (values) => {
      const errors: Record&lt;string, string&gt; = {};
      if (!values.email) errors.email = 'Email is required';
      if (!values.password) errors.password = 'Password is required';
      return errors;
    }
  });
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;Input
        value={values.email}
        onChange={(e) => handleChange('email', e.target.value)}
        error={errors.email}
      /&gt;
      &lt;Button type="submit" loading={isSubmitting}&gt;
        Login
      &lt;/Button&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <h4>3. Business Logic Hooks</h4>

                <pre><code class="language-typescript">// hooks/useShoppingCart.ts
export function useShoppingCart() {
  const [items, setItems] = useState&lt;CartItem[]&gt;([]);
  
  const addItem = useCallback((product: Product, quantity = 1) => {
    setItems(prev => {
      const existing = prev.find(item => item.product.id === product.id);
      
      if (existing) {
        // Update quantity if item exists
        return prev.map(item =>
          item.product.id === product.id
            ? { ...item, quantity: item.quantity + quantity }
            : item
        );
      }
      
      // Add new item
      return [...prev, { product, quantity }];
    });
  }, []);
  
  const removeItem = useCallback((productId: string) => {
    setItems(prev => prev.filter(item => item.product.id !== productId));
  }, []);
  
  const updateQuantity = useCallback((productId: string, quantity: number) => {
    if (quantity <= 0) {
      removeItem(productId);
      return;
    }
    
    setItems(prev =>
      prev.map(item =>
        item.product.id === productId
          ? { ...item, quantity }
          : item
      )
    );
  }, [removeItem]);
  
  const clearCart = useCallback(() => {
    setItems([]);
  }, []);
  
  // Computed values
  const subtotal = useMemo(() => {
    return items.reduce((sum, item) => {
      return sum + (item.product.price * item.quantity);
    }, 0);
  }, [items]);
  
  const tax = useMemo(() => subtotal * 0.08, [subtotal]);
  const total = subtotal + tax;
  const itemCount = items.reduce((sum, item) => sum + item.quantity, 0);
  
  return {
    items,
    itemCount,
    subtotal,
    tax,
    total,
    addItem,
    removeItem,
    updateQuantity,
    clearCart
  };
}</code></pre>

                <h4>4. Utility Hooks</h4>

                <pre><code class="language-typescript">// hooks/useDebounce.ts
export function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
  
  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(handler);
  }, [value, delay]);
  
  return debouncedValue;
}

// hooks/useLocalStorage.ts
export function useLocalStorage&lt;T&gt;(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [storedValue, setValue] as const;
}

// hooks/useMediaQuery.ts
export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(() => {
    return window.matchMedia(query).matches;
  });
  
  useEffect(() => {
    const mediaQuery = window.matchMedia(query);
    
    const handleChange = (e: MediaQueryListEvent) => {
      setMatches(e.matches);
    };
    
    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [query]);
  
  return matches;
}

// Usage
function SearchBar() {
  const [search, setSearch] = useState('');
  const debouncedSearch = useDebounce(search, 500);
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  const isMobile = useMediaQuery('(max-width: 768px)');
  
  // Use debouncedSearch for API calls
  const { data } = useQuery({
    queryKey: ['search', debouncedSearch],
    queryFn: () => searchApi(debouncedSearch),
    enabled: debouncedSearch.length > 0
  });
  
  return (/* ... */);
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Custom Hook Best Practices</h4>
                    <ul>
                        <li><strong>Naming:</strong> Always start with "use" (useCart, useAuth, useDebounce)</li>
                        <li><strong>Single Responsibility:</strong> Each hook should do one thing well</li>
                        <li><strong>Return Object:</strong> Return objects for flexibility, not arrays (unless 2 items max)</li>
                        <li><strong>Memoization:</strong> Use useCallback and useMemo for expensive operations</li>
                        <li><strong>Dependencies:</strong> Always list all dependencies correctly</li>
                        <li><strong>Type Safety:</strong> Use TypeScript generics for reusable hooks</li>
                    </ul>
                </div>

            </section>

            <!-- Section 6: Service Layer Pattern -->
            <section id="section6">
                <h2>ğŸ”Œ Service Layer Pattern</h2>
                
                <p>The service layer is a dedicated abstraction for all external communication. It centralizes API calls, error handling, and data transformation, making your application easier to maintain and test.</p>

                <h3>Why Use a Service Layer?</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Benefit</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Centralization</strong></td>
                            <td>All API logic in one place</td>
                        </tr>
                        <tr>
                            <td><strong>Reusability</strong></td>
                            <td>Same endpoints used across features</td>
                        </tr>
                        <tr>
                            <td><strong>Testability</strong></td>
                            <td>Easy to mock for tests</td>
                        </tr>
                        <tr>
                            <td><strong>Type Safety</strong></td>
                            <td>Typed inputs and outputs</td>
                        </tr>
                        <tr>
                            <td><strong>Error Handling</strong></td>
                            <td>Consistent error handling</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Service Structure</h3>

                <pre><code class="language-typescript">// lib/axios.ts - Configure axios instance
import axios from 'axios';

export const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor - Add auth token
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor - Handle errors
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);</code></pre>

                <h3>Creating Services</h3>

                <pre><code class="language-typescript">// services/userService.ts
import { apiClient } from '@/lib/axios';
import type { User, CreateUserDto, UpdateUserDto } from '@/types';

export const userService = {
  /**
   * Get all users
   */
  async getAll(): Promise&lt;User[]&gt; {
    const response = await apiClient.get&lt;User[]&gt;('/users');
    return response.data;
  },

  /**
   * Get user by ID
   */
  async getById(id: string): Promise&lt;User&gt; {
    const response = await apiClient.get&lt;User&gt;(`/users/${id}`);
    return response.data;
  },

  /**
   * Create new user
   */
  async create(data: CreateUserDto): Promise&lt;User&gt; {
    const response = await apiClient.post&lt;User&gt;('/users', data);
    return response.data;
  },

  /**
   * Update existing user
   */
  async update(id: string, data: UpdateUserDto): Promise&lt;User&gt; {
    const response = await apiClient.patch&lt;User&gt;(`/users/${id}`, data);
    return response.data;
  },

  /**
   * Delete user
   */
  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`/users/${id}`);
  },

  /**
   * Search users by query
   */
  async search(query: string): Promise&lt;User[]&gt; {
    const response = await apiClient.get&lt;User[]&gt;('/users/search', {
      params: { q: query }
    });
    return response.data;
  }
};</code></pre>

                <h3>Advanced Service Patterns</h3>

                <pre><code class="language-typescript">// services/baseService.ts - Generic base service
export class BaseService&lt;T&gt; {
  constructor(private endpoint: string) {}

  async getAll(): Promise&lt;T[]&gt; {
    const response = await apiClient.get&lt;T[]&gt;(this.endpoint);
    return response.data;
  }

  async getById(id: string): Promise&lt;T&gt; {
    const response = await apiClient.get&lt;T&gt;(`${this.endpoint}/${id}`);
    return response.data;
  }

  async create(data: Partial&lt;T&gt;): Promise&lt;T&gt; {
    const response = await apiClient.post&lt;T&gt;(this.endpoint, data);
    return response.data;
  }

  async update(id: string, data: Partial&lt;T&gt;): Promise&lt;T&gt; {
    const response = await apiClient.patch&lt;T&gt;(`${this.endpoint}/${id}`, data);
    return response.data;
  }

  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`${this.endpoint}/${id}`);
  }
}

// services/userService.ts - Extend base service
class UserService extends BaseService&lt;User&gt; {
  constructor() {
    super('/users');
  }

  // Add user-specific methods
  async getProfile(): Promise&lt;User&gt; {
    const response = await apiClient.get&lt;User&gt;('/users/profile');
    return response.data;
  }

  async updateProfile(data: UpdateProfileDto): Promise&lt;User&gt; {
    const response = await apiClient.patch&lt;User&gt;('/users/profile', data);
    return response.data;
  }

  async changePassword(data: ChangePasswordDto): Promise&lt;void&gt; {
    await apiClient.post('/users/change-password', data);
  }
}

export const userService = new UserService();</code></pre>

                <h3>Service with React Query</h3>

                <pre><code class="language-typescript">// hooks/useUsers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userService } from '@/services/userService';

export const userKeys = {
  all: ['users'] as const,
  lists: () => [...userKeys.all, 'list'] as const,
  list: (filters: string) => [...userKeys.lists(), { filters }] as const,
  details: () => [...userKeys.all, 'detail'] as const,
  detail: (id: string) => [...userKeys.details(), id] as const,
};

export function useUsers() {
  return useQuery({
    queryKey: userKeys.lists(),
    queryFn: userService.getAll
  });
}

export function useUser(id: string) {
  return useQuery({
    queryKey: userKeys.detail(id),
    queryFn: () => userService.getById(id)
  });
}

export function useCreateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: userService.create,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    }
  });
}

export function useUpdateUser() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateUserDto }) =>
      userService.update(id, data),
    onSuccess: (_, variables) => {
      queryClient.invalidateQueries({ queryKey: userKeys.detail(variables.id) });
      queryClient.invalidateQueries({ queryKey: userKeys.lists() });
    }
  });
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>âš ï¸ Service Layer Anti-Patterns</h4>
                    <ul>
                        <li><strong>Business Logic in Services:</strong> Services should only handle data access, not business rules</li>
                        <li><strong>Direct State Updates:</strong> Services shouldn't update React state directly</li>
                        <li><strong>Component Dependencies:</strong> Services shouldn't import components or hooks</li>
                        <li><strong>Mixed Responsibilities:</strong> Keep services focused on API communication</li>
                    </ul>
                </div>

            </section>

            <!-- Section 7: Type Organization -->
            <section id="section7">
                <h2>ğŸ“ Type Organization</h2>
                
                <p>Proper TypeScript type organization makes your codebase more maintainable and helps developers understand data structures quickly.</p>

                <h3>Type Organization Strategies</h3>

                <h4>1. Feature-Based Types</h4>

                <pre><code class="language-typescript">// features/users/types/user.types.ts
export interface User {
  id: string;
  email: string;
  name: string;
  avatar?: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserDto {
  email: string;
  name: string;
  password: string;
}

export interface UpdateUserDto {
  name?: string;
  avatar?: string;
}

export interface UserFilters {
  search?: string;
  role?: UserRole;
  status?: UserStatus;
}

export type UserRole = 'admin' | 'user' | 'moderator';
export type UserStatus = 'active' | 'inactive' | 'suspended';</code></pre>

                <h4>2. Shared/Common Types</h4>

                <pre><code class="language-typescript">// shared/types/common.types.ts
export interface ApiResponse&lt;T&gt; {
  data: T;
  message?: string;
  success: boolean;
}

export interface PaginatedResponse&lt;T&gt; {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

export interface ApiError {
  message: string;
  code: string;
  statusCode: number;
  details?: Record&lt;string, any&gt;;
}

export type Nullable&lt;T&gt; = T | null;
export type Optional&lt;T&gt; = T | undefined;
export type ID = string | number;</code></pre>

                <h4>3. Utility Types</h4>

                <pre><code class="language-typescript">// shared/types/utils.types.ts

// Make all properties optional recursively
export type DeepPartial&lt;T&gt; = {
  [P in keyof T]?: T[P] extends object ? DeepPartial&lt;T[P]&gt; : T[P];
};

// Make all properties required recursively
export type DeepRequired&lt;T&gt; = {
  [P in keyof T]-?: T[P] extends object ? DeepRequired&lt;T[P]&gt; : T[P];
};

// Extract keys of type
export type KeysOfType&lt;T, U&gt; = {
  [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];

// Async function return type
export type AsyncReturnType&lt;T extends (...args: any) => Promise&lt;any&gt;&gt; =
  T extends (...args: any) => Promise&lt;infer R&gt; ? R : any;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Type Organization Best Practices</h4>
                    <ul>
                        <li><strong>Naming:</strong> Use descriptive names (UserDto, not UD)</li>
                        <li><strong>DTOs:</strong> Create separate types for API requests/responses</li>
                        <li><strong>Consistency:</strong> Use same naming patterns across types</li>
                        <li><strong>Documentation:</strong> Add JSDoc comments for complex types</li>
                        <li><strong>Exports:</strong> Export through index.ts files</li>
                        <li><strong>Avoid Any:</strong> Never use 'any', use 'unknown' instead</li>
                    </ul>
                </div>

            </section>

            <!-- Section 8: Error Handling Architecture -->
            <section id="section8">
                <h2>ğŸš¨ Error Handling Architecture</h2>
                
                <p>Consistent, well-architected error handling improves user experience and makes debugging easier. A good error handling strategy catches errors at the right level and provides meaningful feedback.</p>

                <h3>Error Handling Layers</h3>

                <div class="mermaid">
graph TB
    A[API Layer] --> B[Service Layer]
    B --> C[Hook Layer]
    C --> D[Component Layer]
    
    A --> E[Axios Interceptor]
    B --> F[Custom Error Classes]
    C --> G[React Query onError]
    D --> H[Error Boundaries]
    D --> I[Toast Notifications]
    
    style A fill:#ffcdd2
    style B fill:#fff3cd
    style C fill:#e3f2fd
    style D fill:#c8e6c9
</div>

                <h3>1. Custom Error Classes</h3>

                <pre><code class="language-typescript">// shared/errors/AppError.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
  }
}

export class ValidationError extends AppError {
  constructor(message: string, details?: Record&lt;string, string&gt;) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'Insufficient permissions') {
    super(message, 'AUTHORIZATION_ERROR', 403);
    this.name = 'AuthorizationError';
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 'NOT_FOUND', 404);
    this.name = 'NotFoundError';
  }
}</code></pre>

                <h3>2. Error Handling in Services</h3>

                <pre><code class="language-typescript">// lib/axios.ts
import { AppError, ValidationError, AuthenticationError } from '@/shared/errors';

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (axios.isAxiosError(error)) {
      const status = error.response?.status;
      const data = error.response?.data;

      switch (status) {
        case 400:
          throw new ValidationError(
            data?.message || 'Validation failed',
            data?.errors
          );
        case 401:
          throw new AuthenticationError(data?.message);
        case 403:
          throw new AuthorizationError(data?.message);
        case 404:
          throw new NotFoundError(data?.resource || 'Resource');
        default:
          throw new AppError(
            data?.message || 'An error occurred',
            'UNKNOWN_ERROR',
            status || 500,
            data
          );
      }
    }

    throw error;
  }
);</code></pre>

                <h3>3. Error Boundaries</h3>

                <pre><code class="language-typescript">// shared/components/ErrorBoundary.tsx
interface ErrorBoundaryProps {
  children: React.ReactNode;
  fallback?: React.ComponentType&lt;{ error: Error; reset: () => void }&gt;;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends React.Component&lt;
  ErrorBoundaryProps,
  ErrorBoundaryState
&gt; {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // Log to error reporting service
    // errorReportingService.log(error, errorInfo);
  }

  reset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError) {
      const FallbackComponent = this.props.fallback || DefaultErrorFallback;
      return &lt;FallbackComponent error={this.state.error!} reset={this.reset} /&gt;;
    }

    return this.props.children;
  }
}

// Default error fallback
function DefaultErrorFallback({ error, reset }: { error: Error; reset: () => void }) {
  return (
    &lt;div className="error-fallback"&gt;
      &lt;h2&gt;Something went wrong&lt;/h2&gt;
      &lt;p&gt;{error.message}&lt;/p&gt;
      &lt;button onClick={reset}&gt;Try again&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>4. Error Handling in Components</h3>

                <pre><code class="language-typescript">// Component with error handling
function UserProfile({ userId }: { userId: string }) {
  const { data, error, isLoading } = useUser(userId);
  const updateMutation = useUpdateUser();

  const handleUpdate = async (data: UpdateUserDto) => {
    try {
      await updateMutation.mutateAsync({ id: userId, data });
      toast.success('Profile updated successfully!');
    } catch (error) {
      if (error instanceof ValidationError) {
        // Show field-specific errors
        Object.entries(error.details || {}).forEach(([field, message]) => {
          toast.error(`${field}: ${message}`);
        });
      } else if (error instanceof AppError) {
        toast.error(error.message);
      } else {
        toast.error('An unexpected error occurred');
      }
    }
  };

  if (isLoading) return &lt;Spinner /&gt;;
  
  if (error) {
    if (error instanceof NotFoundError) {
      return &lt;NotFound message="User not found" /&gt;;
    }
    if (error instanceof AuthorizationError) {
      return &lt;Unauthorized /&gt;;
    }
    return &lt;ErrorMessage error={error} /&gt;;
  }

  return &lt;UserForm user={data} onSubmit={handleUpdate} /&gt;;
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’¡ Error Handling Best Practices</h4>
                    <ul>
                        <li><strong>Fail Fast:</strong> Catch errors as early as possible</li>
                        <li><strong>Be Specific:</strong> Use custom error classes for different scenarios</li>
                        <li><strong>User-Friendly:</strong> Show helpful messages, not technical jargon</li>
                        <li><strong>Logging:</strong> Log errors to a service for debugging</li>
                        <li><strong>Recovery:</strong> Provide ways to recover (retry button, reset)</li>
                        <li><strong>Boundaries:</strong> Use Error Boundaries for unexpected errors</li>
                    </ul>
                </div>

            </section>
            <!-- Hands-On Exercises -->
            <section id="exercises">
                <h2>ğŸ‹ï¸ Hands-On Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Refactor a Monolithic Component</h3>
                    <p><strong>Goal:</strong> Take a component that's doing too much and refactor it using proper architectural patterns.</p>
                    
                    <p><strong>Starting Point:</strong></p>
                    <pre><code class="language-typescript">// âŒ This component has multiple problems
function ProductDashboard() {
  const [products, setProducts] = useState([]);
  const [loading, setLoading] = useState(true);
  const [cart, setCart] = useState([]);
  const [search, setSearch] = useState('');
  
  useEffect(() => {
    fetch('/api/products')
      .then(res => res.json())
      .then(data => {
        setProducts(data);
        setLoading(false);
      });
  }, []);
  
  const addToCart = (product) => {
    const tax = product.price * 0.08;
    const total = product.price + tax;
    setCart([...cart, { ...product, tax, total }]);
    
    fetch('/api/cart', {
      method: 'POST',
      body: JSON.stringify({ productId: product.id })
    });
  };
  
  const filteredProducts = products.filter(p => 
    p.name.toLowerCase().includes(search.toLowerCase())
  );
  
  return (
    &lt;div&gt;
      &lt;input 
        value={search} 
        onChange={(e) => setSearch(e.target.value)} 
      /&gt;
      {loading ? 'Loading...' : (
        filteredProducts.map(product => (
          &lt;div key={product.id}&gt;
            &lt;h3&gt;{product.name}&lt;/h3&gt;
            &lt;p&gt;${product.price}&lt;/p&gt;
            &lt;button onClick={() => addToCart(product)}&gt;
              Add to Cart
            &lt;/button&gt;
          &lt;/div&gt;
        ))
      )}
    &lt;/div&gt;
  );
}</code></pre>

                    <p><strong>Your Task:</strong></p>
                    <ol>
                        <li>Create a service layer for API calls (<code>productService.ts</code>, <code>cartService.ts</code>)</li>
                        <li>Extract business logic into custom hooks (<code>useProducts</code>, <code>useCart</code>)</li>
                        <li>Break into smaller components (<code>ProductList</code>, <code>ProductCard</code>, <code>SearchBar</code>)</li>
                        <li>Add proper TypeScript types</li>
                        <li>Implement error handling</li>
                        <li>Use React Query for data fetching</li>
                    </ol>

                    <details>
                        <summary>ğŸ’¡ Hint #1: Architecture Structure</summary>
                        <pre><code class="language-typescript">// Structure to aim for:
// services/productService.ts
// services/cartService.ts
// hooks/useProducts.ts
// hooks/useCart.ts
// components/ProductDashboard.tsx (orchestrator)
// components/ProductList.tsx (presentational)
// components/ProductCard.tsx (presentational)
// components/SearchBar.tsx (presentational)</code></pre>
                    </details>

                    <details>
                        <summary>ğŸ’¡ Hint #2: Service Layer</summary>
                        <pre><code class="language-typescript">// services/productService.ts
export const productService = {
  async getAll(): Promise&lt;Product[]&gt; {
    const response = await apiClient.get('/api/products');
    return response.data;
  }
};

// services/cartService.ts
export const cartService = {
  async addItem(productId: string): Promise&lt;CartItem&gt; {
    const response = await apiClient.post('/api/cart', { productId });
    return response.data;
  }
};</code></pre>
                    </details>

                    <details>
                        <summary>âœ… Solution Outline</summary>
                        <p>Your refactored solution should have:</p>
                        <ul>
                            <li><strong>Services:</strong> Clean API abstractions</li>
                            <li><strong>Hooks:</strong> useProducts (with React Query), useCart (with business logic)</li>
                            <li><strong>Components:</strong> ProductDashboard (orchestrator), ProductList (receives data), ProductCard (pure UI), SearchBar (controlled input)</li>
                            <li><strong>Types:</strong> Product, CartItem, AddToCartDto interfaces</li>
                            <li><strong>Error Handling:</strong> Try-catch in handlers, Error Boundary around dashboard</li>
                        </ul>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Design a Feature Module</h3>
                    <p><strong>Goal:</strong> Create a complete feature module following best practices for folder structure and organization.</p>
                    
                    <p><strong>Scenario:</strong> You're building a "Comments" feature for a blog application. Users should be able to:</p>
                    <ul>
                        <li>View comments on a post</li>
                        <li>Add new comments</li>
                        <li>Edit their own comments</li>
                        <li>Delete their own comments</li>
                        <li>Reply to comments (nested)</li>
                    </ul>

                    <p><strong>Your Task:</strong></p>
                    <ol>
                        <li>Design the folder structure for <code>features/comments/</code></li>
                        <li>Define TypeScript types and interfaces</li>
                        <li>Create the service layer</li>
                        <li>Design custom hooks</li>
                        <li>Plan component hierarchy</li>
                        <li>Create the public API (index.ts)</li>
                    </ol>

                    <details>
                        <summary>ğŸ’¡ Hint: Folder Structure</summary>
                        <pre><code class="language-bash">features/comments/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ CommentList/
â”‚   â”‚   â”œâ”€â”€ CommentList.tsx
â”‚   â”‚   â”œâ”€â”€ CommentList.test.tsx
â”‚   â”‚   â””â”€â”€ CommentList.module.css
â”‚   â”œâ”€â”€ CommentItem/
â”‚   â”œâ”€â”€ CommentForm/
â”‚   â””â”€â”€ CommentReply/
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ useComments.ts
â”‚   â”œâ”€â”€ useAddComment.ts
â”‚   â”œâ”€â”€ useUpdateComment.ts
â”‚   â””â”€â”€ useDeleteComment.ts
â”œâ”€â”€ api/
â”‚   â””â”€â”€ commentService.ts
â”œâ”€â”€ types/
â”‚   â””â”€â”€ comment.types.ts
â”œâ”€â”€ utils/
â”‚   â””â”€â”€ commentHelpers.ts
â””â”€â”€ index.ts</code></pre>
                    </details>

                    <details>
                        <summary>âœ… Solution Checklist</summary>
                        <ul>
                            <li>âœ… Types defined (Comment, CreateCommentDto, UpdateCommentDto)</li>
                            <li>âœ… Service with all CRUD operations</li>
                            <li>âœ… Custom hooks using React Query</li>
                            <li>âœ… Component hierarchy planned (List > Item > Form/Reply)</li>
                            <li>âœ… Error handling strategy defined</li>
                            <li>âœ… Public API exports only what's needed</li>
                            <li>âœ… Optimistic updates for better UX</li>
                        </ul>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Implement Error Handling Strategy</h3>
                    <p><strong>Goal:</strong> Add comprehensive error handling to an existing feature.</p>
                    
                    <p><strong>Scenario:</strong> You have a user authentication feature that currently has no error handling. Add proper error handling at all layers.</p>

                    <p><strong>Requirements:</strong></p>
                    <ol>
                        <li>Create custom error classes (AuthError, ValidationError, NetworkError)</li>
                        <li>Add error interceptor to axios</li>
                        <li>Implement Error Boundary for the auth pages</li>
                        <li>Add try-catch blocks in components</li>
                        <li>Show user-friendly error messages</li>
                        <li>Log errors to console (simulate error tracking service)</li>
                    </ol>

                    <details>
                        <summary>ğŸ’¡ Hint: Error Class Hierarchy</summary>
                        <pre><code class="language-typescript">class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number
  ) {
    super(message);
  }
}

class AuthError extends AppError {
  constructor(message: string) {
    super(message, 'AUTH_ERROR', 401);
  }
}

// Handle in component:
try {
  await login(credentials);
} catch (error) {
  if (error instanceof AuthError) {
    setError('Invalid email or password');
  } else if (error instanceof NetworkError) {
    setError('Connection failed. Please try again.');
  } else {
    setError('An unexpected error occurred');
  }
}</code></pre>
                    </details>
                </div>
            </section>

            <!-- Quiz Section -->
            <section id="quiz">
                <h2>ğŸ§  Knowledge Check Quiz</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 1: Separation of Concerns</h3>
                    <p>What are the three main layers in a well-architected React application, and what is each responsible for?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>Presentation Layer (Components):</strong> Handles rendering UI and user interactions. Components should be focused on display logic only, not business rules or data fetching.</li>
                                <li><strong>Business Logic Layer (Custom Hooks):</strong> Contains application logic, calculations, validations, and state management. This is where you implement business rules and domain logic.</li>
                                <li><strong>Data Access Layer (Services):</strong> Handles all external communication like API calls, localStorage, or other data sources. Services provide a clean abstraction for data operations.</li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 2: Component Types</h3>
                    <p>What's the difference between Container Components and Presentational Components? When should you use each?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <p><strong>Container Components (Smart Components):</strong></p>
                            <ul>
                                <li>Manage state and side effects</li>
                                <li>Connect to data sources (hooks, context, stores)</li>
                                <li>Contain business logic</li>
                                <li>Pass data down to presentational components</li>
                                <li><strong>Use when:</strong> You need to fetch data, manage state, or implement business logic</li>
                            </ul>
                            <p><strong>Presentational Components (Dumb Components):</strong></p>
                            <ul>
                                <li>Receive data only through props</li>
                                <li>Focus purely on UI rendering</li>
                                <li>No state or side effects</li>
                                <li>Highly reusable and testable</li>
                                <li><strong>Use when:</strong> You need a reusable UI component that just displays data</li>
                            </ul>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 3: Folder Structure</h3>
                    <p>Why is a feature-based folder structure better than organizing by file type (components/, hooks/, services/)? Give at least three reasons.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>Scalability:</strong> As the app grows, feature folders don't become cluttered. Each feature is self-contained.</li>
                                <li><strong>Maintainability:</strong> All related code lives together, making it easier to understand and modify a feature.</li>
                                <li><strong>Team Collaboration:</strong> Different teams can work on different features without conflicts.</li>
                                <li><strong>Code Ownership:</strong> Clear boundaries make it obvious who owns what code.</li>
                                <li><strong>Easier Refactoring:</strong> Features can be moved, removed, or extracted as complete units.</li>
                                <li><strong>Better Imports:</strong> Features export a public API through index.ts, hiding implementation details.</li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 4: Service Layer</h3>
                    <p>What should go in a service layer, and what should NOT go there?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Should go in services:</strong></p>
                            <ul>
                                <li>API calls (GET, POST, PUT, DELETE)</li>
                                <li>Request/response transformation (if needed)</li>
                                <li>HTTP configuration (headers, auth tokens)</li>
                                <li>Basic error throwing</li>
                            </ul>
                            <p><strong>Should NOT go in services:</strong></p>
                            <ul>
                                <li>Business logic (calculations, validations)</li>
                                <li>React state updates</li>
                                <li>Component dependencies</li>
                                <li>UI logic or rendering</li>
                                <li>Direct access to React hooks</li>
                            </ul>
                            <p><strong>Principle:</strong> Services should be pure data access - they communicate with external systems and return/send data, nothing more.</p>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 5: Custom Hooks</h3>
                    <p>When should you create a custom hook? Give an example of logic that belongs in a custom hook vs logic that should stay in a component.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Create a custom hook when:</strong></p>
                            <ul>
                                <li>Logic is used in multiple components</li>
                                <li>Logic involves multiple React hooks</li>
                                <li>Logic contains business rules</li>
                                <li>You want to test logic independently</li>
                                <li>Logic manages complex state</li>
                            </ul>
                            <p><strong>Example - Belongs in Custom Hook:</strong></p>
                            <pre><code>// useShoppingCart.ts
- Calculate cart totals
- Add/remove items logic
- Cart state management
- Business rules (max items, etc.)</code></pre>
                            <p><strong>Example - Stay in Component:</strong></p>
                            <pre><code>// Component
- Button click handlers that just call hooks
- Simple UI state (modal open/closed)
- Navigation after actions
- Direct prop transformations for rendering</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 6: Error Handling</h3>
                    <p>What are the different layers where you should handle errors in a React application? What type of errors should be handled at each layer?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Answer:</strong></p>
                            <ol>
                                <li><strong>API Layer (Axios Interceptors):</strong>
                                    <ul>
                                        <li>HTTP status code errors</li>
                                        <li>Network errors</li>
                                        <li>Transform to custom error classes</li>
                                        <li>Handle auth token refresh</li>
                                    </ul>
                                </li>
                                <li><strong>Service Layer:</strong>
                                    <ul>
                                        <li>Throw custom errors</li>
                                        <li>Add context to errors</li>
                                        <li>No catching (let them bubble up)</li>
                                    </ul>
                                </li>
                                <li><strong>Hook Layer:</strong>
                                    <ul>
                                        <li>React Query onError callbacks</li>
                                        <li>Error state management</li>
                                        <li>Some errors may be caught here</li>
                                    </ul>
                                </li>
                                <li><strong>Component Layer:</strong>
                                    <ul>
                                        <li>Show error UI to users</li>
                                        <li>Try-catch for async actions</li>
                                        <li>User-friendly error messages</li>
                                        <li>Error Boundaries for unexpected errors</li>
                                    </ul>
                                </li>
                            </ol>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 7: Type Organization</h3>
                    <p>Where should you put type definitions in a feature-based architecture? Give examples of feature-specific vs shared types.</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Type Locations:</strong></p>
                            <ul>
                                <li><strong>Feature-specific types:</strong> <code>features/{feature}/types/</code></li>
                                <li><strong>Shared types:</strong> <code>shared/types/</code></li>
                            </ul>
                            <p><strong>Feature-Specific Types (features/users/types/):</strong></p>
                            <pre><code>- User
- CreateUserDto
- UpdateUserDto
- UserFilters
- UserRole (enum)</code></pre>
                            <p><strong>Shared Types (shared/types/):</strong></p>
                            <pre><code>- ApiResponse&lt;T&gt;
- PaginatedResponse&lt;T&gt;
- ApiError
- ID (type alias)
- Nullable&lt;T&gt;
- Common utility types</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Question 8: Architecture Principles</h3>
                    <p>Explain the SOLID principle that's most important in React: Single Responsibility Principle. How does it apply to React components?</p>
                    
                    <details>
                        <summary>Show Answer</summary>
                        <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50; margin-top: 1rem;">
                            <p><strong>Single Responsibility Principle:</strong></p>
                            <p>Each component, function, or module should have one reason to change - one well-defined responsibility.</p>
                            
                            <p><strong>In React Components:</strong></p>
                            <ul>
                                <li>A component should do ONE thing (display user data, OR fetch it, OR validate it - not all three)</li>
                                <li>If you can't describe what a component does in one sentence, it's doing too much</li>
                                <li>Changes to business logic shouldn't require changes to UI components</li>
                                <li>Changes to API structure shouldn't require changes to components</li>
                            </ul>
                            
                            <p><strong>Example:</strong></p>
                            <ul>
                                <li>âŒ BAD: <code>UserProfile</code> fetches data, validates form, handles submission, and renders UI</li>
                                <li>âœ… GOOD: <code>UserProfile</code> just orchestrates. Data fetching is in <code>useUser</code> hook, form logic in <code>useForm</code>, validation in <code>validators</code>, and UI in presentational components</li>
                            </ul>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2>ğŸ“ Lesson Summary</h2>
                
                <div class="card">
                    <h3>ğŸ‰ Congratulations on Completing Lesson 8.5!</h3>
                    <p>You've just completed the final lesson of Module 8! You now have a comprehensive understanding of React architecture patterns that will serve you throughout your career as a professional React developer.</p>
                    
                    <h3>What You've Learned</h3>
                    <ul>
                        <li>âœ… <strong>Architecture Principles:</strong> Separation of Concerns, DRY, KISS, Single Responsibility, and Composition Over Inheritance</li>
                        <li>âœ… <strong>Feature-Based Structure:</strong> How to organize large codebases by feature instead of file type</li>
                        <li>âœ… <strong>Component Organization:</strong> Page, Layout, Container, Presentational, and Shared component patterns</li>
                        <li>âœ… <strong>Separation of Concerns:</strong> Dividing code into Presentation, Business Logic, and Data Access layers</li>
                        <li>âœ… <strong>Custom Hooks:</strong> Extracting business logic into reusable, testable hooks</li>
                        <li>âœ… <strong>Service Layer:</strong> Creating a clean abstraction for API communication</li>
                        <li>âœ… <strong>Type Organization:</strong> Structuring TypeScript types for maintainability</li>
                        <li>âœ… <strong>Error Handling:</strong> Implementing comprehensive error handling at every layer</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">ğŸ¯ Key Architectural Takeaways</h3>
                    <ol style="color: white;">
                        <li><strong>Components should be simple:</strong> If a component is hard to understand or test, it's doing too much. Break it down.</li>
                        <li><strong>Business logic belongs in hooks:</strong> Not in components, not in services - custom hooks are the perfect place.</li>
                        <li><strong>Services only handle data access:</strong> No business logic, no state management - just API calls.</li>
                        <li><strong>Feature-based structure scales:</strong> Organize by feature, not by file type, especially as your app grows.</li>
                        <li><strong>Types should be close to usage:</strong> Feature-specific types in feature folders, shared types in shared folder.</li>
                        <li><strong>Error handling is multi-layered:</strong> Handle errors at the appropriate level - API, service, hook, or component.</li>
                        <li><strong>Test your architecture:</strong> If something is hard to test, it needs better separation of concerns.</li>
                        <li><strong>Start simple, refactor as needed:</strong> Don't over-engineer early. The "Rule of Three" applies - abstract when you need it the third time.</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>ğŸ† Module 8 Complete!</h3>
                    <p>You've now completed all five lessons in <strong>Module 8: State Management and Architecture</strong>:</p>
                    <ul>
                        <li>âœ… Lesson 8.1: State Management Overview</li>
                        <li>âœ… Lesson 8.2: Zustand Basics</li>
                        <li>âœ… Lesson 8.3: Redux Toolkit</li>
                        <li>âœ… Lesson 8.4: React Query (TanStack Query)</li>
                        <li>âœ… Lesson 8.5: Architecture Best Practices</li>
                    </ul>
                    <p><strong>You've learned how to build production-ready, scalable React applications!</strong></p>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>ğŸš€ What's Next?</h3>
                    <p>You're ready to apply everything you've learned in Module 8!</p>
                    
                    <h4>Immediate Next Step:</h4>
                    <p><strong>Module 8 Project: Social Media Feed</strong></p>
                    <p>Build a complete social media feed application that demonstrates:</p>
                    <ul>
                        <li>Feature-based folder structure</li>
                        <li>React Query for data fetching</li>
                        <li>Zustand or Redux Toolkit for client state</li>
                        <li>Proper component organization</li>
                        <li>Custom hooks for business logic</li>
                        <li>Service layer for API calls</li>
                        <li>Comprehensive error handling</li>
                        <li>TypeScript throughout</li>
                    </ul>

                    <h4>Coming Up Next: Module 9 - Testing React Applications</h4>
                    <p>After completing your Module 8 project, you'll learn:</p>
                    <ul>
                        <li>Testing fundamentals and the testing pyramid</li>
                        <li>React Testing Library</li>
                        <li>Testing user interactions and async code</li>
                        <li>Integration and E2E testing</li>
                        <li>Testing best practices</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h3>ğŸ’¡ Applying What You've Learned</h3>
                    <p><strong>In Your Next Project:</strong></p>
                    <ol>
                        <li><strong>Start with structure:</strong> Set up feature folders before writing code</li>
                        <li><strong>Identify layers:</strong> Decide what goes in services, hooks, and components</li>
                        <li><strong>Type everything:</strong> Define TypeScript interfaces before implementing</li>
                        <li><strong>Separate concerns:</strong> Keep components focused on UI</li>
                        <li><strong>Plan error handling:</strong> Set up error classes and boundaries early</li>
                        <li><strong>Refactor regularly:</strong> As patterns emerge, extract and organize</li>
                    </ol>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>ğŸ“š Additional Resources</h3>
                    <ul>
                        <li><a href="https://react.dev/learn/thinking-in-react" target="_blank">Thinking in React - Official React Docs</a></li>
                        <li><a href="https://kentcdodds.com/blog/application-state-management-with-react" target="_blank">Application State Management with React - Kent C. Dodds</a></li>
                        <li><a href="https://www.patterns.dev/" target="_blank">Patterns.dev - React Design Patterns</a></li>
                        <li><a href="https://github.com/alan2207/bulletproof-react" target="_blank">Bulletproof React - Scalable Architecture Guide</a></li>
                        <li><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank">The Practical Test Pyramid - Martin Fowler</a></li>
                    </ul>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson navigation">
                <a href="lesson_8_4_react_query_b.html" class="nav-button prev-lesson">
                    <span class="arrow">â†</span>
                    <span class="label">Previous</span>
                    <span class="title">Lesson 8.4: React Query (Part B)</span>
                </a>
                <a href="index.html" class="nav-button home">
                    <span class="label">Course Home</span>
                </a>
                <a href="module_project_8_social_media_feed.html" class="nav-button next-lesson">
                    <span class="label">Next</span>
                    <span class="title">Module 8 Project: Social Media Feed</span>
                    <span class="arrow">â†’</span>
                </a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="mailto:support@example.com">Contact</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
