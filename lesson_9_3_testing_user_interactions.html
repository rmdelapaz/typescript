<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master advanced user interaction testing in React. Learn to test complex forms, custom hooks, event handlers, keyboard interactions, and real-world user workflows with React Testing Library.">
    <meta name="author" content="Ray">
    <title>Lesson 9.3: Testing User Interactions - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#modules">Module 9: Testing React Applications</a></li>
            <li aria-current="page">Lesson 9.3: Testing User Interactions</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>üéÆ Lesson 9.3: Testing User Interactions</h1>
                <p class="lead">Take your testing skills to the next level by mastering complex user interaction testing. Learn to test forms with validation, custom hooks, keyboard navigation, drag-and-drop, and complete user workflows in React applications.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Test complex forms with multi-field validation and dynamic fields</li>
                        <li>Test custom hooks in isolation and within components</li>
                        <li>Handle keyboard interactions and accessibility testing</li>
                        <li>Test file uploads and drag-and-drop functionality</li>
                        <li>Create custom render functions with providers and context</li>
                        <li>Test complete user workflows and multi-step processes</li>
                        <li>Mock external dependencies and API calls effectively</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Project:</strong> Test a complete multi-step form with file upload</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#introduction" class="toc-link">Introduction to Advanced Testing</a></li>
                        <li><a href="#form-testing" class="toc-link">Testing Complex Forms</a></li>
                        <li><a href="#custom-hooks" class="toc-link">Testing Custom Hooks</a></li>
                        <li><a href="#keyboard-interactions" class="toc-link">Keyboard and Accessibility Testing</a></li>
                        <li><a href="#file-uploads" class="toc-link">Testing File Uploads</a></li>
                        <li><a href="#custom-render" class="toc-link">Custom Render Functions</a></li>
                        <li><a href="#mocking" class="toc-link">Mocking Dependencies</a></li>
                        <li><a href="#workflows" class="toc-link">Testing Complete Workflows</a></li>
                        <li><a href="#exercises" class="toc-link">Hands-on Exercises</a></li>
                        <li><a href="#best-practices" class="toc-link">Best Practices</a></li>
                        <li><a href="#summary" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Introduction -->
            <section id="introduction" class="lesson-section">
                <h2>üìñ Introduction to Advanced Testing</h2>
                
                <p>In the previous lessons, you learned the fundamentals of testing React components. Now it's time to level up and tackle more complex, real-world testing scenarios that you'll encounter in production applications.</p>

                <p>Real applications involve:</p>
                <ul>
                    <li><strong>Complex forms:</strong> Multi-step wizards, dynamic fields, file uploads, and intricate validation</li>
                    <li><strong>Custom hooks:</strong> Reusable logic that needs isolated testing</li>
                    <li><strong>User workflows:</strong> Complete journeys through your application</li>
                    <li><strong>External dependencies:</strong> APIs, authentication, third-party services</li>
                    <li><strong>Accessibility:</strong> Keyboard navigation, screen readers, focus management</li>
                </ul>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ What Makes Interactions "Advanced"?</h4>
                    <p style="color: white;"><strong>Advanced interactions</strong> involve multiple steps, state changes, side effects, and dependencies. They require sophisticated testing techniques including mocking, custom render functions, and careful attention to async behavior and user flows.</p>
                </div>

                <h3>The Testing Mindset for Complex Interactions</h3>
                <p>When testing complex interactions, think like a real user:</p>

                <div class="mermaid">
                    graph TD
                    A[User Opens App] --> B[Sees Form]
                    B --> C[Fills Fields]
                    C --> D[Sees Validation Errors]
                    D --> E[Corrects Errors]
                    E --> F[Uploads File]
                    F --> G[Submits Form]
                    G --> H[Sees Loading State]
                    H --> I[Sees Success Message]
                    
                    style A fill:#667eea,stroke:#333,stroke-width:2px,color:#fff
                    style I fill:#51cf66,stroke:#2f9e44,stroke-width:2px,color:#fff
                </div>

                <p>Your tests should mirror this flow‚Äîeach step building on the previous one, just like a user would experience it.</p>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Key Principles for Advanced Testing</h4>
                    <ol>
                        <li><strong>Test complete flows, not isolated actions:</strong> Users don't just click‚Äîthey complete tasks</li>
                        <li><strong>Include error paths:</strong> Test what happens when things go wrong</li>
                        <li><strong>Test accessibility:</strong> Ensure keyboard users can complete the same tasks</li>
                        <li><strong>Keep tests maintainable:</strong> Use helpers and abstractions for complex setups</li>
                        <li><strong>Mock strategically:</strong> Mock external dependencies, not your own code</li>
                    </ol>
                </div>

                <h3>What We'll Build</h3>
                <p>Throughout this lesson, we'll test a multi-step registration form with:</p>
                <ul>
                    <li>Personal information (name, email, password)</li>
                    <li>Real-time validation with error messages</li>
                    <li>Address autocomplete</li>
                    <li>Profile picture upload with preview</li>
                    <li>Review step before submission</li>
                    <li>Success/error handling</li>
                </ul>

                <p>This mirrors the complexity you'll find in real-world applications!</p>

                <blockquote>
                    <strong>üí¨ Testing Philosophy:</strong> "If a user can do it, you should test it. If a user shouldn't be able to do it, you should test that they can't."
                </blockquote>
            </section>

            <!-- Section 2: Testing Complex Forms -->
            <section id="form-testing" class="lesson-section">
                <h2>üìù Testing Complex Forms</h2>
                
                <p>Forms are the backbone of interactive web applications. Let's master testing them thoroughly, from simple inputs to complex multi-step wizards.</p>

                <h3>Form with Real-Time Validation</h3>
                <p>Here's a registration form with validation that updates as users type:</p>

                <pre><code class="language-typescript">
interface RegistrationFormProps {
  onSubmit: (data: FormData) => Promise&lt;void&gt;;
}

interface FormData {
  email: string;
  password: string;
  confirmPassword: string;
}

export function RegistrationForm({ onSubmit }: RegistrationFormProps) {
  const [formData, setFormData] = React.useState&lt;FormData&gt;({
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  const [errors, setErrors] = React.useState&lt;Partial&lt;FormData&gt;&gt;({});
  const [touched, setTouched] = React.useState&lt;Partial&lt;Record&lt;keyof FormData, boolean&gt;&gt;&gt;({});
  const [isSubmitting, setIsSubmitting] = React.useState(false);
  
  const validateField = (name: keyof FormData, value: string) => {
    switch (name) {
      case 'email':
        if (!value) return 'Email is required';
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
          return 'Invalid email format';
        }
        return '';
      
      case 'password':
        if (!value) return 'Password is required';
        if (value.length < 8) return 'Password must be at least 8 characters';
        if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/.test(value)) {
          return 'Password must contain uppercase, lowercase, and number';
        }
        return '';
      
      case 'confirmPassword':
        if (!value) return 'Please confirm your password';
        if (value !== formData.password) return 'Passwords do not match';
        return '';
      
      default:
        return '';
    }
  };
  
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
    
    // Validate on change if field has been touched
    if (touched[name as keyof FormData]) {
      const error = validateField(name as keyof FormData, value);
      setErrors(prev => ({ ...prev, [name]: error }));
    }
  };
  
  const handleBlur = (e: React.FocusEvent&lt;HTMLInputElement&gt;) => {
    const { name, value } = e.target;
    setTouched(prev => ({ ...prev, [name]: true }));
    
    const error = validateField(name as keyof FormData, value);
    setErrors(prev => ({ ...prev, [name]: error }));
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate all fields
    const newErrors: Partial&lt;FormData&gt; = {};
    Object.keys(formData).forEach(key => {
      const error = validateField(key as keyof FormData, formData[key as keyof FormData]);
      if (error) newErrors[key as keyof FormData] = error;
    });
    
    setErrors(newErrors);
    
    if (Object.keys(newErrors).length === 0) {
      setIsSubmitting(true);
      try {
        await onSubmit(formData);
      } finally {
        setIsSubmitting(false);
      }
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;div&gt;
        &lt;label htmlFor="email"&gt;Email&lt;/label&gt;
        &lt;input
          id="email"
          name="email"
          type="email"
          value={formData.email}
          onChange={handleChange}
          onBlur={handleBlur}
          aria-invalid={!!errors.email}
          aria-describedby={errors.email ? 'email-error' : undefined}
        /&gt;
        {errors.email && (
          &lt;span id="email-error" role="alert"&gt;{errors.email}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="password"&gt;Password&lt;/label&gt;
        &lt;input
          id="password"
          name="password"
          type="password"
          value={formData.password}
          onChange={handleChange}
          onBlur={handleBlur}
          aria-invalid={!!errors.password}
          aria-describedby={errors.password ? 'password-error' : undefined}
        /&gt;
        {errors.password && (
          &lt;span id="password-error" role="alert"&gt;{errors.password}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;div&gt;
        &lt;label htmlFor="confirmPassword"&gt;Confirm Password&lt;/label&gt;
        &lt;input
          id="confirmPassword"
          name="confirmPassword"
          type="password"
          value={formData.confirmPassword}
          onChange={handleChange}
          onBlur={handleBlur}
          aria-invalid={!!errors.confirmPassword}
          aria-describedby={errors.confirmPassword ? 'confirm-error' : undefined}
        /&gt;
        {errors.confirmPassword && (
          &lt;span id="confirm-error" role="alert"&gt;{errors.confirmPassword}&lt;/span&gt;
        )}
      &lt;/div&gt;
      
      &lt;button type="submit" disabled={isSubmitting}&gt;
        {isSubmitting ? 'Creating account...' : 'Create Account'}
      &lt;/button&gt;
    &lt;/form&gt;
  );
}
                </code></pre>

                <h3>Comprehensive Form Tests</h3>
                <pre><code class="language-typescript">
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { RegistrationForm } from './RegistrationForm';

describe('RegistrationForm', () => {
  it('shows validation errors on blur', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    const emailInput = screen.getByLabelText('Email');
    
    // Focus and blur without entering anything
    await user.click(emailInput);
    await user.tab(); // Tab away to trigger blur
    
    // Should show required error
    expect(screen.getByText('Email is required')).toBeInTheDocument();
  });
  
  it('shows format error for invalid email', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    const emailInput = screen.getByLabelText('Email');
    
    // Type invalid email
    await user.type(emailInput, 'notanemail');
    await user.tab();
    
    expect(screen.getByText('Invalid email format')).toBeInTheDocument();
  });
  
  it('validates password strength', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    const passwordInput = screen.getByLabelText('Password');
    
    // Too short
    await user.type(passwordInput, 'short');
    await user.tab();
    expect(screen.getByText('Password must be at least 8 characters')).toBeInTheDocument();
    
    // Clear and try without uppercase
    await user.clear(passwordInput);
    await user.type(passwordInput, 'lowercase123');
    await user.tab();
    expect(screen.getByText(/must contain uppercase/i)).toBeInTheDocument();
  });
  
  it('validates password confirmation matches', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    // Enter password
    await user.type(screen.getByLabelText('Password'), 'Password123');
    
    // Enter different confirmation
    await user.type(screen.getByLabelText('Confirm Password'), 'Different123');
    await user.tab();
    
    expect(screen.getByText('Passwords do not match')).toBeInTheDocument();
  });
  
  it('submits form with valid data', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn().mockResolvedValue(undefined);
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    // Fill form with valid data
    await user.type(screen.getByLabelText('Email'), 'user@example.com');
    await user.type(screen.getByLabelText('Password'), 'Password123');
    await user.type(screen.getByLabelText('Confirm Password'), 'Password123');
    
    // Submit
    await user.click(screen.getByRole('button', { name: 'Create Account' }));
    
    // Should call onSubmit with correct data
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith({
        email: 'user@example.com',
        password: 'Password123',
        confirmPassword: 'Password123'
      });
    });
  });
  
  it('shows loading state during submission', async () => {
    const user = userEvent.setup();
    
    // Mock that takes time to resolve
    const mockOnSubmit = vi.fn(() => 
      new Promise(resolve => setTimeout(resolve, 100))
    );
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    // Fill and submit
    await user.type(screen.getByLabelText('Email'), 'user@example.com');
    await user.type(screen.getByLabelText('Password'), 'Password123');
    await user.type(screen.getByLabelText('Confirm Password'), 'Password123');
    await user.click(screen.getByRole('button', { name: 'Create Account' }));
    
    // Should show loading state
    expect(screen.getByRole('button', { name: 'Creating account...' })).toBeDisabled();
    
    // Wait for completion
    await waitFor(() => {
      expect(screen.getByRole('button', { name: 'Create Account' })).not.toBeDisabled();
    });
  });
  
  it('prevents submission with validation errors', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    // Leave fields empty and submit
    await user.click(screen.getByRole('button', { name: 'Create Account' }));
    
    // Should show all validation errors
    expect(screen.getByText('Email is required')).toBeInTheDocument();
    expect(screen.getByText('Password is required')).toBeInTheDocument();
    
    // Should NOT call onSubmit
    expect(mockOnSubmit).not.toHaveBeenCalled();
  });
  
  it('clears errors when user fixes input', async () => {
    const user = userEvent.setup();
    const mockOnSubmit = vi.fn();
    
    render(&lt;RegistrationForm onSubmit={mockOnSubmit} /&gt;);
    
    const emailInput = screen.getByLabelText('Email');
    
    // Trigger error
    await user.click(emailInput);
    await user.tab();
    expect(screen.getByText('Email is required')).toBeInTheDocument();
    
    // Fix error
    await user.type(emailInput, 'user@example.com');
    
    // Error should clear as user types (after first blur)
    await waitFor(() => {
      expect(screen.queryByText('Email is required')).not.toBeInTheDocument();
    });
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ What We're Testing</h4>
                    <ul>
                        <li><strong>Validation triggers:</strong> Errors appear at the right time (blur, submit)</li>
                        <li><strong>Error messages:</strong> Correct messages for each validation rule</li>
                        <li><strong>Field dependencies:</strong> Password confirmation depends on password</li>
                        <li><strong>Form submission:</strong> Only submits with valid data</li>
                        <li><strong>Loading states:</strong> UI updates during async operations</li>
                        <li><strong>Error recovery:</strong> Errors clear when user fixes issues</li>
                    </ul>
                </div>

                <h3>Testing Dynamic Form Fields</h3>
                <p>Forms that add/remove fields dynamically need special testing:</p>

                <pre><code class="language-typescript">
function DynamicSkillsForm() {
  const [skills, setSkills] = React.useState&lt;string[]&gt;(['']);
  
  const addSkill = () => {
    setSkills([...skills, '']);
  };
  
  const removeSkill = (index: number) => {
    setSkills(skills.filter((_, i) => i !== index));
  };
  
  const updateSkill = (index: number, value: string) => {
    const newSkills = [...skills];
    newSkills[index] = value;
    setSkills(newSkills);
  };
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Skills&lt;/h2&gt;
      {skills.map((skill, index) => (
        &lt;div key={index}&gt;
          &lt;input
            type="text"
            value={skill}
            onChange={(e) => updateSkill(index, e.target.value)}
            aria-label={`Skill ${index + 1}`}
          /&gt;
          {skills.length > 1 && (
            &lt;button 
              type="button"
              onClick={() => removeSkill(index)}
              aria-label={`Remove skill ${index + 1}`}
            &gt;
              Remove
            &lt;/button&gt;
          )}
        &lt;/div&gt;
      ))}
      &lt;button type="button" onClick={addSkill}&gt;Add Skill&lt;/button&gt;
    &lt;/div&gt;
  );
}

test('adds and removes dynamic fields', async () => {
  const user = userEvent.setup();
  render(&lt;DynamicSkillsForm /&gt;);
  
  // Initially one field
  expect(screen.getByLabelText('Skill 1')).toBeInTheDocument();
  
  // Add a skill
  await user.click(screen.getByRole('button', { name: 'Add Skill' }));
  
  // Should now have two fields
  expect(screen.getByLabelText('Skill 1')).toBeInTheDocument();
  expect(screen.getByLabelText('Skill 2')).toBeInTheDocument();
  
  // Fill them
  await user.type(screen.getByLabelText('Skill 1'), 'React');
  await user.type(screen.getByLabelText('Skill 2'), 'TypeScript');
  
  expect(screen.getByLabelText('Skill 1')).toHaveValue('React');
  expect(screen.getByLabelText('Skill 2')).toHaveValue('TypeScript');
  
  // Remove first skill
  await user.click(screen.getByRole('button', { name: 'Remove skill 1' }));
  
  // TypeScript should now be the only skill
  expect(screen.getByLabelText('Skill 1')).toHaveValue('TypeScript');
  expect(screen.queryByLabelText('Skill 2')).not.toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Dynamic Form Testing Tips</h4>
                    <ul>
                        <li>Use <code>aria-label</code> with indices to make fields uniquely queryable</li>
                        <li>Test adding multiple fields, not just one</li>
                        <li>Test removing from different positions (first, middle, last)</li>
                        <li>Verify that removing a field doesn't affect others</li>
                        <li>Test minimum and maximum field constraints</li>
                    </ul>
                </div>

            <!-- Section 3: Testing Custom Hooks -->
            <section id="custom-hooks" class="lesson-section">
                <h2>ü™ù Testing Custom Hooks</h2>
                
                <p>Custom hooks encapsulate reusable logic, but they can't be tested outside of components. React Testing Library provides <code>renderHook</code> to test hooks in isolation.</p>

                <h3>The renderHook Utility</h3>
                <p>Here's a custom hook for managing form state:</p>

                <pre><code class="language-typescript">
// useFormState.ts
import { useState } from 'react';

export function useFormState&lt;T extends Record&lt;string, any&gt;&gt;(initialValues: T) {
  const [values, setValues] = useState&lt;T&gt;(initialValues);
  const [touched, setTouched] = useState&lt;Record&lt;string, boolean&gt;&gt;({});
  
  const handleChange = (name: keyof T, value: any) => {
    setValues(prev => ({ ...prev, [name]: value }));
  };
  
  const handleBlur = (name: keyof T) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  };
  
  const reset = () => {
    setValues(initialValues);
    setTouched({});
  };
  
  const isTouched = (name: keyof T) => touched[name] || false;
  
  return {
    values,
    touched,
    handleChange,
    handleBlur,
    reset,
    isTouched
  };
}
                </code></pre>

                <h3>Testing the Hook</h3>
                <pre><code class="language-typescript">
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect } from 'vitest';
import { useFormState } from './useFormState';

describe('useFormState', () => {
  it('initializes with default values', () => {
    const initialValues = { name: '', email: '' };
    const { result } = renderHook(() => useFormState(initialValues));
    
    expect(result.current.values).toEqual(initialValues);
    expect(result.current.touched).toEqual({});
  });
  
  it('updates values when handleChange is called', () => {
    const { result } = renderHook(() => 
      useFormState({ name: '', email: '' })
    );
    
    act(() => {
      result.current.handleChange('name', 'John');
    });
    
    expect(result.current.values.name).toBe('John');
    expect(result.current.values.email).toBe('');
  });
  
  it('tracks touched fields', () => {
    const { result } = renderHook(() => 
      useFormState({ name: '', email: '' })
    );
    
    expect(result.current.isTouched('name')).toBe(false);
    
    act(() => {
      result.current.handleBlur('name');
    });
    
    expect(result.current.isTouched('name')).toBe(true);
    expect(result.current.isTouched('email')).toBe(false);
  });
  
  it('resets to initial values', () => {
    const initialValues = { name: '', email: '' };
    const { result } = renderHook(() => useFormState(initialValues));
    
    // Make changes
    act(() => {
      result.current.handleChange('name', 'John');
      result.current.handleBlur('name');
    });
    
    expect(result.current.values.name).toBe('John');
    expect(result.current.isTouched('name')).toBe(true);
    
    // Reset
    act(() => {
      result.current.reset();
    });
    
    expect(result.current.values).toEqual(initialValues);
    expect(result.current.touched).toEqual({});
  });
});
                </code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4>üìñ Understanding renderHook</h4>
                    <p style="color: white;"><strong>renderHook()</strong> creates a test component that calls your hook and provides access to its return value through <code>result.current</code>. Use <code>act()</code> to wrap state updates just like in component tests.</p>
                </div>

                <h3>Testing Hooks with Dependencies</h3>
                <p>Test hooks that depend on props or context:</p>

                <pre><code class="language-typescript">
// useDebounce.ts
import { useState, useEffect } from 'react';

export function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);
  
  return debouncedValue;
}

// useDebounce.test.ts
describe('useDebounce', () => {
  it('returns initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 500));
    expect(result.current).toBe('initial');
  });
  
  it('debounces value changes', async () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      { initialProps: { value: 'first', delay: 500 } }
    );
    
    expect(result.current).toBe('first');
    
    // Change value
    rerender({ value: 'second', delay: 500 });
    
    // Should still be first (not debounced yet)
    expect(result.current).toBe('first');
    
    // Wait for debounce
    await waitFor(() => {
      expect(result.current).toBe('second');
    }, { timeout: 600 });
  });
  
  it('cancels previous timeout on rapid changes', async () => {
    const { result, rerender } = renderHook(
      ({ value }) => useDebounce(value, 500),
      { initialProps: { value: 'first' } }
    );
    
    // Rapid changes
    rerender({ value: 'second' });
    rerender({ value: 'third' });
    rerender({ value: 'fourth' });
    
    // Wait for debounce - should skip intermediate values
    await waitFor(() => {
      expect(result.current).toBe('fourth');
    }, { timeout: 600 });
  });
});
                </code></pre>

                <h3>Testing Hooks with Context</h3>
                <pre><code class="language-typescript">
// useAuth.ts
import { useContext } from 'react';
import { AuthContext } from './AuthContext';

export function useAuth() {
  const context = useContext(AuthContext);
  
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  
  return context;
}

// useAuth.test.ts
import { renderHook } from '@testing-library/react';
import { AuthProvider } from './AuthContext';
import { useAuth } from './useAuth';

describe('useAuth', () => {
  it('throws error when used outside provider', () => {
    // Suppress console.error for this test
    const spy = vi.spyOn(console, 'error').mockImplementation(() => {});
    
    expect(() => {
      renderHook(() => useAuth());
    }).toThrow('useAuth must be used within AuthProvider');
    
    spy.mockRestore();
  });
  
  it('returns auth context when inside provider', () => {
    const mockUser = { id: '1', name: 'John' };
    const mockLogin = vi.fn();
    const mockLogout = vi.fn();
    
    const wrapper = ({ children }: { children: React.ReactNode }) => (
      &lt;AuthProvider value={{ user: mockUser, login: mockLogin, logout: mockLogout }}&gt;
        {children}
      &lt;/AuthProvider&gt;
    );
    
    const { result } = renderHook(() => useAuth(), { wrapper });
    
    expect(result.current.user).toEqual(mockUser);
    expect(result.current.login).toBe(mockLogin);
    expect(result.current.logout).toBe(mockLogout);
  });
});
                </code></pre>

                <h3>Testing Async Hooks</h3>
                <pre><code class="language-typescript">
// useFetch.ts
import { useState, useEffect } from 'react';

interface FetchState&lt;T&gt; {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

export function useFetch&lt;T&gt;(url: string): FetchState&lt;T&gt; {
  const [state, setState] = useState&lt;FetchState&lt;T&gt;&gt;({
    data: null,
    loading: true,
    error: null
  });
  
  useEffect(() => {
    let cancelled = false;
    
    setState({ data: null, loading: true, error: null });
    
    fetch(url)
      .then(res => res.json())
      .then(data => {
        if (!cancelled) {
          setState({ data, loading: false, error: null });
        }
      })
      .catch(error => {
        if (!cancelled) {
          setState({ data: null, loading: false, error });
        }
      });
    
    return () => {
      cancelled = true;
    };
  }, [url]);
  
  return state;
}

// useFetch.test.ts
describe('useFetch', () => {
  it('fetches data successfully', async () => {
    const mockData = { id: 1, name: 'Test' };
    global.fetch = vi.fn().mockResolvedValue({
      json: async () => mockData
    });
    
    const { result } = renderHook(() => useFetch('/api/test'));
    
    // Initially loading
    expect(result.current.loading).toBe(true);
    expect(result.current.data).toBe(null);
    
    // Wait for data
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.data).toEqual(mockData);
    expect(result.current.error).toBe(null);
  });
  
  it('handles fetch errors', async () => {
    const mockError = new Error('Network error');
    global.fetch = vi.fn().mockRejectedValue(mockError);
    
    const { result } = renderHook(() => useFetch('/api/test'));
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false);
    });
    
    expect(result.current.data).toBe(null);
    expect(result.current.error).toEqual(mockError);
  });
  
  it('refetches when URL changes', async () => {
    global.fetch = vi.fn()
      .mockResolvedValueOnce({ json: async () => ({ id: 1 }) })
      .mockResolvedValueOnce({ json: async () => ({ id: 2 }) });
    
    const { result, rerender } = renderHook(
      ({ url }) => useFetch(url),
      { initialProps: { url: '/api/1' } }
    );
    
    // Wait for first fetch
    await waitFor(() => {
      expect(result.current.data).toEqual({ id: 1 });
    });
    
    // Change URL
    rerender({ url: '/api/2' });
    
    // Should refetch
    await waitFor(() => {
      expect(result.current.data).toEqual({ id: 2 });
    });
    
    expect(global.fetch).toHaveBeenCalledTimes(2);
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Hook Testing Best Practices</h4>
                    <ul>
                        <li><strong>Use renderHook:</strong> Test hooks in isolation when possible</li>
                        <li><strong>Test in components too:</strong> Verify hooks work in real usage</li>
                        <li><strong>Use act():</strong> Wrap all state updates</li>
                        <li><strong>Test cleanup:</strong> Verify useEffect cleanup functions work</li>
                        <li><strong>Mock dependencies:</strong> Mock external APIs, timers, etc.</li>
                        <li><strong>Test edge cases:</strong> Rapid updates, cancellation, errors</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Keyboard and Accessibility Testing -->
            <section id="keyboard-interactions" class="lesson-section">
                <h2>‚å®Ô∏è Keyboard and Accessibility Testing</h2>
                
                <p>Keyboard navigation is crucial for accessibility. Let's ensure your components work for keyboard users.</p>

                <h3>Tab Navigation</h3>
                <pre><code class="language-typescript">
function NavigationMenu() {
  const [activeIndex, setActiveIndex] = React.useState(0);
  const items = ['Home', 'About', 'Services', 'Contact'];
  
  const handleKeyDown = (e: React.KeyboardEvent, index: number) => {
    switch (e.key) {
      case 'ArrowRight':
        e.preventDefault();
        setActiveIndex((index + 1) % items.length);
        break;
      case 'ArrowLeft':
        e.preventDefault();
        setActiveIndex((index - 1 + items.length) % items.length);
        break;
      case 'Home':
        e.preventDefault();
        setActiveIndex(0);
        break;
      case 'End':
        e.preventDefault();
        setActiveIndex(items.length - 1);
        break;
    }
  };
  
  return (
    &lt;nav role="navigation" aria-label="Main navigation"&gt;
      &lt;ul role="menubar"&gt;
        {items.map((item, index) => (
          &lt;li key={item} role="none"&gt;
            &lt;button
              role="menuitem"
              tabIndex={activeIndex === index ? 0 : -1}
              onKeyDown={(e) => handleKeyDown(e, index)}
              onFocus={() => setActiveIndex(index)}
              aria-current={activeIndex === index ? 'page' : undefined}
            &gt;
              {item}
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}

test('navigates with arrow keys', async () => {
  const user = userEvent.setup();
  render(&lt;NavigationMenu /&gt;);
  
  const home = screen.getByRole('menuitem', { name: 'Home' });
  const about = screen.getByRole('menuitem', { name: 'About' });
  
  // Focus first item
  home.focus();
  expect(home).toHaveFocus();
  
  // Press right arrow
  await user.keyboard('{ArrowRight}');
  expect(about).toHaveFocus();
  
  // Press left arrow
  await user.keyboard('{ArrowLeft}');
  expect(home).toHaveFocus();
  
  // Press End key
  await user.keyboard('{End}');
  expect(screen.getByRole('menuitem', { name: 'Contact' })).toHaveFocus();
  
  // Press Home key
  await user.keyboard('{Home}');
  expect(home).toHaveFocus();
});
                </code></pre>

                <h3>Testing Tab Trapping in Modals</h3>
                <pre><code class="language-typescript">
function Modal({ isOpen, onClose, children }: ModalProps) {
  const modalRef = React.useRef&lt;HTMLDivElement&gt;(null);
  
  React.useEffect(() => {
    if (!isOpen) return;
    
    const focusableElements = modalRef.current?.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    
    if (!focusableElements || focusableElements.length === 0) return;
    
    const firstElement = focusableElements[0] as HTMLElement;
    const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;
    
    const handleTab = (e: KeyboardEvent) => {
      if (e.key !== 'Tab') return;
      
      if (e.shiftKey) {
        if (document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        }
      } else {
        if (document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };
    
    document.addEventListener('keydown', handleTab);
    firstElement.focus();
    
    return () => {
      document.removeEventListener('keydown', handleTab);
    };
  }, [isOpen]);
  
  if (!isOpen) return null;
  
  return (
    &lt;div role="dialog" aria-modal="true" ref={modalRef}&gt;
      &lt;button onClick={onClose} aria-label="Close"&gt;√ó&lt;/button&gt;
      {children}
      &lt;button onClick={onClose}&gt;Close&lt;/button&gt;
    &lt;/div&gt;
  );
}

test('traps focus within modal', async () => {
  const user = userEvent.setup();
  const handleClose = vi.fn();
  
  render(
    &lt;Modal isOpen={true} onClose={handleClose}&gt;
      &lt;h2&gt;Modal Title&lt;/h2&gt;
      &lt;input placeholder="Name" /&gt;
      &lt;input placeholder="Email" /&gt;
    &lt;/Modal&gt;
  );
  
  const closeButton = screen.getByRole('button', { name: 'Close' });
  const nameInput = screen.getByPlaceholderText('Name');
  const emailInput = screen.getByPlaceholderText('Email');
  const bottomCloseButton = screen.getByRole('button', { name: /^Close$/ });
  
  // First element should have focus
  expect(screen.getByRole('button', { name: 'Close' })).toHaveFocus();
  
  // Tab through elements
  await user.tab();
  expect(nameInput).toHaveFocus();
  
  await user.tab();
  expect(emailInput).toHaveFocus();
  
  await user.tab();
  expect(bottomCloseButton).toHaveFocus();
  
  // Tab from last element should loop to first
  await user.tab();
  expect(closeButton).toHaveFocus();
  
  // Shift+Tab should go backwards
  await user.tab({ shift: true });
  expect(bottomCloseButton).toHaveFocus();
});
                </code></pre>

                <h3>Testing Escape Key to Close</h3>
                <pre><code class="language-typescript">
test('closes modal on Escape key', async () => {
  const user = userEvent.setup();
  const handleClose = vi.fn();
  
  render(
    &lt;Modal isOpen={true} onClose={handleClose}&gt;
      &lt;p&gt;Modal content&lt;/p&gt;
    &lt;/Modal&gt;
  );
  
  await user.keyboard('{Escape}');
  
  expect(handleClose).toHaveBeenCalledTimes(1);
});
                </code></pre>

                <h3>Testing ARIA Attributes</h3>
                <pre><code class="language-typescript">
function Accordion() {
  const [expanded, setExpanded] = React.useState&lt;string | null&gt;(null);
  
  const sections = [
    { id: 'section1', title: 'Section 1', content: 'Content 1' },
    { id: 'section2', title: 'Section 2', content: 'Content 2' }
  ];
  
  return (
    &lt;div&gt;
      {sections.map(section => (
        &lt;div key={section.id}&gt;
          &lt;button
            aria-expanded={expanded === section.id}
            aria-controls={`panel-${section.id}`}
            onClick={() => setExpanded(
              expanded === section.id ? null : section.id
            )}
          &gt;
            {section.title}
          &lt;/button&gt;
          &lt;div
            id={`panel-${section.id}`}
            role="region"
            aria-labelledby={section.id}
            hidden={expanded !== section.id}
          &gt;
            {section.content}
          &lt;/div&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

test('has correct ARIA attributes', async () => {
  const user = userEvent.setup();
  render(&lt;Accordion /&gt;);
  
  const button1 = screen.getByRole('button', { name: 'Section 1' });
  
  // Initially collapsed
  expect(button1).toHaveAttribute('aria-expanded', 'false');
  expect(screen.getByRole('region', { hidden: true })).toBeInTheDocument();
  
  // Expand
  await user.click(button1);
  
  expect(button1).toHaveAttribute('aria-expanded', 'true');
  expect(screen.getByText('Content 1')).toBeVisible();
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Accessibility Testing Checklist</h4>
                    <ul>
                        <li>‚úì All interactive elements are keyboard accessible</li>
                        <li>‚úì Tab order is logical and matches visual order</li>
                        <li>‚úì Focus is visible and properly managed</li>
                        <li>‚úì Modal focus is trapped and returns on close</li>
                        <li>‚úì ARIA attributes are correct and updated</li>
                        <li>‚úì Keyboard shortcuts work (Arrow keys, Escape, Enter)</li>
                        <li>‚úì Screen reader announcements happen (role="alert", etc.)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 5: Testing File Uploads -->
            <section id="file-uploads" class="lesson-section">
                <h2>üìÅ Testing File Uploads</h2>
                
                <p>File uploads involve browser APIs and require special handling in tests.</p>

                <h3>Basic File Upload Component</h3>
                <pre><code class="language-typescript">
interface FileUploadProps {
  onFileSelect: (file: File) => void;
  accept?: string;
  maxSize?: number; // in bytes
}

export function FileUpload({ onFileSelect, accept, maxSize }: FileUploadProps) {
  const [error, setError] = React.useState&lt;string | null&gt;(null);
  
  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const file = e.target.files?.[0];
    
    if (!file) return;
    
    setError(null);
    
    // Validate file size
    if (maxSize && file.size > maxSize) {
      setError(`File size must be less than ${maxSize / 1024 / 1024}MB`);
      return;
    }
    
    // Validate file type
    if (accept) {
      const acceptedTypes = accept.split(',').map(t => t.trim());
      const fileExtension = '.' + file.name.split('.').pop();
      
      if (!acceptedTypes.includes(fileExtension) && !acceptedTypes.includes(file.type)) {
        setError(`File type must be: ${accept}`);
        return;
      }
    }
    
    onFileSelect(file);
  };
  
  return (
    &lt;div&gt;
      &lt;label htmlFor="file-upload"&gt;Choose File&lt;/label&gt;
      &lt;input
        id="file-upload"
        type="file"
        onChange={handleChange}
        accept={accept}
      /&gt;
      {error && &lt;div role="alert"&gt;{error}&lt;/div&gt;}
    &lt;/div&gt;
  );
}
                </code></pre>

                <h3>Testing File Upload</h3>
                <pre><code class="language-typescript">
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { FileUpload } from './FileUpload';

describe('FileUpload', () => {
  it('uploads a valid file', async () => {
    const user = userEvent.setup();
    const handleFileSelect = vi.fn();
    
    render(&lt;FileUpload onFileSelect={handleFileSelect} /&gt;);
    
    // Create a mock file
    const file = new File(['hello'], 'hello.png', { type: 'image/png' });
    
    const input = screen.getByLabelText('Choose File');
    
    // Upload the file
    await user.upload(input, file);
    
    expect(handleFileSelect).toHaveBeenCalledWith(file);
  });
  
  it('validates file size', async () => {
    const user = userEvent.setup();
    const handleFileSelect = vi.fn();
    const maxSize = 1024; // 1KB
    
    render(&lt;FileUpload onFileSelect={handleFileSelect} maxSize={maxSize} /&gt;);
    
    // Create a file larger than max size
    const largeFile = new File(['x'.repeat(2000)], 'large.png', { 
      type: 'image/png' 
    });
    
    await user.upload(screen.getByLabelText('Choose File'), largeFile);
    
    expect(screen.getByRole('alert')).toHaveTextContent(/File size must be less than/);
    expect(handleFileSelect).not.toHaveBeenCalled();
  });
  
  it('validates file type', async () => {
    const user = userEvent.setup();
    const handleFileSelect = vi.fn();
    
    render(
      &lt;FileUpload 
        onFileSelect={handleFileSelect} 
        accept=".jpg,.png"
      /&gt;
    );
    
    // Create a file with wrong type
    const file = new File(['content'], 'document.pdf', { type: 'application/pdf' });
    
    await user.upload(screen.getByLabelText('Choose File'), file);
    
    expect(screen.getByRole('alert')).toHaveTextContent(/File type must be/);
    expect(handleFileSelect).not.toHaveBeenCalled();
  });
  
  it('handles multiple file types', async () => {
    const user = userEvent.setup();
    const handleFileSelect = vi.fn();
    
    render(
      &lt;FileUpload 
        onFileSelect={handleFileSelect} 
        accept=".jpg,.png,.gif"
      /&gt;
    );
    
    const jpgFile = new File(['jpg'], 'image.jpg', { type: 'image/jpeg' });
    await user.upload(screen.getByLabelText('Choose File'), jpgFile);
    expect(handleFileSelect).toHaveBeenCalledWith(jpgFile);
    
    const pngFile = new File(['png'], 'image.png', { type: 'image/png' });
    await user.upload(screen.getByLabelText('Choose File'), pngFile);
    expect(handleFileSelect).toHaveBeenCalledWith(pngFile);
  });
});
                </code></pre>

                <h3>Testing File Upload with Preview</h3>
                <pre><code class="language-typescript">
function ImageUploadWithPreview({ onUpload }: { onUpload: (file: File) => void }) {
  const [preview, setPreview] = React.useState&lt;string | null&gt;(null);
  
  const handleFileChange = (e: React.ChangeEvent&lt;HTMLInputElement&gt;) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    // Create preview
    const reader = new FileReader();
    reader.onloadend = () => {
      setPreview(reader.result as string);
    };
    reader.readAsDataURL(file);
    
    onUpload(file);
  };
  
  return (
    &lt;div&gt;
      &lt;input
        type="file"
        onChange={handleFileChange}
        accept="image/*"
        aria-label="Upload image"
      /&gt;
      {preview && (
        &lt;img 
          src={preview} 
          alt="Upload preview" 
          style={{ maxWidth: '200px' }}
        /&gt;
      )}
    &lt;/div&gt;
  );
}

test('shows image preview after upload', async () => {
  const user = userEvent.setup();
  const handleUpload = vi.fn();
  
  render(&lt;ImageUploadWithPreview onUpload={handleUpload} /&gt;);
  
  const file = new File(['image'], 'test.png', { type: 'image/png' });
  
  // Mock FileReader
  const mockFileReader = {
    readAsDataURL: vi.fn(),
    onloadend: null as any,
    result: 'data:image/png;base64,mockImageData'
  };
  
  global.FileReader = vi.fn(() => mockFileReader) as any;
  
  await user.upload(screen.getByLabelText('Upload image'), file);
  
  // Trigger the onloadend callback
  mockFileReader.onloadend?.();
  
  // Preview should appear
  await waitFor(() => {
    expect(screen.getByAltText('Upload preview')).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Testing Drag and Drop</h3>
                <pre><code class="language-typescript">
function DragDropUpload({ onDrop }: { onDrop: (files: File[]) => void }) {
  const [isDragging, setIsDragging] = React.useState(false);
  
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };
  
  const handleDragLeave = () => {
    setIsDragging(false);
  };
  
  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    
    const files = Array.from(e.dataTransfer.files);
    onDrop(files);
  };
  
  return (
    &lt;div
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      style={{
        border: isDragging ? '2px dashed blue' : '2px dashed gray',
        padding: '2rem'
      }}
      data-testid="drop-zone"
    &gt;
      {isDragging ? 'Drop files here' : 'Drag files here'}
    &lt;/div&gt;
  );
}

test('handles file drop', async () => {
  const handleDrop = vi.fn();
  
  render(&lt;DragDropUpload onDrop={handleDrop} /&gt;);
  
  const dropZone = screen.getByTestId('drop-zone');
  
  // Create mock files
  const file1 = new File(['content1'], 'file1.txt', { type: 'text/plain' });
  const file2 = new File(['content2'], 'file2.txt', { type: 'text/plain' });
  
  // Create a drop event
  const dropEvent = new Event('drop', { bubbles: true }) as any;
  dropEvent.dataTransfer = {
    files: [file1, file2]
  };
  
  // Trigger drop
  fireEvent.drop(dropZone, dropEvent);
  
  expect(handleDrop).toHaveBeenCalledWith([file1, file2]);
});

test('shows dragging state', () => {
  const handleDrop = vi.fn();
  
  render(&lt;DragDropUpload onDrop={handleDrop} /&gt;);
  
  const dropZone = screen.getByTestId('drop-zone');
  
  // Initial state
  expect(dropZone).toHaveTextContent('Drag files here');
  
  // Drag over
  fireEvent.dragOver(dropZone);
  expect(dropZone).toHaveTextContent('Drop files here');
  
  // Drag leave
  fireEvent.dragLeave(dropZone);
  expect(dropZone).toHaveTextContent('Drag files here');
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ File Upload Testing Tips</h4>
                    <ul>
                        <li>Use <code>user.upload()</code> for simple file uploads</li>
                        <li>Create mock <code>File</code> objects with <code>new File()</code></li>
                        <li>Mock <code>FileReader</code> for preview functionality</li>
                        <li>Test validation: file size, file type, file count</li>
                        <li>Use <code>fireEvent</code> for drag-and-drop (userEvent doesn't support it yet)</li>
                        <li>Test error states and edge cases</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Custom Render Functions -->
            <section id="custom-render" class="lesson-section">
                <h2>üé® Custom Render Functions</h2>
                
                <p>Real applications wrap components with providers (Theme, Router, Auth, etc.). Creating custom render functions simplifies testing these components.</p>

                <h3>The Problem with Providers</h3>
                <p>Without custom render, you need to wrap every component test:</p>

                <pre><code class="language-typescript">
// ‚ùå Repetitive - wrapping providers in every test
test('renders themed button', () => {
  render(
    &lt;ThemeProvider&gt;
      &lt;AuthProvider&gt;
        &lt;RouterProvider&gt;
          &lt;MyButton /&gt;
        &lt;/RouterProvider&gt;
      &lt;/AuthProvider&gt;
    &lt;/ThemeProvider&gt;
  );
});
                </code></pre>

                <h3>Creating a Custom Render</h3>
                <p>Create a test utilities file to handle all providers:</p>

                <pre><code class="language-typescript">
// test-utils.tsx
import { render, RenderOptions } from '@testing-library/react';
import { ReactElement, ReactNode } from 'react';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider } from './contexts/ThemeContext';
import { AuthProvider } from './contexts/AuthContext';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

interface CustomRenderOptions extends Omit&lt;RenderOptions, 'wrapper'&gt; {
  // Add custom options
  theme?: 'light' | 'dark';
  initialAuth?: {
    isAuthenticated: boolean;
    user?: { id: string; name: string };
  };
  route?: string;
}

export function renderWithProviders(
  ui: ReactElement,
  {
    theme = 'light',
    initialAuth = { isAuthenticated: false },
    route = '/',
    ...renderOptions
  }: CustomRenderOptions = {}
) {
  // Create a fresh QueryClient for each test
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false }
    }
  });
  
  // Set up router history
  window.history.pushState({}, 'Test page', route);
  
  function Wrapper({ children }: { children: ReactNode }) {
    return (
      &lt;BrowserRouter&gt;
        &lt;QueryClientProvider client={queryClient}&gt;
          &lt;ThemeProvider initialTheme={theme}&gt;
            &lt;AuthProvider initialAuth={initialAuth}&gt;
              {children}
            &lt;/AuthProvider&gt;
          &lt;/ThemeProvider&gt;
        &lt;/QueryClientProvider&gt;
      &lt;/BrowserRouter&gt;
    );
  }
  
  return render(ui, { wrapper: Wrapper, ...renderOptions });
}

// Re-export everything from React Testing Library
export * from '@testing-library/react';

// Override render with our custom version
export { renderWithProviders as render };
                </code></pre>

                <h3>Using Custom Render</h3>
                <pre><code class="language-typescript">
// MyComponent.test.tsx
import { render, screen } from './test-utils'; // Import from test-utils
import userEvent from '@testing-library/user-event';
import { MyComponent } from './MyComponent';

test('renders with dark theme', () => {
  // ‚úÖ Clean and simple!
  render(&lt;MyComponent /&gt;, { theme: 'dark' });
  
  expect(screen.getByTestId('theme-indicator')).toHaveTextContent('dark');
});

test('shows user name when authenticated', () => {
  render(&lt;MyComponent /&gt;, {
    initialAuth: {
      isAuthenticated: true,
      user: { id: '1', name: 'Alice' }
    }
  });
  
  expect(screen.getByText('Welcome, Alice')).toBeInTheDocument();
});

test('renders at specific route', () => {
  render(&lt;MyComponent /&gt;, { route: '/dashboard' });
  
  expect(screen.getByText('Dashboard')).toBeInTheDocument();
});
                </code></pre>

                <h3>Custom Render for Specific Contexts</h3>
                <p>Create specialized render functions for different scenarios:</p>

                <pre><code class="language-typescript">
// test-utils.tsx (continued)

// For components that only need router
export function renderWithRouter(
  ui: ReactElement,
  { route = '/' }: { route?: string } = {}
) {
  window.history.pushState({}, 'Test page', route);
  
  return render(ui, {
    wrapper: ({ children }) => &lt;BrowserRouter&gt;{children}&lt;/BrowserRouter&gt;
  });
}

// For components that only need theme
export function renderWithTheme(
  ui: ReactElement,
  { theme = 'light' }: { theme?: 'light' | 'dark' } = {}
) {
  return render(ui, {
    wrapper: ({ children }) => (
      &lt;ThemeProvider initialTheme={theme}&gt;{children}&lt;/ThemeProvider&gt;
    )
  });
}

// For testing forms with React Hook Form
import { FormProvider, useForm } from 'react-hook-form';

export function renderWithForm(
  ui: ReactElement,
  { defaultValues = {} }: { defaultValues?: any } = {}
) {
  function Wrapper({ children }: { children: ReactNode }) {
    const methods = useForm({ defaultValues });
    return &lt;FormProvider {...methods}&gt;{children}&lt;/FormProvider&gt;;
  }
  
  return render(ui, { wrapper: Wrapper });
}
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Custom Render Benefits</h4>
                    <ul>
                        <li><strong>DRY:</strong> Write provider setup once, use everywhere</li>
                        <li><strong>Consistency:</strong> All tests use the same provider configuration</li>
                        <li><strong>Flexibility:</strong> Easily customize providers per test</li>
                        <li><strong>Maintainability:</strong> Update providers in one place</li>
                        <li><strong>Readability:</strong> Tests focus on behavior, not setup</li>
                    </ul>
                </div>
            </section>

            <!-- Section 7: Mocking Dependencies -->
            <section id="mocking" class="lesson-section">
                <h2>üé≠ Mocking Dependencies</h2>
                
                <p>Mocking external dependencies makes tests faster, more reliable, and easier to control. Let's explore different mocking strategies.</p>

                <h3>Mocking API Calls with MSW</h3>
                <p>Mock Service Worker (MSW) intercepts network requests at the network level:</p>

                <pre><code class="language-typescript">
// mocks/handlers.ts
import { rest } from 'msw';

export const handlers = [
  // GET request
  rest.get('/api/users/:id', (req, res, ctx) => {
    const { id } = req.params;
    
    return res(
      ctx.status(200),
      ctx.json({
        id,
        name: 'John Doe',
        email: 'john@example.com'
      })
    );
  }),
  
  // POST request
  rest.post('/api/users', async (req, res, ctx) => {
    const body = await req.json();
    
    return res(
      ctx.status(201),
      ctx.json({
        id: '123',
        ...body
      })
    );
  }),
  
  // Error response
  rest.get('/api/error', (req, res, ctx) => {
    return res(
      ctx.status(500),
      ctx.json({ message: 'Internal server error' })
    );
  })
];

// mocks/server.ts
import { setupServer } from 'msw/node';
import { handlers } from './handlers';

export const server = setupServer(...handlers);

// test/setup.ts
import { beforeAll, afterEach, afterAll } from 'vitest';
import { server } from '../mocks/server';

beforeAll(() => server.listen());
afterEach(() => server.resetHandlers());
afterAll(() => server.close());
                </code></pre>

                <h3>Using MSW in Tests</h3>
                <pre><code class="language-typescript">
import { render, screen, waitFor } from '@testing-library/react';
import { server } from '../mocks/server';
import { rest } from 'msw';
import { UserProfile } from './UserProfile';

test('displays user data from API', async () => {
  render(&lt;UserProfile userId="1" /&gt;);
  
  // MSW automatically handles the request
  await waitFor(() => {
    expect(screen.getByText('John Doe')).toBeInTheDocument();
  });
});

test('handles API errors', async () => {
  // Override handler for this test
  server.use(
    rest.get('/api/users/:id', (req, res, ctx) => {
      return res(
        ctx.status(404),
        ctx.json({ message: 'User not found' })
      );
    })
  );
  
  render(&lt;UserProfile userId="999" /&gt;);
  
  await waitFor(() => {
    expect(screen.getByText('User not found')).toBeInTheDocument();
  });
});

test('handles network errors', async () => {
  server.use(
    rest.get('/api/users/:id', (req, res, ctx) => {
      return res.networkError('Failed to connect');
    })
  );
  
  render(&lt;UserProfile userId="1" /&gt;);
  
  await waitFor(() => {
    expect(screen.getByText(/network error/i)).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>Mocking Modules with Vitest</h3>
                <pre><code class="language-typescript">
// Mocking an entire module
vi.mock('./api', () => ({
  fetchUser: vi.fn(),
  createUser: vi.fn()
}));

import { fetchUser, createUser } from './api';

test('fetches user data', async () => {
  const mockUser = { id: '1', name: 'Alice' };
  
  // Mock implementation
  (fetchUser as any).mockResolvedValue(mockUser);
  
  render(&lt;UserProfile userId="1" /&gt;);
  
  await waitFor(() => {
    expect(screen.getByText('Alice')).toBeInTheDocument();
  });
  
  expect(fetchUser).toHaveBeenCalledWith('1');
});
                </code></pre>

                <h3>Mocking localStorage</h3>
                <pre><code class="language-typescript">
describe('LocalStorageComponent', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear();
  });
  
  it('saves data to localStorage', async () => {
    const user = userEvent.setup();
    render(&lt;SettingsForm /&gt;);
    
    await user.type(screen.getByLabelText('Username'), 'testuser');
    await user.click(screen.getByRole('button', { name: 'Save' }));
    
    expect(localStorage.getItem('username')).toBe('testuser');
  });
  
  it('loads data from localStorage', () => {
    localStorage.setItem('username', 'existing-user');
    
    render(&lt;SettingsForm /&gt;);
    
    expect(screen.getByLabelText('Username')).toHaveValue('existing-user');
  });
});

// Or mock localStorage entirely
const localStorageMock = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
};

global.localStorage = localStorageMock as any;
                </code></pre>

                <h3>Mocking Timers</h3>
                <pre><code class="language-typescript">
import { vi } from 'vitest';

test('auto-hides notification after delay', async () => {
  vi.useFakeTimers();
  
  render(&lt;Notification message="Success!" autoHideDuration={3000} /&gt;);
  
  // Notification visible initially
  expect(screen.getByText('Success!')).toBeInTheDocument();
  
  // Fast-forward time
  vi.advanceTimersByTime(3000);
  
  // Notification should be hidden
  await waitFor(() => {
    expect(screen.queryByText('Success!')).not.toBeInTheDocument();
  });
  
  vi.useRealTimers();
});

test('clears timer on unmount', () => {
  vi.useFakeTimers();
  const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
  
  const { unmount } = render(&lt;TimerComponent /&gt;);
  
  unmount();
  
  expect(clearTimeoutSpy).toHaveBeenCalled();
  
  vi.useRealTimers();
});
                </code></pre>

                <h3>Mocking Date and Time</h3>
                <pre><code class="language-typescript">
test('displays current date', () => {
  // Mock Date
  const mockDate = new Date('2024-01-15T12:00:00Z');
  vi.setSystemTime(mockDate);
  
  render(&lt;DateDisplay /&gt;);
  
  expect(screen.getByText('January 15, 2024')).toBeInTheDocument();
  
  vi.useRealTimers();
});
                </code></pre>

                <h3>Mocking window.location</h3>
                <pre><code class="language-typescript">
test('redirects to login page', () => {
  const mockReload = vi.fn();
  delete (window as any).location;
  window.location = { ...window.location, reload: mockReload };
  
  render(&lt;LogoutButton /&gt;);
  
  fireEvent.click(screen.getByRole('button', { name: 'Logout' }));
  
  expect(mockReload).toHaveBeenCalled();
});
                </code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Mocking Best Practices</h4>
                    <ul>
                        <li><strong>Mock at the boundary:</strong> Mock external APIs, not your own code</li>
                        <li><strong>Use MSW for APIs:</strong> More realistic than mocking fetch</li>
                        <li><strong>Reset mocks:</strong> Clean up between tests</li>
                        <li><strong>Test both success and failure:</strong> Mock errors and edge cases</li>
                        <li><strong>Keep mocks simple:</strong> Don't recreate the entire API</li>
                        <li><strong>Document complex mocks:</strong> Explain why certain data is used</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Testing Complete Workflows -->
            <section id="workflows" class="lesson-section">
                <h2>üîÑ Testing Complete Workflows</h2>
                
                <p>Real users complete multi-step workflows. Let's test entire user journeys from start to finish.</p>

                <h3>Multi-Step Registration Workflow</h3>
                <pre><code class="language-typescript">
test('complete registration workflow', async () => {
  const user = userEvent.setup();
  
  // Mock API calls
  server.use(
    rest.post('/api/register', async (req, res, ctx) => {
      const body = await req.json();
      return res(ctx.status(201), ctx.json({ 
        id: '123', 
        ...body 
      }));
    })
  );
  
  render(&lt;RegistrationWizard /&gt;);
  
  // Step 1: Personal Information
  expect(screen.getByRole('heading', { name: 'Personal Information' })).toBeInTheDocument();
  
  await user.type(screen.getByLabelText('First Name'), 'John');
  await user.type(screen.getByLabelText('Last Name'), 'Doe');
  await user.type(screen.getByLabelText('Email'), 'john@example.com');
  
  await user.click(screen.getByRole('button', { name: 'Next' }));
  
  // Step 2: Account Details
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Account Details' })).toBeInTheDocument();
  });
  
  await user.type(screen.getByLabelText('Username'), 'johndoe');
  await user.type(screen.getByLabelText('Password'), 'SecurePass123');
  await user.type(screen.getByLabelText('Confirm Password'), 'SecurePass123');
  
  await user.click(screen.getByRole('button', { name: 'Next' }));
  
  // Step 3: Profile Picture
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Profile Picture' })).toBeInTheDocument();
  });
  
  const file = new File(['profile'], 'profile.jpg', { type: 'image/jpeg' });
  await user.upload(screen.getByLabelText('Upload Photo'), file);
  
  await user.click(screen.getByRole('button', { name: 'Next' }));
  
  // Step 4: Review
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Review' })).toBeInTheDocument();
  });
  
  expect(screen.getByText('John Doe')).toBeInTheDocument();
  expect(screen.getByText('john@example.com')).toBeInTheDocument();
  expect(screen.getByText('johndoe')).toBeInTheDocument();
  
  // Submit
  await user.click(screen.getByRole('button', { name: 'Submit' }));
  
  // Success message
  await waitFor(() => {
    expect(screen.getByText(/registration successful/i)).toBeInTheDocument();
  });
});
                </code></pre>

                <h3>E-commerce Checkout Flow</h3>
                <pre><code class="language-typescript">
test('complete checkout process', async () => {
  const user = userEvent.setup();
  
  render(&lt;App /&gt;, { 
    route: '/products',
    initialAuth: { 
      isAuthenticated: true, 
      user: { id: '1', name: 'Customer' } 
    }
  });
  
  // 1. Browse products
  expect(screen.getByRole('heading', { name: 'Products' })).toBeInTheDocument();
  
  // 2. Add to cart
  const addToCartButtons = screen.getAllByRole('button', { name: /add to cart/i });
  await user.click(addToCartButtons[0]);
  
  expect(await screen.findByText('1 item in cart')).toBeInTheDocument();
  
  // 3. View cart
  await user.click(screen.getByRole('link', { name: /cart/i }));
  
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Shopping Cart' })).toBeInTheDocument();
  });
  
  // 4. Update quantity
  const quantityInput = screen.getByLabelText('Quantity');
  await user.clear(quantityInput);
  await user.type(quantityInput, '2');
  
  expect(await screen.findByText(/subtotal.*\$39.98/i)).toBeInTheDocument();
  
  // 5. Proceed to checkout
  await user.click(screen.getByRole('button', { name: 'Checkout' }));
  
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Checkout' })).toBeInTheDocument();
  });
  
  // 6. Fill shipping info
  await user.type(screen.getByLabelText('Street Address'), '123 Main St');
  await user.type(screen.getByLabelText('City'), 'Springfield');
  await user.selectOptions(screen.getByLabelText('State'), 'IL');
  await user.type(screen.getByLabelText('Zip Code'), '62701');
  
  // 7. Fill payment info
  await user.type(screen.getByLabelText('Card Number'), '4111111111111111');
  await user.type(screen.getByLabelText('Expiry'), '12/25');
  await user.type(screen.getByLabelText('CVV'), '123');
  
  // 8. Place order
  await user.click(screen.getByRole('button', { name: 'Place Order' }));
  
  // 9. Confirmation
  await waitFor(() => {
    expect(screen.getByText(/order confirmed/i)).toBeInTheDocument();
  }, { timeout: 3000 });
  
  expect(screen.getByText(/order #/i)).toBeInTheDocument();
});
                </code></pre>

                <h3>Testing Navigation Between Pages</h3>
                <pre><code class="language-typescript">
test('navigates through application', async () => {
  const user = userEvent.setup();
  
  render(&lt;App /&gt;, { route: '/' });
  
  // Start at home
  expect(screen.getByRole('heading', { name: 'Home' })).toBeInTheDocument();
  
  // Navigate to about
  await user.click(screen.getByRole('link', { name: 'About' }));
  expect(screen.getByRole('heading', { name: 'About Us' })).toBeInTheDocument();
  
  // Navigate to contact
  await user.click(screen.getByRole('link', { name: 'Contact' }));
  expect(screen.getByRole('heading', { name: 'Contact' })).toBeInTheDocument();
  
  // Fill contact form
  await user.type(screen.getByLabelText('Name'), 'John Doe');
  await user.type(screen.getByLabelText('Email'), 'john@example.com');
  await user.type(screen.getByLabelText('Message'), 'Hello!');
  await user.click(screen.getByRole('button', { name: 'Send' }));
  
  // Success and redirect
  await waitFor(() => {
    expect(screen.getByRole('heading', { name: 'Home' })).toBeInTheDocument();
  });
  expect(screen.getByText(/message sent successfully/i)).toBeInTheDocument();
});
                </code></pre>

                <h3>Testing Error Recovery Flows</h3>
                <pre><code class="language-typescript">
test('handles and recovers from errors', async () => {
  const user = userEvent.setup();
  
  // Start with failing API
  server.use(
    rest.post('/api/submit', (req, res, ctx) => {
      return res(ctx.status(500), ctx.json({ message: 'Server error' }));
    })
  );
  
  render(&lt;SubmitForm /&gt;);
  
  // Fill form
  await user.type(screen.getByLabelText('Name'), 'John');
  await user.click(screen.getByRole('button', { name: 'Submit' }));
  
  // Error appears
  expect(await screen.findByText(/server error/i)).toBeInTheDocument();
  
  // Fix API
  server.use(
    rest.post('/api/submit', (req, res, ctx) => {
      return res(ctx.status(200), ctx.json({ success: true }));
    })
  );
  
  // Retry
  await user.click(screen.getByRole('button', { name: 'Try Again' }));
  
  // Success
  expect(await screen.findByText(/submitted successfully/i)).toBeInTheDocument();
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Workflow Testing Tips</h4>
                    <ul>
                        <li><strong>Test the happy path first:</strong> Ensure the ideal flow works</li>
                        <li><strong>Test error paths:</strong> What happens when things go wrong?</li>
                        <li><strong>Test back navigation:</strong> Can users go back and change things?</li>
                        <li><strong>Test state persistence:</strong> Does data survive navigation?</li>
                        <li><strong>Keep tests focused:</strong> One workflow per test</li>
                        <li><strong>Use descriptive test names:</strong> Name should describe the journey</li>
                    </ul>
                </div>
            </section>

            <!-- Section 9: Hands-on Exercises -->
            <section id="exercises" class="lesson-section">
                <h2>üèãÔ∏è Hands-on Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 1: Multi-Step Survey Form</h3>
                    <p><strong>Objective:</strong> Test a multi-step survey with progress tracking and data persistence.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Test navigation between steps (Next/Back buttons)</li>
                        <li>Test form validation on each step</li>
                        <li>Test progress indicator updates correctly</li>
                        <li>Test data persists when navigating back</li>
                        <li>Test submission with all data</li>
                        <li>Test that incomplete forms can't be submitted</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>screen.getByRole('button', { name: /next/i })</code> for navigation. Check that input values persist with <code>toHaveValue()</code>. Use <code>waitFor</code> for step transitions.</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 2: Search with Debounce</h3>
                    <p><strong>Objective:</strong> Test a search component that debounces API calls.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Test that search doesn't trigger immediately on keystroke</li>
                        <li>Test that search triggers after debounce delay</li>
                        <li>Test that rapid typing cancels previous searches</li>
                        <li>Test loading state during search</li>
                        <li>Test displaying search results</li>
                        <li>Test error handling</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>vi.useFakeTimers()</code> and <code>vi.advanceTimersByTime()</code> to control time. Mock the API with MSW or <code>vi.fn()</code>. Use <code>findBy</code> queries to wait for results.</p>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>üèãÔ∏è Exercise 3: Modal with Focus Management</h3>
                    <p><strong>Objective:</strong> Test a modal dialog with proper keyboard and focus handling.</p>
                    
                    <h4>Requirements:</h4>
                    <ol>
                        <li>Test that opening modal moves focus inside</li>
                        <li>Test that Tab key cycles through focusable elements</li>
                        <li>Test that focus is trapped within modal</li>
                        <li>Test that Escape key closes modal</li>
                        <li>Test that closing modal returns focus to trigger</li>
                        <li>Test correct ARIA attributes</li>
                    </ol>
                    
                    <details>
                        <summary>üí° Hint</summary>
                        <p>Use <code>document.activeElement</code> or <code>toHaveFocus()</code> to check focus. Use <code>user.tab()</code> and <code>user.keyboard('{Escape}')</code> for keyboard interaction. Check <code>aria-modal</code> and <code>role="dialog"</code>.</p>
                    </details>
                </div>
            </section>

            <!-- Section 10: Best Practices -->
            <section id="best-practices" class="lesson-section">
                <h2>‚ú® Best Practices</h2>
                
                <h3>‚úÖ Do's</h3>

                <h4>1. Test Complete User Flows</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - tests the complete user experience
test('user can complete checkout', async () => {
  // Add to cart ‚Üí View cart ‚Üí Enter shipping ‚Üí Payment ‚Üí Confirm
});

// ‚ùå Incomplete - only tests one step
test('user can add to cart', async () => {
  // Just tests adding, not the full journey
});
                </code></pre>

                <h4>2. Keep Tests Independent</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - each test sets up its own data
test('displays cart items', () => {
  const items = [{ id: '1', name: 'Product' }];
  render(&lt;Cart items={items} /&gt;);
});

// ‚ùå Bad - depends on global state
let globalItems = [];
test('adds to cart', () => {
  globalItems.push({ id: '1' });
});
test('displays cart', () => {
  render(&lt;Cart items={globalItems} /&gt;); // Depends on previous test
});
                </code></pre>

                <h4>3. Use Custom Render Functions</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - use custom render
import { render } from './test-utils';
render(&lt;MyComponent /&gt;);

// ‚ùå Tedious - manual provider wrapping
render(
  &lt;Provider1&gt;&lt;Provider2&gt;&lt;MyComponent /&gt;&lt;/Provider2&gt;&lt;/Provider1&gt;
);
                </code></pre>

                <h4>4. Test Error States</h4>
                <pre><code class="language-typescript">
// ‚úÖ Good - tests both success and failure
test('handles successful submission', async () => { /* ... */ });
test('handles submission errors', async () => { /* ... */ });
test('handles network errors', async () => { /* ... */ });

// ‚ùå Incomplete - only tests happy path
test('submits form', async () => { /* ... */ });
                </code></pre>

                <h3>‚ùå Don'ts</h3>

                <h4>1. Don't Test Implementation Details</h4>
                <pre><code class="language-typescript">
// ‚ùå Bad - testing state internals
expect(component.state.count).toBe(1);

// ‚úÖ Good - testing visible output
expect(screen.getByText('Count: 1')).toBeInTheDocument();
                </code></pre>

                <h4>2. Don't Use Brittle Selectors</h4>
                <pre><code class="language-typescript">
// ‚ùå Bad - breaks if styling changes
container.querySelector('.submit-button');

// ‚úÖ Good - uses semantic queries
screen.getByRole('button', { name: 'Submit' });
                </code></pre>

                <h4>3. Don't Make Tests Too Long</h4>
                <pre><code class="language-typescript">
// ‚ùå Bad - testing too many things
test('app works', async () => {
  // 500 lines testing every feature
});

// ‚úÖ Good - focused tests
test('user can register', async () => { /* ... */ });
test('user can login', async () => { /* ... */ });
test('user can update profile', async () => { /* ... */ });
                </code></pre>

                <h3>üí° Pro Tips</h3>

                <h4>1. Create Test Data Factories</h4>
                <pre><code class="language-typescript">
// test-factories.ts
export const createMockUser = (overrides = {}) => ({
  id: '1',
  name: 'Test User',
  email: 'test@example.com',
  ...overrides
});

export const createMockProduct = (overrides = {}) => ({
  id: '1',
  name: 'Test Product',
  price: 9.99,
  ...overrides
});

// Usage
const user = createMockUser({ name: 'John' });
const product = createMockProduct({ price: 19.99 });
                </code></pre>

                <h4>2. Use Testing Library Debug Tools</h4>
                <pre><code class="language-typescript">
test('debugging', () => {
  render(&lt;MyComponent /&gt;);
  
  screen.debug(); // See entire DOM
  screen.logTestingPlaygroundURL(); // Get query suggestions
});
                </code></pre>

                <h4>3. Group Related Tests</h4>
                <pre><code class="language-typescript">
describe('RegistrationForm', () => {
  describe('validation', () => {
    test('validates email format', async () => { /* ... */ });
    test('validates password strength', async () => { /* ... */ });
  });
  
  describe('submission', () => {
    test('submits valid data', async () => { /* ... */ });
    test('handles submission errors', async () => { /* ... */ });
  });
});
                </code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Testing Checklist</h4>
                    <ul>
                        <li>‚úì Tests cover complete user workflows</li>
                        <li>‚úì Both success and error paths are tested</li>
                        <li>‚úì Tests are independent and can run in any order</li>
                        <li>‚úì Custom render functions reduce boilerplate</li>
                        <li>‚úì Mocks are used for external dependencies</li>
                        <li>‚úì Keyboard navigation is tested</li>
                        <li>‚úì ARIA attributes are verified</li>
                        <li>‚úì Async operations are handled properly</li>
                        <li>‚úì Tests are readable and well-named</li>
                    </ul>
                </div>
            </section>

            <!-- Section 11: Summary -->
            <section id="summary" class="lesson-section">
                <h2>üìö Summary</h2>
                
                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>üéâ Key Takeaways</h3>
                    <ul>
                        <li><strong>Complex Forms:</strong> Test validation timing, error messages, field dependencies, and dynamic fields</li>
                        <li><strong>Custom Hooks:</strong> Use <code>renderHook</code> to test hooks in isolation with proper <code>act()</code> wrapping</li>
                        <li><strong>Keyboard Navigation:</strong> Test Tab, Arrow keys, Escape, and focus management for accessibility</li>
                        <li><strong>File Uploads:</strong> Use <code>user.upload()</code> and create mock <code>File</code> objects for testing</li>
                        <li><strong>Custom Render:</strong> Create reusable render functions that wrap providers to simplify tests</li>
                        <li><strong>Mocking:</strong> Use MSW for APIs, mock timers with <code>vi.useFakeTimers()</code>, and mock modules strategically</li>
                        <li><strong>Complete Workflows:</strong> Test entire user journeys from start to finish, including error recovery</li>
                        <li><strong>Test Independence:</strong> Each test should set up its own data and not depend on other tests</li>
                    </ul>
                </div>
                
                <h3>üìö Additional Resources</h3>
                <ul>
                    <li><a href="https://testing-library.com/docs/react-testing-library/api#renderhook" target="_blank">renderHook Documentation</a> - Testing custom hooks</li>
                    <li><a href="https://mswjs.io/" target="_blank">Mock Service Worker</a> - API mocking at the network level</li>
                    <li><a href="https://www.w3.org/WAI/ARIA/apg/" target="_blank">ARIA Authoring Practices</a> - Accessibility patterns to test</li>
                    <li><a href="https://kentcdodds.com/blog/making-your-ui-tests-resilient-to-change" target="_blank">Resilient UI Tests</a> - Kent C. Dodds on maintainable tests</li>
                    <li><a href="https://testing-library.com/docs/user-event/intro" target="_blank">user-event API</a> - Complete interaction reference</li>
                </ul>
                
                <h3>üöÄ What's Next?</h3>
                <p>In the next lesson, we'll explore <strong>Testing Async Code</strong> in depth:</p>
                <ul>
                    <li>Advanced async testing patterns</li>
                    <li>Testing data fetching with React Query</li>
                    <li>Testing WebSockets and real-time features</li>
                    <li>Testing optimistic updates</li>
                    <li>Handling race conditions in tests</li>
                    <li>Testing infinite scroll and pagination</li>
                </ul>

                <blockquote>
                    <strong>üí° Remember:</strong> The best tests tell a story about how users interact with your application. If you can read a test and understand what a user is doing, you've written a great test!
                </blockquote>

                <!-- Encouragement Card -->
                <div class="card" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; text-align: center; padding: 2rem;">
                    <h3 style="color: white;">üéâ Congratulations!</h3>
                    <p style="color: white;">You've mastered advanced user interaction testing! You can now test complex forms, custom hooks, keyboard navigation, file uploads, and complete user workflows. These skills will help you build rock-solid React applications that users can rely on.</p>
                    <p style="color: white; margin-top: 1rem;">Keep practicing, and remember: every interaction you test makes your application better!</p>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_9_2_react_testing_library.html" class="prev-lesson">‚Üê Previous: Lesson 9.2 - React Testing Library</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_9_4_testing_async_code.html" class="next-lesson">Next: Lesson 9.4 - Testing Async Code ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 Ray. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering learners to achieve their goals through quality education.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
