<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Master Redux Toolkit (RTK) for React applications. Learn modern Redux with reduced boilerplate, createSlice, createAsyncThunk, RTK Query, and TypeScript integration for scalable state management.">
    <meta name="author" content="PracticalAce">
    <title>Lesson 8.3: Redux Toolkit - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                ‚ò∞
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">üåô</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Lesson 8.3: Redux Toolkit</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Lesson Header -->
            <header>
                <h1>‚ö° Lesson 8.3: Redux Toolkit (RTK)</h1>
                <p class="lead">Welcome to modern Redux! Redux Toolkit has revolutionized how we use Redux by dramatically reducing boilerplate while maintaining all the power of Redux. If you've heard Redux is "too complex" or "too much code," RTK solves those problems. In this comprehensive lesson, you'll learn how to use Redux Toolkit to build scalable, maintainable state management for complex applications. We'll cover slices, async thunks, RTK Query, and TypeScript integration from the ground up.</p>
                
                <!-- Learning objectives -->
                <div class="card">
                    <h2>üéØ Learning Objectives</h2>
                    <p>By the end of this lesson, you will be able to:</p>
                    <ul>
                        <li>Understand Redux core concepts and when to use Redux vs other solutions</li>
                        <li>Install and configure Redux Toolkit in a React TypeScript project</li>
                        <li>Create type-safe slices with reducers and actions</li>
                        <li>Handle async operations with createAsyncThunk</li>
                        <li>Use RTK Query for powerful data fetching and caching</li>
                        <li>Integrate Redux DevTools for debugging</li>
                        <li>Write properly typed Redux code with TypeScript</li>
                        <li>Organize Redux code in a scalable way</li>
                        <li>Apply Redux Toolkit best practices</li>
                        <li>Compare Redux Toolkit with Zustand and Context</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 75-90 minutes</p>
                    <p><strong>Prerequisites:</strong> Lessons 8.1-8.2 (State Management Overview, Zustand Basics), Modules 1-5</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">üìë In This Lesson</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Understanding Redux and Redux Toolkit</a></li>
                        <li><a href="#section2" class="toc-link">Installation and Setup</a></li>
                        <li><a href="#section3" class="toc-link">Creating Your First Slice</a></li>
                        <li><a href="#section4" class="toc-link">Using Redux in Components</a></li>
                        <li><a href="#section5" class="toc-link">TypeScript Integration</a></li>
                        <li><a href="#section6" class="toc-link">Async Operations with createAsyncThunk</a></li>
                        <li><a href="#section7" class="toc-link">RTK Query</a></li>
                        <li><a href="#section8" class="toc-link">Best Practices</a></li>
                        <li><a href="#section9" class="toc-link">Summary</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Understanding Redux and Redux Toolkit -->
            <section id="section1" class="lesson-section">
                <h2>ü§î Understanding Redux and Redux Toolkit</h2>
                
                <p>Before diving into Redux Toolkit, let's understand what problems it solves and when you should use it.</p>

                <h3>What is Redux?</h3>

                <p>Redux is a predictable state container for JavaScript applications. It provides a centralized store for all application state with strict rules about how state can be updated.</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>Redux</strong> is a state management library based on the Flux architecture that uses a single, immutable state tree and pure reducer functions to handle state changes. <strong>Redux Toolkit (RTK)</strong> is the official, opinionated toolset for efficient Redux development that reduces boilerplate and enforces best practices.</p>
                </div>

                <h3>Core Redux Concepts</h3>

                <div class="mermaid">
graph LR
    A[Action Dispatched] --> B[Store]
    B --> C[Reducer]
    C --> D[New State]
    D --> B
    B --> E[UI Updates]
    E --> A
    
    style A fill:#e3f2fd
    style B fill:#c8e6c9
    style C fill:#fff3cd
    style D fill:#ffcdd2
    style E fill:#f0f0f0
</div>

                <p>Redux follows three fundamental principles:</p>

                <ol>
                    <li><strong>Single Source of Truth:</strong> The entire state of your application is stored in a single object tree within a single store</li>
                    <li><strong>State is Read-Only:</strong> The only way to change state is to dispatch an action, an object describing what happened</li>
                    <li><strong>Changes are Made with Pure Functions:</strong> Reducers are pure functions that take the previous state and an action, and return the next state</li>
                </ol>

                <h3>The Problem with Classic Redux</h3>

                <p>Traditional Redux requires a lot of boilerplate code:</p>

                <pre><code class="language-typescript">// Classic Redux - Too much boilerplate! üò´

// Action types
const INCREMENT = 'counter/INCREMENT';
const DECREMENT = 'counter/DECREMENT';
const SET_COUNT = 'counter/SET_COUNT';

// Action creators
function increment() {
  return { type: INCREMENT };
}

function decrement() {
  return { type: DECREMENT };
}

function setCount(count: number) {
  return { type: SET_COUNT, payload: count };
}

// Reducer
interface CounterState {
  value: number;
}

const initialState: CounterState = {
  value: 0
};

function counterReducer(
  state = initialState, 
  action: { type: string; payload?: any }
): CounterState {
  switch (action.type) {
    case INCREMENT:
      return { ...state, value: state.value + 1 };
    case DECREMENT:
      return { ...state, value: state.value - 1 };
    case SET_COUNT:
      return { ...state, value: action.payload };
    default:
      return state;
  }
}</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Problems with Classic Redux</h4>
                    <ul>
                        <li>Too much boilerplate for simple operations</li>
                        <li>Manual action type constants</li>
                        <li>Repetitive action creators</li>
                        <li>Verbose switch statements</li>
                        <li>Manual immutable updates with spread operators</li>
                        <li>Complex async logic setup</li>
                    </ul>
                </div>

                <h3>How Redux Toolkit Solves These Problems</h3>

                <p>Redux Toolkit reduces the same counter to just this:</p>

                <pre><code class="language-typescript">// Redux Toolkit - Clean and concise! üéâ

import { createSlice } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const initialState: CounterState = {
  value: 0
};

const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1; // Looks like mutation, but it's actually immutable!
    },
    decrement: (state) => {
      state.value -= 1;
    },
    setCount: (state, action) => {
      state.value = action.payload;
    }
  }
});

export const { increment, decrement, setCount } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Redux Toolkit Benefits</h4>
                    <ul>
                        <li><strong>Less Boilerplate:</strong> Drastically reduced code</li>
                        <li><strong>Immer Integration:</strong> Write "mutating" logic that's actually immutable</li>
                        <li><strong>Auto-Generated Actions:</strong> No manual action creators needed</li>
                        <li><strong>Built-in DevTools:</strong> Redux DevTools support out of the box</li>
                        <li><strong>TypeScript Support:</strong> Excellent type inference</li>
                        <li><strong>RTK Query:</strong> Powerful data fetching and caching</li>
                    </ul>
                </div>

                <h3>When to Use Redux Toolkit</h3>

                <p>Redux Toolkit is ideal when you need:</p>

                <table>
                    <thead>
                        <tr>
                            <th>Use Redux Toolkit When...</th>
                            <th>Consider Alternatives When...</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Complex, shared state across many components</td>
                            <td>Simple, local component state (use useState)</td>
                        </tr>
                        <tr>
                            <td>Predictable state updates with clear actions</td>
                            <td>Minimal state management needs (use Context)</td>
                        </tr>
                        <tr>
                            <td>Time-travel debugging and action history</td>
                            <td>Simpler API integration (use React Query)</td>
                        </tr>
                        <tr>
                            <td>Large team needing standardized patterns</td>
                            <td>Quick prototypes or small apps (use Zustand)</td>
                        </tr>
                        <tr>
                            <td>Middleware for complex side effects</td>
                            <td>Server-state only (use React Query/SWR)</td>
                        </tr>
                    </tbody>
                </table>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The Sweet Spot for Redux Toolkit</h4>
                    <p>RTK shines in medium-to-large applications with:</p>
                    <ul>
                        <li>Multiple features with interconnected state</li>
                        <li>Need for time-travel debugging</li>
                        <li>Complex state update logic</li>
                        <li>Team that values explicit, traceable state changes</li>
                        <li>Applications that will scale significantly</li>
                    </ul>
                </div>
            </section>

            <!-- Section 2: Installation and Setup -->
            <section id="section2" class="lesson-section">
                <h2>‚öôÔ∏è Installation and Setup</h2>
                
                <p>Let's get Redux Toolkit up and running in a React TypeScript project.</p>

                <h3>Installing Redux Toolkit</h3>

                <pre><code class="language-bash"># Install Redux Toolkit and React-Redux
npm install @reduxjs/toolkit react-redux

# For TypeScript projects, types are included!
# No need for @types packages</code></pre>

                <h3>Project Structure</h3>

                <p>Organize your Redux code in a scalable way:</p>

                <pre><code class="language-typescript">src/
  store/
    index.ts                 // Store configuration
    hooks.ts                 // Typed hooks (useAppDispatch, useAppSelector)
    
  features/
    auth/
      authSlice.ts          // Auth feature slice
      authAPI.ts            // Auth API calls (optional)
    
    cart/
      cartSlice.ts          // Shopping cart slice
      
    products/
      productsSlice.ts      // Products slice
      productsAPI.ts        // Products API with RTK Query
      
  components/
    auth/
      LoginForm.tsx         // Uses auth slice
    cart/
      CartSummary.tsx       // Uses cart slice</code></pre>

                <h3>Creating the Store</h3>

                <p>Set up the Redux store with TypeScript support:</p>

                <pre><code class="language-typescript">// src/store/index.ts

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';
import authReducer from '../features/auth/authSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    auth: authReducer,
    // Add more reducers here
  },
  // Redux Toolkit includes Redux DevTools by default in development!
});

// Infer the `RootState` and `AppDispatch` types from the store itself
export type RootState = ReturnType&lt;typeof store.getState&gt;;
export type AppDispatch = typeof store.dispatch;</code></pre>

                <h3>Creating Typed Hooks</h3>

                <p>Create pre-typed versions of Redux hooks for better TypeScript support:</p>

                <pre><code class="language-typescript">// src/store/hooks.ts

import { useDispatch, useSelector } from 'react-redux';
import type { TypedUseSelectorHook } from 'react-redux';
import type { RootState, AppDispatch } from './index';

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch: () => AppDispatch = useDispatch;
export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Why Custom Hooks?</h4>
                    <p>Using <code>useAppDispatch</code> and <code>useAppSelector</code> instead of the plain Redux hooks gives you:</p>
                    <ul>
                        <li>Full TypeScript autocomplete for your state shape</li>
                        <li>Type-safe dispatch of actions</li>
                        <li>Compile-time errors for invalid selectors</li>
                        <li>No need to manually type selectors</li>
                    </ul>
                </div>

                <h3>Providing the Store</h3>

                <p>Wrap your app with the Redux Provider:</p>

                <pre><code class="language-typescript">// src/main.tsx (or App.tsx)

import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { store } from './store';
import App from './App';

ReactDOM.createRoot(document.getElementById('root')!).render(
  &lt;React.StrictMode&gt;
    &lt;Provider store={store}&gt;
      &lt;App /&gt;
    &lt;/Provider&gt;
  &lt;/React.StrictMode&gt;
);</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Redux DevTools</h4>
                    <p>Redux Toolkit includes Redux DevTools Extension support by default. Install the browser extension to see:</p>
                    <ul>
                        <li>All dispatched actions</li>
                        <li>State before and after each action</li>
                        <li>Time-travel debugging (replay actions)</li>
                        <li>State diff visualization</li>
                        <li>Action stack traces</li>
                    </ul>
                    <p><a href="https://github.com/reduxjs/redux-devtools" target="_blank" rel="noopener noreferrer">Install Redux DevTools ‚Üí</a></p>
                </div>
            </section>

            <!-- Section 3: Creating Your First Slice -->
            <section id="section3" class="lesson-section">
                <h2>üç∞ Creating Your First Slice</h2>
                
                <p>A "slice" is a collection of Redux reducer logic and actions for a single feature. Let's build a complete counter feature to understand all the concepts.</p>

                <h3>Basic Slice Structure</h3>

                <pre><code class="language-typescript">// src/features/counter/counterSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

// Define the shape of the state
interface CounterState {
  value: number;
  step: number;
}

// Define the initial state
const initialState: CounterState = {
  value: 0,
  step: 1
};

// Create the slice
const counterSlice = createSlice({
  name: 'counter', // Used to generate action types
  initialState,
  reducers: {
    // Reducer with no payload
    increment: (state) => {
      // Immer makes this safe!
      state.value += state.step;
    },
    
    // Reducer with no payload
    decrement: (state) => {
      state.value -= state.step;
    },
    
    // Reducer with payload
    incrementByAmount: (state, action: PayloadAction&lt;number&gt;) => {
      state.value += action.payload;
    },
    
    // Reducer to update step
    setStep: (state, action: PayloadAction&lt;number&gt;) => {
      state.step = action.payload;
    },
    
    // Reducer to reset state
    reset: (state) => {
      state.value = 0;
      state.step = 1;
    }
  }
});

// Export actions (automatically generated)
export const { 
  increment, 
  decrement, 
  incrementByAmount, 
  setStep, 
  reset 
} = counterSlice.actions;

// Export reducer
export default counterSlice.reducer;</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Understanding PayloadAction</h4>
                    <p style="color: white;"><strong>PayloadAction&lt;T&gt;</strong> is a TypeScript type from Redux Toolkit that represents an action with a typed payload. When you define <code>action: PayloadAction&lt;number&gt;</code>, you're saying "this action carries a number as its payload."</p>
                </div>

                <h3>How Immer Works</h3>

                <p>Redux Toolkit uses Immer internally, which allows you to write code that looks like it's mutating state, but actually produces immutable updates:</p>

                <pre><code class="language-typescript">// ‚ùå Without Immer (Classic Redux) - Manual immutability
function increment(state: CounterState): CounterState {
  return {
    ...state,
    value: state.value + state.step
  };
}

// ‚úÖ With Immer (Redux Toolkit) - Simpler "mutable" style
function increment(state: CounterState) {
  state.value += state.step;
  // Immer tracks changes and produces a new immutable state
}</code></pre>

                <h3>Adding the Slice to the Store</h3>

                <pre><code class="language-typescript">// src/store/index.ts

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer, // Key determines how you access state
  }
});

export type RootState = ReturnType&lt;typeof store.getState&gt;;
// RootState will be: { counter: CounterState }

export type AppDispatch = typeof store.dispatch;</code></pre>

                <h3>Complex State Updates</h3>

                <p>Immer handles nested objects and arrays beautifully:</p>

                <pre><code class="language-typescript">// src/features/todos/todosSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodosState {
  items: Todo[];
  filter: 'all' | 'active' | 'completed';
}

const initialState: TodosState = {
  items: [],
  filter: 'all'
};

const todosSlice = createSlice({
  name: 'todos',
  initialState,
  reducers: {
    addTodo: (state, action: PayloadAction&lt;string&gt;) => {
      // Immer lets us push to arrays!
      state.items.push({
        id: Date.now().toString(),
        text: action.payload,
        completed: false
      });
    },
    
    toggleTodo: (state, action: PayloadAction&lt;string&gt;) => {
      // Find and "mutate" - Immer handles immutability
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    
    removeTodo: (state, action: PayloadAction&lt;string&gt;) => {
      // Filter works too
      state.items = state.items.filter(t => t.id !== action.payload);
    },
    
    setFilter: (state, action: PayloadAction&lt;'all' | 'active' | 'completed'&gt;) => {
      state.filter = action.payload;
    }
  }
});

export const { addTodo, toggleTodo, removeTodo, setFilter } = todosSlice.actions;
export default todosSlice.reducer;</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Immer Limitations</h4>
                    <p>Immer is powerful, but has a few rules:</p>
                    <ul>
                        <li>You must either mutate the <code>state</code> directly OR return a new state, not both</li>
                        <li>Cannot reassign the entire <code>state</code> parameter (use <code>return newState</code> instead)</li>
                        <li>Doesn't work with non-plain objects (class instances)</li>
                    </ul>
                    <pre><code class="language-typescript">// ‚ùå Bad: Both mutating AND returning
reducers: {
  bad: (state) => {
    state.value = 5;
    return { value: 10 }; // DON'T DO THIS!
  }
}

// ‚úÖ Good: Either mutate...
reducers: {
  good1: (state) => {
    state.value = 5;
  },
  
  // ...OR return new state
  good2: (state) => {
    return { value: 10 };
  }
}</code></pre>
                </div>
            </section>

            <!-- Section 4: Using Redux in Components -->
            <section id="section4" class="lesson-section">
                <h2>‚öõÔ∏è Using Redux in Components</h2>
                
                <p>Now let's use our Redux slices in React components with full TypeScript support.</p>

                <h3>Reading State with useAppSelector</h3>

                <pre><code class="language-typescript">// src/components/Counter.tsx

import { useAppSelector } from '../../store/hooks';

function Counter() {
  // Select state from the store
  const count = useAppSelector((state) => state.counter.value);
  const step = useAppSelector((state) => state.counter.step);
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      &lt;p&gt;Step: {step}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Dispatching Actions with useAppDispatch</h3>

                <pre><code class="language-typescript">// src/components/CounterControls.tsx

import { useAppDispatch, useAppSelector } from '../../store/hooks';
import { 
  increment, 
  decrement, 
  incrementByAmount, 
  reset 
} from '../../features/counter/counterSlice';

function CounterControls() {
  const dispatch = useAppDispatch();
  const count = useAppSelector((state) => state.counter.value);
  
  return (
    &lt;div&gt;
      &lt;h2&gt;Count: {count}&lt;/h2&gt;
      
      &lt;button onClick={() => dispatch(increment())}&gt;
        +1
      &lt;/button&gt;
      
      &lt;button onClick={() => dispatch(decrement())}&gt;
        -1
      &lt;/button&gt;
      
      &lt;button onClick={() => dispatch(incrementByAmount(5))}&gt;
        +5
      &lt;/button&gt;
      
      &lt;button onClick={() => dispatch(reset())}&gt;
        Reset
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Selecting Multiple Values</h3>

                <pre><code class="language-typescript">// Option 1: Multiple selectors (best for performance)
function TodoList() {
  const todos = useAppSelector((state) => state.todos.items);
  const filter = useAppSelector((state) => state.todos.filter);
  
  // Component only re-renders when todos or filter change
}

// Option 2: Single selector returning object (re-renders if ANY field changes)
function TodoList() {
  const { items, filter } = useAppSelector((state) => ({
    items: state.todos.items,
    filter: state.todos.filter
  }));
  
  // Re-renders even if object contents are the same (new object reference)
}</code></pre>

                <h3>Creating Selector Functions</h3>

                <p>For reusable, computed selectors:</p>

                <pre><code class="language-typescript">// src/features/todos/todosSlice.ts

// ... slice definition ...

// Selector functions
export const selectAllTodos = (state: RootState) => state.todos.items;

export const selectActiveTodos = (state: RootState) =>
  state.todos.items.filter(todo => !todo.completed);

export const selectCompletedTodos = (state: RootState) =>
  state.todos.items.filter(todo => todo.completed);

export const selectFilteredTodos = (state: RootState) => {
  const { items, filter } = state.todos;
  
  switch (filter) {
    case 'active':
      return items.filter(t => !t.completed);
    case 'completed':
      return items.filter(t => t.completed);
    default:
      return items;
  }
};

// Usage in components
import { useAppSelector } from '../../store/hooks';
import { selectFilteredTodos } from './todosSlice';

function TodoList() {
  const filteredTodos = useAppSelector(selectFilteredTodos);
  
  return (
    &lt;ul&gt;
      {filteredTodos.map(todo => (
        &lt;TodoItem key={todo.id} todo={todo} /&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of Selector Functions</h4>
                    <ul>
                        <li><strong>Reusability:</strong> Use the same selector in multiple components</li>
                        <li><strong>Testability:</strong> Easy to test selectors independently</li>
                        <li><strong>Maintainability:</strong> Change selector logic in one place</li>
                        <li><strong>Encapsulation:</strong> Hide state structure details</li>
                        <li><strong>Performance:</strong> Can be memoized with Reselect</li>
                    </ul>
                </div>

                <h3>Complete Todo Example</h3>

                <pre><code class="language-typescript">// src/components/TodoApp.tsx

import React, { useState } from 'react';
import { useAppDispatch, useAppSelector } from '../../store/hooks';
import {
  addTodo,
  toggleTodo,
  removeTodo,
  setFilter,
  selectFilteredTodos
} from '../../features/todos/todosSlice';

function TodoApp() {
  const dispatch = useAppDispatch();
  const filteredTodos = useAppSelector(selectFilteredTodos);
  const filter = useAppSelector((state) => state.todos.filter);
  const [inputText, setInputText] = useState('');
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (inputText.trim()) {
      dispatch(addTodo(inputText));
      setInputText('');
    }
  };
  
  return (
    &lt;div&gt;
      &lt;h1&gt;Todo List&lt;/h1&gt;
      
      &lt;form onSubmit={handleSubmit}&gt;
        &lt;input
          type="text"
          value={inputText}
          onChange={(e) => setInputText(e.target.value)}
          placeholder="Add a todo..."
        /&gt;
        &lt;button type="submit"&gt;Add&lt;/button&gt;
      &lt;/form&gt;
      
      &lt;div&gt;
        &lt;button 
          onClick={() => dispatch(setFilter('all'))}
          disabled={filter === 'all'}
        &gt;
          All
        &lt;/button&gt;
        &lt;button 
          onClick={() => dispatch(setFilter('active'))}
          disabled={filter === 'active'}
        &gt;
          Active
        &lt;/button&gt;
        &lt;button 
          onClick={() => dispatch(setFilter('completed'))}
          disabled={filter === 'completed'}
        &gt;
          Completed
        &lt;/button&gt;
      &lt;/div&gt;
      
      &lt;ul&gt;
        {filteredTodos.map(todo => (
          &lt;li key={todo.id}&gt;
            &lt;input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch(toggleTodo(todo.id))}
            /&gt;
            &lt;span 
              style={{ 
                textDecoration: todo.completed ? 'line-through' : 'none' 
              }}
            &gt;
              {todo.text}
            &lt;/span&gt;
            &lt;button onClick={() => dispatch(removeTodo(todo.id))}&gt;
              Delete
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

export default TodoApp;</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Component Best Practices</h4>
                    <ul>
                        <li>Use <code>useAppSelector</code> and <code>useAppDispatch</code> instead of plain Redux hooks</li>
                        <li>Select only the data you need (avoid selecting entire slices)</li>
                        <li>Extract selector logic into selector functions for reusability</li>
                        <li>Dispatch actions rather than calling action creators directly</li>
                        <li>Keep local UI state in <code>useState</code>, only put shared state in Redux</li>
                    </ul>
                </div>
            </section>
            <!-- Section 5: TypeScript Integration -->
            <section id="section5" class="lesson-section">
                <h2>üìò TypeScript Integration</h2>
                
                <p>Redux Toolkit has excellent TypeScript support built-in. Let's explore advanced typing patterns to make your Redux code fully type-safe.</p>

                <h3>Typing the Store</h3>

                <p>We already created typed hooks, but let's understand the types in depth:</p>

                <pre><code class="language-typescript">// src/store/index.ts

import { configureStore } from '@reduxjs/toolkit';
import counterReducer from '../features/counter/counterSlice';
import todosReducer from '../features/todos/todosSlice';
import authReducer from '../features/auth/authSlice';

export const store = configureStore({
  reducer: {
    counter: counterReducer,
    todos: todosReducer,
    auth: authReducer
  }
});

// Extract the root state type from the store
export type RootState = ReturnType&lt;typeof store.getState&gt;;
// RootState = {
//   counter: CounterState,
//   todos: TodosState,
//   auth: AuthState
// }

// Extract the dispatch type
export type AppDispatch = typeof store.dispatch;

// Optional: Extract store type itself
export type AppStore = typeof store;</code></pre>

                <h3>Typing Slices with Prepare Callbacks</h3>

                <p>Sometimes you need to transform or add metadata to actions. Use prepare callbacks:</p>

                <pre><code class="language-typescript">// src/features/posts/postsSlice.ts

import { createSlice, PayloadAction, nanoid } from '@reduxjs/toolkit';

interface Post {
  id: string;
  title: string;
  content: string;
  createdAt: string;
}

interface PostsState {
  posts: Post[];
}

const initialState: PostsState = {
  posts: []
};

const postsSlice = createSlice({
  name: 'posts',
  initialState,
  reducers: {
    // Simple action - RTK generates the prepare function
    addPost: {
      // Reducer function
      reducer: (state, action: PayloadAction&lt;Post&gt;) => {
        state.posts.push(action.payload);
      },
      // Prepare function - transforms arguments into payload
      prepare: (title: string, content: string) => {
        return {
          payload: {
            id: nanoid(), // Generate unique ID
            title,
            content,
            createdAt: new Date().toISOString()
          }
        };
      }
    },
    
    // You can also add metadata
    postUpdated: {
      reducer: (state, action: PayloadAction&lt;Post, string, { updatedAt: string }&gt;) => {
        const index = state.posts.findIndex(p => p.id === action.payload.id);
        if (index !== -1) {
          state.posts[index] = action.payload;
        }
      },
      prepare: (post: Post) => {
        return {
          payload: post,
          meta: {
            updatedAt: new Date().toISOString()
          }
        };
      }
    }
  }
});

export const { addPost, postUpdated } = postsSlice.actions;
export default postsSlice.reducer;

// Usage in component
function CreatePost() {
  const dispatch = useAppDispatch();
  
  const handleSubmit = (title: string, content: string) => {
    // ID and timestamp added automatically!
    dispatch(addPost(title, content));
  };
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Understanding Prepare Callbacks</h4>
                    <p style="color: white;"><strong>Prepare callbacks</strong> let you customize how action payloads are created. They're useful for generating IDs, adding timestamps, or transforming multiple arguments into a single payload object. The prepare function returns an object with <code>payload</code> and optionally <code>meta</code> and <code>error</code>.</p>
                </div>

                <h3>Typing Action Creators</h3>

                <p>Action creators generated by createSlice are fully typed:</p>

                <pre><code class="language-typescript">import { addTodo, toggleTodo } from './todosSlice';

// Action creators have proper types
const action1 = addTodo('Learn Redux');
// type: { type: 'todos/addTodo', payload: string }

const action2 = toggleTodo('todo-id-123');
// type: { type: 'todos/toggleTodo', payload: string }

// TypeScript error if wrong payload type
const action3 = addTodo(123); // ‚ùå Error: number not assignable to string</code></pre>

                <h3>Typing Selectors</h3>

                <p>Create strongly-typed selectors:</p>

                <pre><code class="language-typescript">// src/features/todos/todosSelectors.ts

import { RootState } from '../../store';
import { createSelector } from '@reduxjs/toolkit';

// Basic selector with explicit typing
export const selectTodos = (state: RootState) => state.todos.items;

export const selectFilter = (state: RootState) => state.todos.filter;

// Memoized selector with createSelector
export const selectFilteredTodos = createSelector(
  [selectTodos, selectFilter],
  (todos, filter) => {
    switch (filter) {
      case 'active':
        return todos.filter(t => !t.completed);
      case 'completed':
        return todos.filter(t => t.completed);
      default:
        return todos;
    }
  }
);

// Selector with parameter
export const selectTodoById = (state: RootState, todoId: string) =>
  state.todos.items.find(todo => todo.id === todoId);

// Memoized parametric selector
export const makeSelectTodoById = () =>
  createSelector(
    [selectTodos, (_state: RootState, todoId: string) => todoId],
    (todos, todoId) => todos.find(todo => todo.id === todoId)
  );</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Benefits of createSelector</h4>
                    <p>Redux Toolkit re-exports <code>createSelector</code> from Reselect. It provides:</p>
                    <ul>
                        <li><strong>Memoization:</strong> Only recalculates when inputs change</li>
                        <li><strong>Composition:</strong> Build complex selectors from simple ones</li>
                        <li><strong>Performance:</strong> Prevents unnecessary recalculations</li>
                        <li><strong>Type Safety:</strong> Input and output types are inferred</li>
                    </ul>
                </div>

                <h3>Typing Middleware</h3>

                <p>If you add custom middleware, type it properly:</p>

                <pre><code class="language-typescript">// src/store/middleware/logger.ts

import { Middleware } from '@reduxjs/toolkit';
import { RootState } from '../index';

export const loggerMiddleware: Middleware&lt;{}, RootState&gt; = 
  (storeAPI) => (next) => (action) => {
    console.log('Dispatching:', action);
    console.log('Current state:', storeAPI.getState());
    
    const result = next(action);
    
    console.log('Next state:', storeAPI.getState());
    return result;
  };

// Add to store
export const store = configureStore({
  reducer: {
    // ... reducers
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(loggerMiddleware)
});</code></pre>

                <h3>Typing Extra Reducers</h3>

                <p>When handling actions from other slices or async thunks, use extraReducers:</p>

                <pre><code class="language-typescript">// src/features/notifications/notificationsSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { addTodo, toggleTodo } from '../todos/todosSlice';

interface Notification {
  id: string;
  message: string;
  type: 'info' | 'success' | 'error';
}

interface NotificationsState {
  notifications: Notification[];
}

const initialState: NotificationsState = {
  notifications: []
};

const notificationsSlice = createSlice({
  name: 'notifications',
  initialState,
  reducers: {
    addNotification: (state, action: PayloadAction&lt;Notification&gt;) => {
      state.notifications.push(action.payload);
    },
    removeNotification: (state, action: PayloadAction&lt;string&gt;) => {
      state.notifications = state.notifications.filter(
        n => n.id !== action.payload
      );
    }
  },
  extraReducers: (builder) => {
    // Listen to actions from other slices
    builder
      .addCase(addTodo, (state) => {
        state.notifications.push({
          id: Date.now().toString(),
          message: 'Todo added successfully!',
          type: 'success'
        });
      })
      .addCase(toggleTodo, (state) => {
        state.notifications.push({
          id: Date.now().toString(),
          message: 'Todo status updated!',
          type: 'info'
        });
      });
  }
});

export const { addNotification, removeNotification } = notificationsSlice.actions;
export default notificationsSlice.reducer;</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° When to Use extraReducers</h4>
                    <p>Use <code>extraReducers</code> when you need to:</p>
                    <ul>
                        <li>Respond to actions defined in other slices</li>
                        <li>Handle async thunk actions (pending, fulfilled, rejected)</li>
                        <li>Cross-slice communication</li>
                        <li>Side effects triggered by actions from elsewhere</li>
                    </ul>
                </div>

                <h3>Generic Slice Patterns</h3>

                <p>Create reusable slice factories with generics:</p>

                <pre><code class="language-typescript">// src/store/genericSlice.ts

import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface LoadingState&lt;T&gt; {
  data: T | null;
  isLoading: boolean;
  error: string | null;
}

function createLoadingSlice&lt;T&gt;(name: string) {
  const initialState: LoadingState&lt;T&gt; = {
    data: null,
    isLoading: false,
    error: null
  };

  return createSlice({
    name,
    initialState,
    reducers: {
      startLoading: (state) => {
        state.isLoading = true;
        state.error = null;
      },
      loadSuccess: (state, action: PayloadAction&lt;T&gt;) => {
        state.data = action.payload;
        state.isLoading = false;
        state.error = null;
      },
      loadFailure: (state, action: PayloadAction&lt;string&gt;) => {
        state.isLoading = false;
        state.error = action.payload;
      },
      reset: (state) => {
        state.data = null;
        state.isLoading = false;
        state.error = null;
      }
    }
  });
}

// Usage
interface User {
  id: string;
  name: string;
  email: string;
}

interface Product {
  id: string;
  name: string;
  price: number;
}

const userSlice = createLoadingSlice&lt;User&gt;('user');
const productsSlice = createLoadingSlice&lt;Product[]&gt;('products');

export const userActions = userSlice.actions;
export const productsActions = productsSlice.actions;</code></pre>

                <h3>Strict Typing for Action Matchers</h3>

                <p>Use type guards and matchers for complex scenarios:</p>

                <pre><code class="language-typescript">import { 
  createSlice, 
  isAnyOf, 
  isPending, 
  isFulfilled, 
  isRejected 
} from '@reduxjs/toolkit';
import { fetchUser, updateUser, deleteUser } from './userThunks';

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    // Match multiple actions at once
    builder
      .addMatcher(
        isAnyOf(fetchUser.pending, updateUser.pending, deleteUser.pending),
        (state) => {
          state.isLoading = true;
        }
      )
      .addMatcher(
        isAnyOf(fetchUser.fulfilled, updateUser.fulfilled),
        (state, action) => {
          state.user = action.payload;
          state.isLoading = false;
        }
      )
      .addMatcher(
        isAnyOf(fetchUser.rejected, updateUser.rejected, deleteUser.rejected),
        (state, action) => {
          state.error = action.error.message || 'Something went wrong';
          state.isLoading = false;
        }
      );
  }
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è TypeScript Best Practices</h4>
                    <ul>
                        <li>Always define state interfaces before creating slices</li>
                        <li>Use <code>PayloadAction&lt;T&gt;</code> for typed action payloads</li>
                        <li>Extract <code>RootState</code> and <code>AppDispatch</code> types</li>
                        <li>Create typed hooks (<code>useAppSelector</code>, <code>useAppDispatch</code>)</li>
                        <li>Use <code>createSelector</code> for memoized, typed selectors</li>
                        <li>Leverage TypeScript's inference - don't over-annotate</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Async Operations with createAsyncThunk -->
            <section id="section6" class="lesson-section">
                <h2>‚è≥ Async Operations with createAsyncThunk</h2>
                
                <p>Most real applications need to fetch data from APIs. Redux Toolkit provides <code>createAsyncThunk</code> to handle async logic with automatic action creators for pending, fulfilled, and rejected states.</p>

                <h3>Understanding createAsyncThunk</h3>

                <div class="mermaid">
graph LR
    A[Dispatch Thunk] --> B[Pending Action]
    B --> C[Async Function]
    C --> D{Success?}
    D -->|Yes| E[Fulfilled Action]
    D -->|No| F[Rejected Action]
    E --> G[Update State]
    F --> G
    
    style A fill:#e3f2fd
    style B fill:#fff3cd
    style C fill:#e3f2fd
    style D fill:#f0f0f0
    style E fill:#c8e6c9
    style F fill:#ffcdd2
    style G fill:#c8e6c9
</div>

                <p>When you create an async thunk, Redux Toolkit automatically generates three action types:</p>
                <ul>
                    <li><code>pending</code>: Dispatched immediately when thunk is called</li>
                    <li><code>fulfilled</code>: Dispatched when promise resolves successfully</li>
                    <li><code>rejected</code>: Dispatched when promise rejects or throws error</li>
                </ul>

                <h3>Basic Async Thunk</h3>

                <pre><code class="language-typescript">// src/features/users/usersSlice.ts

import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';

interface User {
  id: string;
  name: string;
  email: string;
}

interface UsersState {
  users: User[];
  isLoading: boolean;
  error: string | null;
}

const initialState: UsersState = {
  users: [],
  isLoading: false,
  error: null
};

// Create async thunk
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers', // Action type prefix
  async () => {
    const response = await fetch('https://api.example.com/users');
    
    if (!response.ok) {
      throw new Error('Failed to fetch users');
    }
    
    const data = await response.json();
    return data as User[]; // This becomes the 'fulfilled' action payload
  }
);

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      // Handle pending state
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      // Handle fulfilled state
      .addCase(fetchUsers.fulfilled, (state, action: PayloadAction&lt;User[]&gt;) => {
        state.users = action.payload;
        state.isLoading = false;
      })
      // Handle rejected state
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.error.message || 'Failed to fetch users';
      });
  }
});

export default usersSlice.reducer;</code></pre>

                <h3>Using Async Thunks in Components</h3>

                <pre><code class="language-typescript">// src/components/UserList.tsx

import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../../store/hooks';
import { fetchUsers } from '../../features/users/usersSlice';

function UserList() {
  const dispatch = useAppDispatch();
  const { users, isLoading, error } = useAppSelector((state) => state.users);
  
  useEffect(() => {
    // Dispatch the async thunk
    dispatch(fetchUsers());
  }, [dispatch]);
  
  if (isLoading) {
    return &lt;div&gt;Loading users...&lt;/div&gt;;
  }
  
  if (error) {
    return &lt;div&gt;Error: {error}&lt;/div&gt;;
  }
  
  return (
    &lt;ul&gt;
      {users.map(user => (
        &lt;li key={user.id}&gt;
          {user.name} - {user.email}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}</code></pre>

                <h3>Async Thunks with Arguments</h3>

                <pre><code class="language-typescript">// Fetch a single user by ID
export const fetchUserById = createAsyncThunk(
  'users/fetchUserById',
  async (userId: string) => {
    const response = await fetch(`https://api.example.com/users/${userId}`);
    
    if (!response.ok) {
      throw new Error('User not found');
    }
    
    return await response.json() as User;
  }
);

// Create a new user
export const createUser = createAsyncThunk(
  'users/createUser',
  async (userData: Omit&lt;User, 'id'&gt;) => {
    const response = await fetch('https://api.example.com/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    
    if (!response.ok) {
      throw new Error('Failed to create user');
    }
    
    return await response.json() as User;
  }
);

// Update existing user
export const updateUser = createAsyncThunk(
  'users/updateUser',
  async ({ id, updates }: { id: string; updates: Partial&lt;User&gt; }) => {
    const response = await fetch(`https://api.example.com/users/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(updates)
    });
    
    if (!response.ok) {
      throw new Error('Failed to update user');
    }
    
    return await response.json() as User;
  }
);

// Delete user
export const deleteUser = createAsyncThunk(
  'users/deleteUser',
  async (userId: string) => {
    const response = await fetch(`https://api.example.com/users/${userId}`, {
      method: 'DELETE'
    });
    
    if (!response.ok) {
      throw new Error('Failed to delete user');
    }
    
    return userId; // Return the deleted user's ID
  }
);</code></pre>

                <h3>Handling All CRUD Operations</h3>

                <pre><code class="language-typescript">// Complete users slice with CRUD operations

const usersSlice = createSlice({
  name: 'users',
  initialState,
  reducers: {
    // Synchronous actions if needed
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    builder
      // Fetch all users
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.users = action.payload;
        state.isLoading = false;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.error.message || 'Failed to fetch users';
      })
      
      // Create user
      .addCase(createUser.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(createUser.fulfilled, (state, action) => {
        state.users.push(action.payload);
        state.isLoading = false;
      })
      .addCase(createUser.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.error.message || 'Failed to create user';
      })
      
      // Update user
      .addCase(updateUser.fulfilled, (state, action) => {
        const index = state.users.findIndex(u => u.id === action.payload.id);
        if (index !== -1) {
          state.users[index] = action.payload;
        }
      })
      
      // Delete user
      .addCase(deleteUser.fulfilled, (state, action) => {
        state.users = state.users.filter(u => u.id !== action.payload);
      });
  }
});

export const { clearError } = usersSlice.actions;
export default usersSlice.reducer;</code></pre>

                <h3>Custom Error Handling</h3>

                <pre><code class="language-typescript">// Thunk with custom error handling
export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async (_, { rejectWithValue }) => {
    try {
      const response = await fetch('https://api.example.com/users');
      
      if (!response.ok) {
        // Return custom error
        return rejectWithValue({
          message: 'Failed to fetch users',
          status: response.status
        });
      }
      
      return await response.json() as User[];
    } catch (error) {
      // Handle network errors
      if (error instanceof Error) {
        return rejectWithValue({
          message: error.message,
          status: 0
        });
      }
      
      return rejectWithValue({
        message: 'Unknown error occurred',
        status: 0
      });
    }
  }
);

// Handle in reducer
.addCase(fetchUsers.rejected, (state, action) => {
  state.isLoading = false;
  
  if (action.payload) {
    // Custom error from rejectWithValue
    state.error = `Error ${action.payload.status}: ${action.payload.message}`;
  } else {
    // Standard error
    state.error = action.error.message || 'Failed to fetch users';
  }
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ createAsyncThunk Best Practices</h4>
                    <ul>
                        <li>Use <code>rejectWithValue</code> for custom error payloads</li>
                        <li>Always handle pending, fulfilled, and rejected states</li>
                        <li>Use TypeScript generics for payload and return types</li>
                        <li>Extract API calls to separate service files</li>
                        <li>Use thunkAPI for accessing state, dispatch, etc.</li>
                        <li>Add loading indicators for better UX</li>
                    </ul>
                </div>

                <h3>Accessing State and Dispatch in Thunks</h3>

                <p>The thunkAPI provides access to store state, dispatch, and more:</p>

                <pre><code class="language-typescript">export const conditionalFetch = createAsyncThunk(
  'users/conditionalFetch',
  async (_, { getState, dispatch, rejectWithValue }) => {
    const state = getState() as RootState;
    
    // Only fetch if not already loaded
    if (state.users.users.length > 0) {
      return state.users.users;
    }
    
    try {
      const response = await fetch('https://api.example.com/users');
      
      if (!response.ok) {
        throw new Error('Fetch failed');
      }
      
      const users = await response.json();
      
      // Dispatch another action if needed
      dispatch(someOtherAction());
      
      return users as User[];
    } catch (error) {
      return rejectWithValue('Failed to fetch');
    }
  }
);</code></pre>

                <h3>Canceling Thunks</h3>

                <pre><code class="language-typescript">// In component
function UserList() {
  const dispatch = useAppDispatch();
  
  useEffect(() => {
    // Dispatch returns a promise with an abort method
    const promise = dispatch(fetchUsers());
    
    // Cancel on unmount
    return () => {
      promise.abort();
    };
  }, [dispatch]);
}</code></pre>

                <h3>Sequential and Parallel Thunks</h3>

                <pre><code class="language-typescript">// Sequential: Wait for one before starting the next
async function loadUserData(userId: string) {
  const dispatch = useAppDispatch();
  
  try {
    // Wait for user to load
    const user = await dispatch(fetchUserById(userId)).unwrap();
    
    // Then load their posts
    await dispatch(fetchUserPosts(user.id)).unwrap();
    
    // Then load their comments
    await dispatch(fetchUserComments(user.id)).unwrap();
  } catch (error) {
    console.error('Failed to load user data:', error);
  }
}

// Parallel: Start all at once
async function loadDashboardData() {
  const dispatch = useAppDispatch();
  
  try {
    // Start all requests simultaneously
    await Promise.all([
      dispatch(fetchUsers()).unwrap(),
      dispatch(fetchPosts()).unwrap(),
      dispatch(fetchComments()).unwrap()
    ]);
  } catch (error) {
    console.error('Failed to load dashboard:', error);
  }
}</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° The unwrap() Method</h4>
                    <p>Calling <code>.unwrap()</code> on the returned promise gives you:</p>
                    <ul>
                        <li>The fulfilled payload directly (no action wrapper)</li>
                        <li>A thrown error if the thunk was rejected</li>
                        <li>Ability to use try-catch for error handling</li>
                        <li>Better TypeScript inference for the result</li>
                    </ul>
                    <pre><code class="language-typescript">try {
  const user = await dispatch(fetchUser(id)).unwrap();
  // user is typed as User, not PayloadAction&lt;User&gt;
  console.log(user.name);
} catch (error) {
  // Handle error
  console.error('Failed:', error);
}</code></pre>
                </div>
            </section>

            <!-- Section 7: RTK Query (Beginning) -->
            <section id="section7" class="lesson-section">
                <h2>üöÄ RTK Query</h2>
                
                <p>RTK Query is Redux Toolkit's powerful data fetching and caching solution. It's like React Query, but integrated directly into Redux with automatic cache management, optimistic updates, and more.</p>

                <h3>Why RTK Query?</h3>

                <p>RTK Query solves common problems in data fetching:</p>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üìñ Definition</h4>
                    <p style="color: white;"><strong>RTK Query</strong> is a data fetching and caching tool built into Redux Toolkit. It automatically manages loading states, caching, invalidation, and refetching, eliminating the need for hand-written async thunks for most data fetching scenarios.</p>
                </div>

                <table>
                    <thead>
                        <tr>
                            <th>Without RTK Query</th>
                            <th>With RTK Query</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Manually write thunks for each endpoint</td>
                            <td>Define endpoints once, hooks generated automatically</td>
                        </tr>
                        <tr>
                            <td>Manage loading states yourself</td>
                            <td>Loading states provided automatically</td>
                        </tr>
                        <tr>
                            <td>Handle caching manually</td>
                            <td>Automatic caching and invalidation</td>
                        </tr>
                        <tr>
                            <td>Write refetch logic</td>
                            <td>Automatic refetching and polling</td>
                        </tr>
                        <tr>
                            <td>Complex optimistic updates</td>
                            <td>Built-in optimistic update helpers</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Setting Up RTK Query</h3>

                <pre><code class="language-typescript">// src/services/api.ts

import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

interface User {
  id: string;
  name: string;
  email: string;
}

interface Post {
  id: string;
  userId: string;
  title: string;
  body: string;
}

// Define API slice
export const api = createApi({
  reducerPath: 'api', // The key in the Redux store
  baseQuery: fetchBaseQuery({ 
    baseUrl: 'https://jsonplaceholder.typicode.com' 
  }),
  tagTypes: ['User', 'Post'], // For cache invalidation
  endpoints: (builder) => ({
    // Query endpoints (GET requests)
    getUsers: builder.query&lt;User[], void&gt;({
      query: () => '/users',
      providesTags: ['User'] // This data is tagged as 'User'
    }),
    
    getUserById: builder.query&lt;User, string&gt;({
      query: (id) => `/users/${id}`,
      providesTags: (result, error, id) => [{ type: 'User', id }]
    }),
    
    getPosts: builder.query&lt;Post[], void&gt;({
      query: () => '/posts',
      providesTags: ['Post']
    }),
    
    // Mutation endpoints (POST, PUT, DELETE)
    createUser: builder.mutation&lt;User, Omit&lt;User, 'id'&gt;&gt;({
      query: (newUser) => ({
        url: '/users',
        method: 'POST',
        body: newUser
      }),
      invalidatesTags: ['User'] // Invalidate User cache after creating
    }),
    
    updateUser: builder.mutation&lt;User, { id: string; updates: Partial&lt;User&gt; }&gt;({
      query: ({ id, updates }) => ({
        url: `/users/${id}`,
        method: 'PATCH',
        body: updates
      }),
      invalidatesTags: (result, error, { id }) => [{ type: 'User', id }]
    }),
    
    deleteUser: builder.mutation&lt;void, string&gt;({
      query: (id) => ({
        url: `/users/${id}`,
        method: 'DELETE'
      }),
      invalidatesTags: ['User']
    })
  })
});

// Export hooks - automatically generated!
export const {
  useGetUsersQuery,
  useGetUserByIdQuery,
  useGetPostsQuery,
  useCreateUserMutation,
  useUpdateUserMutation,
  useDeleteUserMutation
} = api;</code></pre>

                <h3>Adding API to Store</h3>

                <pre><code class="language-typescript">// src/store/index.ts

import { configureStore } from '@reduxjs/toolkit';
import { api } from '../services/api';
import counterReducer from '../features/counter/counterSlice';

export const store = configureStore({
  reducer: {
    // Add the API reducer
    [api.reducerPath]: api.reducer,
    counter: counterReducer,
    // ... other reducers
  },
  // Add the API middleware
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(api.middleware)
});

export type RootState = ReturnType&lt;typeof store.getState&gt;;
export type AppDispatch = typeof store.dispatch;</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è Don't Forget Middleware!</h4>
                    <p>RTK Query requires its middleware to be added to the store. This middleware handles:</p>
                    <ul>
                        <li>Caching and cache invalidation</li>
                        <li>Automatic refetching</li>
                        <li>Request deduplication</li>
                        <li>Background polling</li>
                    </ul>
                </div>

                <h3>Using Query Hooks</h3>

                <pre><code class="language-typescript">// src/components/UserList.tsx

import { useGetUsersQuery } from '../services/api';

function UserList() {
  // Automatically fetches data and provides loading/error states
  const { data: users, isLoading, isError, error } = useGetUsersQuery();
  
  if (isLoading) {
    return &lt;div&gt;Loading users...&lt;/div&gt;;
  }
  
  if (isError) {
    return &lt;div&gt;Error: {error.toString()}&lt;/div&gt;;
  }
  
  return (
    &lt;ul&gt;
      {users?.map(user => (
        &lt;li key={user.id}&gt;
          {user.name} - {user.email}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

// Query with parameter
function UserProfile({ userId }: { userId: string }) {
  const { data: user, isLoading } = useGetUserByIdQuery(userId);
  
  if (isLoading) return &lt;div&gt;Loading...&lt;/div&gt;;
  if (!user) return &lt;div&gt;User not found&lt;/div&gt;;
  
  return (
    &lt;div&gt;
      &lt;h2&gt;{user.name}&lt;/h2&gt;
      &lt;p&gt;{user.email}&lt;/p&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Using Mutation Hooks</h3>

                <pre><code class="language-typescript">// src/components/CreateUserForm.tsx

import { useState } from 'react';
import { useCreateUserMutation } from '../services/api';

function CreateUserForm() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  
  // Mutation hook returns [trigger function, result object]
  const [createUser, { isLoading, isSuccess, isError }] = useCreateUserMutation();
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    try {
      // Call the mutation
      await createUser({ name, email }).unwrap();
      
      // Reset form on success
      setName('');
      setEmail('');
      alert('User created successfully!');
    } catch (error) {
      alert('Failed to create user');
    }
  };
  
  return (
    &lt;form onSubmit={handleSubmit}&gt;
      &lt;input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="Name"
        required
      /&gt;
      &lt;input
        value={email}
        onChange={(e) => setEmail(e.target.value)}
        placeholder="Email"
        type="email"
        required
      /&gt;
      &lt;button type="submit" disabled={isLoading}&gt;
        {isLoading ? 'Creating...' : 'Create User'}
      &lt;/button&gt;
      
      {isSuccess && &lt;p&gt;User created!&lt;/p&gt;}
      {isError && &lt;p&gt;Failed to create user&lt;/p&gt;}
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ RTK Query Features</h4>
                    <p>Out of the box, RTK Query provides:</p>
                    <ul>
                        <li><strong>Automatic Caching:</strong> Requests are cached and shared</li>
                        <li><strong>De-duplication:</strong> Multiple components requesting the same data = 1 request</li>
                        <li><strong>Cache Invalidation:</strong> Automatic refetch when cache is invalidated</li>
                        <li><strong>Loading States:</strong> <code>isLoading</code>, <code>isFetching</code>, <code>isSuccess</code>, <code>isError</code></li>
                        <li><strong>Polling:</strong> Automatic refetching at intervals</li>
                        <li><strong>Optimistic Updates:</strong> Update UI before server responds</li>
                        <li><strong>TypeScript:</strong> Full type safety for requests and responses</li>
                    </ul>
                </div>
                <h3>Query Options and Configuration</h3>

                <p>RTK Query hooks accept options to customize behavior:</p>

                <pre><code class="language-typescript">function UserList() {
  const { data: users } = useGetUsersQuery(undefined, {
    pollingInterval: 5000, // Refetch every 5 seconds
    refetchOnMountOrArgChange: true, // Refetch on mount
    refetchOnFocus: true, // Refetch when window gains focus
    refetchOnReconnect: true, // Refetch on network reconnect
    skip: false // Skip the query (useful for conditional fetching)
  });
  
  return &lt;div&gt;{/* render users */}&lt;/div&gt;;
}

// Conditional fetching
function UserProfile({ userId }: { userId: string | null }) {
  const { data: user } = useGetUserByIdQuery(userId!, {
    skip: !userId // Don't fetch if userId is null
  });
  
  return user ? &lt;div&gt;{user.name}&lt;/div&gt; : null;
}</code></pre>

                <h3>Manual Cache Management</h3>

                <p>Sometimes you need to manually refetch or invalidate cache:</p>

                <pre><code class="language-typescript">import { useGetUsersQuery } from '../services/api';

function UserList() {
  const { data: users, refetch } = useGetUsersQuery();
  
  return (
    &lt;div&gt;
      &lt;button onClick={() => refetch()}&gt;
        Refresh Users
      &lt;/button&gt;
      
      &lt;ul&gt;
        {users?.map(user => (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
}

// Using useLazyQuery for on-demand fetching
import { useLazyGetUserByIdQuery } from '../services/api';

function SearchUser() {
  const [trigger, result] = useLazyGetUserByIdQuery();
  const [userId, setUserId] = useState('');
  
  const handleSearch = () => {
    if (userId) {
      trigger(userId); // Manually trigger the query
    }
  };
  
  return (
    &lt;div&gt;
      &lt;input value={userId} onChange={(e) => setUserId(e.target.value)} /&gt;
      &lt;button onClick={handleSearch}&gt;Search&lt;/button&gt;
      
      {result.isLoading && &lt;div&gt;Loading...&lt;/div&gt;}
      {result.data && &lt;div&gt;Found: {result.data.name}&lt;/div&gt;}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>Optimistic Updates</h3>

                <p>Update the UI immediately before the server responds:</p>

                <pre><code class="language-typescript">// src/services/api.ts

export const api = createApi({
  // ... base config
  endpoints: (builder) => ({
    updateUser: builder.mutation&lt;User, { id: string; updates: Partial&lt;User&gt; }&gt;({
      query: ({ id, updates }) => ({
        url: `/users/${id}`,
        method: 'PATCH',
        body: updates
      }),
      // Optimistic update
      async onQueryStarted({ id, updates }, { dispatch, queryFulfilled }) {
        // Optimistically update the cache
        const patchResult = dispatch(
          api.util.updateQueryData('getUserById', id, (draft) => {
            Object.assign(draft, updates);
          })
        );
        
        try {
          // Wait for the mutation to complete
          await queryFulfilled;
        } catch {
          // Undo the optimistic update on error
          patchResult.undo();
        }
      }
    }),
    
    deleteUser: builder.mutation&lt;void, string&gt;({
      query: (id) => ({
        url: `/users/${id}`,
        method: 'DELETE'
      }),
      // Optimistically remove from list
      async onQueryStarted(id, { dispatch, queryFulfilled }) {
        const patchResult = dispatch(
          api.util.updateQueryData('getUsers', undefined, (draft) => {
            const index = draft.findIndex(user => user.id === id);
            if (index !== -1) {
              draft.splice(index, 1);
            }
          })
        );
        
        try {
          await queryFulfilled;
        } catch {
          patchResult.undo();
        }
      }
    })
  })
});</code></pre>

                <h3>Transform Responses</h3>

                <p>Transform API responses before they reach your components:</p>

                <pre><code class="language-typescript">export const api = createApi({
  // ... config
  endpoints: (builder) => ({
    getUsers: builder.query&lt;User[], void&gt;({
      query: () => '/users',
      // Transform response
      transformResponse: (response: any[]) => {
        // Add a computed field
        return response.map(user => ({
          ...user,
          fullName: `${user.firstName} ${user.lastName}`,
          isActive: user.status === 'active'
        }));
      },
      // Transform error response
      transformErrorResponse: (response: { status: number; data: any }) => {
        return {
          status: response.status,
          message: response.data?.message || 'An error occurred'
        };
      }
    })
  })
});</code></pre>

                <h3>Advanced Cache Invalidation</h3>

                <pre><code class="language-typescript">export const api = createApi({
  // ... config
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: (builder) => ({
    getUsers: builder.query&lt;User[], void&gt;({
      query: () => '/users',
      // Provide tags for each user
      providesTags: (result) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'User' as const, id })),
              { type: 'User', id: 'LIST' }
            ]
          : [{ type: 'User', id: 'LIST' }]
    }),
    
    getUserPosts: builder.query&lt;Post[], string&gt;({
      query: (userId) => `/users/${userId}/posts`,
      providesTags: (result, error, userId) =>
        result
          ? [
              ...result.map(({ id }) => ({ type: 'Post' as const, id })),
              { type: 'Post', id: userId }
            ]
          : [{ type: 'Post', id: userId }]
    }),
    
    createPost: builder.mutation&lt;Post, Omit&lt;Post, 'id'&gt;&gt;({
      query: (post) => ({
        url: '/posts',
        method: 'POST',
        body: post
      }),
      // Invalidate specific user's posts and the list
      invalidatesTags: (result, error, { userId }) => [
        { type: 'Post', id: userId },
        { type: 'Post', id: 'LIST' }
      ]
    }),
    
    deleteUser: builder.mutation&lt;void, string&gt;({
      query: (id) => ({
        url: `/users/${id}`,
        method: 'DELETE'
      }),
      // Invalidate both the specific user and the list
      invalidatesTags: (result, error, id) => [
        { type: 'User', id },
        { type: 'User', id: 'LIST' }
      ]
    })
  })
});</code></pre>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° RTK Query Pro Tips</h4>
                    <ul>
                        <li><strong>Tag Strategy:</strong> Use specific IDs for granular invalidation, 'LIST' for collection endpoints</li>
                        <li><strong>Polling:</strong> Great for real-time dashboards, but be mindful of server load</li>
                        <li><strong>Optimistic Updates:</strong> Improve perceived performance but always handle rollback</li>
                        <li><strong>Skip Option:</strong> Use for conditional fetching to avoid unnecessary requests</li>
                        <li><strong>Transform Responses:</strong> Normalize or enhance data in one place</li>
                    </ul>
                </div>

                <h3>Code Splitting API Slices</h3>

                <p>For large applications, split your API into multiple files:</p>

                <pre><code class="language-typescript">// src/services/baseApi.ts
export const baseApi = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: 'https://api.example.com' }),
  tagTypes: ['User', 'Post', 'Comment'],
  endpoints: () => ({}) // Empty initially
});

// src/services/users.ts
import { baseApi } from './baseApi';

export const usersApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getUsers: builder.query&lt;User[], void&gt;({
      query: () => '/users',
      providesTags: ['User']
    }),
    // ... other user endpoints
  })
});

export const { useGetUsersQuery } = usersApi;

// src/services/posts.ts
import { baseApi } from './baseApi';

export const postsApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getPosts: builder.query&lt;Post[], void&gt;({
      query: () => '/posts',
      providesTags: ['Post']
    }),
    // ... other post endpoints
  })
});

export const { useGetPostsQuery } = postsApi;

// In store, only add baseApi
export const store = configureStore({
  reducer: {
    [baseApi.reducerPath]: baseApi.reducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware().concat(baseApi.middleware)
});</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>‚ö†Ô∏è When NOT to Use RTK Query</h4>
                    <p>RTK Query is powerful, but not always the right choice:</p>
                    <ul>
                        <li>Simple, one-off API calls (use fetch or axios directly)</li>
                        <li>Non-REST APIs with complex protocols</li>
                        <li>Heavy GraphQL usage (consider Apollo Client)</li>
                        <li>Real-time with WebSockets (needs custom setup)</li>
                        <li>Projects already using React Query successfully</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Best Practices -->
            <section id="section8" class="lesson-section">
                <h2>‚≠ê Best Practices</h2>
                
                <p>Let's consolidate everything into actionable best practices for Redux Toolkit.</p>

                <h3>Slice Organization</h3>

                <h4>1. Feature-Based Structure</h4>

                <pre><code class="language-typescript">src/
  features/
    auth/
      authSlice.ts          // Slice definition
      authSelectors.ts      // Memoized selectors
      authThunks.ts         // Complex async thunks (optional)
      types.ts              // TypeScript types
      
    cart/
      cartSlice.ts
      cartSelectors.ts
      
    products/
      productsSlice.ts
      productsAPI.ts        // RTK Query API
      
  store/
    index.ts               // Store configuration
    hooks.ts               // Typed hooks
    middleware.ts          // Custom middleware (if needed)</code></pre>

                <h4>2. Keep Slices Focused</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Focused slice
interface CartState {
  items: CartItem[];
  total: number;
}

// ‚ùå Bad: Kitchen sink slice
interface AppState {
  users: User[];
  products: Product[];
  cart: CartItem[];
  auth: AuthData;
  ui: UIState;
  // Everything in one slice!
}</code></pre>

                <h3>State Shape Design</h3>

                <h4>1. Normalize Nested Data</h4>

                <pre><code class="language-typescript">// ‚ùå Bad: Nested arrays
interface State {
  users: {
    id: string;
    name: string;
    posts: {
      id: string;
      title: string;
      comments: Comment[];
    }[];
  }[];
}

// ‚úÖ Good: Normalized structure
interface State {
  users: {
    byId: { [id: string]: User };
    allIds: string[];
  };
  posts: {
    byId: { [id: string]: Post };
    allIds: string[];
  };
  comments: {
    byId: { [id: string]: Comment };
    allIds: string[];
  };
}</code></pre>

                <h4>2. Separate UI State from Domain State</h4>

                <pre><code class="language-typescript">// UI state - belongs in components or UI slice
interface UIState {
  isSidebarOpen: boolean;
  activeModal: string | null;
  theme: 'light' | 'dark';
}

// Domain state - belongs in feature slices
interface ProductsState {
  items: Product[];
  isLoading: boolean;
  error: string | null;
}</code></pre>

                <h3>Performance Optimization</h3>

                <h4>1. Use Memoized Selectors</h4>

                <pre><code class="language-typescript">import { createSelector } from '@reduxjs/toolkit';

// ‚úÖ Good: Memoized with createSelector
export const selectFilteredTodos = createSelector(
  [(state: RootState) => state.todos.items, 
   (state: RootState) => state.todos.filter],
  (items, filter) => {
    // Expensive filtering only runs when items or filter change
    return items.filter(item => {
      if (filter === 'active') return !item.completed;
      if (filter === 'completed') return item.completed;
      return true;
    });
  }
);

// ‚ùå Bad: Filtering in component or non-memoized selector
function TodoList() {
  const items = useAppSelector(state => state.todos.items);
  const filter = useAppSelector(state => state.todos.filter);
  
  // Runs on every render!
  const filtered = items.filter(item => {
    if (filter === 'active') return !item.completed;
    if (filter === 'completed') return item.completed;
    return true;
  });
}</code></pre>

                <h4>2. Select Minimal Data</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Select only what you need
function UserName({ userId }: { userId: string }) {
  const name = useAppSelector(state => 
    state.users.byId[userId]?.name
  );
  
  return &lt;div&gt;{name}&lt;/div&gt;;
}

// ‚ùå Bad: Select entire user
function UserName({ userId }: { userId: string }) {
  const user = useAppSelector(state => state.users.byId[userId]);
  
  // Re-renders when ANY user property changes
  return &lt;div&gt;{user?.name}&lt;/div&gt;;
}</code></pre>

                <h3>Async Logic Best Practices</h3>

                <h4>1. Choose the Right Tool</h4>

                <table>
                    <thead>
                        <tr>
                            <th>Use Case</th>
                            <th>Recommended Approach</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>REST API CRUD operations</td>
                            <td>RTK Query</td>
                        </tr>
                        <tr>
                            <td>Complex multi-step async logic</td>
                            <td>createAsyncThunk</td>
                        </tr>
                        <tr>
                            <td>Simple one-off API call</td>
                            <td>useEffect with fetch</td>
                        </tr>
                        <tr>
                            <td>Real-time data (WebSocket)</td>
                            <td>Custom middleware</td>
                        </tr>
                    </tbody>
                </table>

                <h4>2. Handle All Async States</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Handle all states
const usersSlice = createSlice({
  name: 'users',
  initialState: {
    data: null,
    isLoading: false,
    error: null
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUsers.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchUsers.fulfilled, (state, action) => {
        state.data = action.payload;
        state.isLoading = false;
      })
      .addCase(fetchUsers.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.error.message || 'Failed';
      });
  }
});</code></pre>

                <h3>TypeScript Best Practices</h3>

                <h4>1. Define Interfaces First</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Clear type definitions
interface Todo {
  id: string;
  text: string;
  completed: boolean;
}

interface TodosState {
  items: Todo[];
  filter: 'all' | 'active' | 'completed';
  isLoading: boolean;
  error: string | null;
}

// Then use them
const initialState: TodosState = {
  items: [],
  filter: 'all',
  isLoading: false,
  error: null
};</code></pre>

                <h4>2. Use Type Inference</h4>

                <pre><code class="language-typescript">// ‚úÖ Good: Let TypeScript infer
const increment = (state: CounterState) => {
  state.value += 1; // Type of value is inferred
};

// ‚ùå Unnecessary: Over-annotation
const increment = (state: CounterState): void => {
  state.value = (state.value as number) + (1 as number);
};</code></pre>

                <h3>Testing Redux</h3>

                <pre><code class="language-typescript">// Testing reducers
import counterReducer, { increment, decrement } from './counterSlice';

describe('counter reducer', () => {
  const initialState = { value: 0, step: 1 };
  
  it('should handle increment', () => {
    const actual = counterReducer(initialState, increment());
    expect(actual.value).toEqual(1);
  });
  
  it('should handle decrement', () => {
    const actual = counterReducer(initialState, decrement());
    expect(actual.value).toEqual(-1);
  });
});

// Testing selectors
import { selectFilteredTodos } from './todosSelectors';

describe('selectFilteredTodos', () => {
  const state = {
    todos: {
      items: [
        { id: '1', text: 'Test', completed: false },
        { id: '2', text: 'Done', completed: true }
      ],
      filter: 'active'
    }
  };
  
  it('returns active todos when filter is active', () => {
    const result = selectFilteredTodos(state as RootState);
    expect(result).toHaveLength(1);
    expect(result[0].id).toBe('1');
  });
});

// Testing components with Redux
import { render, screen } from '@testing-library/react';
import { Provider } from 'react-redux';
import { configureStore } from '@reduxjs/toolkit';
import counterReducer from './counterSlice';
import Counter from './Counter';

function renderWithRedux(
  ui: React.ReactElement,
  { initialState, ...renderOptions } = {}
) {
  const store = configureStore({
    reducer: { counter: counterReducer },
    preloadedState: initialState
  });
  
  return render(
    &lt;Provider store={store}&gt;{ui}&lt;/Provider&gt;,
    renderOptions
  );
}

test('displays count', () => {
  renderWithRedux(&lt;Counter /&gt;, {
    initialState: { counter: { value: 5, step: 1 } }
  });
  
  expect(screen.getByText(/count: 5/i)).toBeInTheDocument();
});</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>‚úÖ Redux Toolkit Golden Rules</h4>
                    <ol>
                        <li><strong>Use RTK, not classic Redux</strong> - Less boilerplate, better DX</li>
                        <li><strong>Feature-based organization</strong> - Group by feature, not by type</li>
                        <li><strong>Normalize complex data</strong> - Avoid deep nesting</li>
                        <li><strong>Use RTK Query for APIs</strong> - Built-in caching and loading states</li>
                        <li><strong>createSelector for derived data</strong> - Memoize expensive computations</li>
                        <li><strong>Type everything</strong> - Full TypeScript support</li>
                        <li><strong>Keep slices focused</strong> - Single responsibility per slice</li>
                        <li><strong>Test reducer logic</strong> - Pure functions are easy to test</li>
                    </ol>
                </div>
            </section>

            <!-- Section 9: Summary -->
            <section id="section9" class="lesson-section">
                <h2>üìù Summary</h2>
                
                <p>Congratulations! You've mastered Redux Toolkit, the modern, powerful way to manage state in React applications. Let's recap what you've learned:</p>

                <h3>Key Takeaways</h3>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">üéØ What You've Learned</h4>
                    <ul style="color: white;">
                        <li><strong>Redux Fundamentals:</strong> Understanding Redux principles and when to use it</li>
                        <li><strong>Redux Toolkit Setup:</strong> Configuring store with TypeScript support</li>
                        <li><strong>Creating Slices:</strong> Using createSlice with Immer for simpler state updates</li>
                        <li><strong>Async Operations:</strong> Handling async logic with createAsyncThunk</li>
                        <li><strong>RTK Query:</strong> Powerful data fetching with automatic caching</li>
                        <li><strong>TypeScript Integration:</strong> Full type safety for actions, state, and selectors</li>
                        <li><strong>Best Practices:</strong> Organizing code, optimizing performance, and testing</li>
                    </ul>
                </div>

                <h3>Redux Toolkit vs Alternatives</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>Redux Toolkit</th>
                            <th>Zustand</th>
                            <th>Context API</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Bundle Size</td>
                            <td>~8KB</td>
                            <td>~1KB</td>
                            <td>0 (built-in)</td>
                        </tr>
                        <tr>
                            <td>Boilerplate</td>
                            <td>Low (with RTK)</td>
                            <td>Minimal</td>
                            <td>Low-Moderate</td>
                        </tr>
                        <tr>
                            <td>DevTools</td>
                            <td>Excellent</td>
                            <td>Good (via middleware)</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Time Travel</td>
                            <td>Yes</td>
                            <td>No</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Middleware</td>
                            <td>Extensive ecosystem</td>
                            <td>Limited</td>
                            <td>No</td>
                        </tr>
                        <tr>
                            <td>Data Fetching</td>
                            <td>RTK Query (excellent)</td>
                            <td>Manual</td>
                            <td>Manual</td>
                        </tr>
                        <tr>
                            <td>Learning Curve</td>
                            <td>Moderate</td>
                            <td>Easy</td>
                            <td>Easy</td>
                        </tr>
                        <tr>
                            <td>Best For</td>
                            <td>Large, complex apps</td>
                            <td>Small-medium apps</td>
                            <td>Simple state sharing</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Quick Reference</h3>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Creating a Slice</summary>
                    <pre><code class="language-typescript">import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface CounterState {
  value: number;
}

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 } as CounterState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
    setCount: (state, action: PayloadAction&lt;number&gt;) => {
      state.value = action.payload;
    }
  }
});

export const { increment, decrement, setCount } = counterSlice.actions;
export default counterSlice.reducer;</code></pre>
                </details>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">Async Thunk</summary>
                    <pre><code class="language-typescript">import { createAsyncThunk } from '@reduxjs/toolkit';

export const fetchUsers = createAsyncThunk(
  'users/fetchUsers',
  async () => {
    const response = await fetch('/api/users');
    return response.json();
  }
);

// In slice
extraReducers: (builder) => {
  builder
    .addCase(fetchUsers.pending, (state) => {
      state.isLoading = true;
    })
    .addCase(fetchUsers.fulfilled, (state, action) => {
      state.users = action.payload;
      state.isLoading = false;
    })
    .addCase(fetchUsers.rejected, (state, action) => {
      state.error = action.error.message;
      state.isLoading = false;
    });
}</code></pre>
                </details>

                <details>
                    <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem;">RTK Query Setup</summary>
                    <pre><code class="language-typescript">import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const api = createApi({
  reducerPath: 'api',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['User'],
  endpoints: (builder) => ({
    getUsers: builder.query&lt;User[], void&gt;({
      query: () => '/users',
      providesTags: ['User']
    }),
    createUser: builder.mutation&lt;User, Partial&lt;User&gt;&gt;({
      query: (user) => ({
        url: '/users',
        method: 'POST',
        body: user
      }),
      invalidatesTags: ['User']
    })
  })
});

export const { useGetUsersQuery, useCreateUserMutation } = api;</code></pre>
                </details>

                <h3>When to Choose Redux Toolkit</h3>

                <p>Redux Toolkit is the right choice when you need:</p>

                <ul>
                    <li>‚úÖ Complex state logic with many actions</li>
                    <li>‚úÖ Time-travel debugging capabilities</li>
                    <li>‚úÖ Predictable, traceable state updates</li>
                    <li>‚úÖ Extensive middleware ecosystem</li>
                    <li>‚úÖ Large team with standardized patterns</li>
                    <li>‚úÖ Powerful data fetching with RTK Query</li>
                    <li>‚úÖ Applications that will scale significantly</li>
                </ul>

                <p>Consider alternatives when you have:</p>

                <ul>
                    <li>‚ùå Simple state needs (use Context or Zustand)</li>
                    <li>‚ùå Small prototypes or MVPs (use Zustand)</li>
                    <li>‚ùå Mostly server state (use React Query)</li>
                    <li>‚ùå Need minimal bundle size (use Zustand)</li>
                </ul>

                <h3>Next Steps</h3>

                <ol>
                    <li><strong>Practice:</strong> Build a complete app with Redux Toolkit</li>
                    <li><strong>Explore:</strong> Try RTK Query for all data fetching</li>
                    <li><strong>Compare:</strong> Build the same feature with Redux and Zustand</li>
                    <li><strong>Learn:</strong> Explore Redux middleware ecosystem</li>
                    <li><strong>Master:</strong> Advanced patterns like entity adapters</li>
                </ol>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>üí° Final Thoughts</h4>
                    <p>Redux Toolkit has transformed Redux from a verbose, boilerplate-heavy library into a developer-friendly, powerful state management solution. While it may be overkill for small apps, for medium-to-large applications with complex state needs, it's an excellent choice that will scale with your project.</p>
                </div>

                <h3>Resources</h3>

                <ul>
                    <li><a href="https://redux-toolkit.js.org/" target="_blank" rel="noopener noreferrer">Redux Toolkit Documentation</a></li>
                    <li><a href="https://redux.js.org/" target="_blank" rel="noopener noreferrer">Redux Core Documentation</a></li>
                    <li><a href="https://redux-toolkit.js.org/rtk-query/overview" target="_blank" rel="noopener noreferrer">RTK Query Documentation</a></li>
                    <li><a href="https://github.com/reduxjs/redux-toolkit" target="_blank" rel="noopener noreferrer">Redux Toolkit GitHub</a></li>
                    <li><a href="https://github.com/reduxjs/redux-devtools" target="_blank" rel="noopener noreferrer">Redux DevTools</a></li>
                </ul>
            </section>

            <!-- Exercises Section -->
            <section class="lesson-section">
                <h2>üèãÔ∏è Practice Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Shopping Cart with Redux Toolkit</h3>
                    
                    <p><strong>Objective:</strong> Build a complete shopping cart feature using Redux Toolkit.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Create a cart slice with add, remove, update quantity actions</li>
                        <li>Calculate totals with memoized selectors</li>
                        <li>Add discount codes functionality</li>
                        <li>Persist cart to localStorage using middleware</li>
                        <li>Full TypeScript typing</li>
                    </ul>

                    <details>
                        <summary style="cursor: pointer; color: #2196F3; margin-top: 1rem;">üí° Hint</summary>
                        <div style="padding: 1rem; background: white; margin-top: 0.5rem;">
                            <p>Start with this structure:</p>
                            <pre><code class="language-typescript">interface CartItem {
  id: string;
  name: string;
  price: number;
  quantity: number;
}

interface CartState {
  items: CartItem[];
  discountCode: string | null;
  discountPercent: number;
}</code></pre>
                            <p>Use createSelector to calculate totals:</p>
                            <pre><code class="language-typescript">export const selectCartTotal = createSelector(
  [(state: RootState) => state.cart.items,
   (state: RootState) => state.cart.discountPercent],
  (items, discount) => {
    const subtotal = items.reduce((sum, item) => 
      sum + item.price * item.quantity, 0
    );
    return subtotal * (1 - discount / 100);
  }
);</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Blog Platform with RTK Query</h3>
                    
                    <p><strong>Objective:</strong> Create a blog platform using RTK Query for all data operations.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Set up RTK Query API with posts and comments endpoints</li>
                        <li>Implement CRUD operations for posts</li>
                        <li>Add nested comments functionality</li>
                        <li>Use optimistic updates for creating posts</li>
                        <li>Implement proper cache invalidation</li>
                        <li>Add polling for real-time updates</li>
                    </ul>

                    <details>
                        <summary style="cursor: pointer; color: #2196F3; margin-top: 1rem;">üí° Hint</summary>
                        <div style="padding: 1rem; background: white; margin-top: 0.5rem;">
                            <p>API structure:</p>
                            <pre><code class="language-typescript">export const blogApi = createApi({
  reducerPath: 'blogApi',
  baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
  tagTypes: ['Post', 'Comment'],
  endpoints: (builder) => ({
    getPosts: builder.query&lt;Post[], void&gt;({
      query: () => '/posts',
      providesTags: ['Post']
    }),
    getPostComments: builder.query&lt;Comment[], string&gt;({
      query: (postId) => `/posts/${postId}/comments`,
      providesTags: (result, error, postId) => 
        [{ type: 'Comment', id: postId }]
    }),
    // Add more endpoints...
  })
});</code></pre>
                        </div>
                    </details>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Dashboard with Async Thunks</h3>
                    
                    <p><strong>Objective:</strong> Build an admin dashboard with complex async operations.</p>
                    
                    <p><strong>Requirements:</strong></p>
                    <ul>
                        <li>Fetch users, products, and orders data</li>
                        <li>Handle sequential data loading (users ‚Üí their orders ‚Üí order details)</li>
                        <li>Implement error handling and retry logic</li>
                        <li>Add loading states for each data type</li>
                        <li>Create memoized selectors for dashboard stats</li>
                        <li>Handle authentication token refreshing</li>
                    </ul>
                </div>
            </section>

            <!-- Quiz Section -->
            <section class="lesson-section">
                <h2>‚ùì Knowledge Check</h2>
                
                <div class="card">
                    <h3>Question 1: Immer in Redux Toolkit</h3>
                    <p>Why can you write "mutating" code in Redux Toolkit reducers?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="a"> 
                            A) Redux Toolkit disabled immutability
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="b"> 
                            B) Immer uses Proxy to track changes and produces immutable updates
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q1" value="c"> 
                            C) Redux Toolkit converts your code to use spread operators
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>Immer uses JavaScript Proxy objects to track all changes you make to a draft state. Behind the scenes, it produces a completely new immutable state based on those changes. This allows you to write simpler code that looks like mutations while maintaining immutability.</p>
                        </div>
                    </details>
                </div>

                <div class="card">
                    <h3>Question 2: When to Use RTK Query</h3>
                    <p>Which scenario is RTK Query BEST suited for?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="a"> 
                            A) A single one-time API call to fetch config data
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="b"> 
                            B) REST API with CRUD operations needing caching and invalidation
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q2" value="c"> 
                            C) Complex WebSocket real-time updates
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>RTK Query excels at REST APIs with CRUD operations. It provides automatic caching, cache invalidation, loading states, and request deduplication. For simple one-off calls, plain fetch is sufficient. For WebSockets, you'd need custom middleware or other solutions.</p>
                        </div>
                    </details>
                </div>

                <div class="card">
                    <h3>Question 3: createAsyncThunk States</h3>
                    <p>What three action types does createAsyncThunk automatically generate?</p>
                    
                    <div style="margin: 1rem 0;">
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="a"> 
                            A) start, success, failure
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="b"> 
                            B) pending, fulfilled, rejected
                        </label>
                        <label style="display: block; margin: 0.5rem 0;">
                            <input type="radio" name="q3" value="c"> 
                            C) loading, complete, error
                        </label>
                    </div>
                    
                    <details>
                        <summary style="cursor: pointer; color: #4CAF50; margin-top: 1rem;">Show Answer</summary>
                        <div style="padding: 1rem; background: #e8f5e9; margin-top: 0.5rem;">
                            <p><strong>Answer: B</strong></p>
                            <p>createAsyncThunk generates three action types following Promise terminology: <code>pending</code> (when the async function starts), <code>fulfilled</code> (when it completes successfully), and <code>rejected</code> (when it throws an error or returns a rejected promise). You handle these in extraReducers.</p>
                        </div>
                    </details>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson Navigation">
                <a href="lesson_8_2_zustand_basics.html" class="prev-lesson">‚Üê Previous: Zustand Basics</a>
                <a href="index.html" class="home-link">üè† Course Home</a>
                <a href="lesson_8_4_react_query.html" class="next-lesson">Next: React Query ‚Üí</a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer style="background: var(--primary-gradient); color: white; padding: 2rem; text-align: center; margin-top: 4rem;">
        <p>&copy; 2024 PracticalAce. All rights reserved.</p>
        <p style="margin-top: 0.5rem; opacity: 0.9;">Empowering developers to build exceptional applications.</p>
    </footer>

    <!-- JavaScript -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
