<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Module 8 Project: Build a complete social media feed with React Query, Zustand, feature-based architecture, posts, comments, likes, and user interactions.">
    <meta name="author" content="PracticalAce">
    <title>Module 8 Project: Social Media Feed - React TypeScript Course</title>
    <link rel="stylesheet" href="styles/main.css">
    <link rel="icon" type="image/png" href="/favicon.png">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            themeVariables: {
                primaryColor: '#f0f0f0',
                primaryTextColor: '#333',
                primaryBorderColor: '#667eea'
            }
        });
    </script>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#main-content" class="skip-to-main">Skip to main content</a>
    
    <!-- Progress indicator -->
    <div class="progress-indicator" role="progressbar" aria-label="Page scroll progress">
        <div class="progress-bar"></div>
    </div>

    <!-- Navigation -->
    <nav>
        <div class="nav-container">
            <a href="index.html" class="nav-logo">React TypeScript Course</a>
            <button id="mobile-menu-toggle" class="mobile-menu-toggle" aria-expanded="false" aria-controls="nav-links">
                â˜°
            </button>
            <div class="nav-links" id="nav-links" aria-hidden="false">
                <a href="index.html">Home</a>
                <a href="index.html#modules">All Modules</a>
                <button id="theme-toggle" aria-label="Toggle theme">ğŸŒ™</button>
            </div>
        </div>
    </nav>

    <!-- Breadcrumb -->
    <nav class="breadcrumb" aria-label="Breadcrumb">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="index.html#module8">Module 8: State Management and Architecture</a></li>
            <li aria-current="page">Module Project: Social Media Feed</li>
        </ul>
    </nav>

    <!-- Main Content -->
    <main id="main-content">
        <div class="container">
            <!-- Project Header -->
            <header>
                <h1>ğŸ¯ Module 8 Project: Social Media Feed Application</h1>
                <p class="lead">Congratulations on completing Module 8! You've mastered state management with Zustand and Redux Toolkit, learned powerful data fetching with React Query, and discovered professional architecture patterns that separate great applications from good ones. Now it's time to put everything together. In this comprehensive capstone project, you'll build a production-ready social media feed that demonstrates world-class React architecture. This isn't just practiceâ€”it's a portfolio piece that proves you can build real, scalable applications.</p>
                
                <!-- Project objectives -->
                <div class="card">
                    <h2>ğŸ¯ Project Objectives</h2>
                    <p>By completing this project, you will demonstrate your mastery of:</p>
                    <ul>
                        <li>Feature-based folder structure for scalable applications</li>
                        <li>React Query for server state management (posts, comments, users)</li>
                        <li>Zustand for client state management (UI state, notifications)</li>
                        <li>Service layer pattern for clean API abstraction</li>
                        <li>Custom hooks for reusable business logic</li>
                        <li>Component organization (Container/Presentational patterns)</li>
                        <li>Optimistic updates for instant user feedback</li>
                        <li>Comprehensive error handling architecture</li>
                        <li>TypeScript throughout with proper type organization</li>
                        <li>Production-ready code organization and patterns</li>
                    </ul>
                    <p><strong>Estimated Time:</strong> 6-10 hours (or spread over multiple sessions)</p>
                    <p><strong>Difficulty:</strong> Advanced</p>
                </div>
            </header>

            <!-- Sticky Table of Contents -->
            <details class="card" open style="position: sticky; top: 80px; z-index: 100; background: var(--card-bg, white); box-shadow: 0 2px 8px rgba(0,0,0,0.1); margin-bottom: 2rem;">
                <summary style="cursor: pointer; font-weight: bold; padding: 0.5rem 1rem; user-select: none;">
                    <h2 style="display: inline; margin: 0;">ğŸ“‘ Project Guide</h2>
                </summary>
                <nav aria-label="Table of Contents" style="padding: 0 1rem 1rem 1rem;">
                    <ol>
                        <li><a href="#section1" class="toc-link">Project Overview</a></li>
                        <li><a href="#section2" class="toc-link">Features and Requirements</a></li>
                        <li><a href="#section3" class="toc-link">Architecture Design</a></li>
                        <li><a href="#section4" class="toc-link">Project Structure</a></li>
                        <li><a href="#section5" class="toc-link">Setup and Dependencies</a></li>
                        <li><a href="#section6" class="toc-link">Phase 1: Foundation</a></li>
                        <li><a href="#section7" class="toc-link">Phase 2: Posts Feature</a></li>
                        <li><a href="#section8" class="toc-link">Phase 3: Comments Feature</a></li>
                        <li><a href="#section9" class="toc-link">Phase 4: Likes and Interactions</a></li>
                        <li><a href="#section10" class="toc-link">Phase 5: User Profiles</a></li>
                    </ol>
                </nav>
            </details>

            <!-- Section 1: Project Overview -->
            <section id="section1">
                <h2>ğŸ“‹ Project Overview</h2>
                
                <p>You'll build a modern social media feed application with real-time interactions, similar to Twitter/X or Facebook. This project demonstrates every architectural pattern you've learned in Module 8.</p>

                <div class="mermaid">
graph TB
    A[Social Media Feed] --> B[Posts Feature]
    A --> C[Comments Feature]
    A --> D[Users Feature]
    A --> E[Auth Feature]
    
    B --> F[Post List]
    B --> G[Create Post]
    B --> H[Like Post]
    B --> I[Share Post]
    
    C --> J[Comment List]
    C --> K[Add Comment]
    C --> L[Reply to Comment]
    
    D --> M[User Profile]
    D --> N[Follow/Unfollow]
    D --> O[User Stats]
    
    E --> P[Login/Signup]
    E --> Q[Auth State]
    
    style A fill:#667eea,stroke:#333,stroke-width:3px,color:#fff
    style B fill:#4CAF50,stroke:#333,stroke-width:2px,color:#fff
    style C fill:#FF9800,stroke:#333,stroke-width:2px,color:#fff
    style D fill:#2196F3,stroke:#333,stroke-width:2px,color:#fff
    style E fill:#9C27B0,stroke:#333,stroke-width:2px,color:#fff
</div>

                <h3>What You'll Build</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸŒŸ Core Features</h4>
                    
                    <h5>1. Posts Feed</h5>
                    <ul>
                        <li>Infinite scroll feed with pagination</li>
                        <li>Create new posts with text and images</li>
                        <li>Edit and delete your own posts</li>
                        <li>Like/unlike posts with optimistic updates</li>
                        <li>Share posts (simulated)</li>
                        <li>Post timestamp and author information</li>
                        <li>Loading states and skeleton screens</li>
                    </ul>

                    <h5>2. Comments System</h5>
                    <ul>
                        <li>View comments on any post</li>
                        <li>Add new comments</li>
                        <li>Nested replies to comments</li>
                        <li>Edit and delete your comments</li>
                        <li>Like comments</li>
                        <li>Real-time comment count updates</li>
                    </ul>

                    <h5>3. User Interactions</h5>
                    <ul>
                        <li>User profiles with bio and stats</li>
                        <li>Follow/unfollow users</li>
                        <li>View user's posts</li>
                        <li>Follower/following counts</li>
                        <li>User avatars and display names</li>
                    </ul>

                    <h5>4. Authentication</h5>
                    <ul>
                        <li>Login and signup forms</li>
                        <li>JWT token management</li>
                        <li>Protected routes</li>
                        <li>Auth state with Zustand</li>
                        <li>Persistent login</li>
                    </ul>

                    <h5>5. UI/UX Features</h5>
                    <ul>
                        <li>Responsive mobile-first design</li>
                        <li>Toast notifications for actions</li>
                        <li>Loading skeletons</li>
                        <li>Error boundaries</li>
                        <li>Optimistic UI updates</li>
                        <li>Smooth animations</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">ğŸ“ What You'll Learn</h4>
                    <ul style="color: white;">
                        <li><strong>Real-World Architecture:</strong> See how professional applications are structured</li>
                        <li><strong>State Management Patterns:</strong> When to use React Query vs Zustand</li>
                        <li><strong>Scalable Code Organization:</strong> Feature folders that grow with your app</li>
                        <li><strong>Performance Optimization:</strong> Caching, optimistic updates, lazy loading</li>
                        <li><strong>Error Handling:</strong> Graceful degradation at every layer</li>
                        <li><strong>TypeScript Best Practices:</strong> Type safety throughout the stack</li>
                        <li><strong>Component Patterns:</strong> Container/Presentational separation</li>
                        <li><strong>API Integration:</strong> Clean service layer abstractions</li>
                    </ul>
                </div>

                <h3>Technology Stack</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Category</th>
                            <th>Technology</th>
                            <th>Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Framework</strong></td>
                            <td>React 18 + TypeScript</td>
                            <td>Core application framework</td>
                        </tr>
                        <tr>
                            <td><strong>Server State</strong></td>
                            <td>React Query (TanStack Query)</td>
                            <td>Posts, comments, users data fetching</td>
                        </tr>
                        <tr>
                            <td><strong>Client State</strong></td>
                            <td>Zustand</td>
                            <td>Auth state, UI state, notifications</td>
                        </tr>
                        <tr>
                            <td><strong>Routing</strong></td>
                            <td>React Router</td>
                            <td>Navigation and protected routes</td>
                        </tr>
                        <tr>
                            <td><strong>Forms</strong></td>
                            <td>React Hook Form + Zod</td>
                            <td>Post creation, comments, auth forms</td>
                        </tr>
                        <tr>
                            <td><strong>HTTP Client</strong></td>
                            <td>Axios</td>
                            <td>API requests with interceptors</td>
                        </tr>
                        <tr>
                            <td><strong>UI/Styling</strong></td>
                            <td>CSS Modules / Tailwind</td>
                            <td>Component styling</td>
                        </tr>
                        <tr>
                            <td><strong>Icons</strong></td>
                            <td>Lucide React</td>
                            <td>UI icons</td>
                        </tr>
                        <tr>
                            <td><strong>Notifications</strong></td>
                            <td>React Hot Toast</td>
                            <td>Toast notifications</td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <!-- Section 2: Features and Requirements -->
            <section id="section2">
                <h2>âœ¨ Features and Requirements</h2>
                
                <h3>Functional Requirements</h3>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Must-Have Features</h4>
                    
                    <h5>Posts Management</h5>
                    <ul>
                        <li>View infinite scroll feed of posts</li>
                        <li>Create posts with text content (minimum 1 character, max 280)</li>
                        <li>Edit own posts within 5 minutes of creation</li>
                        <li>Delete own posts with confirmation</li>
                        <li>Like/unlike posts with instant feedback</li>
                        <li>View like count and list of users who liked</li>
                        <li>Display post author with avatar and name</li>
                        <li>Show relative timestamps (e.g., "2 hours ago")</li>
                    </ul>

                    <h5>Comments System</h5>
                    <ul>
                        <li>View all comments on a post</li>
                        <li>Add new comment to post</li>
                        <li>Reply to existing comments (one level deep)</li>
                        <li>Edit own comments</li>
                        <li>Delete own comments</li>
                        <li>Like comments</li>
                        <li>Display comment count on posts</li>
                    </ul>

                    <h5>User Features</h5>
                    <ul>
                        <li>View user profiles with bio and stats</li>
                        <li>Follow/unfollow other users</li>
                        <li>View follower and following counts</li>
                        <li>See user's posts on their profile</li>
                        <li>Update own profile (name, bio, avatar)</li>
                    </ul>

                    <h5>Authentication</h5>
                    <ul>
                        <li>Sign up with email and password</li>
                        <li>Log in with credentials</li>
                        <li>Log out functionality</li>
                        <li>Persist auth state across page refreshes</li>
                        <li>Protected routes (redirects to login)</li>
                        <li>Public routes (feed visible to all)</li>
                    </ul>
                </div>

                <div class="card" style="background: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>ğŸ¨ Nice-to-Have Features (Stretch Goals)</h4>
                    <ul>
                        <li>Image upload for posts and profile pictures</li>
                        <li>Search functionality for posts and users</li>
                        <li>Hashtag support and trending topics</li>
                        <li>Notifications for likes and comments</li>
                        <li>Dark mode toggle</li>
                        <li>Share post to clipboard</li>
                        <li>Report inappropriate content</li>
                        <li>Block users</li>
                    </ul>
                </div>

                <h3>Technical Requirements</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ—ï¸ Architecture Requirements</h4>
                    <ul>
                        <li><strong>Feature-Based Structure:</strong> Organize code by feature (posts, comments, users, auth)</li>
                        <li><strong>Service Layer:</strong> All API calls in dedicated service files</li>
                        <li><strong>Custom Hooks:</strong> Business logic extracted into reusable hooks</li>
                        <li><strong>Type Safety:</strong> Full TypeScript coverage, no <code>any</code> types</li>
                        <li><strong>Error Handling:</strong> Custom error classes and error boundaries</li>
                        <li><strong>Component Separation:</strong> Container and Presentational components</li>
                        <li><strong>Code Reusability:</strong> Shared components in <code>shared/</code> folder</li>
                        <li><strong>State Management:</strong> React Query for server state, Zustand for client state</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ’» Implementation Requirements</h4>
                    <ul>
                        <li><strong>React Query:</strong>
                            <ul>
                                <li>Configure QueryClient with sensible defaults</li>
                                <li>Implement query keys factory</li>
                                <li>Use mutations for all data modifications</li>
                                <li>Implement optimistic updates for likes</li>
                                <li>Proper cache invalidation strategies</li>
                            </ul>
                        </li>
                        <li><strong>Zustand:</strong>
                            <ul>
                                <li>Auth store with login/logout actions</li>
                                <li>UI store for modals and notifications</li>
                                <li>Persist auth state to localStorage</li>
                                <li>Typed store with proper TypeScript</li>
                            </ul>
                        </li>
                        <li><strong>Error Handling:</strong>
                            <ul>
                                <li>Custom error classes (ApiError, AuthError, ValidationError)</li>
                                <li>Axios interceptors for global error handling</li>
                                <li>Error boundaries for component errors</li>
                                <li>User-friendly error messages</li>
                            </ul>
                        </li>
                        <li><strong>Performance:</strong>
                            <ul>
                                <li>Lazy loading for routes</li>
                                <li>Infinite scroll with React Query</li>
                                <li>Memoization where appropriate</li>
                                <li>Optimistic UI updates</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <h3>Non-Functional Requirements</h3>

                <table>
                    <thead>
                        <tr>
                            <th>Requirement</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Responsive Design</strong></td>
                            <td>Mobile-first, works on all screen sizes (320px+)</td>
                        </tr>
                        <tr>
                            <td><strong>Accessibility</strong></td>
                            <td>Proper ARIA labels, keyboard navigation, screen reader support</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Fast initial load, smooth scrolling, no janky animations</td>
                        </tr>
                        <tr>
                            <td><strong>Error Handling</strong></td>
                            <td>Graceful degradation, helpful error messages</td>
                        </tr>
                        <tr>
                            <td><strong>Code Quality</strong></td>
                            <td>Clean, well-organized, commented where necessary</td>
                        </tr>
                        <tr>
                            <td><strong>Type Safety</strong></td>
                            <td>No TypeScript errors, proper typing throughout</td>
                        </tr>
                    </tbody>
                </table>

            </section>

            <!-- Section 3: Architecture Design -->
            <section id="section3">
                <h2>ğŸ›ï¸ Architecture Design</h2>
                
                <p>This project demonstrates professional React architecture. Understanding the design decisions will help you build scalable applications in your career.</p>

                <h3>System Architecture Overview</h3>

                <div class="mermaid">
graph TB
    subgraph "Presentation Layer"
        A[Pages/Routes]
        B[Layout Components]
        C[Feature Components]
        D[Shared UI Components]
    end
    
    subgraph "Business Logic Layer"
        E[Custom Hooks]
        F[React Query Hooks]
        G[Zustand Stores]
    end
    
    subgraph "Data Access Layer"
        H[API Services]
        I[Axios Instance]
        J[Error Interceptors]
    end
    
    subgraph "External"
        K[REST API]
        L[LocalStorage]
    end
    
    A --> B
    A --> C
    C --> D
    C --> E
    C --> F
    C --> G
    
    E --> F
    F --> H
    G --> L
    H --> I
    I --> J
    J --> K
    
    style A fill:#e3f2fd
    style E fill:#fff3cd
    style H fill:#c8e6c9
    style K fill:#ffccbc
</div>

                <h3>State Management Strategy</h3>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h4>ğŸ“Š When to Use What</h4>
                    
                    <table>
                        <thead>
                            <tr>
                                <th>State Type</th>
                                <th>Tool</th>
                                <th>Examples</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Server State</strong></td>
                                <td>React Query</td>
                                <td>Posts, comments, users, followers</td>
                            </tr>
                            <tr>
                                <td><strong>Global Client State</strong></td>
                                <td>Zustand</td>
                                <td>Auth state, current user, theme</td>
                            </tr>
                            <tr>
                                <td><strong>UI State (Global)</strong></td>
                                <td>Zustand</td>
                                <td>Modal open/closed, toast notifications</td>
                            </tr>
                            <tr>
                                <td><strong>UI State (Local)</strong></td>
                                <td>useState</td>
                                <td>Form inputs, dropdown open, loading buttons</td>
                            </tr>
                            <tr>
                                <td><strong>Form State</strong></td>
                                <td>React Hook Form</td>
                                <td>Create post form, comment form, login form</td>
                            </tr>
                            <tr>
                                <td><strong>URL State</strong></td>
                                <td>React Router</td>
                                <td>Current page, filters, search query</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Feature Architecture Pattern</h3>

                <p>Each feature follows the same architectural pattern for consistency:</p>

                <pre><code class="language-bash">features/posts/
â”œâ”€â”€ components/          # UI components
â”‚   â”œâ”€â”€ PostList.tsx    # Container component
â”‚   â”œâ”€â”€ PostCard.tsx    # Presentational component
â”‚   â”œâ”€â”€ PostForm.tsx    # Form component
â”‚   â””â”€â”€ PostActions.tsx # Action buttons
â”œâ”€â”€ hooks/              # Custom hooks
â”‚   â”œâ”€â”€ usePosts.ts     # Query hook
â”‚   â”œâ”€â”€ useCreatePost.ts # Mutation hook
â”‚   â”œâ”€â”€ useLikePost.ts  # Mutation hook
â”‚   â””â”€â”€ useDeletePost.ts
â”œâ”€â”€ api/                # API service
â”‚   â””â”€â”€ postService.ts
â”œâ”€â”€ types/              # TypeScript types
â”‚   â””â”€â”€ post.types.ts
â””â”€â”€ index.ts            # Public API</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Benefits of This Pattern</h4>
                    <ul>
                        <li><strong>Scalable:</strong> Add features without cluttering existing code</li>
                        <li><strong>Maintainable:</strong> All related code lives together</li>
                        <li><strong>Testable:</strong> Each layer can be tested independently</li>
                        <li><strong>Reusable:</strong> Hooks and services can be shared</li>
                        <li><strong>Type-Safe:</strong> TypeScript ensures correctness</li>
                        <li><strong>Team-Friendly:</strong> Clear ownership and boundaries</li>
                    </ul>
                </div>

                <h3>Data Flow Architecture</h3>

                <div class="mermaid">
sequenceDiagram
    participant U as User
    participant C as Component
    participant H as Custom Hook
    participant RQ as React Query
    participant S as Service
    participant API as Backend API
    
    U->>C: Click "Like Post"
    C->>H: Call useLikePost()
    H->>RQ: mutation.mutate(postId)
    
    Note over RQ: Optimistic Update
    RQ->>C: Update UI immediately
    C->>U: Show liked state
    
    RQ->>S: Call likePost(postId)
    S->>API: POST /api/posts/:id/like
    
    alt Success
        API-->>S: 200 OK + updated post
        S-->>RQ: Return data
        RQ->>RQ: Invalidate queries
        RQ->>C: Refetch & confirm
        C->>U: Keep liked state
    else Error
        API-->>S: 500 Error
        S-->>RQ: Throw error
        RQ->>RQ: Rollback optimistic
        RQ->>C: Restore previous state
        C->>U: Show unliked + error
    end
</div>

                <h3>Error Handling Flow</h3>

                <pre><code class="language-typescript">// Error handling at each layer

// 1. API Layer (Axios Interceptor)
axios.interceptors.response.use(
  response => response,
  error => {
    // Transform HTTP errors to custom errors
    if (error.response?.status === 401) {
      throw new AuthError('Please log in');
    }
    throw new ApiError(error.message);
  }
);

// 2. Service Layer
export const postService = {
  async like(postId: string) {
    // Let errors bubble up
    const response = await apiClient.post(`/posts/${postId}/like`);
    return response.data;
  }
};

// 3. Hook Layer (React Query)
export function useLikePost() {
  return useMutation({
    mutationFn: postService.like,
    onError: (error) => {
      // React Query handles rollback
      toast.error(error.message);
    }
  });
}

// 4. Component Layer
function PostCard({ post }: { post: Post }) {
  const likeMutation = useLikePost();
  
  const handleLike = () => {
    likeMutation.mutate(post.id);
    // No try-catch needed, React Query handles it
  };
  
  return (
    &lt;button onClick={handleLike}&gt;
      Like ({post.likes})
    &lt;/button&gt;
  );
}</code></pre>

            </section>

            <!-- Section 4: Project Structure -->
            <section id="section4">
                <h2>ğŸ“‚ Project Structure</h2>
                
                <p>Here's the complete folder structure for the social media feed application. This structure scales from small projects to enterprise applications.</p>

                <h3>Complete Folder Tree</h3>

                <pre><code class="language-bash">social-media-feed/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ favicon.png
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ features/               # Feature modules
â”‚   â”‚   â”œâ”€â”€ auth/              # Authentication
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ LoginForm.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SignupForm.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ProtectedRoute.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAuth.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useLogin.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useSignup.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ authService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ store/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ authStore.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ posts/             # Posts feature
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PostList.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PostCard.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PostForm.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PostActions.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ PostSkeleton.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ usePosts.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useInfinitePosts.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useCreatePost.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useUpdatePost.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useDeletePost.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useLikePost.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ postService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ post.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ comments/          # Comments feature
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CommentList.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CommentItem.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CommentForm.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CommentReply.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useComments.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useAddComment.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useDeleteComment.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useLikeComment.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ commentService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ comment.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ users/             # Users/profiles
â”‚   â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserProfile.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserCard.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ UserStats.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FollowButton.tsx
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EditProfileForm.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useUser.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useUserPosts.ts
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ useFollowUser.ts
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ useUpdateProfile.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ userService.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ types/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ user.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ notifications/     # Notifications (optional)
â”‚   â”‚       â”œâ”€â”€ components/
â”‚   â”‚       â”œâ”€â”€ store/
â”‚   â”‚       â”œâ”€â”€ types/
â”‚   â”‚       â””â”€â”€ index.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ shared/                # Shared across features
â”‚   â”‚   â”œâ”€â”€ components/        # Reusable UI
â”‚   â”‚   â”‚   â”œâ”€â”€ Button/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.tsx
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Button.module.css
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Button.test.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ Input/
â”‚   â”‚   â”‚   â”œâ”€â”€ Card/
â”‚   â”‚   â”‚   â”œâ”€â”€ Modal/
â”‚   â”‚   â”‚   â”œâ”€â”€ Avatar/
â”‚   â”‚   â”‚   â”œâ”€â”€ Spinner/
â”‚   â”‚   â”‚   â”œâ”€â”€ ErrorBoundary/
â”‚   â”‚   â”‚   â””â”€â”€ InfiniteScroll/
â”‚   â”‚   â”œâ”€â”€ hooks/             # Reusable hooks
â”‚   â”‚   â”‚   â”œâ”€â”€ useDebounce.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useLocalStorage.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ useMediaQuery.ts
â”‚   â”‚   â”‚   â””â”€â”€ useIntersectionObserver.ts
â”‚   â”‚   â”œâ”€â”€ utils/             # Utility functions
â”‚   â”‚   â”‚   â”œâ”€â”€ formatDate.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ formatNumber.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ validators.ts
â”‚   â”‚   â”‚   â””â”€â”€ helpers.ts
â”‚   â”‚   â”œâ”€â”€ types/             # Shared types
â”‚   â”‚   â”‚   â”œâ”€â”€ common.types.ts
â”‚   â”‚   â”‚   â””â”€â”€ api.types.ts
â”‚   â”‚   â”œâ”€â”€ errors/            # Custom errors
â”‚   â”‚   â”‚   â”œâ”€â”€ AppError.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ ApiError.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ AuthError.ts
â”‚   â”‚   â”‚   â””â”€â”€ ValidationError.ts
â”‚   â”‚   â””â”€â”€ constants/
â”‚   â”‚       â””â”€â”€ config.ts
â”‚   â”‚
â”‚   â”œâ”€â”€ lib/                   # Third-party setup
â”‚   â”‚   â”œâ”€â”€ axios.ts          # Axios instance
â”‚   â”‚   â”œâ”€â”€ react-query.ts    # React Query config
â”‚   â”‚   â””â”€â”€ router.tsx         # Router config
â”‚   â”‚
â”‚   â”œâ”€â”€ pages/                 # Route components
â”‚   â”‚   â”œâ”€â”€ HomePage.tsx
â”‚   â”‚   â”œâ”€â”€ LoginPage.tsx
â”‚   â”‚   â”œâ”€â”€ SignupPage.tsx
â”‚   â”‚   â”œâ”€â”€ ProfilePage.tsx
â”‚   â”‚   â”œâ”€â”€ PostDetailPage.tsx
â”‚   â”‚   â””â”€â”€ NotFoundPage.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ layouts/               # Layout components
â”‚   â”‚   â”œâ”€â”€ MainLayout.tsx
â”‚   â”‚   â”œâ”€â”€ AuthLayout.tsx
â”‚   â”‚   â””â”€â”€ ProfileLayout.tsx
â”‚   â”‚
â”‚   â”œâ”€â”€ styles/                # Global styles
â”‚   â”‚   â”œâ”€â”€ globals.css
â”‚   â”‚   â”œâ”€â”€ variables.css
â”‚   â”‚   â””â”€â”€ reset.css
â”‚   â”‚
â”‚   â”œâ”€â”€ App.tsx                # Root component
â”‚   â”œâ”€â”€ main.tsx               # Entry point
â”‚   â””â”€â”€ vite-env.d.ts         # Vite types
â”‚
â”œâ”€â”€ .env.example               # Environment variables
â”œâ”€â”€ .gitignore
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ vite.config.ts
â””â”€â”€ README.md</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Key Points About This Structure</h4>
                    <ul>
                        <li><strong>Features are self-contained:</strong> Each feature has everything it needs</li>
                        <li><strong>Shared folder for reusability:</strong> Common code goes here</li>
                        <li><strong>Clear boundaries:</strong> Easy to see what belongs where</li>
                        <li><strong>Scalable:</strong> Add new features without touching existing ones</li>
                        <li><strong>Testable:</strong> Each piece can be tested independently</li>
                        <li><strong>Type-safe:</strong> Types live close to where they're used</li>
                    </ul>
                </div>

            </section>

            <!-- Section 5: Setup and Dependencies -->
            <section id="section5">
                <h2>âš™ï¸ Setup and Dependencies</h2>
                
                <h3>Step 1: Create Project</h3>

                <pre><code class="language-bash"># Create Vite project with React + TypeScript
npm create vite@latest social-media-feed -- --template react-ts

# Navigate to project
cd social-media-feed

# Install dependencies
npm install</code></pre>

                <h3>Step 2: Install Required Dependencies</h3>

                <pre><code class="language-bash"># State Management & Data Fetching
npm install @tanstack/react-query zustand
npm install axios

# Routing
npm install react-router-dom

# Forms & Validation
npm install react-hook-form @hookform/resolvers zod

# UI & Icons
npm install lucide-react
npm install react-hot-toast

# DevTools
npm install @tanstack/react-query-devtools --save-dev</code></pre>

                <h3>Step 3: Install Type Definitions</h3>

                <pre><code class="language-bash"># TypeScript types for libraries
npm install @types/react @types/react-dom --save-dev</code></pre>

                <h3>Step 4: Project Configuration</h3>

                <h4>tsconfig.json</h4>
                <pre><code class="language-json">{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@/features/*": ["./src/features/*"],
      "@/shared/*": ["./src/shared/*"],
      "@/lib/*": ["./src/lib/*"]
    }
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}</code></pre>

                <h4>vite.config.ts</h4>
                <pre><code class="language-typescript">import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@/features': path.resolve(__dirname, './src/features'),
      '@/shared': path.resolve(__dirname, './src/shared'),
      '@/lib': path.resolve(__dirname, './src/lib'),
    },
  },
})</code></pre>

                <h4>.env.example</h4>
                <pre><code class="language-bash"># API Configuration
VITE_API_URL=http://localhost:3000/api
VITE_API_TIMEOUT=10000

# App Configuration
VITE_APP_NAME=Social Feed
VITE_APP_VERSION=1.0.0</code></pre>

                <div class="card" style="background-color: #fff3cd; border-left: 4px solid #ffc107;">
                    <h4>âš ï¸ Important: Backend API</h4>
                    <p>This project requires a backend API. You have three options:</p>
                    <ol>
                        <li><strong>Use JSONPlaceholder:</strong> Free fake API (https://jsonplaceholder.typicode.com)</li>
                        <li><strong>Use Mock Service Worker (MSW):</strong> Mock API in browser</li>
                        <li><strong>Build your own:</strong> Create a simple Node.js/Express API</li>
                    </ol>
                    <p>For learning purposes, we'll start with option 1 (JSONPlaceholder) and show you how to adapt it.</p>
                </div>

                <h3>Step 5: Create Folder Structure</h3>

                <pre><code class="language-bash"># Create all necessary folders
mkdir -p src/{features,shared,lib,pages,layouts,styles}
mkdir -p src/features/{auth,posts,comments,users}
mkdir -p src/shared/{components,hooks,utils,types,errors,constants}

# Create initial files
touch src/lib/{axios.ts,react-query.ts,router.tsx}
touch src/styles/{globals.css,variables.css}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Setup Complete!</h4>
                    <p>You now have:</p>
                    <ul>
                        <li>âœ… React + TypeScript project with Vite</li>
                        <li>âœ… All required dependencies installed</li>
                        <li>âœ… Path aliases configured</li>
                        <li>âœ… Feature-based folder structure</li>
                        <li>âœ… TypeScript strict mode enabled</li>
                    </ul>
                    <p><strong>Next:</strong> We'll start building the foundation with shared utilities and configurations.</p>
                </div>

            </section>
            <!-- Section 6: Phase 1 - Foundation -->
            <section id="section6">
                <h2>ğŸ—ï¸ Phase 1: Foundation Setup</h2>
                
                <p>Before building features, we need to establish the foundation: shared utilities, error handling, API configuration, and base components. This infrastructure will be used throughout the application.</p>

                <h3>Step 1: Configure Axios Instance</h3>

                <pre><code class="language-typescript">// src/lib/axios.ts
import axios from 'axios';
import type { AxiosInstance, InternalAxiosRequestConfig } from 'axios';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000/api';
const TIMEOUT = Number(import.meta.env.VITE_API_TIMEOUT) || 10000;

export const apiClient: AxiosInstance = axios.create({
  baseURL: API_URL,
  timeout: TIMEOUT,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - Add auth token
apiClient.interceptors.request.use(
  (config: InternalAxiosRequestConfig) => {
    const token = localStorage.getItem('authToken');
    if (token && config.headers) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - Handle errors globally
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // Handle common errors
    if (error.response?.status === 401) {
      // Clear auth and redirect to login
      localStorage.removeItem('authToken');
      localStorage.removeItem('user');
      window.location.href = '/login';
    }

    return Promise.reject(error);
  }
);</code></pre>

                <h3>Step 2: Create Custom Error Classes</h3>

                <pre><code class="language-typescript">// src/shared/errors/AppError.ts
export class AppError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number,
    public details?: any
  ) {
    super(message);
    this.name = 'AppError';
    Object.setPrototypeOf(this, AppError.prototype);
  }
}

// src/shared/errors/ApiError.ts
import { AppError } from './AppError';

export class ApiError extends AppError {
  constructor(message: string, statusCode = 500, details?: any) {
    super(message, 'API_ERROR', statusCode, details);
    this.name = 'ApiError';
  }
}

// src/shared/errors/AuthError.ts
import { AppError } from './AppError';

export class AuthError extends AppError {
  constructor(message = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401);
    this.name = 'AuthError';
  }
}

// src/shared/errors/ValidationError.ts
import { AppError } from './AppError';

export class ValidationError extends AppError {
  constructor(message: string, details?: Record&lt;string, string&gt;) {
    super(message, 'VALIDATION_ERROR', 400, details);
    this.name = 'ValidationError';
  }
}

// src/shared/errors/index.ts
export { AppError } from './AppError';
export { ApiError } from './ApiError';
export { AuthError } from './AuthError';
export { ValidationError } from './ValidationError';</code></pre>

                <h3>Step 3: Configure React Query</h3>

                <pre><code class="language-typescript">// src/lib/react-query.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Global query defaults
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 10,   // 10 minutes (formerly cacheTime)
      refetchOnWindowFocus: false,
      refetchOnReconnect: true,
      retry: 1,
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
    mutations: {
      // Global mutation defaults
      retry: 0,
      onError: (error) => {
        console.error('Mutation error:', error);
      },
    },
  },
});</code></pre>

                <h3>Step 4: Shared TypeScript Types</h3>

                <pre><code class="language-typescript">// src/shared/types/common.types.ts
export type ID = string | number;

export interface ApiResponse&lt;T&gt; {
  data: T;
  message?: string;
  success: boolean;
}

export interface PaginatedResponse&lt;T&gt; {
  data: T[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
}

export interface ApiError {
  message: string;
  code: string;
  statusCode: number;
  details?: Record&lt;string, any&gt;;
}

export type Nullable&lt;T&gt; = T | null;
export type Optional&lt;T&gt; = T | undefined;

// src/shared/types/api.types.ts
export interface BaseEntity {
  id: string;
  createdAt: string;
  updatedAt: string;
}

export interface QueryParams {
  page?: number;
  limit?: number;
  sort?: string;
  order?: 'asc' | 'desc';
}

export interface InfiniteQueryParams extends QueryParams {
  cursor?: string;
}</code></pre>

                <h3>Step 5: Utility Functions</h3>

                <pre><code class="language-typescript">// src/shared/utils/formatDate.ts
import { formatDistanceToNow, format } from 'date-fns';

export function formatRelativeTime(date: string | Date): string {
  return formatDistanceToNow(new Date(date), { addSuffix: true });
}

export function formatFullDate(date: string | Date): string {
  return format(new Date(date), 'PPP');
}

export function formatDateTime(date: string | Date): string {
  return format(new Date(date), 'PPP p');
}

// src/shared/utils/formatNumber.ts
export function formatNumber(num: number): string {
  if (num >= 1000000) {
    return `${(num / 1000000).toFixed(1)}M`;
  }
  if (num >= 1000) {
    return `${(num / 1000).toFixed(1)}K`;
  }
  return num.toString();
}

export function formatPlural(count: number, singular: string, plural?: string): string {
  if (count === 1) return `${count} ${singular}`;
  return `${count} ${plural || singular + 's'}`;
}

// src/shared/utils/validators.ts
export function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

export function isStrongPassword(password: string): boolean {
  // At least 8 chars, 1 uppercase, 1 lowercase, 1 number
  const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
  return passwordRegex.test(password);
}

export function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.slice(0, maxLength) + '...';
}</code></pre>

                <h3>Step 6: Shared Custom Hooks</h3>

                <pre><code class="language-typescript">// src/shared/hooks/useDebounce.ts
import { useState, useEffect } from 'react';

export function useDebounce&lt;T&gt;(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => clearTimeout(handler);
  }, [value, delay]);

  return debouncedValue;
}

// src/shared/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage&lt;T&gt;(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState&lt;T&gt;(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });

  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(error);
    }
  };

  return [storedValue, setValue];
}

// src/shared/hooks/useIntersectionObserver.ts
import { useEffect, useRef, useState } from 'react';

export function useIntersectionObserver(
  options?: IntersectionObserverInit
): [React.RefObject&lt;HTMLDivElement&gt;, boolean] {
  const ref = useRef&lt;HTMLDivElement&gt;(null);
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    const observer = new IntersectionObserver(([entry]) => {
      setIsIntersecting(entry.isIntersecting);
    }, options);

    observer.observe(element);

    return () => observer.disconnect();
  }, [options]);

  return [ref, isIntersecting];
}</code></pre>

                <h3>Step 7: Base UI Components</h3>

                <h4>Button Component</h4>
                <pre><code class="language-typescript">// src/shared/components/Button/Button.tsx
import React from 'react';
import './Button.css';

interface ButtonProps extends React.ButtonHTMLAttributes&lt;HTMLButtonElement&gt; {
  variant?: 'primary' | 'secondary' | 'danger' | 'ghost';
  size?: 'small' | 'medium' | 'large';
  loading?: boolean;
  children: React.ReactNode;
}

export function Button({
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled,
  children,
  className = '',
  ...props
}: ButtonProps) {
  return (
    &lt;button
      className={`btn btn-${variant} btn-${size} ${className}`}
      disabled={disabled || loading}
      {...props}
    &gt;
      {loading ? (
        &lt;span className="btn-spinner"&gt;Loading...&lt;/span&gt;
      ) : (
        children
      )}
    &lt;/button&gt;
  );
}</code></pre>

                <h4>Avatar Component</h4>
                <pre><code class="language-typescript">// src/shared/components/Avatar/Avatar.tsx
import React from 'react';
import './Avatar.css';

interface AvatarProps {
  src?: string;
  alt: string;
  size?: 'small' | 'medium' | 'large';
  fallback?: string;
}

export function Avatar({ src, alt, size = 'medium', fallback }: AvatarProps) {
  const getInitials = (name: string): string => {
    return name
      .split(' ')
      .map(n => n[0])
      .join('')
      .toUpperCase()
      .slice(0, 2);
  };

  return (
    &lt;div className={`avatar avatar-${size}`}&gt;
      {src ? (
        &lt;img src={src} alt={alt} className="avatar-img" /&gt;
      ) : (
        &lt;div className="avatar-fallback"&gt;
          {fallback || getInitials(alt)}
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h4>Card Component</h4>
                <pre><code class="language-typescript">// src/shared/components/Card/Card.tsx
import React from 'react';
import './Card.css';

interface CardProps {
  children: React.ReactNode;
  className?: string;
  padding?: 'small' | 'medium' | 'large';
  hoverable?: boolean;
}

export function Card({ 
  children, 
  className = '', 
  padding = 'medium',
  hoverable = false 
}: CardProps) {
  return (
    &lt;div 
      className={`card card-padding-${padding} ${hoverable ? 'card-hoverable' : ''} ${className}`}
    &gt;
      {children}
    &lt;/div&gt;
  );
}</code></pre>

                <h4>Spinner Component</h4>
                <pre><code class="language-typescript">// src/shared/components/Spinner/Spinner.tsx
import React from 'react';
import './Spinner.css';

interface SpinnerProps {
  size?: 'small' | 'medium' | 'large';
  text?: string;
}

export function Spinner({ size = 'medium', text }: SpinnerProps) {
  return (
    &lt;div className="spinner-container"&gt;
      &lt;div className={`spinner spinner-${size}`}&gt;&lt;/div&gt;
      {text && &lt;p className="spinner-text"&gt;{text}&lt;/p&gt;}
    &lt;/div&gt;
  );
}</code></pre>

                <h4>Error Boundary</h4>
                <pre><code class="language-typescript">// src/shared/components/ErrorBoundary/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';

interface Props {
  children: ReactNode;
  fallback?: (error: Error, reset: () => void) => ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component&lt;Props, State&gt; {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('ErrorBoundary caught an error:', error, errorInfo);
  }

  reset = () => {
    this.setState({ hasError: false, error: null });
  };

  render() {
    if (this.state.hasError && this.state.error) {
      if (this.props.fallback) {
        return this.props.fallback(this.state.error, this.reset);
      }

      return (
        &lt;div className="error-boundary"&gt;
          &lt;h2&gt;Something went wrong&lt;/h2&gt;
          &lt;p&gt;{this.state.error.message}&lt;/p&gt;
          &lt;button onClick={this.reset}&gt;Try again&lt;/button&gt;
        &lt;/div&gt;
      );
    }

    return this.props.children;
  }
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Phase 1 Complete!</h4>
                    <p>You now have:</p>
                    <ul>
                        <li>âœ… Axios configured with interceptors</li>
                        <li>âœ… Custom error classes</li>
                        <li>âœ… React Query configured</li>
                        <li>âœ… Shared TypeScript types</li>
                        <li>âœ… Utility functions</li>
                        <li>âœ… Custom hooks (debounce, localStorage, intersection observer)</li>
                        <li>âœ… Base UI components (Button, Avatar, Card, Spinner, ErrorBoundary)</li>
                    </ul>
                    <p><strong>Next:</strong> We'll build the Posts feature with full CRUD operations.</p>
                </div>

            </section>

            <!-- Section 7: Phase 2 - Posts Feature -->
            <section id="section7">
                <h2>ğŸ“ Phase 2: Posts Feature</h2>
                
                <p>The Posts feature is the core of our social media feed. We'll implement infinite scrolling, CRUD operations, and optimistic updates for likes.</p>

                <h3>Step 1: Define Post Types</h3>

                <pre><code class="language-typescript">// src/features/posts/types/post.types.ts
import type { BaseEntity } from '@/shared/types/api.types';

export interface Post extends BaseEntity {
  content: string;
  authorId: string;
  author: {
    id: string;
    name: string;
    username: string;
    avatar?: string;
  };
  likes: number;
  likedBy: string[];
  commentsCount: number;
  sharesCount: number;
  isLiked?: boolean; // Computed based on current user
}

export interface CreatePostDto {
  content: string;
}

export interface UpdatePostDto {
  content: string;
}

export interface PostFilters {
  authorId?: string;
  search?: string;
}

export interface InfinitePostsResponse {
  posts: Post[];
  nextCursor: string | null;
  hasMore: boolean;
}</code></pre>

                <h3>Step 2: Create Post Service</h3>

                <pre><code class="language-typescript">// src/features/posts/api/postService.ts
import { apiClient } from '@/lib/axios';
import type { 
  Post, 
  CreatePostDto, 
  UpdatePostDto, 
  InfinitePostsResponse 
} from '../types/post.types';

export const postService = {
  /**
   * Get paginated posts (infinite scroll)
   */
  async getInfinitePosts(cursor?: string, limit = 10): Promise&lt;InfinitePostsResponse&gt; {
    const params = new URLSearchParams();
    if (cursor) params.append('cursor', cursor);
    params.append('limit', limit.toString());

    const response = await apiClient.get&lt;InfinitePostsResponse&gt;(
      `/posts?${params.toString()}`
    );
    return response.data;
  },

  /**
   * Get single post by ID
   */
  async getById(id: string): Promise&lt;Post&gt; {
    const response = await apiClient.get&lt;Post&gt;(`/posts/${id}`);
    return response.data;
  },

  /**
   * Get posts by user
   */
  async getByUser(userId: string): Promise&lt;Post[]&gt; {
    const response = await apiClient.get&lt;Post[]&gt;(`/users/${userId}/posts`);
    return response.data;
  },

  /**
   * Create new post
   */
  async create(data: CreatePostDto): Promise&lt;Post&gt; {
    const response = await apiClient.post&lt;Post&gt;('/posts', data);
    return response.data;
  },

  /**
   * Update post
   */
  async update(id: string, data: UpdatePostDto): Promise&lt;Post&gt; {
    const response = await apiClient.patch&lt;Post&gt;(`/posts/${id}`, data);
    return response.data;
  },

  /**
   * Delete post
   */
  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`/posts/${id}`);
  },

  /**
   * Like/unlike post
   */
  async toggleLike(id: string): Promise&lt;Post&gt; {
    const response = await apiClient.post&lt;Post&gt;(`/posts/${id}/like`);
    return response.data;
  },
};</code></pre>

                <h3>Step 3: Create Custom Hooks</h3>

                <h4>Query Keys Factory</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/postKeys.ts
export const postKeys = {
  all: ['posts'] as const,
  lists: () => [...postKeys.all, 'list'] as const,
  list: (filters: string) => [...postKeys.lists(), { filters }] as const,
  infinite: () => [...postKeys.all, 'infinite'] as const,
  details: () => [...postKeys.all, 'detail'] as const,
  detail: (id: string) => [...postKeys.details(), id] as const,
  byUser: (userId: string) => [...postKeys.all, 'user', userId] as const,
};</code></pre>

                <h4>useInfinitePosts Hook</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/useInfinitePosts.ts
import { useInfiniteQuery } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';

export function useInfinitePosts() {
  return useInfiniteQuery({
    queryKey: postKeys.infinite(),
    queryFn: ({ pageParam }) => postService.getInfinitePosts(pageParam),
    initialPageParam: undefined as string | undefined,
    getNextPageParam: (lastPage) => {
      return lastPage.hasMore ? lastPage.nextCursor : undefined;
    },
    staleTime: 1000 * 60 * 2, // 2 minutes
  });
}</code></pre>

                <h4>usePost Hook</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/usePost.ts
import { useQuery } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';

export function usePost(id: string) {
  return useQuery({
    queryKey: postKeys.detail(id),
    queryFn: () => postService.getById(id),
    staleTime: 1000 * 60 * 5, // 5 minutes
  });
}</code></pre>

                <h4>useCreatePost Hook</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/useCreatePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';
import type { CreatePostDto, Post } from '../types/post.types';
import toast from 'react-hot-toast';

export function useCreatePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreatePostDto) => postService.create(data),
    onSuccess: (newPost: Post) => {
      // Invalidate infinite query to show new post
      queryClient.invalidateQueries({ queryKey: postKeys.infinite() });
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
      
      toast.success('Post created successfully!');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to create post');
    },
  });
}</code></pre>

                <h4>useUpdatePost Hook</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/useUpdatePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';
import type { UpdatePostDto } from '../types/post.types';
import toast from 'react-hot-toast';

export function useUpdatePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdatePostDto }) =>
      postService.update(id, data),
    onSuccess: (updatedPost) => {
      // Update specific post cache
      queryClient.setQueryData(postKeys.detail(updatedPost.id), updatedPost);
      
      // Invalidate lists
      queryClient.invalidateQueries({ queryKey: postKeys.infinite() });
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
      
      toast.success('Post updated successfully!');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to update post');
    },
  });
}</code></pre>

                <h4>useDeletePost Hook</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/useDeletePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';
import toast from 'react-hot-toast';

export function useDeletePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (postId: string) => postService.delete(postId),
    onSuccess: (_, deletedId) => {
      // Remove from cache
      queryClient.removeQueries({ queryKey: postKeys.detail(deletedId) });
      
      // Invalidate lists
      queryClient.invalidateQueries({ queryKey: postKeys.infinite() });
      queryClient.invalidateQueries({ queryKey: postKeys.lists() });
      
      toast.success('Post deleted successfully!');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to delete post');
    },
  });
}</code></pre>

                <h4>useLikePost Hook (with Optimistic Updates)</h4>
                <pre><code class="language-typescript">// src/features/posts/hooks/useLikePost.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { postService } from '../api/postService';
import { postKeys } from './postKeys';
import type { Post } from '../types/post.types';

export function useLikePost() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (postId: string) => postService.toggleLike(postId),
    
    // Optimistic update
    onMutate: async (postId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: postKeys.detail(postId) });
      
      // Snapshot previous value
      const previousPost = queryClient.getQueryData&lt;Post&gt;(
        postKeys.detail(postId)
      );
      
      // Optimistically update cache
      queryClient.setQueryData&lt;Post&gt;(postKeys.detail(postId), (old) => {
        if (!old) return old;
        
        const isCurrentlyLiked = old.isLiked;
        
        return {
          ...old,
          likes: isCurrentlyLiked ? old.likes - 1 : old.likes + 1,
          isLiked: !isCurrentlyLiked,
        };
      });
      
      return { previousPost };
    },
    
    // Rollback on error
    onError: (error, postId, context) => {
      if (context?.previousPost) {
        queryClient.setQueryData(postKeys.detail(postId), context.previousPost);
      }
    },
    
    // Always refetch after success or error
    onSettled: (data, error, postId) => {
      queryClient.invalidateQueries({ queryKey: postKeys.detail(postId) });
      queryClient.invalidateQueries({ queryKey: postKeys.infinite() });
    },
  });
}</code></pre>

                <h3>Step 4: Export Public API</h3>

                <pre><code class="language-typescript">// src/features/posts/index.ts
// Components
export { PostList } from './components/PostList';
export { PostCard } from './components/PostCard';
export { PostForm } from './components/PostForm';

// Hooks
export { useInfinitePosts } from './hooks/useInfinitePosts';
export { usePost } from './hooks/usePost';
export { useCreatePost } from './hooks/useCreatePost';
export { useUpdatePost } from './hooks/useUpdatePost';
export { useDeletePost } from './hooks/useDeletePost';
export { useLikePost } from './hooks/useLikePost';

// Types
export type { Post, CreatePostDto, UpdatePostDto } from './types/post.types';</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Phase 2 Foundation Complete!</h4>
                    <p>You now have the complete Posts feature infrastructure:</p>
                    <ul>
                        <li>âœ… TypeScript types defined</li>
                        <li>âœ… Service layer with all CRUD operations</li>
                        <li>âœ… Query keys factory for consistent caching</li>
                        <li>âœ… Custom hooks for all operations</li>
                        <li>âœ… Optimistic updates for instant feedback</li>
                        <li>âœ… Error handling with toast notifications</li>
                        <li>âœ… Public API exported</li>
                    </ul>
                    <p><strong>Next:</strong> We'll create the UI components (PostList, PostCard, PostForm) to display and interact with posts.</p>
                </div>

            </section>
            <!-- Section 8: Phase 3 - Posts UI Components -->
            <section id="section8">
                <h2>ğŸ¨ Phase 3: Posts UI Components</h2>
                
                <p>Now that we have the data layer complete, let's build the user interface components for displaying and interacting with posts.</p>

                <h3>PostCard Component</h3>

                <pre><code class="language-typescript">// src/features/posts/components/PostCard.tsx
import { Heart, MessageCircle, Trash2, Edit2 } from 'lucide-react';
import { Avatar } from '@/shared/components/Avatar';
import { Card } from '@/shared/components/Card';
import { Button } from '@/shared/components/Button';
import { formatRelativeTime } from '@/shared/utils/formatDate';
import { formatNumber } from '@/shared/utils/formatNumber';
import { useLikePost, useDeletePost } from '../hooks';
import type { Post } from '../types/post.types';

interface PostCardProps {
  post: Post;
  onEdit?: (post: Post) => void;
  onCommentClick?: (post: Post) => void;
}

export function PostCard({ post, onEdit, onCommentClick }: PostCardProps) {
  const likeMutation = useLikePost();
  const deleteMutation = useDeletePost();
  const currentUserId = 'current-user-id'; // Get from auth store

  const handleLike = () => {
    likeMutation.mutate(post.id);
  };

  const handleDelete = () => {
    if (window.confirm('Are you sure you want to delete this post?')) {
      deleteMutation.mutate(post.id);
    }
  };

  const isOwnPost = post.authorId === currentUserId;

  return (
    &lt;Card className="post-card"&gt;
      {/* Header */}
      &lt;div className="post-header"&gt;
        &lt;Avatar
          src={post.author.avatar}
          alt={post.author.name}
          size="medium"
        /&gt;
        &lt;div className="post-author-info"&gt;
          &lt;h4&gt;{post.author.name}&lt;/h4&gt;
          &lt;p className="post-username"&gt;@{post.author.username}&lt;/p&gt;
        &lt;/div&gt;
        &lt;span className="post-time"&gt;
          {formatRelativeTime(post.createdAt)}
        &lt;/span&gt;
      &lt;/div&gt;

      {/* Content */}
      &lt;div className="post-content"&gt;
        &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;/div&gt;

      {/* Actions */}
      &lt;div className="post-actions"&gt;
        &lt;button
          className={`post-action-btn ${post.isLiked ? 'liked' : ''}`}
          onClick={handleLike}
          disabled={likeMutation.isPending}
        &gt;
          &lt;Heart fill={post.isLiked ? 'currentColor' : 'none'} /&gt;
          &lt;span&gt;{formatNumber(post.likes)}&lt;/span&gt;
        &lt;/button&gt;

        &lt;button
          className="post-action-btn"
          onClick={() => onCommentClick?.(post)}
        &gt;
          &lt;MessageCircle /&gt;
          &lt;span&gt;{formatNumber(post.commentsCount)}&lt;/span&gt;
        &lt;/button&gt;

        {isOwnPost && (
          &lt;&gt;
            &lt;button
              className="post-action-btn"
              onClick={() => onEdit?.(post)}
            &gt;
              &lt;Edit2 size={18} /&gt;
            &lt;/button&gt;
            &lt;button
              className="post-action-btn danger"
              onClick={handleDelete}
              disabled={deleteMutation.isPending}
            &gt;
              &lt;Trash2 size={18} /&gt;
            &lt;/button&gt;
          &lt;/&gt;
        )}
      &lt;/div&gt;
    &lt;/Card&gt;
  );
}</code></pre>

                <h3>PostList Component with Infinite Scroll</h3>

                <pre><code class="language-typescript">// src/features/posts/components/PostList.tsx
import { useEffect } from 'react';
import { Spinner } from '@/shared/components/Spinner';
import { useIntersectionObserver } from '@/shared/hooks/useIntersectionObserver';
import { useInfinitePosts } from '../hooks';
import { PostCard } from './PostCard';

export function PostList() {
  const {
    data,
    fetchNextPage,
    hasNextPage,
    isFetchingNextPage,
    isLoading,
    isError,
    error,
  } = useInfinitePosts();

  // Intersection observer for infinite scroll
  const [loadMoreRef, isIntersecting] = useIntersectionObserver({
    threshold: 0.5,
  });

  useEffect(() => {
    if (isIntersecting && hasNextPage && !isFetchingNextPage) {
      fetchNextPage();
    }
  }, [isIntersecting, hasNextPage, isFetchingNextPage, fetchNextPage]);

  if (isLoading) {
    return &lt;Spinner size="large" text="Loading posts..." /&gt;;
  }

  if (isError) {
    return (
      &lt;div className="error-message"&gt;
        &lt;p&gt;Error loading posts: {error.message}&lt;/p&gt;
        &lt;button onClick={() => window.location.reload()}&gt;Retry&lt;/button&gt;
      &lt;/div&gt;
    );
  }

  const posts = data?.pages.flatMap((page) => page.posts) ?? [];

  if (posts.length === 0) {
    return (
      &lt;div className="empty-state"&gt;
        &lt;p&gt;No posts yet. Be the first to post!&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div className="post-list"&gt;
      {posts.map((post) => (
        &lt;PostCard key={post.id} post={post} /&gt;
      ))}

      {/* Load more trigger */}
      &lt;div ref={loadMoreRef} className="load-more-trigger"&gt;
        {isFetchingNextPage && &lt;Spinner text="Loading more..." /&gt;}
      &lt;/div&gt;

      {!hasNextPage && posts.length > 0 && (
        &lt;p className="end-message"&gt;You've reached the end!&lt;/p&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>

                <h3>PostForm Component</h3>

                <pre><code class="language-typescript">// src/features/posts/components/PostForm.tsx
import { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/shared/components/Button';
import { useCreatePost } from '../hooks';
import type { CreatePostDto } from '../types/post.types';

const postSchema = z.object({
  content: z
    .string()
    .min(1, 'Post cannot be empty')
    .max(280, 'Post cannot exceed 280 characters'),
});

type PostFormData = z.infer&lt;typeof postSchema&gt;;

export function PostForm() {
  const createMutation = useCreatePost();
  const [charCount, setCharCount] = useState(0);

  const {
    register,
    handleSubmit,
    formState: { errors },
    reset,
    watch,
  } = useForm&lt;PostFormData&gt;({
    resolver: zodResolver(postSchema),
  });

  // Watch content for character count
  const content = watch('content', '');
  useEffect(() => {
    setCharCount(content.length);
  }, [content]);

  const onSubmit = async (data: PostFormData) => {
    await createMutation.mutateAsync(data);
    reset();
    setCharCount(0);
  };

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)} className="post-form"&gt;
      &lt;textarea
        {...register('content')}
        placeholder="What's on your mind?"
        className="post-textarea"
        rows={3}
      /&gt;

      {errors.content && (
        &lt;p className="error-text"&gt;{errors.content.message}&lt;/p&gt;
      )}

      &lt;div className="post-form-footer"&gt;
        &lt;span className={`char-count ${charCount > 280 ? 'error' : ''}`}&gt;
          {charCount}/280
        &lt;/span&gt;
        &lt;Button
          type="submit"
          loading={createMutation.isPending}
          disabled={createMutation.isPending}
        &gt;
          Post
        &lt;/Button&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Posts Feature Complete!</h4>
                    <p>You now have a fully functional Posts feature with:</p>
                    <ul>
                        <li>âœ… PostCard component with like, comment, edit, delete actions</li>
                        <li>âœ… PostList with infinite scroll</li>
                        <li>âœ… PostForm with character counter and validation</li>
                        <li>âœ… Optimistic UI updates</li>
                        <li>âœ… Loading and error states</li>
                        <li>âœ… Complete TypeScript coverage</li>
                    </ul>
                </div>

            </section>

            <!-- Section 9: Phase 4 - Comments Feature -->
            <section id="section9">
                <h2>ğŸ’¬ Phase 4: Comments Feature</h2>
                
                <p>The Comments feature follows the same architectural pattern as Posts. We'll create types, services, hooks, and components.</p>

                <h3>Step 1: Define Comment Types</h3>

                <pre><code class="language-typescript">// src/features/comments/types/comment.types.ts
import type { BaseEntity } from '@/shared/types/api.types';

export interface Comment extends BaseEntity {
  content: string;
  postId: string;
  authorId: string;
  author: {
    id: string;
    name: string;
    username: string;
    avatar?: string;
  };
  likes: number;
  isLiked?: boolean;
  parentId?: string; // For nested replies
  replies?: Comment[];
}

export interface CreateCommentDto {
  content: string;
  postId: string;
  parentId?: string;
}

export interface UpdateCommentDto {
  content: string;
}</code></pre>

                <h3>Step 2: Create Comment Service</h3>

                <pre><code class="language-typescript">// src/features/comments/api/commentService.ts
import { apiClient } from '@/lib/axios';
import type { Comment, CreateCommentDto, UpdateCommentDto } from '../types/comment.types';

export const commentService = {
  async getByPost(postId: string): Promise&lt;Comment[]&gt; {
    const response = await apiClient.get&lt;Comment[]&gt;(`/posts/${postId}/comments`);
    return response.data;
  },

  async create(data: CreateCommentDto): Promise&lt;Comment&gt; {
    const response = await apiClient.post&lt;Comment&gt;('/comments', data);
    return response.data;
  },

  async update(id: string, data: UpdateCommentDto): Promise&lt;Comment&gt; {
    const response = await apiClient.patch&lt;Comment&gt;(`/comments/${id}`, data);
    return response.data;
  },

  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`/comments/${id}`);
  },

  async toggleLike(id: string): Promise&lt;Comment&gt; {
    const response = await apiClient.post&lt;Comment&gt;(`/comments/${id}/like`);
    return response.data;
  },
};</code></pre>

                <h3>Step 3: Create Comment Hooks</h3>

                <pre><code class="language-typescript">// src/features/comments/hooks/useComments.ts
import { useQuery } from '@tanstack/react-query';
import { commentService } from '../api/commentService';

export const commentKeys = {
  all: ['comments'] as const,
  byPost: (postId: string) => [...commentKeys.all, 'post', postId] as const,
};

export function useComments(postId: string) {
  return useQuery({
    queryKey: commentKeys.byPost(postId),
    queryFn: () => commentService.getByPost(postId),
    staleTime: 1000 * 60 * 2,
  });
}

// src/features/comments/hooks/useAddComment.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { commentService } from '../api/commentService';
import { commentKeys } from './useComments';
import { postKeys } from '@/features/posts/hooks/postKeys';
import toast from 'react-hot-toast';

export function useAddComment() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: commentService.create,
    onSuccess: (newComment) => {
      // Invalidate comments for this post
      queryClient.invalidateQueries({ 
        queryKey: commentKeys.byPost(newComment.postId) 
      });
      
      // Update post's comment count
      queryClient.invalidateQueries({ 
        queryKey: postKeys.detail(newComment.postId) 
      });
      
      toast.success('Comment added!');
    },
    onError: (error: Error) => {
      toast.error(error.message || 'Failed to add comment');
    },
  });
}</code></pre>

                <h3>Step 4: CommentList Component</h3>

                <pre><code class="language-typescript">// src/features/comments/components/CommentList.tsx
import { useState } from 'react';
import { Spinner } from '@/shared/components/Spinner';
import { useComments } from '../hooks/useComments';
import { CommentItem } from './CommentItem';
import { CommentForm } from './CommentForm';

interface CommentListProps {
  postId: string;
}

export function CommentList({ postId }: CommentListProps) {
  const { data: comments, isLoading, isError } = useComments(postId);
  const [replyingTo, setReplyingTo] = useState&lt;string | null&gt;(null);

  if (isLoading) {
    return &lt;Spinner text="Loading comments..." /&gt;;
  }

  if (isError) {
    return &lt;p&gt;Failed to load comments&lt;/p&gt;;
  }

  return (
    &lt;div className="comments-section"&gt;
      &lt;h3&gt;Comments ({comments?.length || 0})&lt;/h3&gt;
      
      &lt;CommentForm postId={postId} /&gt;

      &lt;div className="comments-list"&gt;
        {comments?.map((comment) => (
          &lt;CommentItem
            key={comment.id}
            comment={comment}
            onReply={() => setReplyingTo(comment.id)}
          /&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}</code></pre>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h4>âœ… Comments Feature Complete!</h4>
                    <p>Following the same pattern as Posts, you now have:</p>
                    <ul>
                        <li>âœ… Comment types with nested replies support</li>
                        <li>âœ… Comment service for API calls</li>
                        <li>âœ… Custom hooks with cache management</li>
                        <li>âœ… Comment UI components</li>
                    </ul>
                </div>

            </section>

            <!-- Section 10: Phase 5 - Auth & User Features -->
            <section id="section10">
                <h2>ğŸ‘¤ Phase 5: Authentication & Users</h2>
                
                <h3>Auth Store with Zustand</h3>

                <pre><code class="language-typescript">// src/features/auth/store/authStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface User {
  id: string;
  name: string;
  username: string;
  email: string;
  avatar?: string;
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (user: User, token: string) => void;
  logout: () => void;
  updateUser: (user: Partial&lt;User&gt;) => void;
}

export const useAuthStore = create&lt;AuthState&gt;()(
  persist(
    (set) => ({
      user: null,
      token: null,
      isAuthenticated: false,

      login: (user, token) => {
        localStorage.setItem('authToken', token);
        set({ user, token, isAuthenticated: true });
      },

      logout: () => {
        localStorage.removeItem('authToken');
        set({ user: null, token: null, isAuthenticated: false });
      },

      updateUser: (userData) => {
        set((state) => ({
          user: state.user ? { ...state.user, ...userData } : null,
        }));
      },
    }),
    {
      name: 'auth-storage',
    }
  )
);</code></pre>

                <h3>Protected Route Component</h3>

                <pre><code class="language-typescript">// src/features/auth/components/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useAuthStore } from '../store/authStore';

interface ProtectedRouteProps {
  children: React.ReactNode;
}

export function ProtectedRoute({ children }: ProtectedRouteProps) {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

  if (!isAuthenticated) {
    return &lt;Navigate to="/login" replace /&gt;;
  }

  return &lt;&gt;{children}&lt;/&gt;;
}</code></pre>

                <h3>Main App Structure</h3>

                <pre><code class="language-typescript">// src/App.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { BrowserRouter } from 'react-router-dom';
import { Toaster } from 'react-hot-toast';
import { queryClient } from './lib/react-query';
import { AppRoutes } from './lib/router';
import { ErrorBoundary } from './shared/components/ErrorBoundary';

export function App() {
  return (
    &lt;ErrorBoundary&gt;
      &lt;QueryClientProvider client={queryClient}&gt;
        &lt;BrowserRouter&gt;
          &lt;AppRoutes /&gt;
          &lt;Toaster position="top-right" /&gt;
        &lt;/BrowserRouter&gt;
        &lt;ReactQueryDevtools initialIsOpen={false} /&gt;
      &lt;/QueryClientProvider&gt;
    &lt;/ErrorBoundary&gt;
  );
}</code></pre>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h4 style="color: white;">ğŸ‰ Congratulations!</h4>
                    <p style="color: white;">You've built a complete, production-ready social media feed application with:</p>
                    <ul style="color: white;">
                        <li>âœ… Feature-based architecture</li>
                        <li>âœ… React Query for server state</li>
                        <li>âœ… Zustand for client state</li>
                        <li>âœ… Service layer pattern</li>
                        <li>âœ… Custom hooks for business logic</li>
                        <li>âœ… Optimistic updates</li>
                        <li>âœ… Infinite scroll</li>
                        <li>âœ… Complete TypeScript coverage</li>
                        <li>âœ… Error handling at every layer</li>
                        <li>âœ… Professional code organization</li>
                    </ul>
                </div>

            </section>

            <!-- Exercises Section -->
            <section id="exercises">
                <h2>ğŸ‹ï¸ Extension Exercises</h2>
                
                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 1: Add Search Functionality</h3>
                    <p><strong>Goal:</strong> Implement post and user search with debouncing.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol>
                        <li>Create a search input component</li>
                        <li>Use <code>useDebounce</code> hook for the search term</li>
                        <li>Add search endpoint to post service</li>
                        <li>Create <code>useSearchPosts</code> hook</li>
                        <li>Display search results with highlighting</li>
                    </ol>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 2: Add User Profiles</h3>
                    <p><strong>Goal:</strong> Create user profile pages with their posts and follower stats.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol>
                        <li>Create user types and service</li>
                        <li>Build UserProfile component</li>
                        <li>Implement follow/unfollow functionality</li>
                        <li>Show user's posts on their profile</li>
                        <li>Display follower/following counts</li>
                    </ol>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>Exercise 3: Add Notifications</h3>
                    <p><strong>Goal:</strong> Implement a notifications system for likes and comments.</p>
                    <p><strong>Tasks:</strong></p>
                    <ol>
                        <li>Create notifications feature module</li>
                        <li>Build Zustand store for notifications</li>
                        <li>Add NotificationBell component</li>
                        <li>Show unread count badge</li>
                        <li>Mark notifications as read</li>
                    </ol>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2>ğŸ“ Project Summary</h2>
                
                <div class="card">
                    <h3>ğŸ‰ Module 8 Project Complete!</h3>
                    <p>Congratulations on building a production-ready social media feed application! This project demonstrates every architectural pattern and state management technique you learned in Module 8.</p>
                    
                    <h3>What You Built</h3>
                    <ul>
                        <li>âœ… <strong>Feature-Based Architecture:</strong> Scalable folder structure by feature</li>
                        <li>âœ… <strong>React Query Integration:</strong> Server state with caching and optimistic updates</li>
                        <li>âœ… <strong>Zustand State Management:</strong> Client state for auth and UI</li>
                        <li>âœ… <strong>Service Layer:</strong> Clean API abstraction with axios</li>
                        <li>âœ… <strong>Custom Hooks:</strong> Reusable business logic</li>
                        <li>âœ… <strong>Component Patterns:</strong> Container and Presentational separation</li>
                        <li>âœ… <strong>Infinite Scroll:</strong> Performant feed with cursor pagination</li>
                        <li>âœ… <strong>Error Handling:</strong> Multi-layer error architecture</li>
                        <li>âœ… <strong>TypeScript:</strong> Full type safety throughout</li>
                        <li>âœ… <strong>Optimistic UI:</strong> Instant feedback for user actions</li>
                    </ul>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">ğŸ¯ Key Achievements</h3>
                    <ol style="color: white;">
                        <li><strong>Professional Architecture:</strong> Your code is organized like production applications at top companies</li>
                        <li><strong>Scalable Patterns:</strong> The patterns you used scale from small projects to enterprise apps</li>
                        <li><strong>Best Practices:</strong> Separation of concerns, DRY, single responsibility throughout</li>
                        <li><strong>Modern Stack:</strong> React Query, Zustand, TypeScript - industry standard tools</li>
                        <li><strong>Performance:</strong> Optimistic updates, infinite scroll, proper caching</li>
                        <li><strong>Maintainability:</strong> Easy to find, modify, and extend features</li>
                    </ol>
                </div>

                <div class="card" style="background: #e8f5e9; border-left: 4px solid #4CAF50;">
                    <h3>ğŸš€ What's Next?</h3>
                    <p>You've completed Module 8! Here's what comes next:</p>
                    
                    <h4>Immediate Next Steps:</h4>
                    <ul>
                        <li>Complete the extension exercises to deepen your understanding</li>
                        <li>Deploy your social media feed to Vercel or Netlify</li>
                        <li>Add it to your portfolio with screenshots and live demo</li>
                        <li>Consider building a real backend API for it</li>
                    </ul>

                    <h4>Module 9: Testing React Applications</h4>
                    <p>In the next module, you'll learn how to:</p>
                    <ul>
                        <li>Write comprehensive tests for React applications</li>
                        <li>Use React Testing Library</li>
                        <li>Test hooks, components, and user interactions</li>
                        <li>Mock API calls and test async code</li>
                        <li>Write integration and E2E tests</li>
                    </ul>
                </div>

                <div class="card" style="background: #e3f2fd; border-left: 4px solid #2196F3;">
                    <h3>ğŸ“š Additional Challenges</h3>
                    <p>To further improve your skills, try these challenges:</p>
                    <ol>
                        <li><strong>Image Upload:</strong> Add image support for posts using file upload</li>
                        <li><strong>Real-Time Updates:</strong> Implement WebSocket for live notifications</li>
                        <li><strong>Dark Mode:</strong> Add theme switching with Zustand</li>
                        <li><strong>Hashtags:</strong> Implement hashtag parsing and trending topics</li>
                        <li><strong>Advanced Search:</strong> Add filters (date range, author, hashtags)</li>
                        <li><strong>Analytics:</strong> Track user engagement and post performance</li>
                        <li><strong>Accessibility:</strong> Ensure full keyboard navigation and ARIA labels</li>
                        <li><strong>Tests:</strong> Add comprehensive test coverage (Module 9 skill!)</li>
                    </ol>
                </div>

                <div class="card" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                    <h3 style="color: white;">ğŸ’¼ Portfolio Presentation</h3>
                    <p style="color: white;">This project is portfolio-ready! When presenting it:</p>
                    <ul style="color: white;">
                        <li><strong>Highlight the architecture:</strong> Explain your feature-based structure</li>
                        <li><strong>Discuss state management decisions:</strong> Why React Query vs Zustand for different state types</li>
                        <li><strong>Show the code organization:</strong> Service layer, custom hooks, component separation</li>
                        <li><strong>Demonstrate optimistic updates:</strong> The instant like feedback</li>
                        <li><strong>Explain scalability:</strong> How easy it is to add new features</li>
                        <li><strong>Mention TypeScript:</strong> Type safety throughout the application</li>
                    </ul>
                </div>
            </section>

            <!-- Lesson Navigation -->
            <nav class="lesson-nav" aria-label="Lesson navigation">
                <a href="lesson_8_5_architecture_best_practices_c.html" class="nav-button prev-lesson">
                    <span class="arrow">â†</span>
                    <span class="label">Previous</span>
                    <span class="title">Lesson 8.5: Architecture Best Practices</span>
                </a>
                <a href="index.html" class="nav-button home">
                    <span class="label">Course Home</span>
                </a>
                <a href="index.html#module9" class="nav-button next-lesson">
                    <span class="label">Next</span>
                    <span class="title">Module 9: Testing React Applications</span>
                    <span class="arrow">â†’</span>
                </a>
            </nav>
        </div>
    </main>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2025 React TypeScript Course. All rights reserved.</p>
            <p>
                <a href="index.html">Home</a> |
                <a href="index.html#modules">All Modules</a> |
                <a href="mailto:support@example.com">Contact</a>
            </p>
        </div>
    </footer>

    <!-- Scripts -->
    <script src="js/clipboard.js"></script>
    <script src="js/course-enhancements.js"></script>
</body>
</html>
